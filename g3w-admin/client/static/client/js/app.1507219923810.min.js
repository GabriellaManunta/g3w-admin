(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var apptitle = "G3W Client";

var plugins = {
};

var tools = {
  tools:  []
};

// restituisce la configurazione/ messaggi
var i18n = {
  resources: require('./locales/app.js')
};

var client =  {
  debug:  true,
  local:  false
};

var server =  {
  urls:  {
    baseurl: '/',
    ows:  'ows',
    api:  'api',
    initconfig:  'api/initconfig',
    config:  'api/config'
  }
};

module.exports = {
  apptitle: apptitle,
  client: client,
  server: server,
  plugins:  plugins,
  tools:  tools,
  i18n: i18n
};

},{"./locales/app.js":2}],2:[function(require,module,exports){
var translations = {
  "it": {
    "translation": {
      "component": "Componente Generico",
      "search": "Ricerche",
      "print": "Stampa",
      "dosearch": "Cerca",
      "catalog": "Mappa",
      "baselayers": "Basi",
      "tools": "Strumenti",
      "tree": "Strati",
      "legend": "Legenda",
      "street_search": "Cerca indirizzo",
      "show": "Mostra",
      "hide": "Nascondi",
      "copy_form_data": "Copia i dati del modulo",
      "paste_form_data": "Incolla",
      "copy_form_data_from_feature": "Copia i dati dalla mappa",
      "could_not_load_vector_layers": "Errore di connessione al server: non è stato possibile caricare i vettoriali richiesti",
      "input_validation_error": "Campo obbligatorio o valore non corretto"
    }
  },
  "en": {
    "translation": {
      "component": "Componente Generico",
      "search": "Ricerche",
      "print": "Stampa",
      "dosearch": "Cerca",
      "catalog": "Mappa",
      "baselayers": "Basi",
      "tools": "Strumenti",
      "tree": "Strati",
      "legend": "Legenda",
      "street_search": "Cerca indirizzo",
      "show": "Mostra",
      "hide": "Nascondi",
      "copy_form_data": "Copia i dati del modulo",
      "paste_form_data": "Incolla",
      "copy_form_data_from_feature": "Copia i dati dalla mappa",
      "could_not_load_vector_layers": "Errore di connessione al server: non è stato possibile caricare i vettoriali richiesti",
      "input_validation_error": "Campo obbligatorio o valore non corretto"
    }
  }
};

module.exports = translations;

},{}],3:[function(require,module,exports){
var i18ninit = require('sdk').core.i18n.init;
// oggetto
var ApplicationService = require('sdk/sdk').core.ApplicationService;
// oggetto application template che si occupa di gestire il template dell'applicazione
var ApplicationTemplate = require('./template/js/template');
// configurazione dell'applicazione
var config = require('./config/config.js');
// SETTO LA VARIABILE GLOBALE g3wsdk, COME SE AVESSI USATO sdk.js
window.g3wsdk = require('sdk');
//imposto il timeout delle richieste ajax di jquery
// $.ajaxSetup({
//    timeout: 5000 // in milliseconds
// });
// inizializza l'internalizzazione
i18ninit(config.i18n);

// questa funzione che ala configurazione inizale dell'applicazione
// tutte le cose in comune
function createApplicationConfig() {
  return {
    apptitle: config.apptitle || '',
    logo_img: config.group.header_logo_img,
    logo_link: config.group.header_logo_link,
    terms_of_use_text: config.group.header_terms_of_use_text,
    terms_of_use_link: config.group.terms_of_use_link,
    debug: config.client.debug || false,
    group: config.group,
    urls: config.server.urls,
    mediaurl: config.server.urls.mediaurl,
    resourcesurl: config.server.urls.clienturl,
    vectorurl:config.server.urls.vectorurl,
    projects: config.group.projects,
    initproject: config.group.initproject,
    overviewproject: (config.group.overviewproject && config.group.overviewproject.gid) ? config.group.overviewproject : null,
    baselayers: config.group.baselayers,
    mapcontrols: config.group.mapcontrols,
    background_color: config.group.background_color,
    crs: config.group.crs,
    proj4: config.group.proj4,
    minscale: config.group.minscale,
    maxscale: config.group.maxscale,
    // richiesto da ProjectService
    getWmsUrl: function(project){
      return config.server.urls.baseurl+config.server.urls.ows+'/'+config.group.id+'/'+project.type+'/'+project.id;
    },
    // richiesto da ProjectsRegistry per acquisire informazioni specifiche del progetto
    getProjectConfigUrl: function(project){
      return config.server.urls.baseurl+config.server.urls.config+'/'+config.group.id+'/'+project.type+'/'+project.id;
    },
    plugins: config.group.plugins,
    tools: config.tools,
    views: config.views || {},
    user: config.user || null
  };
}

// questa è la configurazione base del template che conterrà tutti gli
// elementi previsti dal template. Nella definizione sono tutti oggetti vuoti
// Sarà l'applicazione a scegliere di riempire gli elementi
function createTemplateConfig() {
  // recupero i componenti
  var CatalogComponent = require('sdk').gui.vue.CatalogComponent;
  var SearchComponent = require('sdk').gui.vue.SearchComponent;
  var PrintComponent = require('sdk').gui.vue.PrintComponent;
  var ToolsComponent = require('sdk').gui.vue.ToolsComponent;
  var MapComponent = require('sdk').gui.vue.MapComponent;
  var ContentsComponent = require('./template/js/contentsviewer');
  //al momento si utilizza quesllo quenerico ma si potrebbe costruire un componente
  //ad hoc per i risultati
  var QueryResultsComponent = require('sdk').gui.vue.QueryResultsComponent;
  return {
    title: config.apptitle,
    placeholders: {
      navbar: {
        components: []
      },
      sidebar: {
        components: [
          new PrintComponent({
            id: 'print',
            open: false,
            collapsible: true, //  i permette di capire se cliccandoci sopra posso lanciare il setOpen del componente
            icon: "fa fa-print"
          }),
          new SearchComponent({
            id: 'search',
            open: false,
            collapsible: true,
            icon: "fa fa-search"
          }),
          new CatalogComponent({
            id: 'catalog',
            open: false,
            collapsible: false,
            icon: "fa fa-map-o"
          }),
          // qui vanno i plugins sotto forma di tools
          new ToolsComponent({
            id: 'tools',
            open: false,
            collapsible: true,
            icon: "fa fa-gears"
          })
        ]
      },
      floatbar:{
        components: []
      }
    },
    othercomponents: [
      new QueryResultsComponent({
        id: 'queryresults'
      })
    ],
    viewport: {
      // placeholder del contenuto (view content) inizialmente Vista Secondaria (nascosta)
      components: {
        map: new MapComponent({
          id: 'map'
        }),
        content: new ContentsComponent({
          id: 'contents'
        })
      }
    }
  }
}

function sendErrorToApplicationTemplate(reloadFnc,error) {
  if (error && error.responseJSON && error.responseJSON.error.data) {
    error = error.responseJSON.error.data
  } else {
    error = 'Errore di connessione'
  }
  // stato un erore ne caricamento della configurazione del progetto
  // passo la stessa funzione di bootstrap
  ApplicationTemplate.fail(reloadFnc, error);
}

ApplicationService.on('ready', function() {
  //istanzio l'appication template passando la configurazione
  // del template e l'applicationService che fornisce API del progetto
  var templateConfig = createTemplateConfig();
  //istanzio l'application Template passando il templateconfig, l'applicationservice
  applicationTemplate = new ApplicationTemplate(templateConfig, this);
  //inizializzo e faccio partire con il metodo init
  applicationTemplate.init();
  // quando (dopo la chiamta e il setup del layout etc..) dell'application template
  // è ready lancio l'applicationTemplate service postBoostrat
  applicationTemplate.on('ready', function() {
    ApplicationService.postBootstrap();
  });
});

// funzione che viene lanciata al momento di caricare app.js
var bootstrap = function() {
  //ottengo al configurazione inizilae del gruppo di progetti
  // config.server.urls.initconfig: è l'api url a cui chiedere la configurazione iniziale
  ApplicationService.obtainInitConfig(config.server.urls.initconfig)
  .then(function(initConfig) {
    // una volta ottenuta la configurazione inziale
    // vado a scrivere gli url dei file statici e del media urld del base url e del vector url
    config.server.urls.baseurl = initConfig.baseurl;
    config.server.urls.staticurl = initConfig.staticurl;
    config.server.urls.clienturl = initConfig.staticurl+initConfig.client;
    config.server.urls.mediaurl = initConfig.mediaurl;
    config.server.urls.vectorurl = initConfig.vectorurl;
    config.group = initConfig.group;
    config.user = initConfig.user;
    var applicationConfig = createApplicationConfig();
    // unavolta ottenuta la configurazione e settetat in modo digeribile all'applicazione
    // la vado a pssare al metodo init dell'application service
    ApplicationService.init(applicationConfig, true) // lancio manualmente il postBootstrp
      .then(function() {
        // andato tutto a buon fine
      })
      .fail(function(error) {
        sendErrorToApplicationTemplate(bootstrap, error);
      })
  })
  .fail(function(error) {
    sendErrorToApplicationTemplate(bootstrap, error);
  })
};

// lancio subito il bootstrap
bootstrap();


},{"./config/config.js":1,"./template/js/contentsviewer":13,"./template/js/template":19,"sdk":184,"sdk/sdk":184}],4:[function(require,module,exports){
module.exports = "<div class=\"wrapper\">\n  <header class=\"main-header\">\n    <!-- Logo -->\n    <!-- Header Navbar: style can be found in header.less -->\n    <nav class=\"navbar navbar-static-top\" role=\"navigation\">\n      <!-- Toggle button on navbar only for mobile -->\n      <a v-if=\"isMobile()\" href=\"#\" class=\"sidebar-toggle\" data-toggle=\"offcanvas\" role=\"button\">\n        <span class=\"sr-only\">Expand</span>\n      </a>\n      <div class=\"logo-wrapper\">\n        <a v-if=\"logo_url\" :href=\"logo_link\" :target=\"logo_link_target\" class=\"\"><img :src=\"logo_url\" style=\"height:40px\"></a>\n        <span class=\"\">{{project_title}}</span>\n      </div>\n      <div v-if=\"user\" class=\"navbar-custom-menu\">\n        <ul class=\"nav navbar-nav\">\n          <li class=\"dropdown user\" v-if=\"numberOfProjectsInGroup > 1\">\n            <a href=\"#\" @click=\"openProjectsMenu\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n              <i class=\"fa fa-th\" aria-hidden=\"true\"></i>\n              <span> Cambia Mappa</span>\n            </a>\n          </li>\n          <li class=\"dropdown user user-menu\">\n            <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n              <i class=\"fa fa-user\"></i>\n              <span class=\"hidden-xs\">{{ user.username }}</span>\n            </a>\n            <ul class=\"dropdown-menu\">\n              <li class=\"user-header\">\n                <p>\n                  {{ user.first_name }} {{ user.last_name }}\n                </p>\n              </li>\n              <li class=\"user-footer\">\n                <div class=\"pull-left\">\n                  <a :href=\"user.admin_url\" class=\"btn btn-default btn-flat\"><i class=\"fa fa-folder\"></i> Admin</a>\n                </div>\n                <div class=\"pull-right\">\n                  <a :href=\"user.logout_url\" class=\"btn btn-default btn-flat\"><i class=\"fa fa-sign-out\"></i>Sign out</a>\n                </div>\n              </li>\n            </ul>\n          </li>\n          <li class=\"dropdown user user-menu\">\n            <a href=\"#\" data-toggle=\"modal\" data-target=\"#credits\" class=\"dropdown-toggle\">\n              <span>Credits</span>\n            </a>\n          </li>\n        </ul>\n      </div>\n    </nav>\n  </header>\n  <!-- Left side column. contains the logo and sidebar -->\n  <sidebar></sidebar>\n  <!-- Content Wrapper. Contains page content -->\n  <div class=\"content-wrapper\" style=\"background-color:white\">\n    <viewport></viewport>\n  </div>\n  <!-- /.content-wrapper -->\n  <!-- Control Sidebar -->\n  <floatbar></floatbar>\n  <!-- /.control-sidebar -->\n  <!-- Add the sidebar's background. This div must be placed\n       immediately after the control sidebar -->\n  <div class=\"control-sidebar-bg\"></div>\n  <!--full screen modal element-->\n  <div class=\"modal fade modal-fullscreen force-fullscreen\" id=\"full-screen-modal\" tabindex=\"-1\" role=\"dialog\" data-backdrop=\"static\" data-keyboard=\"false\" aria-labelledby=\"full-screen-modal\" aria-hidden=\"true\"></div>\n  <!---->\n  <div id=\"credits\" class=\"modal fade\">\n    <div class=\"modal-dialog\" role=\"document\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n          </button>\n          <a style=\"text-align: center!important;\" href=\"http://www.gis3w.it\" target=\"_blank\">\n            <img src=\"http://gis3w.it/wp-content/uploads/sites/7/2017/01/logo_gis3w_156_85.png?x22227\" class=\"img-responsive center-block\" alt=\"\">\n            <div style=\"text-align: center!important; margin-bottom:50px; margin-top:20px; color:#000000\">\n              <h4>GIS3W s.n.c.</h4>\n            </div>\n          </a>\n          <address id=\"address-credits\" style=\"line-height: 2; text-align: center;\">\n            <i class=\"fa fa-map-marker\" aria-hidden=\"true\"></i>\n            <span> Viale Verdi, 24 - Montecatini Terme (PT)</span></br>\n            <i class=\"fa fa-mobile\" aria-hidden=\"true\"></i>\n            <span> +39 347 6597931</span></br>\n            <i class=\"fa fa-fax\" aria-hidden=\"true\"></i>\n            <span> +39 0572 901639</span></br>\n            <i class=\"fa fa-envelope\" aria-hidden=\"true\">\n            </i>\n            <span><a href=\"mailto:info@gis3w.it\" style=\"color:#000000\"> info@gis3w.it</a></span>\n          </address>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],5:[function(require,module,exports){
module.exports = "<div id=\"contents\" class=\"contents\"></div>\n";

},{}],6:[function(require,module,exports){
module.exports = "<aside class=\"control-sidebar control-sidebar-light\" >\n  <a v-show=\"panelsinstack\" href=\"#\" class=\"floatbar-aside-toggle\" data-toggle=\"control-sidebar\" role=\"button\">\n    <span class=\"sr-only\">Expand</span>\n  </a>\n  <div id=\"floatbar-spinner\" style=\"position:absolute\"></div>\n  <div v-show=\"panelsinstack\" class=\"g3w-sidebarpanel\">\n    <div v-if=\"closable\" class=\"row\">\n      <div class=\"col-xs-12 col-sm-12 col-md-12\">\n        <button class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closePanel\"></button>\n      </div>\n    </div>\n    <div v-if=\"panelname\">\n      <h4 class=\"g3w-floatbarpanel-name\">{{ panelname }}</h4>\n    </div>\n    <div id=\"g3w-floatbarpanel-placeholder\" class=\"g3w-floatbarpanel-placeholder\"></div>\n  </div>\n</aside>\n";

},{}],7:[function(require,module,exports){
module.exports = "<div id=\"menu-projects\" class=\"container nano\">\n  <div v-show=\"loading\" class=\"bar-loader\"></div>\n  <div class=\"nano-content\">\n    <div class=\"row row-equal\">\n      <!-- item -->\n      <div v-for=\"menuitem in state.menuitems\"  @click=\"trigger(menuitem)\" class=\"col-xs-12 col-sm-4 project-menu\">\n        <div class=\"project-menu-item-image\">\n          <img :src=\"logoSrc(menuitem.thumbnail)\" class=\"img-responsive\">\n        </div>\n        <div class=\"project-menu-item-content\">\n          <div class=\"project-menu-item-text\">\n            <h4 class=\"project-menu-item-title\">{{ menuitem.title }}</h4>\n            <div v-html=\"menuitem.description\"></div>\n          </div>\n        </div>\n      </div>\n      <div v-if=\"!state.menuitems.length\" style=\"margin-left:15px;\">\n        <h2>Non ci sono altri progetti in questo gruppo cartografico</h2>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],8:[function(require,module,exports){
module.exports = "<li  v-show=\"state.visible\" class=\"treeview sidebaritem\" :class=\"{'active': open}\">\n  <a @click=\"onClickItem\" href=\"#\">\n    <i :class=\"icon\"></i>\n    <span class=\"treeview-label\">{{title | t}}</span>\n    <i class=\"fa fa-angle-left pull-right\"></i>\n  </a>\n  <div id=\"g3w-sidebarcomponent-placeholder\"></div>\n</li>\n";

},{}],9:[function(require,module,exports){
module.exports = "<aside class=\"main-sidebar\">\n  <!-- sidebar: style can be found in sidebar.less -->\n  <!-- Sidebar toggle button-->\n  <!-- Toggle button on the left side of main sidebar only if not mobile -->\n  <a v-if=\"!isMobile()\" href=\"#\" class=\"sidebar-aside-toggle\" data-toggle=\"offcanvas\" role=\"button\">\n    <span class=\"sr-only\">Expand</span>\n  </a>\n  <!--<div class=\"quick-actions-menu\">-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-share-alt\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-modal-window\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-print\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-search\"></button>-->\n  <!--</div>-->\n\t<section class=\"sidebar\">\n    <div v-show=\"panelsinstack\" class=\"g3w-sidebarpanel\">\n      <div style=\"overflow: hidden;line-height: 14px;margin-top: 4px; font-size:1.5em\">\n          <button class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closePanel\"></button>\n      </div>\n      <div id=\"g3w-sidebarpanel-placeholder\" class=\"g3w-sidebarpanel-placeholder\"></div>\n    </div>\n\t  <ul id=\"g3w-sidebarcomponents\" v-show=\"showmainpanel\" class=\"sidebar-menu\"></ul>\n\t</section>\n\t<!-- /.sidebar -->\n</aside>\n";

},{}],10:[function(require,module,exports){
module.exports = "<div class=\"g3w-viewport\">\n  <div id=\"g3w-view-map\" class=\"g3w-view map\" :style=\"{width:state.map.sizes.width+'px',height:state.map.sizes.height+'px'}\">\n  </div>\n  <div id=\"g3w-view-content\" class=\"g3w-view content\" :style=\"{width:state.content.sizes.width+'px',height:state.content.sizes.height+'px'}\">\n    <div v-if=\"(showtitle && contentTitle) || previousTitle || (state.content.closable && state.content.aside)\" class=\"close-panel-block\">\n      <div v-if=\"previousTitle\" class=\"g3w_contents_back\">\n        <span  @click=\"gotoPreviousContent()\"><span class=\"glyphicon glyphicon-chevron-left\"></span> Torna  {{ previousTitle }}</span>\n      </div>\n      <button v-if=\"state.content.closable && state.content.aside\" class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closeContent\"></button>\n      <div v-if=\"showtitle && contentTitle\">\n        <span>{{ contentTitle }}</span>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],11:[function(require,module,exports){
var ApplicationService = require('core/applicationservice');
var ProjectsRegistry = require('core/project/projectsregistry');
var ProjectsMenuComponent = require('./projectsmenu');
var GUI = require('sdk/gui/gui');
var layout = require('./layout');
var AppUI = Vue.extend({
  template: require('../html/app.html'),
  mounted: function(){
    this.$nextTick(function(){
      /* start to render LayoutManager layout */
      layout.loading(false);
      layout.setup();
      //Fix the problem with right sidebar and layout boxed
      layout.pushMenu.expandOnHover();
      layout.controlSidebar._fix($(".control-sidebar-bg"));
      layout.controlSidebar._fix($(".control-sidebar"));
      var controlsidebarEl = layout.options.controlSidebarOptions.selector;
      function setFloatBarMaxHeight(){
        $(controlsidebarEl).css('max-height',$(window).innerHeight());
        $('.g3w-sidebarpanel').css('height',$(window).height() - $(".main-header").height());
      }
      setFloatBarMaxHeight();
      function setModalHeight(){
        $('#g3w-modal-overlay').css('height',$(window).height());
      }
      $(window).resize(function() {
        setFloatBarMaxHeight();
        setModalHeight();
      });
    })
  },
  computed: {
    logo_url: function() {
      var config = ApplicationService.getConfig();
      var logo_url;
      if (config.logo_img && config.logo_img!='') {
        logo_url = config.mediaurl+config.logo_img;
      }
      return logo_url;
    },
    logo_link: function() {
      var logo_link = this.getLogoLink();
      return logo_link ? logo_link : "#";
    },
    logo_link_target: function() {
      var logo_link = this.getLogoLink();
      return logo_link ? "_blank" : "";
    },
    project_title: function() {
      var currentProject = ProjectsRegistry.getCurrentProject();
      return currentProject.state.name;
    },
    user: function() {
      var user = ApplicationService.getConfig().user;
      // verifico nel caso fosse un oggetto vuoto
      if (_.isEmpty(user)) {user = null}
      return user;
    },
    numberOfProjectsInGroup: function() {
      return ProjectsRegistry.getProjects().length;
    }
  },
  methods: {
    closePanel: function(){
      sidebarService.closePanel();
    },
    isMobile: function(){return isMobile.any},
    getLogoLink: function() {
      var logo_link = null;
      if (ApplicationService.getConfig().logo_link) {
        logo_link = ApplicationService.getConfig().logo_link;
      }
      return logo_link;
    },
    openProjectsMenu: function() {
      var contentsComponent = GUI.getComponent('contents');
      // verifico che il content è il projectsmenu
      if (contentsComponent.getComponentById('projectsmenu')) {
        GUI.closeContent();
      } else {
        GUI.setContent({
          content: new ProjectsMenuComponent(),
          title: '',
          perc:100
        });
      }
    }
  }
});

module.exports = AppUI;
},{"../html/app.html":4,"./layout":15,"./projectsmenu":17,"core/applicationservice":22,"core/project/projectsregistry":74,"sdk/gui/gui":132}],12:[function(require,module,exports){
var utils = require('sdk/core/utils/utils');
var inherit = require('sdk/core/utils/utils').inherit;
var G3WObject = require('sdk/core/g3wobject');
var Component = require('gui/vue/component');
var Panel = require('gui/panel');

//classe barstack
// Ha lo scopo di montare stack di pannelli
// sopra ogni parte del parent in questione
function BarStack() {
  this._parent = null;
  // state del barstak contenente array pannelli
  this.state = {
    contentsdata: []
  }
}

//eredita dall'oggetto G3WOBJECT
inherit(BarStack, G3WObject);

var proto = BarStack.prototype;

// funzione che immette il componente (di qualsiasi tipo) nel parent element
proto.push = function(content, options) {
  // parent è l'identificativo dell'elemento DOM sui cui montare (in append o meno) il component/panel
  this._parent = options.parent;
  // chiamo il metodo mount del barstack
  return this._mount(content, options);
};

// toglie l'ultimo componente dallo stack
proto.pop = function(){
  var self = this;
  var d = $.Deferred();
  // qui potremo chiedere al pannello se può essere chiuso...
  if (this.state.contentsdata.length) {
    var content = this.state.contentsdata.slice(-1)[0].content;
    return this._unmount(content)
    .then(function(){
      self.state.contentsdata.pop();
    })
  }
  else {
    d.resolve();
  }
  return d.promise();
};

// fa il clear di tutto lo stack in una volta sola
proto.clear = function() {
  var self = this;
  var d = $.Deferred();
  if (this.state.contentsdata.length) {
    var unmountRequests = [];
    _.forEach(this.state.contentsdata, function (data, idx) {
      unmountRequests.push(self._unmount(data.content));
    });
    $.when(unmountRequests).then(function () {
      //self.state.contentsdata = [];
      self.state.contentsdata.splice(0,self.state.contentsdata.length);
      d.resolve();
    });
  }
  else {
    d.resolve();
  }
  return d.promise();
};

proto.getContentData = function() {
  return this.state.contentsdata
};

proto.getCurrentContentData = function() {
  return this.state.contentsdata[this.state.contentsdata.length - 1];
};

proto.getPreviousContentData = function() {
  return this.state.contentsdata[this.state.contentsdata.length - 2];
};

// funzione che fa il mopnt del componente
proto._mount = function(content, options) {
  // verifico il tipo di content passato:
  //oggetto JQuery
  if (content instanceof jQuery) {
    return this._setJqueryContent(content);
  }
  //stringa
  else if (_.isString(content)) {
    var jqueryEl = $(content);
    // nel caso in cui content sia testo puro, devo wrapparlo in un tag HTML in modo che $() generi un elemento DOM
    if (!jqueryEl.length) {
      jqueryEl = $('<div>'+content+'</div>');
    }
    return this._setJqueryContent(jqueryEl);
  }
  // istanza componente (vue alla fine)
  else if (content.mount && typeof content.mount == 'function') {
    this._checkDuplicateVueContent(content); // nel caso esista già prima lo rimuovo
    return this._setVueContent(content,options)
  }
  // infine è elemento dom
  else {
    return this._setDOMContent(content);
  }
};

//funzione che permettere di appendere oggetto jquery
proto._setJqueryContent = function(content,options) {
  $(this._parent).append(content);
  this.state.contentsdata.push({
    content: content,
    options: options
  });
  return utils.resolve();
};

//funzione che appende dom element
proto._setDOMContent = function(content,options) {
  this._parent.appendChild(content);
  this.state.contentsdata.push({
    content: content,
    options: options
  });
  return utils.resolve();
};

// funzione che monta il componte su parent
proto._setVueContent = function(content, options) {
  var self = this;
  var d = $.Deferred();
  var append = options.append || false;
  content.mount(this._parent, append)
  .then(function(){
    $(parent).localize();
    // inserisco nell'array del content data un oggetto avente attributi:
    // content: oggetto component
    // options: oprizioni riguardanti title, perc etc ...
    self.state.contentsdata.push({
      content: content,
      options: options
    });
    d.resolve();
  });
  return d.promise();
};

// verifica nel caso di un componente vue
proto._checkDuplicateVueContent = function(content) {
  var self = this;
  var idxToRemove = null;
  var id = content.getId();
  _.forEach(this.state.contentsdata, function(data,idx) {
    if (data.content.getId && (data.content.getId() == id)) {
      idxToRemove = idx;
    }
  });
  if (!_.isNull(idxToRemove)) {
    var data = self.state.contentsdata[idxToRemove];
    data.content.unmount()
      .then(function() {
        self.state.contentsdata.splice(idxToRemove,1);
      });
  }
};

// smonta il componente
proto._unmount = function(content) {
  var self = this;
  var d = $.Deferred();
  if (content instanceof Component || content instanceof Panel) {
    content.unmount()
    .then(function(){
      d.resolve();
    });
  }
  else {
    $(this._parent).empty();
    d.resolve();
  }
  return d.promise();
};

proto.forEach = function(cbk) {
  _.forEach(this.state.contentsdata,function(data){
    cbk(data.content);
  })
};

// resituisce la lunghezza (numero elementi) dello stack
proto.getLength = function() {
  return this.state.contentsdata.length;
};

module.exports = BarStack;

},{"gui/panel":153,"gui/vue/component":182,"sdk/core/g3wobject":30,"sdk/core/utils/utils":80}],13:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Stack = require('./barstack.js');
// componente base
var Component = require('gui/vue/component');

// componente interno (VUE) del content della viewport
var InternalComponent = Vue.extend({
  template: require('../html/contentsviewer.html'), // altro non è che <div id="contents" class="contents"></div>
  data: function() {
    return {
      state: null
    }
  }
});

// componente content Viewer
function ContentsViewerComponent(options) {
  base(this, options);
  this.stack = new Stack();
  // setta come servizio se stesso
  this.setService(this);
  this.title = "contents";
  // lo state del component padre è
  /*
   this.state = {
    visible: options.visible || true,
    open: options.open || false
   }
   */
  this.contentsdata = this.stack.state.contentsdata;
  this.state.visible = true;
  // vado a settare il componente interno
  // sfruttando il metodo del componente base
  this.setInternalComponent(new InternalComponent({
    service: this
  }));
  // setto lo state del componente interno vue uguale allo state del service
  // che non è altro lo state component padre state={open, visible};
  this.internalComponent.state = this.state;
}

/// stooto classe di Component
inherit(ContentsViewerComponent, Component);

var proto = ContentsViewerComponent.prototype;

// setta il contenuto dell content
proto.setContent = function(options) {
  var self = this;
  var d = $.Deferred();
  var push = options.push || false;
  var content = options.content;
  // svuoto sempre lo stack, così ho sempre un solo elemento (la gestione dello stack è delegata alla viewport).
  // Uso comunque barstack perché implementa già la logica di montaggio dei contenuti nel DOM
  if (!push) {
    // elemino tutto lo stack content
    this.clearContents()
    .then(function() {
      self.addContent(content, options)
      .then(function(){
        d.resolve();
      })
    })
  }
  else {
    this.addContent(content,options)
    .then(function(){
      d.resolve();
    })
  }
  this.setOpen(true);
  return d.promise();
};

//aggiunge al componente base content componenti
proto.addContent = function(content, options) {
  var self = this;
  // l'emento parente è proprio il template content
  options.parent = this.internalComponent.$el;
  // definisce l'append a true
  options.append = true;
  // stack.push è una promise
  return this.stack.push(content, options)
  .then(function() {
    // prendo il contentuo dello stack
    self.contentsdata = self.stack.state.contentsdata;
    // aggiorna la visibilità dei vari componenti vue montati
    self.updateContentVisibility();
  })
};

// rimuove il contenuto dallo stack
proto.removeContent = function() {
  this.setOpen(false);
  return this.clearContents();
};

// usato da viewport.js
proto.popContent = function() {
  var self = this;
  return this.stack.pop()
  .then(function() {
    // solo dopo che lo stack è stato aggiornato aggiorna il contentsdata
    self.contentsdata = self.stack.state.contentsdata;
    // aggiorna la visibilità dei vari componenti vue montanti
    self.updateContentVisibility();
  });
};

// recupera il component attraverso la classe
proto.getComponentByClass = function(componentClass) {
  var component;
  var contentdata = this.stack.getContentData();
  _.forEach(contentdata, function(content) {
    if (content.content instanceof componentClass) {
      component = content.content;
      return false
    }
  });
  return component
};

// recupera il component attraverso l'id del componente
proto.getComponentById = function(id) {
  var component;
  var contentdata = this.stack.getContentData();
  _.forEach(contentdata, function(content) {
    if (content.content.id == id) {
      component = content.content;
      return false
    }
  });
  return component
};

proto.getContentData = function() {
  return this.stack.getContentData();
};

// restituisce il current contentdata
proto.getCurrentContentData = function(){
  return this.stack.getCurrentContentData();
};

// restituisce il previuos content data
proto.getPreviousContentData = function() {
  return this.stack.getPreviousContentData();
};

// funzione che aggiorna la visibilità dei componenti del content
proto.updateContentVisibility = function() {
  // hide tuttigli elementi all'infuri che l'ultimo
  var contentsEls = $(this.internalComponent.$el).children();
  contentsEls.hide();
  contentsEls.last().show();
};

// fa il clear dello stack in quanto si vuole che lo stack del contenteComponente
// deve essere sempre vuoto in partenza
proto.clearContents = function() {
  var self = this;
  return this.stack.clear()
  .then(function() {
    self.contentsdata = self.stack.state.contentsdata;
  })
};

// funzione che serve per definire di volta in volta il layout del content
// i parametri sono l'altezza e la larghezza dell'elemento parent contenitore
proto.layout = function(parentWidth, parentHeight) {
  var self = this;
  // elemento template del componente vue
  var el = $(this.internalComponent.$el);
  //lancia la callback solo dopo che è stato aggiornato lo stato di Vue
  Vue.nextTick(function() {
    // el.parent() è il div g3w-view-content
    var height = el.parent().height() - el.siblings('.close-panel-block').outerHeight(true) - el.siblings('.g3w_contents_back').outerHeight(true);
    el.height(height);
    el.children().first().height(height);
    var contentsdata = self.stack.state.contentsdata;
    contentsdata.forEach(function(data) {
      //vado a scorrere su tutti i cmponenti caricari nello stack
      if (typeof data.content.layout == 'function') {
        // vado a chiamare la funzione layout di tutti i componenti presenti nello stack
        data.content.layout(parentWidth, height);
      }
    })
  })
};

module.exports = ContentsViewerComponent;

},{"../html/contentsviewer.html":5,"./barstack.js":12,"core/utils/utils":80,"gui/vue/component":182}],14:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
var Stack = require('./barstack.js');
var GUI = require('sdk/gui/gui');

function FloatbarService(){
  this.stack = new Stack();
  this.init = function(layout){
    this.layout = layout;
    this.sidebarEl = $(this.layout.options.controlSidebarOptions.selector);
    this._zindex = this.sidebarEl.css("z-index");
    this._modalOverlay = null;
    this._modal = false;
    this._isopen = false;
  };

  this.isOpen = function() {
    return this._isopen;
  };

  this.open = function() {
    this.layout.floatBar.open(this.sidebarEl,true);
    this._isopen = true;
  };

  this.close = function() {
    this.layout.floatBar.close(this.sidebarEl,true);
    this._isopen = false;
  };

  this.showPanel = function(panel,options){
    var options = options || {};
    var append = options.append || false;
    var modal = options.modal || false;
    options.parent = "#g3w-floatbarpanel-placeholder";
    this.stack.push(panel, options);
    if (!this._isopen) {
      this.open();
    };
  };
  
  this.closePanel = function(panel){
    if (panel) {
      this.stack.remove(panel);
    }
    else {
      this.stack.pop();
    }
    if (!this.stack.getLength()) {
      if (this._modal){
        GUI.setModal(false);
        this.close();
        $('.control-sidebar-bg').toggleClass('control-sidebar-bg-shadow');
        this.sidebarEl.css("z-index","");
        this.sidebarEl.css("padding-top","50px");
        $('.control-sidebar-bg').css("z-index","");
        this._modal = false;
      }
      else {
        this.close();
      }
    }
  };
  
  this.hidePanel = function(){
    this.close();
  };
}

var floatbarService = new FloatbarService();

var FloatbarComponent = Vue.extend({
    template: require('../html/floatbar.html'),
    data: function() {
    	return {
        stack: floatbarService.stack.state,
      };
    },
    computed: {
      // quanti pannelli sono attivi nello stack
      panelsinstack: function(){
        return this.stack.contentsdata.length>0;
      },
      panelname: function(){
        var name;
        if (this.stack.contentsdata.length){
          name = this.stack.contentsdata.slice(-1)[0].content.getTitle();
        }
        return name;
      },
      closable: function() {
        return floatbarService.closable;
      }
    },
    watch: {
      // TODO: Brutto, ma è l'unico (per ora) modo flessibile che ho trovato per implementare il concetto di stack... 
      "stack.contentsdata": function(){
        var children = $("#g3w-floatbarpanel-placeholder").children();
        _.forEach(children,function(child,index){
          if (index == children.length-1){
            $(child).show();
          }
          else {
            $(child).hide();
          }
        })
      }
    },
    methods: {
      closePanel: function(){
        floatbarService.closePanel();
      }
    }
});

module.exports = {
  FloatbarService: floatbarService,
  FloatbarComponent: FloatbarComponent
};

},{"../html/floatbar.html":6,"./barstack.js":12,"sdk/core/i18n/i18n.service":33,"sdk/gui/gui":132}],15:[function(require,module,exports){
//Make sure jQuery has been loaded before app.js
if (typeof jQuery === "undefined") {
  throw new Error("LayoutManager requires jQuery");
}

$.LayoutManager = {};

/* --------------------
 * - LayoutManager Options -
 * --------------------
 * Modify these options to suit your implementation
 */
$.LayoutManager.options = {
  //Add slimscroll to navbar menus
  //This requires you to load the slimscroll plugin
  //in every page before app.js
  navbarMenuSlimscroll: true,
  navbarMenuSlimscrollWidth: "0px", //The width of the scroll bar
  navbarMenuHeight: "200px", //The height of the inner menu
  //General animation speed for JS animated elements such as box collapse/expand and
  //sidebar treeview slide up/down. This options accepts an integer as milliseconds,
  //'fast', 'normal', or 'slow'
  animationSpeed:'fast',
  //Sidebar push menu toggle button selector
  sidebarToggleSelector: "[data-toggle='offcanvas']",
  //Activate sidebar push menu
  sidebarPushMenu: true,
  //Activate sidebar slimscroll if the fixed layout is set (requires SlimScroll Plugin)
  sidebarSlimScroll: true,
  //Enable sidebar expand on hover effect for sidebar mini
  //This option is forced to true if both the fixed layout and sidebar mini
  //are used together
  sidebarExpandOnHover: false,
  //BoxRefresh Plugin
  enableBoxRefresh: true,
  //Bootstrap.js tooltip
  enableBSToppltip: true,
  BSTooltipSelector: "[data-toggle='tooltip']",
  //Enable Fast Click. Fastclick.js creates a more
  //native touch experience with touch devices. If you
  //choose to enable the plugin, make sure you load the script
  //before LayoutManager's app.js
  enableFastclick: true,
  //Control Sidebar Options
  enableControlSidebar: true,
  controlSidebarOptions: {
    //Which button should trigger the open/close event
    toggleBtnSelector: "[data-toggle='control-sidebar']",
    //The sidebar selector
    selector: ".control-sidebar",
    //Enable slide over content
    slide: true
  },
  //Box Widget Plugin. Enable this plugin
  //to allow boxes to be collapsed and/or removed
  enableBoxWidget: true,
  //Box Widget plugin options
  boxWidgetOptions: {
    boxWidgetIcons: {
      //Collapse icon
      collapse: 'fa-minus',
      //Open icon
      open: 'fa-plus',
      //Remove icon
      remove: 'fa-times'
    },
    boxWidgetSelectors: {
      //Remove button selector
      remove: '[data-widget="remove"]',
      //Collapse button selector
      collapse: '[data-widget="collapse"]'
    }
  },
  //Direct Chat plugin options
  directChat: {
    //Enable direct chat by default
    enable: true,
    //The button to open and close the chat contacts pane
    contactToggleSelector: '[data-widget="chat-pane-toggle"]'
  },
  //Define the set of colors to use globally around the website
  colors: {
    lightBlue: "#3c8dbc",
    red: "#f56954",
    green: "#00a65a",
    aqua: "#00c0ef",
    yellow: "#f39c12",
    blue: "#0073b7",
    navy: "#001F3F",
    teal: "#39CCCC",
    olive: "#3D9970",
    lime: "#01FF70",
    orange: "#FF851B",
    fuchsia: "#F012BE",
    purple: "#8E24AA",
    maroon: "#D81B60",
    black: "#222222",
    gray: "#d2d6de"
  },
  //The standard screen sizes that bootstrap uses.
  //If you change these in the variables.less file, change
  //them here too.
  screenSizes: {
    xs: 480,
    sm: 768,
    md: 992,
    lg: 1200
  }
};


/* ----------------------------------
 * - Initialize the LayoutManager Object -
 * ----------------------------------
 * All LayoutManager functions are implemented below.
 */
$.LayoutManager._init = function() {
  'use strict';
  /* Layout
   * ======
   * Fixes the layout height in case min-height fails.
   *
   * @type Object
   * @usage $.LayoutManager.layout.activate()
   *        $.LayoutManager.layout.fix()
   *        $.LayoutManager.layout.fixSidebar()
   */
  $.LayoutManager.layout = {
    activate: function () {
      var _this = this;
      _this.fix();
      _this.fixSidebar();
      $(window, ".wrapper").resize(function () {
        _this.fix();
        _this.fixSidebar();
      });
    },
    fix: function () {
      //Get window height and the wrapper height
      var neg = $('.main-header').outerHeight() + $('.main-footer').outerHeight();
      var window_height = $(window).height();
      var sidebar_height = $(".sidebar").height();
      //Set the min-height of the content and sidebar based on the
      //the height of the document.
      if ($("body").hasClass("fixed")) {
        $(".content-wrapper, .right-side").css('min-height', window_height - $('.main-footer').outerHeight());
        $(".content-wrapper, .right-side").css('height', window_height - $('.main-footer').outerHeight());
      } else {
        var postSetWidth;
        if (window_height >= sidebar_height) {
          $(".content-wrapper, .right-side").css('min-height', window_height - neg);
          postSetWidth = window_height - neg;
        } else {
          $(".content-wrapper, .right-side").css('min-height', sidebar_height);
          postSetWidth = sidebar_height;
        }
        //Fix for the control sidebar height
        var controlSidebar = $($.LayoutManager.options.controlSidebarOptions.selector);
        if (typeof controlSidebar !== "undefined") {
          if (controlSidebar.height() > postSetWidth)
            $(".content-wrapper, .right-side").css('min-height', controlSidebar.height());
        }

      }
    },
    fixSidebar: function () {
      //Make sure the body tag has the .fixed class
      if (!$("body").hasClass("fixed")) {
        if (typeof $.fn.slimScroll != 'undefined') {
          $(".sidebar").slimScroll({destroy: true}).height("auto");
        }
        return;
      } else if (typeof $.fn.slimScroll == 'undefined' && window.console) {
        window.console.error("Error: the fixed layout requires the slimscroll plugin!");
      }
      //Enable slimscroll for fixed layout
      if ($.LayoutManager.options.sidebarSlimScroll) {
        if (typeof $.fn.slimScroll != 'undefined') {
          //Destroy if it exists
          $(".sidebar").slimScroll({destroy: true}).height("auto");
          //Add slimscroll
          $(".sidebar").slimscroll({
            height: ($(window).height() - $(".main-header").height()) + "px",
            color: "rgba(255,255,255,0.7)",
            size: "3px"
          });
        }
      }
      else {
         $(".sidebar").css({'height': ($(window).height() - $(".main-header").height()) + "px"})
      }
      
      /*$(".sidebar li a").each(function(){
        var $this = $(this);
        var checkElement = $this.next();
        if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
          //Get the parent menu
          var parent = $this.parents('ul').first();
          var parent_li = $this.parent("li");
          var li_siblings = parent_li.siblings();
          var parent_find_active;
          var sidebar_content_height = parent.height() - parent.find('li.header').outerHeight();
          var treeviewHeight = parent_li.outerHeight();
          li_siblings.not('.header').each(function(index, el) {
                  treeviewHeight+=$(el).find('a').outerHeight();
          });
          var section_height = (sidebar_content_height - treeviewHeight);
          checkElement.css({
            'height': section_height + 'px',
            'max-height':section_height + 'px',
            'overflow-y': 'auto'
          });
        }
      });*/
      
    }
    
  };

  /* PushMenu()
   * ==========
   * Adds the push menu functionality to the sidebar.
   *
   * @type Function
   * @usage: $.LayoutManager.pushMenu("[data-toggle='offcanvas']")
   */
  $.LayoutManager.pushMenu = {
    activate: function (toggleBtn) {
      //Get the screen sizes
      var screenSizes = $.LayoutManager.options.screenSizes;

      //Enable sidebar toggle
      $(toggleBtn).on('click', function (e) {
        e.preventDefault();

        //Enable sidebar push menu
        if ($(window).width() > (screenSizes.sm - 1)) {
          if ($("body").hasClass('sidebar-collapse')) {
            $("body").removeClass('sidebar-collapse').trigger('expanded.pushMenu');
          } else {
            $("body").addClass('sidebar-collapse').trigger('collapsed.pushMenu');
          }
        }
        //Handle sidebar push menu for small screens
        else {
          if ($("body").hasClass('sidebar-open')) {
            $("body").removeClass('sidebar-open').removeClass('sidebar-collapse').trigger('collapsed.pushMenu');
          } else {
            $("body").addClass('sidebar-open').trigger('expanded.pushMenu');
          }
        }
      });

      /*$(".content-wrapper").click(function () {
        //Enable hide menu when clicking on the content-wrapper on small screens
        if ($(window).width() <= (screenSizes.sm - 1) && $("body").hasClass("sidebar-open")) {
          $("body").removeClass('sidebar-open');
        }
      });*/

      //Enable expand on hover for sidebar mini
      if ($.LayoutManager.options.sidebarExpandOnHover || ($('body').hasClass('fixed') && $('body').hasClass('sidebar-mini'))) {
        this.expandOnHover();
      }
    },
    expandOnHover: function () {
      var _this = this;
      var screenWidth = $.LayoutManager.options.screenSizes.sm - 1;
      //Expand sidebar on hover
      $('.main-sidebar').hover(function () {
        if ($('body').hasClass('sidebar-mini') && $("body").hasClass('sidebar-collapse') && $(window).width() > screenWidth) {
          _this.expand();
        }
      }, function () {
        if ($('body').hasClass('sidebar-mini') && $('body').hasClass('sidebar-expanded-on-hover') && $(window).width() > screenWidth) {
          _this.collapse();
        }
      });
    },
    expand: function () {
      $("body").removeClass('sidebar-collapse').addClass('sidebar-expanded-on-hover');
    },
    collapse: function () {
      if ($('body').hasClass('sidebar-expanded-on-hover')) {
        $('body').removeClass('sidebar-expanded-on-hover').addClass('sidebar-collapse');
      }
    }
  };

  /* Tree()
   * ======
   * Converts the sidebar into a multilevel
   * tree view menu.
   *
   * @type Function
   * @Usage: $.LayoutManager.tree('.sidebar')
   */
  $.LayoutManager.tree = function (menu) {
    var _this = this;
    var animationSpeed = $.LayoutManager.options.animationSpeed;
    //click event //
    $(document).on('click', menu + ' li a', function (e) {

      //Get the clicked link and the next element
      var $this = $(this);
      //is the content of the "accordion" ul //
      var checkElement = $this.next();

      //Check if the next element is a menu and is visible
      if ((checkElement.is('.treeview-menu')) && (checkElement.is(':visible'))) {
        //Close the menu
        checkElement.slideUp(animationSpeed, function () {
          checkElement.parent("li.treeview").removeClass("active");
          checkElement.removeClass('menu-open');
          //Fix the layout in case the sidebar stretches over the height of the window
          //_this.layout.fix();
        });

      }
      //If the menu is not visible
      else if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
        //Get the parent menu
        var parent = $this.parents('ul').first();
        var parent_li = $this.parent("li");
        var li_siblings = parent_li.siblings();
        var parent_find_active;
        var sidebar_content_height = parent.height() - parent.find('li.header').outerHeight();
        var treeviewHeight = parent_li.outerHeight();
        li_siblings.not('.header').each(function(index, el) {
                treeviewHeight+=$(el).find('a').outerHeight();
        });
        var section_height = (sidebar_content_height - treeviewHeight);
        /*checkElement.css({
          'height': section_height + 'px',
          'max-height':section_height + 'px',
          //'overflow-y': 'auto'
        });*/
        //Close all open menus within the parent
        var ul = parent.find('ul.treeview-menu:visible').slideUp(animationSpeed);
        //Remove the menu-open class from the parent
        ul.removeClass('menu-open');
        //Get the parent li
        //Open the target menu and add the menu-open class
        checkElement.slideDown(animationSpeed, function () {
          //Add the class active to the parent li
          checkElement.addClass('menu-open');
          parent_find_active = parent.find('li.treeview.active');
          parent_find_active.removeClass('active');
          parent_li.addClass('active');
          //Fix the layout in case the sidebar stretches over the height of the window
          _this.layout.fix();
        });
      }
      //if this isn't a link, prevent the page from being redirected
      if (checkElement.is('.treeview-menu')) {
        e.preventDefault();
      }
      
      //$.LayoutManager.layout.fix();
      //$.LayoutManager.layout.fixSidebar();
    });
  };

  /* ControlSidebar
   * ==============
   * Adds functionality to the right sidebar
   *
   * @type Object
   * @usage $.LayoutManager.controlSidebar.activate(options)
   */
  $.LayoutManager.floatBar = $.LayoutManager.controlSidebar = {
    //instantiate the object
    activate: function () {
      //Get the object
      var _this = this;
      //Update options
      var o = $.LayoutManager.options.controlSidebarOptions;
      //Get the sidebar
      var sidebar = $(o.selector);
      //The toggle button
      var btn = $(o.toggleBtnSelector);

      //Listen to the click event
      btn.on('click', function (e) {
        e.preventDefault();
        //If the sidebar is not open
        if (!sidebar.hasClass('control-sidebar-open') && !$('body').hasClass('control-sidebar-open')) {
          //Open the sidebar
          _this.open(sidebar, o.slide);
        } else {
          _this.close(sidebar, o.slide);
        }
      });

      //If the body has a boxed layout, fix the sidebar bg position
      var bg = $(".control-sidebar-bg");
      _this._fix(bg);

      //If the body has a fixed layout, make the control sidebar fixed
      if ($('body').hasClass('fixed')) {
        _this._fixForFixed(sidebar);
      } else {
        //If the content height is less than the sidebar's height, force max height
        if ($('.content-wrapper, .right-side').height() < sidebar.height()) {
          _this._fixForContent(sidebar);
        }
      }
    },
    //Open the control sidebar
    open: function (sidebar, slide) {
      //Slide over content
      if (slide) {
        sidebar.addClass('control-sidebar-open');
      } else {
        //Push the content by adding the open class to the body instead
        //of the sidebar itself
        $('body').addClass('control-sidebar-open');
      }
    },
    //Close the control sidebar
    close: function (sidebar, slide) {
      if (slide) {
        sidebar.removeClass('control-sidebar-open');
      } else {
        $('body').removeClass('control-sidebar-open');
      }
    },
    _fix: function (sidebar) {
      var _this = this;
      if ($("body").hasClass('layout-boxed')) {
        sidebar.css('position', 'absolute');
        sidebar.height($(".wrapper").height());
        $(window).resize(function () {
          _this._fix(sidebar);
        });
      } else {
        sidebar.css({
          'position': 'fixed',
          'height': 'auto'
        });
      }
    },
    _fixForFixed: function (sidebar) {
      sidebar.css({
        'position': 'fixed',
        'max-height': '100%',
        //'overflow': 'auto',  // non dovrebbe fare danni questo commento, serve per non nascondere il pulsanti "Chiudi pannello"
        'padding-bottom': '50px'
      });
    },
    _fixForContent: function (sidebar) {
      $(".content-wrapper, .right-side").css('min-height', sidebar.height());
    }
  };

  /* BoxWidget
   * =========
   * BoxWidget is a plugin to handle collapsing and
   * removing boxes from the screen.
   *
   * @type Object
   * @usage $.LayoutManager.boxWidget.activate()
   *        Set all your options in the main $.LayoutManager.options object
   */
  $.LayoutManager.boxWidget = {
    selectors: $.LayoutManager.options.boxWidgetOptions.boxWidgetSelectors,
    icons: $.LayoutManager.options.boxWidgetOptions.boxWidgetIcons,
    animationSpeed: $.LayoutManager.options.animationSpeed,
    activate: function (_box) {
      var _this = this;
      if (!_box) {
        _box = document; // activate all boxes per default
      }
      //Listen for collapse event triggers
      $(_box).on('click', _this.selectors.collapse, function (e) {
        e.preventDefault();
        _this.collapse($(this));
      });

      //Listen for remove event triggers
      $(_box).on('click', _this.selectors.remove, function (e) {
        e.preventDefault();
        _this.remove($(this));
      });
    },
    collapse: function (element) {
      var _this = this;
      //Find the box parent
      var box = element.parents(".box").first();
      //Find the body and the footer
      var box_content = box.find("> .box-body, > .box-footer, > form  >.box-body, > form > .box-footer");
      if (!box.hasClass("collapsed-box")) {
        //Convert minus into plus
        element.find(".btn-collapser")
                .removeClass(_this.icons.collapse)
                .addClass(_this.icons.open);
        //Hide the content
        box_content.slideUp(_this.animationSpeed, function () {
          box.addClass("collapsed-box");
        });
      } else {
        //Convert plus into minus
        element.find(".btn-collapser")
                .removeClass(_this.icons.open)
                .addClass(_this.icons.collapse);
        //Show the content
        box_content.slideDown(_this.animationSpeed, function () {
          box.removeClass("collapsed-box");
        });
      }
    },
    remove: function (element) {
      //Find the box parent
      var box = element.parents(".box").first();
      box.slideUp(this.animationSpeed);
    }
  };
  
  return $.LayoutManager;
};

/* ------------------
 * - Custom Plugins -
 * ------------------
 * All custom plugins are defined below.
 */

/*
 * BOX REFRESH BUTTON
 * ------------------
 * This is a custom plugin to use with the component BOX. It allows you to add
 * a refresh button to the box. It converts the box's state to a loading state.
 *
 * @type plugin
 * @usage $("#box-widget").boxRefresh( options );
 */
$.LayoutManager.addRefreshButton = function () {
  "use strict";

  $.fn.boxRefresh = function (options) {

    // Render options
    var settings = $.extend({
      //Refresh button selector
      trigger: ".refresh-btn",
      //File source to be loaded (e.g: ajax/src.php)
      source: "",
      //Callbacks
      onLoadStart: function (box) {
        return box;
      }, //Right after the button has been clicked
      onLoadDone: function (box) {
        return box;
      } //When the source has been loaded

    }, options);

    //The overlay
    var overlay = $('<div class="overlay"><div class="fa fa-refresh fa-spin"></div></div>');

    return this.each(function () {
      //if a source is specified
      if (settings.source === "") {
        if (window.console) {
          window.console.log("Please specify a source first - boxRefresh()");
        }
        return;
      }
      //the box
      var box = $(this);
      //the button
      var rBtn = box.find(settings.trigger).first();

      //On trigger click
      rBtn.on('click', function (e) {
        e.preventDefault();
        //Add loading overlay
        start(box);

        //Perform ajax call
        box.find(".box-body").load(settings.source, function () {
          done(box);
        });
      });
    });

    function start(box) {
      //Add overlay and loading img
      box.append(overlay);

      settings.onLoadStart.call(box);
    }

    function done(box) {
      //Remove overlay and loading img
      box.find(overlay).remove();

      settings.onLoadDone.call(box);
    }

  };
  return $.LayoutManager;
};

/*
 * EXPLICIT BOX ACTIVATION
 * -----------------------
 * This is a custom plugin to use with the component BOX. It allows you to activate
 * a box inserted in the DOM after the app.js was loaded.
 *
 * @type plugin
 * @usage $("#box-widget").activateBox();
 */
$.LayoutManager.activateBox = function () {
  'use strict';

  $.fn.activateBox = function () {
    $.LayoutManager.boxWidget.activate(this);
  };
  
  return $.LayoutManager;
};

/*
 * TODO LIST CUSTOM PLUGIN
 * -----------------------
 * This plugin depends on iCheck plugin for checkbox and radio inputs
 *
 * @type plugin
 * @usage $("#todo-widget").todolist( options );
 */

$.LayoutManager.listCustomPlugin = function () {

	  'use strict';

	  $.fn.todolist = function (options) {
	    // Render options
	    var settings = $.extend({
	      //When the user checks the input
	      onCheck: function (ele) {
	        return ele;
	      },
	      //When the user unchecks the input
	      onUncheck: function (ele) {
	        return ele;
	      }
	    }, options);

	    return this.each(function () {

	      if (typeof $.fn.iCheck != 'undefined') {
	        $('input', this).on('ifChecked', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          settings.onCheck.call(ele);
	        });

	        $('input', this).on('ifUnchecked', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          settings.onUncheck.call(ele);
	        });
	      } else {
	        $('input', this).on('change', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          if ($('input', ele).is(":checked")) {
	            settings.onCheck.call(ele);
	          } else {
	            settings.onUncheck.call(ele);
	          }
	        });
	      }
	    });
	  };
	  return $.LayoutManager;
	};
	
	/* ------------------
	 * - Implementation -
	 * ------------------
	 * The next block of code implements LayoutManager's
	 * functions and plugins as specified by the
	 * options above.
	 */
	$.LayoutManager.setup = function ()
	{
	  "use strict";

	  //Fix for IE page transitions
	  $("body").removeClass("hold-transition");

	  //Extend options if external options exist
	  if (typeof LayoutManagerOptions !== "undefined") {
	    $.extend(true,
	            $.LayoutManager.options,
	            LayoutManagerOptions);
	  }

	  //Easy access to options
	  var o = $.LayoutManager.options;

	  //Set up the object
	  $.LayoutManager._init();

	  //Activate the layout maker
	  $.LayoutManager.layout.activate();

	  //Enable sidebar tree view controls
	  $.LayoutManager.tree('.sidebar');

	  //Enable control sidebar
	  if (o.enableControlSidebar) {
	    $.LayoutManager.controlSidebar.activate();
	  }

	  //Add slimscroll to navbar dropdown
	  if (o.navbarMenuSlimscroll && typeof $.fn.slimscroll != 'undefined') {
	    $(".navbar .menu").slimscroll({
	      height: o.navbarMenuHeight,
	      alwaysVisible: false,
	      size: o.navbarMenuSlimscrollWidth
	    }).css("width", "100%");
	  }

	  //Activate sidebar push menu
	  if (o.sidebarPushMenu) {
	    $.LayoutManager.pushMenu.activate(o.sidebarToggleSelector);
	  }

	  //Activate Bootstrap tooltip
	  if (o.enableBSToppltip) {
	    $('body').tooltip({
	      selector: o.BSTooltipSelector
	    });
	  }

	  //Activate box widget
	  if (o.enableBoxWidget) {
	    $.LayoutManager.boxWidget.activate();
	  }

	  //Activate fast click
	  if (o.enableFastclick && typeof FastClick != 'undefined') {
	    FastClick.attach(document.body);
	  }

	  //Activate direct chat widget
	  if (o.directChat.enable) {
	    $(document).on('click', o.directChat.contactToggleSelector, function () {
	      var box = $(this).parents('.direct-chat').first();
	      box.toggleClass('direct-chat-contacts-open');
	    });
	  }

	  /*
	   * INITIALIZE BUTTON TOGGLE
	   * ------------------------
	   */
	  $('.btn-group[data-toggle="btn-toggle"]').each(function () {
	    var group = $(this);
	    $(this).find(".btn").on('click', function (e) {
	      group.find(".btn.active").removeClass("active");
	      $(this).addClass("active");
	      e.preventDefault();
	    });

	  });
	  
	  return $.LayoutManager
	  	.addRefreshButton()
	  	.activateBox()
	  	.listCustomPlugin();
	};

$.LayoutManager.loading = function(start) {
  $('#initerror').remove();
  var start = _.isBoolean(start) ? start : true;
  if (start) {
    $('body').append('<div id="loadspinner" class="loading"></div>');
  }
  else {
    $('#loadspinner').remove();
  }
};

$.LayoutManager.reload = function(errorMsg) {
  $('body').append('<div id="initerror"><h2>Oops!!! Si è verificato un errore</h2>' +
    '<h4>Causa:  '+ errorMsg+'</h4>' +
    '<h5>Al momento non è possibile caricare la mappa</h5>' +
    '<button id="reload" type="button" class="btn btn-primary center-block" onclick="$.LayoutManager.loading();$.LayoutManager.bootstrap()">' +
    '<span class="glyphicon glyphicon-refresh"></span> <strong>Riprova</strong></button>' +
    '</div>'
  );
};

module.exports = $.LayoutManager;

},{}],16:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var GUI = require('gui/gui');
var ProjectsRegistry = require('core/project/projectsregistry');

var InternalComponent = Vue.extend({
  template: require('../html/menu.html'),
  data: function() {
    return {
      state: null,
      loading: false
    }

  },
  methods: {
    trigger: function(item) {
      var self = this;
      if (item.cbk) {
        //setto il modale a schermo intero
        $('#full-screen-modal').modal('show');
        this.loading = true;
        item.cbk.apply(item)
          .then(function(){
            self.loading = false;
            // tyolgo il modale a schermo intero
            $('#full-screen-modal').modal('hide');
          })
          .fail(function() {
            GUI.notify.error("<h4>Errore di caricamento della nuova mappa.</h4>" +
              "<h5>Controllare la connessione internet o contattare l'amministratore</h5>");
            $('#full-screen-modal').modal('hide');
            self.loading = false;
          })
      }
      else if (item.href) {
        window.open(item.href, '_blank');
      }
      else if (item.route) {
        GUI.goto(item.route);
      }
      else {
        console.log("Nessuna azione per "+item.title);
      }
    },
    logoSrc: function(src) {
      if (src.indexOf('./') > -1) {
        return ProjectsRegistry.config.mediaurl + src;
      } else {
        return src;
      }
    }
  },
  mounted: function() {
    Vue.nextTick(function () {
      $("#menu-projects.nano").nanoScroller();
    })
  }
});

function MenuComponent(options){
  options = options || {};
  base(this,options);
  //this.id = "menu_"+Date.now();
  this.title = options.title || "menu";
  this.state.visible = true;
  this.state.menuitems = options.menuitems;
  merge(this, options);
  this.internalComponent = new InternalComponent({
    service: this
  });
  this.internalComponent.state = this.state;
}
inherit(MenuComponent, Component);

var proto = MenuComponent.prototype;

proto.trigger = function(item) {

};

module.exports = MenuComponent;


},{"../html/menu.html":7,"core/i18n/i18n.service":33,"core/project/projectsregistry":74,"core/utils/utils":80,"gui/gui":132,"gui/vue/component":182}],17:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('core/plugin/pluginsregistry');
var MenuComponent = require('./menu');
var SidebarService = require('./sidebar').SidebarService;
var GUI = require('sdk').gui.GUI;

function ProjectsMenuComponent(options) {
  options = options || {};
  options.id = 'projectsmenu';
  base(this, options);
  var menuitems = [];
  var projects = ProjectRegistry.getListableProjects();
  _.forEach(projects, function(project){
    menuitems.push({
      title: project.title,
      description: project.description,
      thumbnail: project.thumbnail,
      cbk: function() {
        var d = $.Deferred();
        var currentProject;
        ProjectRegistry.getProject(project.gid)
        .then(function(project) {
          GUI.closeContent()
            .then(function() {
              currentProject = project;
              var currentUrl = window.location.href;
              var paths = currentUrl.split('/');
              if (!paths[ paths.length-1 ]) {
                paths[ paths.length-2 ] = project.getId();
                paths[ paths.length-3 ] = project.getType();
              } else {
                paths[ paths.length-1 ] = project.getId();
                paths[ paths.length-2 ] = project.getType();
              }
              //window.location = paths.join('/');
              // cambio la url
              history.pushState(null, null, paths.join('/'));
              // vado a cambiiare il set currentProject
              ProjectRegistry.setCurrentProject(currentProject);
              // vado a afre il reload dei plugins
              PluginsRegistry.reloadPlugins(project);
              // vado a fare il reloads dei component
              SidebarService.reloadComponents();
              d.resolve();
            })
        })
        .fail(function() {
          d.reject();
        });
        return d.promise();
      }
    })
  });
  this.state.menuitems = menuitems;
}

inherit(ProjectsMenuComponent, MenuComponent);

module.exports = ProjectsMenuComponent;



},{"./menu":16,"./sidebar":18,"core/i18n/i18n.service":33,"core/plugin/pluginsregistry":69,"core/project/projectsregistry":74,"core/utils/utils":80,"sdk":184}],18:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
var inherit = require('sdk/core/utils/utils').inherit;
var Stack = require('./barstack.js');
var G3WObject = require('sdk/core/g3wobject');
var base = require('sdk/core/utils/utils').base;

//sidebar item che non è altro che un li della sidebar dove sarà possibile impostare
//titolo tipo di icona etc .. customizzata per ogni componente
var SidebarItem = Vue.extend({
  template: require('../html/sidebar-item.html'),
  data: function() {
    return {
        main: true,
        component: null,
        active: false,
        title: 'component',
        open: false,
        icon: null,
        state: null
      };
  },
  methods: {
    onClickItem: function() {
      var self = this;
      var sidebarService = this.$options.service;
      this.component.setOpen(!this.component.state.open);
      // setto lo stato del componente open
      _.forEach(sidebarService.state.components, function (component) {
        if (component != self.component && self.component.collapsible) {
          component.setOpen(false);
        }
      })
    }
  }
});

// service sidebar
function SidebarService() {
  //stack della sidebar
  this.stack = new Stack();
  // metto i setter close sidebarpanel per catturare l'evento
  // della chiusura del pannello sulla sidebar
  this.setters = {
    closeSidebarPanel: function()  {
      //hook function
    },
    openCloseItem: function(bool) {
    }
  };
  //stato del servizio
  this.state = {
    components: []
  };
  //inizializzazione del servizio (non sembra chaimato mai)
  this.init = function(layout) {
    this.layout = layout;
  };
  // funzione che serve ad aggiungere componeti alla sidebar
  this.addComponents = function(components){
    var self = this;
    // per ogni componente (istanza) appartenete alla sidebar viene chiamato il metodo
    // addComponent
    _.forEach(components,function(component){
      self.addComponent(component);
    });
    // rtorno true alla fine dell'aggiunta dei componenti perchè mi serve
    // al template durante il buoldtemplate di dire se è stato regitstrato (true) o meno
    return true;
  };
  // funzione che aggiunge il singolo componente sulla sidebar
  // aggiungo anche possibilità di insicare la positione nella sidebar
  this.addComponent = function(component, position) {
    //faccio montare il sidebar-item che contiene al suo interno il placeholder del componente vero e proprio
    //in questo modo il componente non si dovrà occupare di costruire anche l'elemento li della sidebar
    //ma conterrà solo il contenuto
    var sidebarItem = new SidebarItem({
      service: this
    });
    //setto le parti della sidebar-item che cambiano da componente a componente (da rivedere)
    sidebarItem.title = component.title || sidebarItem.title;
    sidebarItem.open = component.state.open;//(component.open === undefined) ? sidebarItem.open : component.open;
    sidebarItem.icon = component.icon || sidebarItem.icon;
    sidebarItem.state = component.state || true;
    sidebarItem.collapsible = component.collapsible || true;
    sidebarItem.component = component;
    //lo appendo al g3w-sidebarcomponents (template sidebar.html)
    var itemcomponent = sidebarItem.$mount();
    if (_.isNil(position)) {
      this.state.components.push(component);
      $('#g3w-sidebarcomponents').append(itemcomponent.$el);
    } else {
      this.state.components = this.state.components.splice(0,0,component);
      $('#g3w-sidebarcomponents').children().each(function(index, element) {
        if (position == index) {
          $(itemcomponent.$el).insertBefore(element);
        }
      });
    }
    //monto il componete nella g3w-sidebarcomponent-placeholder (template sidebar-item.html);
    component.mount("#g3w-sidebarcomponent-placeholder");
    // verifico che il componete abbia l'iniService come metodo
    if (_.has(component, 'initService')) {
      //se si lo chiamo inizializzazione del servizo
      component.initService();
    }
    return true;
  };

  // restituisce il component in base all'id
  this.getComponent = function(id) {
    var Component;
    _.forEach(this.state.components, function(component) {
      if (component.getId() == id) {
        Component = component;
        return false;
      }
    });
    return Component;
  };

  // restiuisce tutti i componenti
  this.getComponents = function() {
    return this.state.components;
  };

  this.reloadComponent = function(id) {
    var component = this.getComponent(id);
    component.reload();
  };

  this.reloadComponents = function() {
    // vado a forzare la chisura del panel
    this.closePanel();
    _.forEach(this.state.components, function(component) {
      if (component.collapsible && component.state.open) {
        $(component.getInternalComponent().$el).siblings().click();
        component.setOpen(false);
      }
      component.reload();
    })
  };
  //rimuove il component
  this.removeComponent = function(component) {
    var self = this;
    _.forEach(this.state.components, function(sidebarComponent, index) {
      if (component == sidebarComponent) {
        component.unmount();
        self.state.components.splice(index, 1);
        return false;
      }
    })
  };
  // visualizzazione pannello sullo stack
  this.showPanel = function(panel) {
    var parent = "#g3w-sidebarpanel-placeholder";
    // utilizzo il metodo push dello stack per montare il panel sul sidebar
    this.stack.push(panel, {
      parent: parent
    });
  };
  // chiusura pannello
  this.closePanel = function() {
    this.closeSidebarPanel();
    var panel = this.stack.pop();
  };

  base(this);
}

// eredito da G3Wobject così posso agire su onafter etc ..
inherit(SidebarService, G3WObject);

var sidebarService = new SidebarService;

var SidebarComponent = Vue.extend({
    template: require('../html/sidebar.html'),
    data: function() {
    	return {
        components: sidebarService.state.components,
        panels: sidebarService.stack.state.contentsdata,
        bOpen: true,
    		bPageMode: false,
    		header: t('main navigation')
        };
    },
    computed: {
      // quanti pannelli sono attivi nello stack
      panelsinstack: function(){
        return this.panels.length > 0;
      },
      showmainpanel: function(){
        return this.components.length>0 && !this.panelsinstack;
      },
      componentname: function(){
        var name = "";
        if (this.components.length){
          name = this.components.slice(-1)[0].getTitle();
        }
        return name;
      },
      panelname: function(){
        var name = "";
        if (this.panels.length){
          name = this.panels.slice(-1)[0].content.getTitle();
        }
        return name;
      }
    },
    methods: {
      closePanel: function(){
        sidebarService.closePanel();
      },
      isMobile: function(){
        return isMobile.any
      }
    }
});

module.exports = {
  SidebarService: sidebarService,
  SidebarComponent: SidebarComponent
};

},{"../html/sidebar-item.html":8,"../html/sidebar.html":9,"./barstack.js":12,"sdk/core/g3wobject":30,"sdk/core/i18n/i18n.service":33,"sdk/core/utils/utils":80}],19:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
require('sdk/gui/vue/vue.directives');
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ComponentsRegistry = require('sdk/gui/componentsregistry');
var GUI = require('sdk/gui/gui');
// temporaneo per far funzionare le cose
var config = {
  client:{}
};
// vado a recuperare le parti che compongono l'applicazione
var sidebar = require('./sidebar');
var floatbar = require('./floatbar');
var viewport = require('./viewport');
var AppUI = require('./applicationui');
var layout = require('./layout');

// forse da trovare un posto migliore per attivare lo spinner iniziale...
layout.loading(true);
// classe che serve per instaziare e settare il template dell'applicazione
var ApplicationTemplate = function(templateConfig, ApplicationService) {
  self = this;
  this.templateConfig = templateConfig;
  this.init = function() {
    var config = ApplicationService.getConfig();
    // fa il setup dell'interfaccia
    // dichiarando i metodi generali dell'applicazione GUI.showForm etc ..
    this._setupInterface();
    // fa il setup del layout
    this._setupLayout();
    //vado a registrare tutti i servizi dell'appilazione
    this._setUpServices();
  };

  // setup layout
  // funzione che registra i componenti vue dell'applicazione
  this._setupLayout = function(){
    Vue.filter('t', function (value) {
      return t(value);
    });

    // veramente brutto ma ora non saprei fare diversamente: quando non siamo su mobile definiamo un left per dare spazio al sidebar-aside-toggle
    if (!isMobile.any) {
      $("<style type='text/css'> .ol-control-tl {" +
        "top: 7px;" +
        "left:43px;" +
      "}</style>").appendTo("head");
    }
    // Inizializzo i componenti vue dell'applicazione
    // prima che venga istanziato l'oggetto vue padre
    Vue.component('sidebar', sidebar.SidebarComponent);
    Vue.component('viewport', viewport.ViewportComponent);
    Vue.component('floatbar', floatbar.FloatbarComponent);
    Vue.component('app', AppUI);
    //inizializza l'applicazione Vue oggetto vue padre dell'applicazione
    var app = new Vue({
      el: '#app',
      mounted: function() {
        //una volta che l'istanza vue è pronta
        // inzio a costruire il template aggiungendo i vari componenti
        self._buildTemplate();
        // faccio il localize
        $(document).localize();
        this.$nextTick(function(){
          // setto la viewport passadogli la configurazione del viewport dell'applicazione
          self._setViewport(self.templateConfig.viewport);
          // emetto l'evento ready
          self.emit('ready');
          GUI.ready();
        });
      }
    });
  };
  //funzione che server per registrare tutti i servizi legati
  // alle vaie pari dell'appliazione
  this._setUpServices = function() {
    // registro i servizi dei componenti principali applicazione
    // sidebar, viewport etc..
    _.forEach(ApplicationTemplate.Services, function(service, element) {
      ApplicationService.registerService(element, service);
    });
    // registro tutti i servizi del componenti figli
    _.forEach(GUI.getComponents(), function(component) {
      ApplicationService.registerService(component.id, component.getService());
    })
  };
  // funzione che costruice il template
  this._buildTemplate = function() {
    var self = this;
    floatbar.FloatbarService.init(layout);
    // recupero i plceholders dalla configurazione del template
    var placeholdersConfig = this.templateConfig.placeholders;
    // ciclo su ogni placeholder
    _.forEach(placeholdersConfig, function(options, placeholder) {
      // per ogni placeholder ci possono essere più componenti ciclo e aggiungo
      //che vuol dire montare i varic componenti vue nei rispettivi placeholder
      self._addComponents(options.components, placeholder);
    });
    //registro altri componenti che non hanno una collocazione spaziale precisa
    // come da esempio QueryResultsComponent, form  che possono essere montati sulla floatbar o altre parti del template
    this._addOtherComponents();
  };

  //aggiungere compineti non legati ad un placeholder
  this._addOtherComponents = function() {
    var self = this;
    // verifico che ci siano altrimcomponenti rispetto a quelli in posizione standard
    if (this.templateConfig.othercomponents) {
      self._addComponents(this.templateConfig.othercomponents);
    }
  };
  // metodo per il setting della vieport
  this._setViewport = function(viewportOptions) {
    // sono passati i componenti della viewport
    // es.: map e content
    /*

    components: {
      map: new MapComponent({
        id: 'map'
      }),
      content: new ContentsComponent({
        id: 'content',
      })
     }

     */
    if (viewportOptions) {
      // inizializzo il service della viewport
      ApplicationTemplate.Services.viewport.init(viewportOptions);
      // passo i componenti della viewport per essere aggiunti alla viewport
      this._addComponents(viewportOptions.components);
    }
  };
  // aggiunge componente al template
  this._addComponent = function(component, placeholder) {
    this._addComponents([component], placeholder);
  };
  // aggiunge componenti al template e registra con componentregistry
  this._addComponents = function(components, placeholder) {
    var register = true;
    // qui entro solo e soltanto se è stato passato un placeholder e che questo
    // sia tra i componeti dei placeholders previsti
    // ad esempio nel caso della vieport (setViewport) non viene passato nessun placeholder
    // e quindi non viene chiamato addComponet del servizio viewport in quanto è
    // chaitao quando viene inizializzazto (chiamato init) del servizio
    if (placeholder && ApplicationTemplate.PLACEHOLDERS.indexOf(placeholder) > -1) {
      // recupero il service del placeholder associato (sidebar, navbar etc..)
      var placeholderService = ApplicationTemplate.Services[placeholder];
      // se non è nullo o vuoto
      if (placeholderService) {
        // delego il servizio del placheholder di aggiungere il componente
        register = placeholderService.addComponents(components);
      }
    }
    // ciclo sui componenti
    _.forEach(components, function(component) {
      // verifico se è stato registrato
      // nel cosa in cui non è stato registrato (esempio caso otherscomponents)
      if (register) {
        // registro il componente
        ComponentsRegistry.registerComponent(component);
      }
    })
  };
  // rimuovo il componente andando a toglierlo al component registry
  this._removeComponent = function(componentId) {
    ComponentsRegistry.unregisterComponent(componentId);
  };
  // funzione che visualizza la modelae overlay
  this._showModalOverlay = function(bool) {
    var mapService = GUI.getComponent('map').getService();
    if (bool) {
      mapService.startDrawGreyCover();
    } else {
      mapService.stopDrawGreyCover();
    }
  };
  this._showSidebar = function() {
    //codice qui
  };
  this._hideSidebar = function() {
    //codice qui
  };
  // setup dell'interfaccia dell'applicazione
  // qui definisco i metodi generali dell'applicazione
  // per poter interagire con essa attraverso maggiormente con l'oggetto GUI
  this._setupInterface = function() {
    /* DEFINIZIONE INTERFACCIA PUBBLICA */
    /* Metodi comuni a tutti i template */
    GUI.layout = layout;
    GUI.addComponent = _.bind(this._addComponent, this);
    GUI.removeComponent = _.bind(this._removeComponent, this);
    /* Metodi da definire (tramite binding) */
    GUI.getResourcesUrl = _.bind(function() {
      return ApplicationService.getConfig().resourcesurl;
    },this);
    //LIST
    GUI.showList = _.bind(floatbar.FloatbarService.showPanel, floatbar.FloatbarService);
    GUI.closeList = _.bind(floatbar.FloatbarService.closePanel, floatbar.FloatbarService);
    GUI.hideList = _.bind(floatbar.FloatbarService.hidePanel, floatbar.FloatbarService);
    // TABLE
    GUI.showTable = function() {};
    GUI.closeTable = function() {};
    //esempio di metodo generico Aside Results e Form etc...
    // metodo che restituisce il metodo GUI
    // a cui passare oggetto per la visualizzazione del Panello sul content component
    GUI.showContentFactory = function(type) {
      var showPanelContent;
      switch (type) {
        case 'query':
          showPanelContent = GUI.showQueryResults;
          break;
        case 'form':
          showPanelContent = GUI.showForm;
          break;
      }
      return showPanelContent;
    };
    // funzione per la visualizzazione del form
    // viene utilizzata ad esempio dall'editor per visualizzare il form nel content component
    GUI.showForm = function(options) {
      // recupero il compomponete Form base
      var FormComponent = require('sdk').gui.vue.FormComponent;
      // verifico che sia stato definito un formcomponent dall'editor custom del plugin
      // Istanzio sempre un componente nuovo
      var formComponent = options.formComponent ? new options.formComponent(options) :  new FormComponent(options);
      //recupero il servizio (che darà sempre una nuova istanza)
      var formService = formComponent.getService();
      // agggiunto un ulteriore parametro closable che di default è true
      // e quindi sarà possibile chidere il pannello con la x
      // parametri : [content, title, push, perc, split, closable]
      GUI.setContent({
        content: formComponent,
        push: !!options.push, //significa che ci deve essere solo lui( cancellando eventuali precedenti form)
        showgoback: !!options.showgoback,
        closable: false
      });
      //ritorno il formService
      return formService;
    };
    // chiudo il form che chiama il metodo removeContent del service viewport
    GUI.closeForm = function() {
      viewport.ViewportService.removeContent();
      // forzo a far si che il modale venga tolto
      GUI.setModal(false);
    };

    // funzione che nasconde il content
    GUI.hideContent = function(bool, perc) {
      return viewport.ViewportService.hideContent(bool, perc);
    };
    // chide la colonna di dentra del content
    // ritorna una promise
    GUI.closeContent = function() {
      return viewport.ViewportService.closeContent();
    };

    // funzione per la visuzlizzazione dei risultati
    GUI.showQueryResults = function(title, results) {
      // prendo il componente
      var queryResultsComponent = GUI.getComponent('queryresults');
      // prendo il servizio del componente
      var queryResultService = queryResultsComponent.getService();
      queryResultService.reset();
      if (results) {
        queryResultService.setQueryResponse(results);
      }
      var contentsComponent = GUI.getComponent('contents');
      //vado a verificare se non c'è contentuto oppure se è stato fatta una sola query
      if (!contentsComponent.getContentData().length || (contentsComponent.getContentData().length == 1 && contentsComponent.getCurrentContentData().content.getId() == 'queryresults')) {
        GUI.showContextualContent(
          {
            content: queryResultsComponent,
            title: "Risultati " + title
          }
        );
      } else {
        if (contentsComponent.getCurrentContentData().content.getId() == 'queryresults') {
          contentsComponent.popContent();
        }
        GUI.pushContent({
          content: queryResultsComponent,
          backonclose: true,
          closable:false,
          perc: 50,
          title: "Risultati " + title
        });
      }
      return queryResultService;
    };
    //temporaneo show panel
    GUI.showPanel = _.bind(sidebar.SidebarService.showPanel, sidebar.SidebarService);
    GUI.closePanel = _.bind(sidebar.SidebarService.closePanel, sidebar.SidebarService);

    /* ------------------ */

    toastr.options.positionClass = 'toast-top-center';
    toastr.options.preventDuplicates = true;
    toastr.options.timeOut = 2000;

    /* --------------------- */
    // proxy della libreria toastr
    GUI.notify = toastr;
    // proxy della libreria bootbox
    GUI.dialog = bootbox;
    /* spinner */
    GUI.showSpinner = function(options){
      var container = options.container || 'body';
      var id = options.id || 'loadspinner';
      var where = options.where || 'prepend'; // append | prepend
      var style = options.style || '';
      var transparent = options.transparent ? 'background-color: transparent' : '';
      var center = options.center ? 'margin: auto' : '';
      if (!$("#"+id).length) {
        $(container)[where].call($(container),'<div id="'+id+'" class="spinner-wrapper '+style+'" style="'+transparent+'"><div class="spinner '+style+'" style="'+ center+'"></div></div>');
      }
    };
    //fa sparire lo spinner di caricamento
    GUI.hideSpinner = function(id){
      $("#"+id).remove();
    };
    /* end spinner*/
    /* fine metodi comuni */

    /* Metodi specifici del template */
    // FLOATBAR //
    GUI.showFloatbar = function() {
      floatbar.FloatbarService.open();
    };
    GUI.hideFloatbar = function() {
      floatbar.FloatbarService.close();
    };
    // SIDEBAR //
    GUI.showSidebar = _.bind(this._showSidebar, this);
    GUI.hideSidebar = _.bind(this._hideSidebar, this);
    // MODAL
    GUI.setModal = _.bind(this._showModalOverlay, this);

    // VIEWPORT //
    GUI.setPrimaryView = function(viewName) {
      viewport.ViewportService.setPrimaryView(viewName);
    };
    // Mostra la mappa nascondendo la vista dei contenuti
    GUI.showMap = function() {
      viewport.ViewportService.showMap();
    };
    // Mostra la mappa come vista aside (nel caso sia attiva la vista contenuti). Percentuale di default 30%
    GUI.showContextualMap = function(perc,split) {
      perc = perc || 30;
      viewport.ViewportService.showContextualMap({
        perc: perc,
        split: split
      })
    };
    GUI.setContextualMapComponent = function(mapComponent) {
      viewport.ViewportService.setContextualMapComponent(mapComponent);
    };
    GUI.resetContextualMapComponent = function() {
      viewport.ViewportService.resetContextualMapComponent();
    };
    // Mostra il contenuto (100%)
    GUI.showContent = function(options) {
      options =  options || {};
      options.perc = 100;
      GUI.setContent(options);
    };
    // Mostra il contenuto. Il contenuto può essere una string HTML,
    // un elemento DOM o un componente Vue. Percentuale di default 50%
    GUI.showContextualContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 50;
      GUI.setContent(options)
    };
    // funzione che server ad aggiungere il componente
    // allo stack del content (in append)
    // Le differenze rispetto a setContent sono :
    //  - nel fatto che push è sempre a true e quindi il component viene impilato su altro componente
    //  - ha un parametro in più che è il backonclose che specifica se nel cosa venga clicckato sulla x
    //    il contentComponet viene chiuso totalmente e lo stack resettato o rimosso solo quel componete
    GUI.pushContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 100;
      options.push = true;
      GUI.setContent(options);
    };
    // Aggiunge contenuto allo stack
    GUI.pushContextualContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 50;
      options.push = true;
      GUI.setContent(options);
    };
    // rimuove l'ultimo content
    GUI.popContent = function() {
      viewport.ViewportService.popContent()
    };
    // funzione che setta i parametri del contenuto del content
    // come il componete etc..
    GUI.setContent = function(options) {
      options = options || {};
      // vado a verificare le opzioni passate e setto valori di default
      // in caso di mancata assegnazione
      options.content = options.content || null;
      options.title = options.title || "";
      options.push = _.isBoolean(options.push) ? options.push : false;
      options.perc = options.perc || 0;
      options.split = options.split || 'h';
      options.backonclose = _.isBoolean(options.backonclose) ? options.backonclose : false;
      options.showtitle = _.isBoolean(options.showtitle) ? options.showtitle : true;
      // chiamo il metodo showContent del servizio
      // viewport per poter visualizzare il content
      viewport.ViewportService.showContent(options);
    };

    /* FINE VIEWPORT */
    /* fine metodi specifici */
    /* FINE DEFINIZIONE INTERFACCIA PUBBLICA */
  };
  base(this);
};

inherit(ApplicationTemplate,G3WObject);

// funzione di classe
ApplicationTemplate.fail = function(bootstrap, errorMsg) {
  layout.loading(false);
  if (!layout.bootstrap) layout.bootstrap = bootstrap;
  layout.reload(errorMsg);
};

// questi sono i plceholder previsti ne standard dell'applicazione
ApplicationTemplate.PLACEHOLDERS = [
  'navbar',
  'sidebar',
  'viewport',
  'floatbar'
];

// questi sono i servizi dei contenitori di componenti
ApplicationTemplate.Services = {
  navbar: null,
  sidebar: sidebar.SidebarService,
  viewport: viewport.ViewportService,
  floatbar: sidebar.FloatbarService
};

module.exports =  ApplicationTemplate;


},{"./applicationui":11,"./floatbar":14,"./layout":15,"./sidebar":18,"./viewport":20,"core/g3wobject":30,"core/utils/utils":80,"sdk":184,"sdk/core/i18n/i18n.service":33,"sdk/gui/componentsregistry":122,"sdk/gui/gui":132,"sdk/gui/vue/vue.directives":183}],20:[function(require,module,exports){
var inherit = require('sdk').core.utils.inherit;
var base = require('sdk').core.utils.base;
var G3WObject = require('sdk').core.G3WObject;
var GUI = require('sdk').gui.GUI;

// calsse servizio della viewport
var ViewportService = function() {
  // contiene lo stato della viewport
  this.state = {
    primaryView: 'map', // di default la vista primaria è la prima
    // percentuale della secondary view
    secondaryPerc: 0,
    // come viene splittatta la vista (h = orizzontale, v = verticale)
    split: 'h',
    //mappa
    map: {
      sizes: {
        width: 0,
        height: 0
      },
      aside: false
    },
    //content
    content:{
      sizes: {
        width: 0,
        height: 0
      },
      aside: true,
      showgoback: true,
      stack: [], // array contentente gli elementi nello stack del contents
      closable: true, // specifica se chiudibile o meno (presenza della x)
      backonclose: false, // se al click della x deve essere chiso il contenuto tutto o toglierer l'ultomo contenuto dalla stack
      contentsdata:[] // array contenete i dati del content
    }
  };
  // sono i contentuti della viewport (mappa e content)
  this._components = {
    map: null,
    content: null
  };
  // contenuti di default
  this._defaultMapComponent;
  this._contextualMapComponent;

  // altezza e largezza minima della secondary view
  // imposte per evitare che la secondaryView (principalmente il content) possa diventare
  // molto piccola (esempio impostando un perc = 1) e quindi rendere illeggibile
  // il contenuto
  this._secondaryViewMinWidth = 300;
  this._secondaryViewMinHeight = 200;
  // attributo che serve per
  this._immediateComponentsLayout = true;
  /* INTERFACCIA PUBBLICA */
  // funzione che va ad aggiungere i comnponenti alla viewport
  // funzione di inizialilizzazione
  this.init = function(options) {
    var options = options || {};
    // verifica se è stata settata/specificata la primary view altrimenti mette la mappa di default
    this.state.primaryView = options.primaryview ? options.primaryview : 'map';
    // verifica se è stato settato la modalità di splitting altrimenti mette quello orizzontale
    this.state.split = options.split ? options.split : 'h';
    // aggiunge i componenti ( che sono map e content)
    this._addComponents(options.components);
  };

  // aggiunge i componenti alla viewport
  this._addComponents = function(components) {
    var self = this;
    // components è un oggetto contente chiave nome componente e valure istanza componente
    // nel caso attuale (vedi index.js)
    /*
     {
      map: new MapComponent({
        id: 'map'
      }),
      content: new ContentsComponent({
        id: 'contents'
      })
     }
     */
    _.forEach(components, function(component, viewName) {
      // verifica che i componenti siano map o content
      if (['map', 'content'].indexOf(viewName) > -1) {
        // monto (chiamo il metodo mount che tuttti i componeti hanno) componente sull'id specifico del componenti della mappa
        // map e content
        // monto con append a true
        component.mount('#g3w-view-'+viewName, true)
          .then(function() {
            // una volta che è stato montato aggiungo
            // all'array components
            self._components[viewName] = component;
            // verifico se il nome della view è la mappa
            if (viewName == 'map') {
              // setto il il componete come componente mappa di default
              self._defaultMapComponent = component;
            }
          });
      }
    })
  };


  // funzione showMap per la visulizzazione della mappa
  this.showMap = function() {
    this._toggleMapComponentVisibility(this._defaultMapComponent,true);
    this._components['map'] = this._defaultMapComponent;
    this._showView('map');
  };

  this.showContextualMap = function(options) {
    var self = this;
    if (!this._contextualMapComponent) {
      this._contextualMapComponent = this._defaultMapComponent;
    }
    if (this._contextualMapComponent != this._defaultMapComponent) {
      this._toggleMapComponentVisibility(this._defaultMapComponent,false);
    }
    if (!this._contextualMapComponent.ismount()) {
      var contextualMapComponent = this._contextualMapComponent;
      contextualMapComponent.mount('#g3w-view-map', true)
        .then(function(){
          self._components['map'] = contextualMapComponent;
        });
    }
    else {
      self._components['map'] = this._contextualMapComponent;
      this._toggleMapComponentVisibility(this._contextualMapComponent,true);
    }
    this._showView('map',options);
  };

  // funzione che recupera il componente mappa di default
  this.recoverDefaultMap = function() {
    // se il componente mappa è diversa dal componente mappa di default
    if (this._components['map'] != this._defaultMapComponent) {
      this._components['map'] = this._defaultMapComponent;
      this._toggleMapComponentVisibility(this._contextualMapComponent,false);
      this._toggleMapComponentVisibility(this._defaultMapComponent,true);
    }
  };

  this.setContextualMapComponent = function(mapComponent) {
    var self = this;
    if (mapComponent == this._defaultMapComponent) {
      return;
    }
    if (this._contextualMapComponent) {
      this._contextualMapComponent.unmount();
    }
    this._contextualMapComponent = mapComponent;
  };

  this.resetContextualMapComponent = function() {
    if (this._contextualMapComponent) {
      this._contextualMapComponent.unmount();
    }
    this._contextualMapComponent = this._defaultMapComponent;
  };

  this._toggleMapComponentVisibility = function(mapComponent,toggle) {
    mapComponent.internalComponent.$el.style.display = toggle ? 'block' : 'none';
  };


  // chiude la mappa
  this.closeMap = function() {
    this.state.secondaryPerc = (this.state.primaryView == 'map') ? 100 : 0;
    this.recoverDefaultMap();
    this._layout();
  };

  // visualizza il contentuto della content della viewport
  /*
   options: {
     content: può essere una stringa di testo, un elemento jQuery o un componente Vue
     title: il title da mostrare nella finestra dei contenuti
     push (opzionale, default false): se il contenuto deve essere impilato sul precedente (con possibilità di tornare indietro nello stack dei contenuti (contentStack)
     split (opzionale, default 'h'): 'h' || 'v' splittare le finestre orizzontalmente o verticalmente. per ora testato solo orizzontalmente
     perc (opzionale, default 50): valore numerico, indica la percentuale delle finestra dei contenuti (es. 33 -> 2/3 saranno di mappa e 1/3 di contenuti)
   }
   */
  // funzione che è chiamata da GUI.setContent per visualizzare conentuto all'interno del content component
  this.showContent = function(options) {
    var self = this;
    // verifica se è stato settato l'opzione push
    options.push = options.push || false;
    // vado a settare tutti i parametri per il content come la parcentuale, titolo, etc ..
    this._prepareContentView(options);
    // setto immediateComponentsLayout a false
    this._immediateComponentsLayout = false;
    this._showView('content', options, true);
    this._components.content.setContent(options)
      .then(function(){
        //var data = self._components.content.getCurrentContentData();
        //self._prepareView(data.options);
        self._layoutComponents();
        self._immediateComponentsLayout = true;
      });
  };

  // nasconde il content
  this.hideContent = function(bool, perc) {
    var prevContentPerc = this.state.secondaryPerc;
    this.state.secondaryPerc = !!bool ? 0: perc;
    this.state.secondaryVisible = !bool;
    this._layout();
    // restituisce la percentuale precedente
    return prevContentPerc;
  };

  // funzione che toglie l'ultimo content al contentStack
  this.popContent = function() {
    var self = this;
    // verifica che ci sia il conentuto nel compontentStack
    if (this.state.content.contentsdata.length) {
      this.recoverDefaultMap();
      // recupero il precedente content dallo stack
      var data = this._components.content.getPreviousContentData();
      this._prepareContentView(data.options);
      this._immediateComponentsLayout = false;
      this._showView('content');
      this._components.content.popContent()
        .then(function(){
          self._layoutComponents();
          self._immediateComponentsLayout = true;
        })
    }
  };

  // chiude il content
  this.closeContent = function() {
    this._components.content.removeContent();
    //fa il recover della mappa di default
    this.recoverDefaultMap();
    // chiudo la View secondaria ritornando una promise
    return this.closeSecondaryView();
  };

  // funzione che rimuove il cont dalla viewport o solo una parte
  this.removeContent = function() {
    // verifico che l'attributo backonclose sia true o false
    // per fare in modo che lo stack del contentStack si completamente rimosso
    // o tolto solamente il componente
    if (this.state.content.backonclose && this.state.content.contentsdata.length > 1) {
      this.popContent();
    } else {
      this._components.content.removeContent();
      //fa il recover della mappa di default
      this.recoverDefaultMap();
      // chido la View secondaria
      return this.closeSecondaryView();
    }
  };

  // risposte se è view primaria
  this.isPrimaryView = function(viewName) {
    return this.state.primaryView == viewName;
  };

  // metodo per definire qual'è la vista primaria
  this.setPrimaryView = function(viewTag) {
    if (this.state.primaryView != viewTag) {
      this.state.primaryView = viewTag;
    }
    this._layout();
  };

  // visualizza la primary view a seconda della percentuale passata come argomento
  this.showPrimaryView = function(perc) {
    if (perc && this.state.secondaryVisible && this.state.secondaryPerc == 100) {
      this.state.secondaryPerc = 100 - perc;
      this._layout();
    }
  };

  // metodo per la visualizzazione della vista secondaria
  // nella maggior parte dei casi è il content
  this.showSecondaryView = function(split, perc) {
    // setto la visibilità dello stato della seconda view
    this.state.secondaryVisible = true;
    this.state.split = split ? split : this.state.split;
    this.state.secondaryPerc = perc ? perc : this.state.perc;
    // richiamo la funzione layout
    this._layout();
  };

  // chiudo la view secondaria
  this.closeSecondaryView = function(componentId) {
    var d = $.Deferred();
    var self = this;
    var secondaryViewComponent = this._components[this._otherView(this.state.primaryView)];
    if (secondaryViewComponent.clearContents) {
      secondaryViewComponent.clearContents()
        .then(function(){
          self.state.secondaryVisible = false;
          self._layout();
          Vue.nextTick(function() {
            d.resolve();
          })
        });
    }
    else {
      this.state.secondaryVisible = false;
      // questo è il metodo che esegue il layout delle viste,
      // e dà ad ogni componente l'opportunità di ricalcolare il proprio layout
      this._layout();
      Vue.nextTick(function() {
        d.resolve();
      })
    }
    return d.promise();
  };

  //ritorna il valore di default della percentuale della view a sconda del tipo
  // di content
  this.getDefaultViewPerc = function(viewName) {
    return this.isPrimaryView(viewName) ? 100 : 50;
  };

  // ritorna la vista opposta rispoetto a quella passata
  this._otherView = function(viewName) {
    return (viewName == 'map') ? 'content' : 'map';
  };

  this._isSecondary = function(view) {
    return this.state.primaryView != view;
  };

  // meccanismo per il ricalcolo delle dimensioni della viewport e dei suoi componenti figli
  this._setPrimaryView = function(viewTag) {
    if (this.state.primaryView != viewTag) {
      this.state.primaryView = viewTag;
    }
  };

  // setto gli attributi del content della viewport
  this._prepareContentView = function(options) {
    this.state.content.preferredPerc = options.perc || this.getDefaultViewPerc('content');
    this.state.content.title = options.title;
    this.state.content.closable =  _.isNil(options.closable) ? true : options.closable;
    this.state.content.backonclose = _.isNil(options.backonclose) ? true : options.backonclose;
    this.state.content.contentsdata = this._components.content.contentsdata;
    this.state.content.showgoback = _.isNil(options.showgoback) ? true : options.showgoback;
  };

  // metodo che si occupa delle gestione di tutta la logica di visualizzazione delle due viste (mappa e contenuti)
  // viewName può essere: map o content
  // le opzione specificano percentuali , splitting tittolo etc ..
  this._showView = function(viewName, options) {
    options = options || {};
    // prende il parametro percentuale
    var perc = options.perc || this.getDefaultViewPerc(viewName);
    // prende la tipologia di split della viewport
    var split = options.split || 'h';
    var aside;
    // verifica se la view in question è la primaria o meno
    if (this.isPrimaryView(viewName)) {
      aside = (typeof(options.aside) == 'undefined') ? false : options.aside;
    }
    else {
      aside = true;
    }
    // setto il valore di aside della view
    this.state[viewName].aside = aside;
    // calcolo la percentuale della view secondaria
    var secondaryPerc = this.isPrimaryView(viewName) ? 100 - perc : perc;
    if (secondaryPerc > 0) {
      // vado a visualizzare la secondaru view
      this.showSecondaryView(split, secondaryPerc);
    } else {
      // vado a chidere la view secondaria
      return this.closeSecondaryView();
    }
  };

  // funzione che restituisce le misure in alterzza e larghezza per cui
  // il contentuo deve essere spostato per evitare che venga messo sotto
  //sidebar-aside-toggle nel caso di un content al 100% a tutta viewport
  this._getReducedSizes = function(){
    var contentEl = $('.content');
    var reducedWidth = 0;
    var reducedHeight = 0;
    if (contentEl && this.state.secondaryVisible && this.state.secondaryPerc == 100) {
      var sideBarToggleEl = $('.sidebar-aside-toggle');
      if (sideBarToggleEl && sideBarToggleEl.is(':visible')) {
        var toggleWidth = sideBarToggleEl.outerWidth();
        contentEl.css('padding-left',toggleWidth + 5);
        reducedWidth = (toggleWidth - 5);
      }
    }
    else {
      contentEl.css('padding-left', 15);
    }
    return {
      reducedWidth: reducedWidth,
      reducedHeight: reducedHeight
    }
  };

  // funzione principale che si occupa dell'intero layout della vieport
  this._layout = function() {
    var self = this;
    // prende il tipo di split
    var splitClassToAdd = (this.state.split == 'h') ? 'split-h' : 'split-v';
    var splitClassToRemove =  (this.state.split == 'h') ? 'split-v' : 'split-c';
    // vengono aggiunte e rimosse le classi
    $(".g3w-viewport .g3w-view").addClass(splitClassToAdd);
    $(".g3w-viewport .g3w-view").removeClass(splitClassToRemove);
    var reducesdSizes = this._getReducedSizes();
    // setta il size delle vista
    this._setViewSizes(reducesdSizes.reducedWidth,reducesdSizes.reducedHeight);
    // cloaseMap button
    var closeMapBtn = $('#closemap-btn');
    if (!closeMapBtn.length) {
      var closeMapBtn = $('<div id="closemap-btn" @click="closeMap" style="\
        position: absolute;\
        right: 10px;\
        top: 7px;\
        line-height: 1;\
        padding: 7px 2px;\
        font-size: 1.5em;\
        background-color: #3c8dbc;\
        color: white;\
        z-index:1000;\
        height: 39px;\
        width: 39px">\
          <button class="glyphicon glyphicon-remove pull-right close-panel-button" style="background-color: transparent;border: 0px;"></button>\
        </div>');
      closeMapBtn.on('click',function(){
        self.closeMap();
      });
      var mapView = $(".g3w-viewport .map");
      mapView.append(closeMapBtn);
    }

    if (this.state.secondaryVisible) {
      if (this._isSecondary('content') && (this.state.secondaryPerc < this.state.content.preferredPerc)) {
        closeMapBtn.show()
      }
      else {
        closeMapBtn.hide();
      }
    }
    else {
      closeMapBtn.hide();
    }

    if (this._immediateComponentsLayout) {
      this._layoutComponents();
    }
  };

  // funzione che setta i size delle view (primaria e secondari)
  this._setViewSizes = function() {
    // view primaria e secondaria
    var primaryView = this.state.primaryView;
    // recupera la seconda View che è non è la primary (verosimilmente 'content')
    var secondaryView = this._otherView(primaryView);
    // altezza e larghezza della viewport
    var viewportWidth = this._viewportWidth();
    var viewportHeight = this._viewportHeight();
    // asegna alla primary view l'altezza e la larghezza della viewport
    var primaryWidth = viewportWidth;
    var primaryHeight = viewportHeight;
    var scale = this.state.secondaryPerc / 100;
    // verifica il tipo di plistting
    // caso orizzontale
    if (this.state.split == 'h') {
      secondaryWidth = this.state.secondaryVisible ? Math.max((viewportWidth * scale),this._secondaryViewMinWidth) : 0;
      secondaryHeight = viewportHeight;
      primaryWidth = viewportWidth - secondaryWidth;
      primaryHeight = viewportHeight;
    }
    else {
      secondaryWidth = viewportWidth;
      secondaryHeight = this.state.secondaryVisible ? Math.max((viewportHeight * scale),this._secondaryViewMinHeight) : 0;
      primaryWidth = viewportWidth;
      primaryHeight = viewportHeight - secondaryHeight;
    }
    // riassegno le giuste proporzione in sia height e width alla primary e secondary view
    // primary ViewSizes
    this.state[primaryView].sizes.width = primaryWidth;
    this.state[primaryView].sizes.height = primaryHeight;
    // secondaryViewSizes
    this.state[secondaryView].sizes.width = secondaryWidth;
    this.state[secondaryView].sizes.height = secondaryHeight;
  };

  // funzione che restituisce l'altezza che deve avere la viewPort
  this._viewportHeight = function() {
    var topHeight = $(".navbar").innerHeight();
    return $(window).innerHeight() - topHeight;
  };

  // funzione che restituisce la larghezza della view
  this._viewportWidth = function() {
    // prendo la posizione della posizione a sinistra
    // della sidebar
    var offset = $(".main-sidebar").offset().left;
    var width = $(".main-sidebar").innerWidth();
    var sideBarSpace = width + offset;
    // resituisco la larghezza riservata alla viewport
    return $(window).innerWidth() - sideBarSpace;
  };

  // funzione che va a caricare i componenti (della viewport)
  // solo dopo che le size delle view sono state corrette
  this._layoutComponents = function() {
    var self = this;
    Vue.nextTick(function(){
      var reducesdSizes = self._getReducedSizes();
      reducedWidth = reducesdSizes.reducedWidth || 0;
      reducedHeight = reducesdSizes.reducedHeight || 0;
      _.forEach(self._components, function(component, name) {
        // viene chiamato il metodo per il ricacolo delle dimensioni nei componenti figli
        var width = self.state[name].sizes.width - reducedWidth ;
        var height = self.state[name].sizes.height - reducedHeight;
        // ogni componente (mappa e contenuto) qui
        // ha l'opportunità di ricalcolare il proprio il layout.
        // Usato per esempio dalla mappa per reagire al resize della viewport
        component.layout(width, height);
      })
    });
  };

  // funzione che viene chiamata la prima volta che
  // si instanzia la viewport
  this._firstLayout = function() {
    var self = this;
    var drawing = false;
    var resizeFired = false;

    // funzione che fa il trigger del resize
    function triggerResize() {
      resizeFired = true;
      drawResize();
    }

    function drawResize() {
      if (resizeFired === true) {
        resizeFired = false;
        drawing = true;
        // chiama la funzione che si occupa ti settare
        // il layout della viewport
        self._layout(true);
        //funzione javascript nativa del browser (html5) che serve
        // per il Controllo temporizzazione per animazioni basate su script
        requestAnimationFrame(drawResize);
      } else {
        drawing = false;
      }
    }
    // registra la funzione che deve essere lanciata una volta che
    // la GUI e pronta (si ha quando è stato chiamato il metodo _buildTemplate di template.js)
    // che non fa altro che aggiungere alle varie parti dell'applicazione
    GUI.on('ready',function(){
      // prendo al primary view (verosimilmente 'map')
      var primaryView = self.state.primaryView;
      // secondary view 'content' di solito
      var secondaryView = self._otherView(primaryView);
      // seleziono l'elemento secondario con JQuery
      var secondaryEl = $(".g3w-viewport ."+secondaryView);
      // prendo (se esiste il valore css della seconday view min-width)
      var secondaryViewMinWidth = secondaryEl.css('min-width');
      if ((secondaryViewMinWidth != "") && !_.isNaN(parseFloat(secondaryViewMinWidth))) {
        self._secondaryViewMinWidth =  parseFloat(secondaryViewMinWidth);
      }
      var secondaryViewMinHeight = secondaryEl.css('min-height');
      if ((secondaryViewMinHeight != "") && !_.isNaN(parseFloat(secondaryViewMinHeight))) {
        self._secondaryViewMinHeight =  parseFloat(secondaryViewMinHeight);
      }
      self._layout(true);
      // resize scatenato da GUI
      GUI.on('guiresized',function() {
        triggerResize();
      });
      // resize della window
      $(window).resize(function() {
        // set resizedFired to true and execute drawResize if it's not already running
        if (drawing === false) {
          triggerResize();
        }
      });
      // resize sul ridimensionamento della sidebar
      $('.main-sidebar').on('webkitTransitionEnd transitionend msTransitionEnd oTransitionEnd', function () {
        $(this).trigger('trans-end');
        triggerResize();
      });
    });
  };
  this._firstLayout();
  base(this);
};
// eredita da G3WOBJECT
inherit(ViewportService, G3WObject);

//singleton
var viewportService = new ViewportService;

// COMPONENTE VUE VIEWPORT
var ViewportComponent = Vue.extend({
  template: require('../html/viewport.html'),
  data: function() {
    return {
      state: viewportService.state // lo stato del compoente è quello del servizio
    }
  },
  computed: {
    // proprietà derivata (booleana) che è legata al contentsdata dell'oggetto content
    showtitle: function() {
      var showtitle = true;
      // prende l'array di componenti dello stack del content
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length) {
        var options = contentsData[contentsData.length - 1].options;
        if (_.isBoolean(options.showtitle)) showtitle = options.showtitle;
      }
      return showtitle;
    },
    showContent: function() {
      return this.state.content.show;
    },
    contentTitle: function() {
      // cambia il titolo prendendo l'ultimo elemento aggiunto alla stack
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length) {
        return contentsData[contentsData.length - 1].options.title;
      }
    },
    previousTitle: function() {
      // prende il titolo del precendete elemento
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length > 1 && this.state.content.showgoback) {
        if (!contentsData[contentsData.length - 2].options.title) {
          return 'indietro'
        }
        return 'a ' + contentsData[contentsData.length - 2].options.title;
      }
      return false;
    },
    contentSmallerThenPreferred: function() {
      return this.state.secondaryPerc < this.state.content.preferredPerc;
    }
  },
  methods: {
    closeContent: function() {
      viewportService.removeContent();
    },
    closeMap: function() {
      viewportService.closeMap();
    },
    gotoPreviousContent: function() {
      viewportService.popContent();
    }
  }
});

module.exports = {
  ViewportService: viewportService,
  ViewportComponent: ViewportComponent
};

},{"../html/viewport.html":10,"sdk":184}],21:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var reject = require('core/utils/utils').reject;

function ApiService(){
  this._config = null;
  this._baseUrl = null;
  this.init = function(config) {
    var deferred = $.Deferred();
    this._config = config;
    // prende l'url base delle api dal config dell'applicazione
    this._baseUrl = config.urls.api;
    this._apiEndpoints = config.urls.apiEndpoints;
    deferred.resolve();
    return deferred.promise();
  };
  //incrementi
  var howManyAreLoading = 0;
  this._incrementLoaders = function(){
    if (howManyAreLoading == 0){
      this.emit('apiquerystart');
    }
    howManyAreLoading += 1;
  };
  
  this._decrementLoaders = function(){
    howManyAreLoading -= 1;
    if (howManyAreLoading == 0){
      this.emit('apiqueryend');
    }
  };
  this.get = function(api, options) {
    var self = this;
    var apiEndPoint = this._apiEndpoints[api];
    if (apiEndPoint) {
      var completeUrl = this._baseUrl + '/' + apiEndPoint;
      if (options.request) {
         completeUrl = completeUrl + '/' + options.request;
      }
      var params = options.params || {};
      
      self.emit(api+'querystart');
      this._incrementLoaders();
      return $.get(completeUrl,params)
      .done(function(response){
        self.emit(api+'queryend',response);
        return response;
      })
      .fail(function(e){
        self.emit(api+'queryfail',e);
        return e;
      })
      .always(function(){
        self._decrementLoaders();
      });
    }
    else {
      return reject();
    }
  };
  base(this);
}

inherit(ApiService,G3WObject);

module.exports = new ApiService;

},{"core/g3wobject":30,"core/utils/utils":80}],22:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ApiService = require('core/apiservice');
var RouterService = require('core/router');
var ProjectsRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('core/plugin/pluginsregistry');
var ClipboardService = require('core/clipboardservice');

var G3W_VERSION = "1507219923810";

//oggetto servizio per la gestione dell'applicazione
var ApplicationService = function() {
  var self = this;
  this.version = G3W_VERSION.indexOf("G3W_VERSION") == -1 ? G3W_VERSION  : "";
  this.secret = "### G3W Client Application Service ###";
  this.ready = false;
  this.complete = false;
  this._modalOverlay = null;
  this._acquirePostBoostrap = false;
  // oggetto che tiene tutti i servizi dei vari sidebar etc..
  // utili per il plugin
  this._applicationServices = {};
  this.config = {};
  this._initConfigUrl = null;
  this._initConfig = {};
  // chiama il costruttore di G3WObject (che in questo momento non fa niente)
  base(this);
  // funzione inizializzazione che prende la configurazione dal server
  this.init = function(config, acquirePostBoostrap) {
    this._config = config;
    if (acquirePostBoostrap) {
      this._acquirePostBoostrap = true;
    }
    // lancio il bootstrap dell'applicazione
    return this._bootstrap();
  };
  // restituisce la configurazione
  this.getConfig = function() {
    return this._config;
  };
  // restituisce il router service
  this.getRouterService = function() {
    return RouterService;
  };
  // clipboard service
  this.getClipboardService = function() {
    return ClipboardService;
  };

  // funzione che ottiene la configurazione dal server
  this.obtainInitConfig = function(initConfigUrl) {
    var self = this;
    if (!this._initConfigUrl) {
      this._initConfigUrl = initConfigUrl;
    }
    var d = $.Deferred();
    //se esiste un oggetto globale initiConfig
    //risolvo con quell'oggetto
    if (window.initConfig) {
      this._initConfig = window.initConfig;
      return d.resolve(window.initConfig);
    }
    // altrimenti devo prenderlo dal server usando il percorso indicato in ?project=<percorso>
    else {
      var projectPath;
      var queryTuples;
      if (location.search) {
        queryTuples = location.search.substring(1).split('&');
        _.forEach(queryTuples, function (queryTuple) {
          //se esiste la parola project nel url
          if(queryTuple.indexOf("project") > -1) {
            //prendo il valore del path progetto (nomeprogetto/tipoprogetto/idprogetto)
            //esempio comune-di-capannori/qdjango/22/
            projectPath = queryTuple.split("=")[1];
          }
        });
      } else {
        // prevista per il reload in fase di admin
        projectPath = location.pathname.split('/').splice(-4,3).join('/');
      }
      if (projectPath) {
        var initUrl = this._initConfigUrl;
        if (projectPath) {
          initUrl = initUrl + '/' + projectPath;
        }
        //recupro dal server la configurazione di quel progetto
        $.get(initUrl)
          .then(function(initConfig) {
            //initConfig è l'oggetto contenete:
            //group, mediaurl, staticurl, user
            initConfig.staticurl = "../dist/"; // in locale forziamo il path degli asset
            initConfig.clienturl = "../dist/"; // in locale forziamo il path degli asset
            self._initConfig = initConfig;
            // setto la variabile initConfig
            window.initConfig = initConfig;
            d.resolve(initConfig);
          })
          .fail(function(error) {
            d.reject(error);
          })
      }
    }
    return d.promise();
  };

  this.getInitConfig = function() {
    return this._initConfig;
  };

  this.getInitConfigUrl = function() {
    return this._initConfigUrl;
  };

  this.setInitConfigUrl = function(initConfigUrl) {
    this._initConfigUrl = initConfigUrl;
  };

  // funzione post boostratp
  this.postBootstrap = function() {
    if (!this.complete) {
      RouterService.init();
      // una volta inizializzati i progetti e l'api service
      // registra i plugins passando gli static urls e l'oggetto plugins
      PluginsRegistry.init({
        pluginsBaseUrl: self._config.urls.staticurl,
        pluginsConfigs: self._config.plugins,
        otherPluginsConfig: ProjectsRegistry.getCurrentProject().getState()
      });
      this.complete = true;
    }
  };

  // funzione bootstrap (quando viene chiamato l'init)
  this._bootstrap = function() {
    var self = this;
    var d = $.Deferred();
    //nel caso in cui (prima volta) l'application service non è pronta
    //faccio una serie di cose
    if (!this.ready) {
      // Inizializza la configurazione dei servizi.
      // Ognungo cercherà dal config quello di cui avrà bisogno
      // una volta finita la configurazione emetto l'evento ready.
      // A questo punto potrò avviare l'istanza Vue globale
      $.when(
        // registra i progetti
        ProjectsRegistry.init(this._config),
        // inizializza api service
        ApiService.init(this._config)
      ).then(function() {
        // emetto l'evento ready
        self.emit('ready');
        if (!self._acquirePostBoostrap) {
          self.postBootstrap();
        }
        this.initialized = true;
        d.resolve();
      }).fail(function(error) {
        d.reject(error);
      })
    }
    return d.promise();
  };

  this.registerService = function(element, service) {
    this._applicationServices[element] = service;
  };

  this.unregisterService = function(element) {
    delete this._applicationServices[element];
  };

  this.getService = function(element) {
    return this._applicationServices[element];
  };

  this.errorHandler = function(error) {
    console.log(error);
  }

};

inherit(ApplicationService,G3WObject);


module.exports = new ApplicationService;

},{"core/apiservice":21,"core/clipboardservice":24,"core/g3wobject":30,"core/plugin/pluginsregistry":69,"core/project/projectsregistry":74,"core/router":78,"core/utils/utils":80}],23:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var LayersStoresRegistry = require('core/layers/layersstoresregistry');

function CatalogLayersStoresRegistry() {
  base(this);
}

inherit(CatalogLayersStoresRegistry, LayersStoresRegistry);

module.exports = new CatalogLayersStoresRegistry();
},{"core/layers/layersstoresregistry":44,"core/utils//utils":80,"core/utils/utils":80}],24:[function(require,module,exports){
function ClipboardService() {
  this._data = {};
  this.set = function(formId, data) {
    // clipBoardId : id del form, data sono fileds e relations passate al form
    // il clipBoardForm mi serve per capire se attivare o meno la clipboard
    // se e solo se si riferisce allo stesso id
    var formLayer = formId.split('form')[0];
    this._data[formLayer] = data;
  };

  this.get = function(formLayer) {
    var data = this._data[formLayer] || {};
    this._data[formLayer] = {};
    return data;
  };

}
module.exports = new ClipboardService;

},{}],25:[function(require,module,exports){
// questa classe mi serve per far applicare le modifche fatte sulle varie feature
// sui vari oggetti che ne devono essere modificati
function ChangesManager() {
  this.execute = function(object, items, reverse) {
    var fnc;
    var feature;
    // ciclo sugli items da applicare all'oggetto o featuresstore
    _.forEach(items, function(item) {
      feature = item.feature;
      if (reverse) {
        // cambio lo stato dell'item al suo opposto
        feature[ChangesManager.Actions[feature.getState()].opposite]();
      }
      // estraggo il comnado / metogo da eseguire sull'oggetto
      fnc = ChangesManager.Actions[feature.getState()].fnc;
      object[fnc](feature);
    })
  }
}

// azioni possibili
ChangesManager.Actions = {
  'add': {
    fnc: 'addFeature',
    opposite: 'delete'
  },
  'delete': {
    fnc: 'removeFeature',
    opposite: 'add'
  },
  'update': {
    fnc: 'updateFeature',
    opposite: 'update'
  }
};

module.exports = new ChangesManager();
},{}],26:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var Session = require('./session');

// classe Editor che ha lo scopo di comunicare con il layer e
// di svolgere azioni primarie
function Editor(options) {
  options = options || {};
  this.setters = {
    save: function() {
      this._save();
    },
    addFeature: function(feature) {
      this._addFeature(feature);
    },
    updateFeature: function(feature) {
      this._updateFeature(feature);
    },
    deleteFeature: function(feature) {
      this._deleteFeature(feature);
    },
    setFeatures: function(features) {
      this._setFeatures(features);
    },
    getFeatures: function (options) {
      return this._getFeatures(options);
    }
  };
  base(this);
  //deve far riferimento necessariamente ad un layer
  this._layer = options.layer;
  // attributo che mi dice se l'editor è attivo o no
  this._started = false;
}

inherit(Editor, G3WObject);

var proto = Editor.prototype;

proto.getLayer = function() {
  return this._layer;
};

proto.setLayer = function(layer) {
  this._layer = layer;
  return this._layer;
};

// funzione per il recupero delle get features
proto._getFeatures = function(options) {
  var d = $.Deferred();
  this._layer.getFeatures(options)
    .then(function (promise) {
      promise.then(function (features) {
        return d.resolve(features);
      }).fail(function (err) {
        return d.reject(err);
      })
    })
    .fail(function (err) {
      d.reject(err);
    });
  return d.promise();
};

// funzione che viene lanciata dopo che è stato salvato
// il nuovo stato del layer definitivamente sul server
proto.commit = function(commitItems, featurestore) {
  var d = $.Deferred();
  this._layer.commit(commitItems, featurestore)
    .then(function (promise) {
      promise
        .then(function(response) {
          // vado ad aggiornare le features nel caso di nuovi insrimenti
          return d.resolve(response);
        })
        .fail(function (err) {
        return d.reject(err);
      })
    })
    .fail(function (err) {
      d.reject(err);
    });
  return d.promise();
};

//funzione che fa partire lo start editing
proto.start = function(options) {
  var self = this;
  var d = $.Deferred();
  // carica le features del layer in base al tipo di filtro (da vedere come)
  this.getFeatures(options)
    .then(function(promise) {
      promise
        .then(function(features) {
          // le features ono già dentro il featuresstore del layer
          d.resolve(features);
          // se andato tutto bene setto a true la proprietà
          self._started = true;
        })
        .fail(function(err) {
          d.reject(err);
        })

    })
    .fail(function(err) {
      d.reject(err);
    });
  return d.promise()
};

//qui sono le azioni che agiscono direttamente sul layer

proto._addFeature = function(feature) {
  this._layer.addFeature(feature);
};

proto._deleteFeature = function(feature) {
  this._layer.deleteFeature(feature);
};

proto._updateFeature = function(feature) {
  this._layer.updateFeature(feature);
};

proto._setFeatures = function(features) {
  this._layer.setFeatures(features);
};

// stop editor
proto.stop = function() {
  var d = $.Deferred();
  var self = this;
  this._layer.unlock()
    .then(function(response) {
      self._started = false;
      d.resolve(response);
    })
    .fail(function(err) {
      console.log(err);
      d.reject(err);
    });
  return d.promise();
};

//metodo save che non fa altro che lanciare il save del layer
proto._save = function() {
  this._layer.save();
};

proto.isStarted = function() {
  return this._started;
};

proto.clear = function() {
  this._layer.getFeaturesStore().clear();
};


module.exports = Editor;
},{"./session":28,"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],27:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var Feature = require('core/layers/features/feature');

function History(options) {
  options = options || {};
  this.id = options.id;
  base(this);
  // vengono registrati tutte le modifiche
  // che sono coinvolti
  /*
  *{
  * _states: [
  *     {
  *       id: chiaveunica
  *       state: [state] // esempio history che contiene come state la/le features
  *                      // da considerare un array di stati feature perchè un tool
  *                      // può coinvolgere più features (pensiamo allo split di una feature)
  *     },
  *     {
  *       id: chiaveunica
  *       state: [state]
  *     },
  *   ]
  *     ....
  *
  *  _current: chiaveunica // questo mi server per undo/redo per spostarmi nel tempo
  *
  *
  * */
  // qui setto la massima lunghezza del "buffer history" per undo redo
  // al momento non utilizzata
  this._maxSteps = 10;
  this._states = [];
  // lo state (reattivo della history)
  this.state = {
    commit: false,
    undo:false,
    redo: false
  };
  this._current = null;
}

inherit(History, G3WObject);

var proto = History.prototype;

proto.add = function(uniqueId, items) {
  var self = this;
  //l'oggetto state non è altro che un array contenente feature/features
  // modificate in quella transazione
  var d = $.Deferred();
  var currentStateIndex;
  // prima di inserire un nuovo stato nella storia
  //verifico che siamo nell'ultimo stato (non è stato fatto nessun undo)
  // in questo modo non apro strani brach nella storia
  //Se non siamo all'ultimo, vado a cancellare cosa c'è dopo a quello attuale
  //e inserisco la nuova storia
  if (this._states.length && this._current != this.getLastState().id) {
    _.forEach(this._states, function(state, idx) {
      if (self._current == state.id) {
        currentStateIndex = idx;
        return false;
      }
    });
    //vado a sostiture il nuovo states array (una nuova storia da quel momento inizia)
    this._states = this._states.slice(0, currentStateIndex+1);
  }
    this._states.push({
    id: uniqueId,
    items: items
  });
  this._current = uniqueId;
  this._setState();
  // ritorna la chiave univoca per quella modifica vine restituita dal chiamante
  // che potrà essere utilizzata ad esempio nel salvataggio dello stato della relazione
  // settandone la staessa chiave del layer padre
  d.resolve(uniqueId);
  return d.promise();
};

// funzione interna che viene sfruttatat per cambiare lo state della history quando si
// verifica una chiamata ad una funzione che modifica lo stato della history
proto._setState = function() {
  this.canUndo();
  this.canCommit();
  this.canRedo();
};

//funzione che verifica se c'è stato un update (gli update sono formati da un array di due valori , il vecchio e il nuovo)
proto._checkItems = function(items, action) {
  /**
   * action: 0 per uno; 1: redo si riferiscono all'indice dell'array dell'item
   */
  var self = this;
  var newItems = {
    own: [], //array di modifiche da applicare al layer della sessione
    dependencies: {} // qui vengono raccolte le dependencies
  };
  _.forEach(items, function(item) {
    if (_.isArray(item))
      item = item[action];
    // vado a verificare se appartiene alla sessione
    if (self.id == item.layerId) {
      newItems.own.push(item)
    } else {
      if (!newItems.dependencies[item.layerId])
        newItems.dependencies[item.layerId] = {
          own: [],
          dependencies: {}
        };
      newItems.dependencies[item.layerId].own.push(item);
    }
  });
  return newItems;
};

// funzione undo
proto.undo = function() {
  var self = this;
  var items;
  if (this._current == this.getFirstState().id) {
    // setto a negativo il current il che significa che posso solo andare avanti
    this._current = null;
    // restituisco l'unico stata presente
    items = this._states[0].items;
  } else {
    _.forEach(this._states, function(state, idx) {
      if (state.id == self._current) {
        items = self._states[idx].items;
        self._current = self._states[idx-1].id;
        return false;
      }
    })
  }
  items = this._checkItems(items, 0);
  this._setState();
  return items;
  
};

//funzione redo
proto.redo = function() {
  var self = this;
  var items;
  if (!this._current) {
    items = this._states[0].items;
    this._current = this._states[0].id;
    stateIdx = 1;
  } else {
    _.forEach(this._states, function(state, idx) {
      if (self._current == state.id) {
        self._current = self._states[idx+1].id;
        items = self._states[idx+1].items;
        return false;
      }
    })
  }
  items = this._checkItems(items, 1);
  this._setState();
  return items;
};

// ripulisce tutta la storia se non è stato specificato nessun ids
// ids: array di id
proto.clear = function(ids) {
  var self = this;
  if (ids) {
    _.forEach(this._states, function(state, idx) {
      if (ids.indexOf(state.id) != -1) {
        if (self._current && self._current == state.id())
          //faccio un undo
          self.undo();
        self._states.splice(idx, 1);
      }
    })
  } else {
    this._clearAll();
  }
};

// funzione che pulisce tutto states 
proto._clearAll =  function() {
  this._states = [];
  this._current = null;
  this.state.commit = false;
  this.state.redo = false;
  this.state.undo = false;
  
};

// ritorna lo stato a seconda dell'id
proto.getState = function(id) {
  var state = null;
  _.forEach(this._states, function(state) {
    if (state.id == id) {
      state = state;
      return false;
    }
  });
  return state;
};

proto.getFirstState = function() {
  return this._states.length ? this._states[0] : null;
};

//restituisce l'ultimo state registrato (che non è detto sia quello corrente)
proto.getLastState = function() {
  var length = this._states.length;
  return length ? this._states[length -1] : null;
};

// funzione che mi permette di ricavare stato corrente del layer
// attualmente nella storia
proto.getCurrentState = function() {
  var self = this;
  var currentState = null;
  if (this._current && this._states.length) {
    _.forEach(this._states, function (state) {
        if (self._current == state.id) {
          currentState = state;
          return false
        }
    });
  }
  return currentState;
};

// funzione che mi permette di ricavarel'indice dello stato corrente
proto.getCurrentStateIndex = function() {
  var self = this;
  var currentStateIndex = null;
  if (this._current && this._states.length) {
    _.forEach(this._states, function (state, idx) {
      if (self._current == state.id) {
        currentStateIndex = idx;
        return false
      }
    });
  }
  return currentStateIndex;
};

// funzione che mi dice se ci sono cose da committare
proto.canCommit = function() {
  var canCommit = false;
  var idToIgnore = [];
  var statesToCommit = this._getStatesToCommit();
  _.forEach(statesToCommit, function(state) {
    _.forEach(state.items, function(item) {
      if (_.isArray(item))
      // vado a prendere il secondo valore che è quello modificato
        item = item[1];
     // se esiste un non nuovo vuol dire che
     // c'è stata fatta una modifica
     if (item.feature.isNew() && item.feature.isDeleted()) {
       idToIgnore.push(item.feature.getPk());
     } else {
       if (!(item.feature.isNew() && idToIgnore.indexOf(item.feature.getPk())!= -1) || !idToIgnore.length) {
         canCommit = true;
         return false;
       }
     }
    });
    if (canCommit) {
      return false;
    }
  });
  this.state.commit = canCommit;
  return this.state.commit;
};

//funzione che mi dice se posso fare l'undo sulla history
proto.canUndo = function() {
  var steps = (this._states.length - 1) - this.getCurrentStateIndex();
  this.state.undo = !_.isNull(this._current) && (this._maxSteps > steps);
  return this.state.undo;
};

// funzione che mi dice se posso fare il redo sulla history
proto.canRedo = function() {
  this.state.redo = this.getLastState() && this.getLastState().id != this._current || _.isNull(this._current) && this._states.length > 0;
  return this.state.redo;
};

proto._getStatesToCommit = function() {
  var self = this;
  // devo clonare lo states altrimenti ho problem con il reverse per undo e redo
  var statesToCommit = this._current ? _.clone(this._states): [];
  // qui ricavo solo la parte degli state che mi servono per ricostruire la storia
  _.forEach(statesToCommit.reverse(), function(state, idx) {
    if (self.getCurrentState() == state) {
      // in pratica taglio il pezzo di storia "dopo" il current
      statesToCommit = statesToCommit.slice(idx, statesToCommit.length);
      return false;
    }
  });
  return statesToCommit;
};

//funzione che restituisce tutte le modifche uniche da applicare (mandare al server)
proto.commit = function() {
  // contegono oggetti aventi lo stato di una feature unica e il relativo id
  var commitItems = {};
  var feature;
  var layerId;
  var add = true;
  var statesToCommit = this._getStatesToCommit();
  // inzioa ascorrere sugli stati della history
  _.forEach(statesToCommit, function (state) {
    //ciclo sugli items dello stato
    _.forEach(state.items, function(item) {
      // nel caso di un array, quindi di fronte ad un update
      if (_.isArray(item))
        // vado a prendere il secondo valore che è quello modificato
        item = item[1];
      //vado a ciclare sugli evtnuali stati committati cioè aggiunti
      _.forEach(commitItems[item.layerId], function(commitItem, idx) {
        //verifico se presente uno stesso ite
        if (commitItem.getId() == item.feature.getId()) {
          // verifcio inoltre se è una feature nuova, se non è stata cancellata (già presente nei commitItems) e se aggiunta
          // perchè allora setto come add
          if (item.feature.isNew() && !commitItem.isDeleted()  && item.feature.isAdded()) {
            // allora setto l'ultima versione allo stato add
            commitItem.add();
          }
          add = false;
          return false;
        }
      });
      // se true significa che lo devo aggiungere
      if (add) {
        feature = item.feature;
        layerId = item.layerId;
        // vado a verificar condizioni
        if (!(!feature.isNew() && feature.isAdded())) {
          if (!commitItems[layerId])
            commitItems[layerId] = [];
          commitItems[layerId].push(feature);
        }
      }
      // risetto a true
      add = true;
    });
  });
  return commitItems;
};

module.exports = History;
},{"core/g3wobject":30,"core/layers/features/feature":34,"core/utils//utils":80,"core/utils/utils":80}],28:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var History = require('./history');
var FeaturesStore = require('core/layers/features/featuresstore');
var ChangesManager = require('./changesmanager');
var SessionsRegistry = require('./sessionsregistry');

// classe Session
function Session(options) {
  options = options || {};
  this.setters = {
    // setter per start
    start: function(options) {
      return this._start(options);
    },
    getFeatures: function(options) {
      return this._getFeatures(options);
    },
    stop: function() {
      this._stop();
    }
  };
  base(this, options);
  //attributo che stabilisce se la sessione è partita
  this.state = {
    id: options.id, // id della sessione che fa riferimento all'id del layer editato
    started: false
  };
  // editor
  this._editor = options.editor || null;
  // featuresstore che contiene tutte le modifiche che vengono eseguite al layer
  // è la versione temporanea del features store de singolo editor
  this._featuresstore = options.featuresstore || new FeaturesStore();
  // history -- oggetto che contiene gli stati dei layers
  this._history = new History({
    id: this.state.id
  });
  // contenitore temporaneo che servirà a salvare tutte le modifiche
  // temporanee che andranno poi salvate nella history e nel featuresstore
  this._temporarychanges = [];
}

inherit(Session, G3WObject);

var proto = Session.prototype;

proto.getId = function() {
  return this.state.id;
};

proto._start = function(options) {
  var self = this;
  var d = $.Deferred();
  // vado a registrare la sessione
  SessionsRegistry.register(this);
  this._editor.start(options)
    .then(function(features) {
      features = self._cloneFeatures(features);
      // vado a popolare il featuresstore della sessione con le features
      //che vengono caricate via via dall'editor
      self._featuresstore.addFeatures(features);
      self.state.started = true;
      d.resolve(features);
    })
    .fail(function(err) {
      self.state.started = true;
      d.reject(err);
    });
  return d.promise();
};

//funzione che server per recuperare le features
//dal server o dalla fonte delle features
proto._getFeatures = function(options) {
  var self = this;
  var d = $.Deferred();
  this._editor.getFeatures(options)
    .then(function(promise) {
      promise.then(function(features) {
        features = self._cloneFeatures(features);
        self._featuresstore.addFeatures(features);
        d.resolve(features);
      })
      .fail(function (err) {
        d.reject(err);
      });
    });
  return d.promise();
};

// funzione che permette di clonerae le feature che vengono reperite tramite editor
proto._cloneFeatures = function(features) {
  var cloneFeatures = [];_.forEach(features, function(feature) {
    cloneFeatures.push(feature.clone())
  });
  return cloneFeatures;
};

proto.isStarted = function() {
  return this.state.started;
};

proto.getEditor = function() {
  return this._editor;
};

proto.setEditor = function(editor) {
  this._editor = editor;
};

//restituisce il feature store della sessione
proto.getFeaturesStore = function() {
  return this._featuresstore;
};

// questa funzione sarà adibita al salvataggio (temporaneo) delle modifiche
// al layer sia nella history che nel featuresstore
proto.save = function(options) {
  //vado a pololare la history
  console.log("Session Saving .... ");
  var self = this;
  var d = $.Deferred();
  // vado a d aggiungere tutte le modifiche temporanee alla history
  // rendendole parte della sessione solo se esisitono
  if (this._temporarychanges.length) {
    options = options || {};
    var uniqueId = options.id || Date.now();
    this._history.add(uniqueId, this._temporarychanges)
      .then(function() {
        // vado a fare il clear dei cambiamenti temporanei
        self._temporarychanges = [];
        // risolvo ritornando l'id unico
        d.resolve(uniqueId);
      });
    // andarà a popolare la history
  } else {
    d.resolve(null);
  }
  return d.promise();
};

proto.pushAdd = function(layerId, feature) {
  this.push({
    layerId: layerId,
    feature: feature.add()
  })
};


// metodo per aggiungere la cancellazione di una feature temporaneamente
proto.pushDelete = function(layerId, feature) {
  this.push({
    layerId: layerId,
    feature: feature.delete()
  })
};

// metodo per aggiungere temporaneamente la modifica di una feature
proto.pushUpdate = function(layerId, newFeature, oldFeature) {

  this.push(
    {
      layerId: layerId,
      feature: newFeature.update()
    },
    {
      layerId: layerId,
      feature: oldFeature.update()
      
    })
};

// metodo che server ad aggiungere features temporanee che poi andranno salvate
// tramite il metodo save della sessione
proto.push = function(New, Old) {
  /*
  New e Old saranno oggetti contenti {
      layerId: xxxx,
      feature: feature
    }
   */
  // verifico se è stata passata anche l'olfFeature
  var feature = Old? [Old, New]: New;
  this._temporarychanges.push(feature);
};

proto._applyChanges = function(items, reverse) {
  reverse = reverse || true;
  ChangesManager.execute(this._featuresstore, items, reverse);
};


// funzione che permetterà di cancellare tutte le modifiche salvate nella history
// e quindi ripulire la sessione
proto.revert = function() {
  var d = $.Deferred();
  var self = this;
  this._editor.getFeatures().then(function(promise) {
    promise
      .then(function(features) {
        features =  self._cloneFeatures(features);
        self.getFeaturesStore().setFeatures(features);
        self._history.clear();
        d.resolve();
      })
      .fail(function(err) {
        d.reject(err);
      })
  });
  return d.promise();
};

// organizza i cambiamenti temporanei in base al layer coinvolto
proto._filterChanges = function() {
  var id = this.getId();
  var changes = {
    own:[],
    dependencies: {}
  };
  var change;
  _.forEach(this._temporarychanges, function(temporarychange) {
    change = _.isArray(temporarychange) ? temporarychange[0] : temporarychange;
    if (change.layerId == id)
      changes.own.push(change);
    else {
      if (!changes.dependencies[change.layerId])
        changes.dependencies[change.layerId] = [];
      // le vado a posizionare dal più recente al più lontano in ordine inverso FILO
      changes.dependencies[change.layerId].unshift(change);
    }
  });
  return changes;
};

// funzione di rollback
// questa in pratica restituirà tutte le modifche che non saranno salvate nella history
// e nel featuresstore della sessione ma riapplicate al contrario
proto.rollback = function(changes) {
  //vado a after il rollback dellle feature temporanee salvate in sessione
  console.log('Session Rollback.....', changes);
  var d = $.Deferred();
  if (changes) {
    this._applyChanges(changes, true);
    d.resolve();
  }  else {
    changes = this._filterChanges();
    // vado a modificare il featurestore facendo il rollback dei cambiamenti temporanei
    this._applyChanges(changes.own, true);
    this._temporarychanges = [];
    d.resolve(changes.dependencies);
  }
  return d.promise()// qui vado a restituire le dipendenze
};

// funzione di undo che chiede alla history di farlo
proto.undo = function(items) {
  var items = items || this._history.undo();
  this._applyChanges(items.own, true);
  return items.dependencies;
};

// funzione di undo che chiede alla history di farlo
proto.redo = function(items) {
  var items = items || this._history.redo();
  this._applyChanges(items.own, true);
  return items.dependencies;
};

//funzione che prende tutte le modifche dalla storia e le
//serializza in modo da poterle inviare tramite posto al server
proto._serializeCommit = function(itemsToCommit) {
  // id del layer legato alla sessione
  var id = this.getId();
  var state;
  var layer;
  var commitObj = {
    add: [],
    update: [],
    delete: [],
    relations: {}
  };
  _.forEach(itemsToCommit, function(items, key) {
    if (key != id) {
      // vado a recuperare i lockId del layer relaione
      var lockids = SessionsRegistry.getSession(key).getEditor().getLayer().getFeaturesStore().getLockIds();
      // vado a creare una nuova chiave nelle relazioni
      commitObj.relations[key] = {
        lockids:lockids,
        add: [],
        update: [],
        delete: []
      };
      layer = commitObj.relations[key];
      // e assegno struttura per il commit
    } else {
      layer = commitObj
    }
    _.forEach(items, function(item) {
      state = item.getState();
      var GeoJSONFormat = new ol.format.GeoJSON();
      switch (state) {
        case 'delete':
          if (!item.isNew())
            layer.delete.push(item.getId());
          break;
        default:
          layer[item.getState()].push(GeoJSONFormat.writeFeatureObject(item));
          break;
      }
    });

  });
  return commitObj;
};

// funzione che mi server per ricavare quali saranno 
// gli items da committare
proto.getCommitItems = function() {
  return this._history.commit();
};

// funzione che serializzerà tutto che è stato scritto nella history e passato al server
// per poterlo salvare nel database
proto.commit = function(options) {
  options = options || {};
  var self = this;
  var d = $.Deferred();
  var commitItems;
  console.log("Sessione Committing...");
  //vado a verificare se nell'opzione del commit
  // è stato passato gli gli ids degli stati che devono essere committati,
  //nel caso di non specifica committo tutto
  var ids = options.ids || null;
  // vado a leggete l'id dal layer necessario al server
  if (ids) {
    commitItems = this._history.commit(ids);
    this._history.clear(ids);
  } else {
    // andà a pescare dalla history tutte le modifiche effettuare
    // e si occuperà di di eseguire la richiesta al server di salvataggio dei dati
    commitItems = this._history.commit();
    // le serializzo
    commitItems = this._serializeCommit(commitItems);
    // passo all'editor un secondo parametro.
    this._editor.commit(commitItems, this._featuresstore)
      .then(function(response) {
        // poi vado a fare tutto quello che devo fare (server etc..)
        //vado a vare il clean della history
        self._history.clear();
        d.resolve(response)
      })
      .fail(function(err) {
        d.reject(err);
      });
  }

  return d.promise();
};

//funzione di stop della sessione
proto._stop = function() {
  var self = this;
  var d = $.Deferred();
  // vado a unregistrare la sessione
  SessionsRegistry.unregister(this.getId());
  console.log('Sessione stopping ..');
  this._editor.stop()
    .then(function() {
      self.state.started = false;
      self.clear();
      d.resolve();
    })
    .fail(function(err) {
      console.log(err);
      d.reject(err);
    });
  return d.promise();

};

// clear di tutte le cose associate alla sessione
proto.clear = function() {
  this._editor.clear();
  // vado a ripulire la storia
  this._clearHistory();
  // risetto il featurestore a nuovo
  this._featuresstore.clear();
};

//ritorna l'history così che lo chiama può fare direttanmente undo e redo della history
proto.getHistory = function() {
  return this._history;
};

// funzione che fa il cera della history
proto._clearHistory = function() {
  this._history.clear();
};

module.exports = Session;
},{"./changesmanager":25,"./history":27,"./sessionsregistry":29,"core/g3wobject":30,"core/layers/features/featuresstore":35,"core/utils//utils":80,"core/utils/utils":80}],29:[function(require,module,exports){
var SessionsRegistry = function() {
  this._sessions = {};
  
  this.register = function(session) {
    var id = session.getId();
    this._sessions[id] = session;
  };

  this.unregister = function(id) {
    delete this._sessions[id];
  };

  this.getSession = function(id) {
    return this._sessions[id];
  };

  this.setSession = function(id, session) {
    this._sessions[id] = session;
  }
};

module.exports = new SessionsRegistry();

},{}],30:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var noop = require('core/utils/utils').noop;

/**
 * Un oggetto base in grado di gestire eventuali setter e relativa catena di listeners.
 * @constructor
 */
var G3WObject = function() {
  //quando istanzio l'oggetto verifico che nella sua proprietà
  // ci sia l'attributo setters. Se si vado a registare la catena di eventi
  // per poter registare azioni prima e dopo la chiamata del metodo
  if (this.setters) {
    this._setupListenersChain(this.setters);
  }
};

inherit(G3WObject, EventEmitter);

var proto = G3WObject.prototype;

/**
 * Inserisce un listener dopo che è stato eseguito il setter
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener (solo sincrona)
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onafter = function(setter, listener, priority){
  return this._onsetter('after', setter, listener, false, priority);
};

// un listener può registrarsi in modo da essere eseguito PRIMA dell'esecuzione del metodo setter. Può ritornare true/false per
// votare a favore o meno dell'esecuzione del setter. Se non ritorna nulla o undefined, non viene considerato votante
/**
 * Inserisce un listener prima che venga eseguito il setter. Se ritorna false il setter non viene eseguito
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener, a cui viene passato una funzione "next" come ultimo parametro, da usare nel caso di listener asincroni
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onbefore = function(setter, listener, priority) {
  return this._onsetter('before', setter, listener, false, priority);
};

/**
 * Inserisce un listener prima che venga eseguito il setter. Al listener viene passato una funzione "next" come ultimo parametro, da chiamare con parametro true/false per far proseguire o meno il setter
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener, a cui
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onbeforeasync = function(setter, listener, priority) {
  return this._onsetter('before', setter, listener, true, priority);
};

proto.un = function(setter, key){
  _.forEach(this.settersListeners,function(settersListeners) {
    _.forEach(settersListeners[setter],function(setterListener, idx) {
      if(setterListener.key == key) {
        settersListeners[setter].slice(idx, 1);
      }
    })
  })
};

// funzione che si occupa di settare le funzioni legate al setter in base alla tipologia
// di evento se prima o dopo
/*
  when=before|after,
  type=sync|async
*/
proto._onsetter = function(when, setter, listener, async, priority) {
  // vado a recuperarer l'oggetto che ceh si riferifsce al when
  var settersListeners = this.settersListeners[when];
  // creo una listenerKey unica
  var listenerKey = ""+Math.floor(Math.random()*1000000)+""+Date.now();
  // verifico la priorità
  priority = priority || 0;
  // prendo tutto ciò che riguarda il setter (la funzione che dovrà essere chiamata)
  var settersListeneres = settersListeners[setter];
  // vado ad inserire l'oggetto che mi servirà a chiamare la funzione legata
  // al tipo di evento del setter
  settersListeneres.push({
    key: listenerKey,
    fnc: listener,
    async: async,
    priority: priority
  });
  // vado a riordinare l'array dei listeners del setter per quell'evento in base alla priorità
  settersListeners[setter] = _.sortBy(settersListeneres, function(setterListener) {
    return setterListener.priority;
  });
  // ritorno la chiave
  return listenerKey;
};

// funzione che viene lanciata se la sottoclasse ha come parametro setters
proto._setupListenersChain = function(setters) {
  // inizializza tutti i metodi definiti nell'oggetto "setters" della classe figlia.
  var self = this;
  this.settersListeners = {
    after: {},
    before: {}
  };
  // per ogni setter viene definito l'array dei listeners e fiene sostituito
  // il metodo originale con la funzioni che gestisce la coda di listeners
  // setterOption è la funzione
  // stters è la chiave/nome del metodo che viene assegnato all'istanza
  _.forEach(setters, function(setterOption, setter) {
    var setterFnc = noop;
    var setterFallback = noop;
    // verifico che il valore della chiave setter sia una funzione
    if (_.isFunction(setterOption)){
      setterFnc = setterOption
    } // altrimenti vado a vedere il valore dell'attributo fnc
    else {
      setterFnc = setterOption.fnc;
      setterFallback = setterOption.fallback || noop; // funzione in caso di errore nell'esecuzione della fnc
    }
    //vado a creare l'arry dei metodi/azioni/funzioni che devo essere eseguiti prima/dopo
    //la chiamata del metodo sette dell'oggetto
    self.settersListeners.after[setter] = [];
    self.settersListeners.before[setter] = [];
    // setter aggiunto come proprietà dell'istanza
    self[setter] = function() {
      // prendo gli argomenti passati alla funzione
      var args = arguments;
      var deferred = $.Deferred();
      var returnVal = null;
      var counter = 0;
      // funzione complete che serve per lanciare la funzione setter dell'istanza
      function complete() {
        // eseguo la funzione setter
        returnVal = setterFnc.apply(self,args);
        // e risolvo la promessa (eventualmente utilizzata da chi ha invocato il setter)
        deferred.resolve(returnVal);
        //vado a eseguire tutti i listener che sono stati settati dopo l'esecuzione del setter
        var afterListeners = self.settersListeners.after[setter];
        _.forEach(afterListeners, function(listener) {
          listener.fnc.apply(self, args);
        })
      }
      // funzione abort che mi server ad uscire dal ciclo dei listener
      // nel caso si verificasse un problema
      function abort() {
        // se non posso proseguire ...
        // chiamo l'eventuale funzione di fallback
        setterFallback.apply(self,args);
        // e rigetto la promessa
        deferred.reject();
      }

      // vado a prendere l'array delle funzioni che devo lanciare prima di lanciare il setter
      var beforeListeners = self.settersListeners['before'][setter];
      // contatore dei listener che verrà decrementato ad ogni chiamata a next()
      counter = 0;
      // funzione passata come ultimo parametro ai listeners,
      // che ***SE SONO STATI AGGIUNTI COME ASINCRONI la DEVONO*** richiamare per poter proseguire la catena
      function next(bool) {
        // inizializzo la variabile cont a true (continue) non possibile usare
        // continue perchè parola riservata di javascript
        var cont = true;
        // verifica se è stato passato un parametro boolenao alla funzione
        // e la setto alla variabile cont (continue)
        if (_.isBoolean(bool)) {
          cont = bool;
        }
        // ricavo l'array di argomenti passati alla funzione setter
        var _args = Array.prototype.slice.call(args);
        // se la catena è stata bloccata (cont==false)
        // o se siamo arrivati alla fine dei beforelisteners
        // o non non sono stati settati nessun beforelisteners
        if (cont === false || (counter == beforeListeners.length)) {
          if (cont === false) {
            // significa che si è verificato un errore oppure si è forzato a concludere
            abort.apply(self, args);
          } else {
            //vado a chiamare la funzione setter
            completed = complete.apply(self, args);
            //verifico che cosa ritorna
            if (_.isUndefined(completed) || completed === true) {
              self.emitEvent('set:'+setter,args);
            }
          }
        } else {
          // se cont è true (continua)
          if (cont) {
            // vado a prendere la funzione dall'array dei before listener
            var listenerFnc = beforeListeners[counter].fnc;
            // verifico se questa è asyncrona
            if (beforeListeners[counter].async) {
              // aggiungo next come ulyimo nel caso di onbeforeasync
              _args.push(next);
              // vado ad aggiornare il counter dei listener onbefore
              counter += 1;
              // chiamo la funzione passandogli l'argomento (modificato con next)
              // su se stesso
              listenerFnc.apply(self, _args)
            } // nel caso di onbefore(quindi non asincrona)
            else {
              // chiamo la funzione listener che mi deve ritornare un boolenano o undefined
              var _cont = listenerFnc.apply(self,_args);
              //vado ad aggiornare il counter
              counter += 1;
              next(_cont);
            }
          }
        }
      }
      // quando viene chiamato la funzione
      // viene lanciato la funzione next
      next();
      // la nuova funzione (il setter) associato all'ggetto che ne ha dichiarato
      // la presenza ritorneà una promise
      return deferred.promise();
    }
  })
};

// funzione che unregistra la chiave del listener
proto.un = function(listenerKey) {
  _.forEach(this.settersListeners, function(setterListeners) {
      _.forEach(setterListeners,function(listener,idx){
        if (listener.key == listenerKey) {
          setterListeners.splice(idx,1);
        }
      })
  })
};

//metodo get
proto.get = function(key) {
  var value = this[key] && !(this[key] instanceof Function) ? this[key] : null;
  return value;
};

//metodo set
proto.set = function(key, value) {
  this[key] = value;
};

module.exports = G3WObject;

},{"core/utils/utils":80}],31:[function(require,module,exports){
var geom = {
  distance: function(c1,c2){
    return Math.sqrt(geom.squaredDistance(c1,c2));
  },
  squaredDistance: function(c1,c2){
    var x1 = c1[0];
    var y1 = c1[1];
    var x2 = c2[0];
    var y2 = c2[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    return dx * dx + dy * dy;
  },
  closestOnSegment: function(coordinate, segment) {
    var x0 = coordinate[0];
    var y0 = coordinate[1];
    var start = segment[0];
    var end = segment[1];
    var x1 = start[0];
    var y1 = start[1];
    var x2 = end[0];
    var y2 = end[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = (dx === 0 && dy === 0) ? 0 :
        ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);
    var x, y;
    if (along <= 0) {
      x = x1;
      y = y1;
    } else if (along >= 1) {
      x = x2;
      y = y2;
    } else {
      x = x1 + along * dx;
      y = y1 + along * dy;
    }
    return [x, y];
  }
}

module.exports = geom;

},{}],32:[function(require,module,exports){
var Geometry = {};

Geometry.GeometryTypes = {
  POINT: "Point",
  MULTIPOINT: "MultiPoint",
  LINESTRING: "Line", // per seguire la definizione di QGis.GeometryType, che definisce Line invece di Linestring.
  MULTILINESTRING: "MultiLine",
  POLYGON: "Polygon",
  MULTIPOLYGON: "MultiPolygon",
  GEOMETRYCOLLECTION: "GeometryCollection"
};

Geometry.SupportedGeometryTypes = [
  Geometry.GeometryTypes.POINT,
  Geometry.GeometryTypes.MULTIPOINT,
  Geometry.GeometryTypes.LINESTRING,
  Geometry.GeometryTypes.MULTILINESTRING,
  Geometry.GeometryTypes.POLYGON,
  Geometry.GeometryTypes.MULTIPOLYGON
];

module.exports = Geometry;

},{}],33:[function(require,module,exports){
function init(config) {
  i18next
  .use(i18nextXHRBackend)
  .init({ 
      lng: 'it',
      ns: 'app',
      fallbackLng: 'it',
      resources: config.resources
  });
  
  jqueryI18next.init(i18next, $, {
    tName: 't', // --> appends $.t = i18next.t
    i18nName: 'i18n', // --> appends $.i18n = i18next
    handleName: 'localize', // --> appends $(selector).localize(opts);
    selectorAttr: 'data-i18n', // selector for translating elements
    targetAttr: 'data-i18n-target', // element attribute to grab target element to translate (if diffrent then itself)
    optionsAttr: 'data-i18n-options', // element attribute that contains options, will load/set if useOptionsAttr = true
    useOptionsAttr: false, // see optionsAttr
    parseDefaultValueFromContent: true // parses default values from content ele.val or ele.text
  });
}
    
var t = function(text){
    var trad = i18next.t(text);
    return trad;
};
    
module.exports = {
  init: init,
  t: t
};

},{}],34:[function(require,module,exports){
// Classe Feature che eridita da ol.Feature sfruttando tutti i metodi
// necessari anche alla costruzione di un layer vettoriale
// Allo stesso modo può essere un oggetto non vettoriale non settando la geometria
// ma solo le proprièta
var Feature = function(options) {
  ol.Feature.call(this);
  options = options || {};
  this._newPrefix = '_new_';
  // mi serve per capire quale è la pk della feature
  this._pk = options.pk || "id";
  var feature = options.feature;
  //verificare come utilizzare clone
  if (feature) {
    this.setProperties(feature.getProperties());
    //vado a scrivere l'id univoco (corrispondente alla chiave primaria
    this.setId(feature.getId());
    this.setGeometryName(feature.getGeometryName());
    var geometry = feature.getGeometry();
    if (geometry) {
      this.setGeometry(geometry);
    }
    var style = this.getStyle();
    if (style) {
      this.setStyle(style);
    }
  }
  // necessario per poter interagire reattivamente con l'esterno
  this.state = {
    new: false,
    state: null
  };
};

ol.inherits(Feature, ol.Feature);

proto = Feature.prototype;

// vado a cambiare il costruttore
proto.constructor = 'Feature';

proto.clone = function() {
  // clono la feature
  var feature = ol.Feature.prototype.clone.call(this);
  feature.setId(this.getId());
  var clone =  new Feature({
    feature: feature,
    pk: this._pk
  });
  // aggiungo lo state
  clone.setState(this.getState());
  return clone;
};

proto.setTemporaryId = function() {
  var newValue = this._newPrefix + Date.now();
  this.setId(newValue);
  this.setNew();
};

proto.setNew = function() {
  this.state.new = true;
};

proto.getPk = function() {
  return this._pk;
};

// setta la feature a state 2 delete
proto.delete = function() {
  this.state.state = 'delete';
  return this;
};

//setta lo stato a feature aggiornata
proto.update = function() {
  this.state.state = 'update';
  return this;
};

// setta lo stato a nuovo 0
proto.add = function() { 
  this.state.state = 'add';
  return this;
};

proto.isNew = function() {
  return this.state.new;
};

proto.isAdded = function() {
  return this.state.state == 'add';
};

proto.isUpdated = function() {
  return this.state.state == 'update';
};

proto.isDeleted = function() {
  return this.state.state == 'delete';
};

proto.getState = function() {
  return this.state.state;
};

proto.setState = function(state) {
  this.state.state = state;
};

// vado a fare il clena dello state della feature
proto.clearState = function() {
  this.state.state = null;
  this.state.new = false;
};


module.exports = Feature;
},{}],35:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interfaccia per registare i layers
function FeaturesStore(options) {
  var self = this;
  options = options || {};
  this._features = [];
  this._provider = options.provider || null;
  this._loadedPks = []; // contiene gli id loccati (che alla fine sono gli stessi delle feature caricate)
  this._lockIds = []; // contiene le features loccate
  this.setters = {
    addFeatures: function(features) {
      _.forEach(features, function(feature) {
        self._addFeature(feature);
      })
    },
    addFeature: function(feature) {
      this._addFeature(feature);
    },
    removeFeature: function(feature) {
      this._removeFeature(feature);
    },
    updateFeature: function(feature) {
      this._updateFeature(feature);
    },
    clear: function() {
      this._clearFeatures();
      this._lockIds = [];
      this._loadedPks = [];
    },
    getFeatures: function(options) {
      return this._getFeatures(options);
    },
    commit: function(commitItems, featurestore) {
      return this._commit(commitItems, featurestore);
    }
  };

  base(this);
}

inherit(FeaturesStore, G3WObject);

proto = FeaturesStore.prototype;

// funzione per l'unlock delle features
proto.unlock = function() {
  return this._provider.unlock();
};

// funzione che recupera le features o dal server o dall'attributo _features
proto._getFeatures = function(options) {
  var self = this;
  var d = $.Deferred();
  var features;
  // verifico che ci sia un provider altrimenti vado a recuperare le
  if (this._provider && options) {
    this._provider.getFeatures(options)
      .then(function(options) {
        features = self._filterFeaturesResponse(options);
        self.addFeatures(features);
        d.resolve(features);
      })
      .fail(function(err) {
        d.reject(err)
      })
  } else {
    d.resolve(this._readFeatures());
  }
  return d.promise();
};

//funzione che in base alle features caricate filtra
// escludendo quelle già inserite
proto._filterFeaturesResponse = function(options) {
  var self = this;
  var added = false;
  options = options || {};
  var features = options.features || [];
  var featurelocks = options.featurelocks || [];
  var featuresToAdd = _.filter(features, function(feature) {
    added = _.includes(self._loadedPks, feature.getId());
    if (!added)
      self._loadedPks.push(feature.getId());
    return !added
  });
  self._filterLockIds(featurelocks);
  return featuresToAdd;
};

// funzione che mi dice le feature loccate
proto._filterLockIds = function(featurelocks) {
  var toAddLockId = _.differenceBy(featurelocks, this._lockIds, 'featureid');
  this._lockIds = _.union(this._lockIds, toAddLockId);
};

proto.getLockIds = function() {
  return this._lockIds;
};

// aggiunge nuovi lock Ids
proto.addLockIds = function(lockIds) {
  this._lockIds = _.union(this._lockIds, lockIds);
};

proto._readFeatures = function() {
  return this._features;
};

proto._commit = function(commitItems, featurestore) {
  var d = $.Deferred();
  // verifico che ci siano opzioni e un provider altrimenti vado a recuperare le
  // features direttamente nel featuresstore
  if (commitItems && this._provider) {
    commitItems.lockids = this._lockIds;
    this._provider.commit(commitItems)
      .then(function(response) {
        d.resolve(response);
      })
      .fail(function(err) {
        d.reject(err);
      })
  } else {
    d.reject();
  }
  return d.promise();
};

// recupera una feature dal suo id
proto.getFeatureById = function(featureId) {
  var feat;
  _.forEach(this._features, function(feature) {
    if (feature.getId() == featureId) {
      feat = feature;
      return false;
    }
  });
  return feat;
};

proto._addFeature = function(feature) {
  this._features.push(feature);
};

//vado ad eseguire in pratica la sostituzione della feature dopo una modifica
proto._updateFeature = function(feature) {
  var self = this;
  _.forEach(this._features, function(feat, idx) {
    if (feat.getId() == feature.getId()) {
      self._features[idx] = feature;
      return false;
    }
  });
};

proto.updatePkFeature = function(newValue, oldValue) {
  var feature
};

proto.setFeatures = function(features) {
  this._features = features;
};

proto._removeFeature = function(feature) {
  var self = this;
  _.forEach(this._features.getArray(), function(feat, idx) {
    if (feature.getId() == feat.getId()) {
      self._features.removeAt(idx);
      return false
    }
  })
};

proto._clearFeatures = function() {
  // vado a rimuovere le feature in modo reattivo (per vue) utlizzando metodi che vue
  // possa reagire allacancellazione di elementi di un array
  this._features.splice(0, this._features.length);
};

proto.getDataProvider = function() {
  return this._dataprovider;
};

// metodo che a differenza del getFeatures prevede di fare
// la lettura delle features attualmente sul featuressotre
proto.readFeatures = function() {
  return this._features;
};

module.exports = FeaturesStore;
},{"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],36:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var FeaturesStore = require('./featuresstore');

// Storage delle features di un layer vettoriale
function OlFeaturesStore(options) {
  base(this, options);
  this._features = new ol.Collection();
}

inherit(OlFeaturesStore, FeaturesStore);

proto = OlFeaturesStore.prototype;

//sovrascrivo
proto.setFeatures = function(features) {
  var self = this;
  this._features.clear();
  _.forEach(features, function(feature) {
    self._features.push(feature);
  })
};
// sovrascrivo
proto.readFeatures = function() {
  return this._features.getArray();
};

proto.getFeaturesCollection = function() {
  return this._features;
};

proto.getFeatureById = function(featureId) {
  var feat;
  _.forEach(this._features.getArray(), function(feature) {
    if (feature.getId() == featureId) {
      feat = feature;
      return false;
    }
  });
  return feat;
};

//vado ad eseguire in pratica la sostituzione della feature dopo una modifica
proto._updateFeature = function(feature) {
  this._features.forEach(function(feat, idx, array) {
    if (feat.getId() == feature.getId()) {
      this.setAt(idx, feature);
      return false;
    }
  }, this._features);
};

// funzione che va a rimuovere la feature
proto._removeFeature = function(feature) {
  this._features.forEach(function(feat, idx, array) {
    if (feature.getId() == feat.getId()) {
      this.removeAt(idx);
      return false
    }
  }, this._features)
};

proto._clearFeatures = function() {
  // vado a rimuovere le feature in modo reattivo (per vue) utlizzando metodi che vue
  // possa reagire allacancellazione di elementi di un array
  this._features.clear();
};

module.exports = OlFeaturesStore;
},{"./featuresstore":35,"core/utils//utils":80,"core/utils/utils":80}],37:[function(require,module,exports){
function Expression() {
  this._expression = '';
}

var proto = Expression.prototype;

proto.and = function(field, value) {
    this._expression = this._expression ? this._expression + ' AND ': this._expression;
    if (field && value) {
      this.eq(field, value);
    }
    return this;
};

proto.or = function() {
  if (field && value) {
    this._expression = this._expression ? this._expression + ' OR ' : this._expression;
    this.eq(field, value);
  }
  return this;
};

proto.eq = function (field, value) {
  this._expression = this._expression + this._build('eq', field, value);
  return this;
};

proto.like = function(field, value) {
  this._expression = this._expression + this._build('LIKE', field, value);
  return this;
};

proto.ilike = function(field, value) {
  this._expression = this._expression + this._build('ILIKE', field, value);
  return this;
};

proto.not = function(field, value) {
  this._expression = this._expression + this._build('NOT', field, value);
  return this;
};

proto.gt = function(field, value) {
  this._expression = this._expression + this._build('gt', field, value);
  return this;
};

proto.gte = function(field, value) {
  this._expression = this._expression + this._build('gte', field, value);
  return this;
};

proto.lt = function(field, value) {
  this._expression = this._expression + this._build('lt', field, value);
  return this;
};

proto.lte = function(field, value) {
  this._expression = this._expression + this._build('lte', field, value);
  return this;
};

proto.clear = function() {
  this._expression = '';
  return this;
};

// metodo per il recupero dell'espressione
// chiamato da chi vuole ortriene il valore reale dell'espressione
proto.get = function() {
  return this._expression;
};

proto._build = function(operator, field, value) {
  return [field, Expression.OPERATORS[operator], value].join(' ')
};

proto.createExpressionFromFilter = function(filterObject, layername) {
  /////inserisco il nome del layer (typename) ///
  var filter = [];
  function createSingleFilter(booleanObject) {
    var filterElements = [];
    var filterElement = '';
    var valueExtra = "";
    var valueQuotes = "'";
    var rootFilter;
    _.forEach(booleanObject, function(v, k, obj) {
      //creo il filtro root che sarà AND OR
      rootFilter = Expression.OPERATORS[k];
      //qui c'è array degli elementi di un booleano
      _.forEach(v, function(input){
        //scorro su oggetto
        valueExtra = "";
        _.forEach(input, function(v, k, obj) {
          //verifico se il valore dell'oggetto è array e quindi è altro oggetto padre booleano
          if (_.isArray(v)) {
            filterElement = createSingleFilter(obj);
          } else { // è un oggetto operatore
            if (k == 'LIKE' || k == 'ILIKE') {
              valueExtra = "%";
            }
            filterOp = Expression.OPERATORS[k];
            var value;
            _.forEach(input, function(v, k, obj) {
              _.forEach(v, function(v, k, obj) {
                //verifico se il valore non è un numero e quindi aggiungo singolo apice
                if (!(_.isNull(v) || (_.isNaN(v) || _.trim(v) == ''))) {
                  filterElement = "\"" + k + "\" "+ filterOp +" " + valueQuotes + valueExtra + v + valueExtra + valueQuotes;
                  filterElements.push(filterElement);
                }
              });
            });
          }
        });
      });
      rootFilter = (filterElements.length > 0) ? filterElements.join(" "+ rootFilter + " ") : false;
    });
    return rootFilter;
  }
  //assegno il filtro creato
  if (createSingleFilter(filterObject)) {
    this._expression = layername + ":" + createSingleFilter(filterObject);
    return this;
  } else {
    return this
  }
};


Expression.OPERATORS = {
  eq: '=',
  gt: '>',
  gte: '>=',
  lt: '<',
  lte: '=<',
  LIKE: 'LIKE',
  ILIKE: 'ILIKE',
  AND: 'AND',
  OR: 'OR',
  NOT: '!='
};

module.exports = Expression;
},{}],38:[function(require,module,exports){
var Expression = require('./expression');

// classe Filtro per poter creare filtri
// chiesti principalmente dai providers per poter
// effettuare richieste di dati
function Filter() {
  this._filter = null;
  this._type = null;
}

var proto = Filter.prototype;

// server per creare un filtro complesso
proto.setExpression = function(expression) {
  this._type = Filter.TYPES.expression;
  this._filter = expression;
};

proto.setGeometry = function(geometry) {
  this._type = Filter.TYPES.geometry;
  this._filter = geometry;
  return this;
};

proto.setBBOX = function(bbox) {
  this._type = Filter.TYPES.bbox;
  this._filter = bbox;
  return this;
};

proto.setFids = function(ids) {
  this._type = Filter.TYPES.fids;
  this._filter = ids;
  return this;
};

proto.serialize = function() {
  return JSON.stringify(this);
};

// funzione che server per recuperare il valore del filtro
proto.get = function() {
  return this._filter;
};

proto.getType = function() {
  return this._type;
};

proto.clear = function() {
  this._filter = null;
};


Filter.TYPES = {
  bbox: 'bbox',
  geometry: 'geometry',
  expression: 'expression',
  fids: 'fids'
};

module.exports = Filter;

},{"./expression":37}],39:[function(require,module,exports){
var Layer = require('core/layers/layer');
var Projections = require('g3w-ol3/src/projection/projections');


function GeoLayerMixin(config) {}

var proto = GeoLayerMixin.prototype;

proto.setup = function(config){
  if (!this.config) {
    console.log("GeoLayerMixin must be used from a valid (geo) Layer instance");
    return;
  }

  this.config.multilayerid = config.multilayer;

  // estendo lo stato del layer settando la proprietà
  // geolayer a true e aggiungendo le informazioni del bbox alla proprietà bbox
  _.extend(this.state, {
    geolayer: true,
    bbox: config.bbox || null
  });

  if (config.projection) {
    this.config.projection = config.projection;
  }
  else if (config.crs) {
    if (config.project) {
      if (config.project.getProjection().getCode() != config.crs) {
        Projections.get(config.crs,config.proj4);
      }
      else {
        this.config.projection = config.project.getProjection();
      }
    }
  }
};

proto.getConfig = function() {
  return this.config;
};

proto.getState = function() {
  return this.state;
};

proto.getMultiLayerId = function() {
  return this.config.multilayerid;
};

proto.getGeometryType = function() {
  return this.config.geometrytype;
};

proto.getMultiLayerId = function() {
  return this.config.multilayerid;
};

proto.setProjection = function(crs,proj4) {
  this.config.projection = Projections.get(crs,proj4);
};

proto.getProjection = function() {
  return this.config.projection;
};

proto.getCrs = function() {
  if (this.config.projection) {
    return this.config.projection.getCode();
  }
};

proto.isCached = function() {
  return this.config.cache_url && this.config.cache_url != '';
};

proto.getCacheUrl = function(){
  if (this.isCached()) {
    return this.config.cache_url;
  }
};

module.exports = GeoLayerMixin;

},{"core/layers/layer":41,"g3w-ol3/src/projection/projections":112}],40:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var mixin = require('core/utils/utils').mixin;
var Layer = require('core/layers/layer');
var VectorLayer = require('./vectorlayer');
var GeoLayerMixin = require('./geolayermixin');

function ImageLayer(config) {
  config = config || {};
  /*{
    id,
    title,
    name,
    origname,
    multilayerid,
    servertype,
    source,
    crs,
    projection,
    bbox,
    capabilities,
    cache_url,
    baselayer,
    geometrytype,
    editops,
    expanded,
    fields,
    wmsUrl,
    infoformat,
    infourl,
    maxscale,
    minscale,
    visible,
    scalebasedvisibility,
    wfscapabilities
  }*/
  base(this, config);

  this.config.baselayer = config.baselayer || false;
  this.type = Layer.LayerTypes.IMAGE;
  // vado a modificare lo state aggiungendo il bbox e l'informazione geolayer
  this.setup(config);
}

inherit(ImageLayer, Layer);

mixin(ImageLayer, GeoLayerMixin);

var proto = ImageLayer.prototype;

proto.getLayerForEditing = function() {
  if (this.isEditable()) {
    // vado a clonare la configurazione
    // affinchè non vado a toccare l'originale
    var config = _.cloneDeep(this.config);
    // faccio in modo che non possono essere di solo editabili
    //config.capabilities = 5;
    // TEMPORANEO SETTO A NULL LE CAPABILITIES
    config.capabilities = null;
    //ritorno l'istanza del vectorlayer
    return new VectorLayer(config);
  } else {
    return null
  }
};

proto.isBaseLayer = function() {
  return this.config.baselayer;
};

proto.isWMS = function() {
  return ImageLayer.WMSServerTypes.indexOf(this.config.servertype) > -1;
};

proto.isExternalWMS = function() {
  return (this.config.source && this.config.source.url);
};

proto.getWMSLayerName = function() {
  // prendo come inizio 'attributo name come nome del layer wms
  var layerName = this.config.name;
  if (this.config.source && this.config.source.layers) {
    layerName = this.config.source.layers;
  }
  return layerName;
};

proto.getWmsUrl = function() {
  var url;
  if (this.config.source && this.config.source.type == 'wms' && this.config.source.url) {
    url = this.config.source.url
  } else {
    url = this.config.wmsUrl;
  }
  return url;
};

proto.getQueryUrl = function() {
  var url = base(this, 'getQueryUrl');
  if (this.getServerType() == 'QGIS' && this.config.source && this.config.source.type == 'wms' && this.config.source.external) {
    url+='SOURCE=wms';
  }
  return url;
};

proto.getLegendUrl = function() {
  var url = this.getWmsUrl();
  sep = (url.indexOf('?') > -1) ? '&' : '?';
  return url+sep+'SERVICE=WMS&VERSION=1.3.0&REQUEST=GetLegendGraphic&SLD_VERSION=1.1.0&FORMAT=image/png&TRANSPARENT=true&ITEMFONTCOLOR=white&LAYERTITLE=True&ITEMFONTSIZE=10&WIDTH=300&LAYER='+this.getWMSLayerName();
};

proto.getWFSLayerName = function() {
  // prendo come inizio 'attributo name come nome del layer wms
  var layerName = this.config.origname;
  if (this.config.source && this.config.source.layers) {
    layerName = this.config.source.layers;
  }
  return layerName;
};

proto.getWfsCapabilities = function() {
  return this.config.wfscapabilities || this.config.capabilities == 1 ;
};

ImageLayer.WMSServerTypes = [
  Layer.ServerTypes.QGIS,
  Layer.ServerTypes.Mapserver,
  Layer.ServerTypes.Geoserver,
  Layer.ServerTypes.OGC
];

module.exports = ImageLayer;

},{"./geolayermixin":39,"./vectorlayer":54,"core/layers/layer":41,"core/utils//utils":80,"core/utils/utils":80}],41:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var ProviderFactory = require('core/layers/providers/providersfactory');

// classe padre di tutti i Layer
function Layer(config) {
  config = config || {};
  // contiene la configurazione statica del layer
  // messo merge perchè deve eventualmente mergiare attributi in comune
  this.config = _.merge({
    id: config.id || 'Layer' ,
    title: config.title  || null,
    name: config.name || null,
    origname: config.origname || null,
    capabilities: config.capabilities || null,
    editops: config.editops || null,
    infoformat: config.infoformat || null,
    servertype: config.servertype || null,
    source: config.source || null,
    geolayer: false,
    fields: config.fields || {},
    urls: {
      query: config.infourl && config.infour != '' || config.wmsUrl
    }
  }, config);

  // contiene la parte dinamica del layer
  //this.state = config; // questo fa in modo che il catalog reagisca al mutamento
  // delle proprietà dinamiche (select, disable, visible)
  this.state = {
    id: config.id,
    title: config.name,
    visible: config.visible,
    selected: config.selected | false,
    disabled: config.disabled | false,
    hidden: config.hidden || false
  };
  // tipo di server
  var serverType = this.config.servertype;
  // tipo di sorgente del layer
  var sourceType = this.config.source.type;
  // vado a fare riferimento al suo contenitore (layersstore);
  this._layersstore = config.layersstore || null;
  /*
    questi sono i providers che il layer ha per
    la gestione di una query semplice, query che utilizza filtri e recupero dei
    dati grezzi del layer. Tutto è delegato ai sui providers
    Esistono tre tipi di provider:
      1 - query
      2 - filter
      3 - data -- utilizzato quando dobbiamo recupeare i dati grezzi del layer (esempio editing)
   */
  this.providers = {
    query: ProviderFactory.build('query', serverType, sourceType, {
      layer: this
    }),
    filter: ProviderFactory.build('filter', serverType, sourceType, {
      layer: this
    }),
    search: ProviderFactory.build('search', serverType, sourceType, {
      layer: this
    }),
    data: ProviderFactory.build('data', serverType, sourceType, {
      layer: this
    })
  };

  base(this);
}

inherit(Layer, G3WObject);

var proto = Layer.prototype;


//metodo search
proto.search = function(options) {
  options = options || {};
  var d = $.Deferred();
  var provider = this.getProvider('search');
  if (provider) {
    provider.query(options)
      .done(function(response) {
        d.resolve(response);
      })
      .fail(function(err) {
        d.reject(err);
      });
  } else {
    d.reject('Il layer non è searchable');
  }
  return d.promise();
};

// metodo che server a recupere informazioni del layer
// vinene chiamato solo nei layers che sono interroabili
proto.query = function(options) {
  options = options || {};
  var d = $.Deferred();
  // prendo come provider di default il provider query
  var provider = this.getProvider('query');
  // nel caso in cui nell'opzioni della query ho passato il parametro filtro
  if (options.filter) {
    provider = this.providers.filter;
  }
  // solo nel caso in cui sia stato istanziato un provider
  if (provider) {
    provider.query(options)
      .done(function(response) {
        d.resolve(response);
      })
      .fail(function(err) {
        d.reject(err);
      });
  } else {
    d.reject('Il layer non è interrogabile');
  }
  return d.promise();
};

proto.getProject = function() {
  return this.config.project;
};

proto.getConfig = function() {
  return this.config;
};

proto.getState = function() {
  return this.state;
};

proto.getEditingLayer = function() {
  return self;
};

proto.isHidden = function() {
  return this.state.hidden;
};

proto.setHidden = function(bool) {
  this.state.hidden = _.isBoolean(bool) ? bool: true;
};

proto.isModified = function() {
  //medodo che stbilisce se modificato o no
  return this.state.modified;
};

proto.getId = function() {
  return this.config.id;
};

proto.getTitle = function() {
  return this.config.title;
};

proto.getName = function() {
  return this.config.name;
};

proto.getOrigName = function() {
  return this.config.origname;
};

proto.getServerType = function() {
  if (this.config.servertype && this.config.servertype != '') {
    return this.config.servertype;
  }
  else {
    return ServerTypes.QGIS;
  }
};

proto.getType = function() {
  return this.type;
};

proto.isSelected = function() {
  return this.state.selected;
};

proto.isDisabled = function() {
  return this.state.disabled;
};

proto.isVisible = function() {
  return this.state.visible;
};

// verifica se il layer è interrogabile
proto.isQueryable = function() {
  var queryEnabled = false;
  var queryableForCababilities = !!(this.config.capabilities && (this.config.capabilities & Layer.CAPABILITIES.QUERYABLE));
  // se è interrogabile verifico che il suo stato sia visibile e non disabilitato
  if (queryableForCababilities) {
    // è interrogabile se visibile e non disabilitato (per scala) oppure se interrogabile comunque (forzato dalla proprietà infowhennotvisible)
    queryEnabled = (this.isVisible() && !this.isDisabled());
    if (!_.isUndefined(this.config.infowhennotvisible) && (this.config.infowhennotvisible === true)) {
      queryEnabled = true;
    }
  }
  return queryEnabled;
};

//verifica se il il Layer è filtrabile
proto.isFilterable = function() {
  return !!(this.config.capabilities && (this.config.capabilities & Layer.CAPABILITIES.FILTERABLE));
};

proto.isEditable = function() {
  return !!(this.config.capabilities && (this.config.capabilities & Layer.CAPABILITIES.EDITABLE));
};

proto.isBaseLayer = function() {
  return this.config.baselayer;
};

// funzione che permette di ricavare un tipo di url del layer passandofli il tio (esempio data, editing..etc..)
proto.getUrl = function(type) {
  return this.config.urls[type];
};

// funzione generica che ritorna il valore urls del config
proto.getUrls = function() {
  return this.config.urls;
};

proto.getQueryUrl = function() {
  return this.config.urls.query;
};

proto.setQueryUrl = function(queryUrl) {
  this.config.urls.query = queryUrl;
};

proto.getQueryLayerName = function() {
  var queryLayerName;
  if (this.config.infolayer && this.config.infolayer != '') {
    queryLayerName = this.config.infolayer;
  }
  else {
    queryLayerName = this.config.name;
  }
  return queryLayerName;
};

proto.getQueryLayerOrigName = function() {
  var queryLayerName;
  if (this.state.infolayer && this.config.infolayer != '') {
    queryLayerName = this.config.infolayer;
  }
  else {
    queryLayerName = this.config.origname;
  }
  return queryLayerName;
};

proto.getInfoFormat = function(ogcService) {
  if (this.config.infoformat && this.config.infoformat != '' && ogcService !='wfs') {
    return this.config.infoformat;
  }
  else {
    return 'application/vnd.ogc.gml';
  }
};

proto.setInfoFormat = function(infoFormat) {
  this.state.infoformat = infoFormat;
};

proto.getAttributes = function() {
  return this.fields;
};

proto.changeAttribute = function(attribute, type, options) {
  _.forEach(this.fields, function(field) {
    if (field.name == attribute) {
      field.type = type;
      field.options = options;
    }
  })
};

proto.getAttributeLabel = function(name) {
  var label;
  _.forEach(this.getAttributes(),function(field){
    if (field.name == name){
      label = field.label;
    }
  });
  return label;
};

proto.getProvider = function(type) {
  return this.providers[type];
};

proto.getProviders = function() {
  return this.providers;
};

proto.getLayersStore = function() {
  return this._layersstore;
};

proto.setLayersStore = function(layerstore) {
  this._layersstore = layerstore;
};

///PROPRIETÀ DEL LAYER

// Tipo di Layer
Layer.LayerTypes = {
  TABLE: "table",
  IMAGE: "image",
  VECTOR: "vector"
};

// Tipo di server che lo gestisce
Layer.ServerTypes = {
  OGC: "OGC",
  QGIS: "QGIS",
  Mapserver: "Mapserver",
  Geoserver: "Geoserver",
  ArcGIS: "ArcGIS",
  OSM: "OSM",
  Bing: "Bing",
  Local: "Local"
};

// tipo di sorgente
Layer.SourceTypes = {
  POSTGIS: 'postgres',
  SPATIALITE: 'spatialite',
  CSV: 'delimitedtext',
  WMS: 'wms'
};

// Caratteristiche del layer
Layer.CAPABILITIES = {
  QUERYABLE: 1,
  FILTERABLE: 2,
  EDITABLE: 4
};

//Tipi di editing sul layer
Layer.EDITOPS = {
  INSERT: 1,
  UPDATE: 2,
  DELETE: 4
};


module.exports = Layer;

},{"core/g3wobject":30,"core/layers/providers/providersfactory":48,"core/utils//utils":80,"core/utils/utils":80}],42:[function(require,module,exports){
var Layer = require('./layer');
var TableLayer = require('./tablelayer');
var VectorLayer = require('./vectorlayer');
var ImageLayer = require('./imagelayer');

// oggetto che ha il compito di costruire
// l'istanza Layer a seconda della configurazione
function LayerFactory() {
  this.build = function(config, options) {
    // ritorna l'istanza del layer in base alla configurazione
    var layerClass = this.get(config);
    if (layerClass) {
      return new layerClass(config, options);
    }
    return null;
  };

  this.get = function(config) {
    var LayerClass;
    var serverType = config.servertype;
    // server QGIS
    if (serverType == 'QGIS') {
      // imposto subito a ImageLayer
      LayerClass = ImageLayer;
      // poi vado a verificare
      if (config.source && config.geometrytype) {
        if ([Layer.SourceTypes.POSTGIS, Layer.SourceTypes.SPATIALITE, Layer.SourceTypes.CSV].indexOf(config.source.type) > -1) {
          if (config.geometrytype && config.geometrytype == 'No geometry') {
            // se non è stato definito il tipo geometrico allora assesgno classe
            // TableLayer
            LayerClass = TableLayer;
          }
        }
      }
    }
    ///server OGC
    else if (serverType == 'OGC') {
      if (config.source) {
        var type = config.source.type;
        switch (type) {
          case 'WMS':
            LayerClass = ImageLayer;
            break;
          case 'WFS':
            LayerClass = VectorLayer;
        }
      }
    }
    //Layer vettoriale caricato localmente
    else if (serverType == 'Local') {
      LayerClass = VectorLayer;
    }
    return LayerClass;
  };
}

module.exports = new LayerFactory();
},{"./imagelayer":40,"./layer":41,"./tablelayer":53,"./vectorlayer":54}],43:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interfaccia per registare i layers
function LayersStore(config) {
  var self = this;
  config = config || {};
  this.config = {
    id: config.id || Date.now(),
    projection: config.projection,
    extent: config.extent,
    initextent: config.initextent,
    wmsUrl: config.wmsUrl,
    //metto caratteristica catalogabile
    catalog: _.isBoolean(config.catalog) ? config.catalog : true
  };

  this.state = {
    //questo attributo mi server per popolare eventualmente l'abero del catalogo
    layerstree: [],
    relations: null // mi servirà a costruire il tree delle relazioni paddri figlio
  };

  this._layers = this.config.layers || {};

  this.setters = {
    setLayersVisible: function (layersIds, visible) {
      var self = this;
      _.forEach(layersIds, function (layerId) {
        self.getLayerById(layerId).state.visible = visible;
      })
    },
    setLayerSelected: function(layerId, selected) {
      var layers = this.getLayers();
      _.forEach(layers, function(layer) {
        layer.state.selected = ((layerId == layer.getId()) && selected) || false;
      })
    },
    addLayer: function(layer) {
      this._addLayer(layer);
    },
    removeLayer: function(layerId) {
      this._removeLayer(layerId);
    }
  };

  base(this);
}

inherit(LayersStore, G3WObject);

proto = LayersStore.prototype;

proto.showOnCatalog = function() {
  return this.config.catalog;
};

proto.setOptions = function(config) {
  this.config = config;
};

proto.getId = function() {
  return this.config.id;
};

proto._addLayer = function(layer) {
  this._layers[layer.getId()] = layer;
};

proto.addLayers = function(layers) {
  var self = this;
  _.forEach(layers, function(layer) {
    self.addLayer(layer);
  });
};

proto._removeLayer = function(layerId) {
  delete this._layers[layerId];
};

proto.removeLayers = function(layersId) {
  _.forEach(layersId, function(layerId) {
    self.removeLayer(layer)
  })
};

proto.getLayersDict = function(options) {
  if (!options) {
    return this._layers;
  }
  var options = options || {};
  var filterActive = options.ACTIVE;
  var filterQueryable = options.QUERYABLE;
  var filterFilterable = options.FILTERABLE;
  var filterEditable = options.EDITABLE;
  var filterVisible = options.VISIBLE;
  var filterSelected = options.SELECTED;
  var filterCached = options.CACHED;
  var filterSelectedOrAll = options.SELECTEDORALL;
  var filterAllNotSelected = options.ALLNOTSELECTED;
  var filterServerType = options.SERVERTYPE;
  var filterBaseLayer = options.BASELAYER;
  var filterGeoLayer = options.GEOLAYER;
  var filterHidden = options.HIDDEN;
  var filterWfs = options.WFS;
  if (filterSelectedOrAll) {
    filterSelected = null;
  }
  if (_.isUndefined(filterQueryable)
    && _.isUndefined(filterFilterable)
    && _.isUndefined(filterEditable)
    && _.isUndefined(filterVisible)
    && _.isUndefined(filterActive)
    && _.isUndefined(filterSelected)
    && _.isUndefined(filterCached)
    && _.isUndefined(filterSelectedOrAll)
    && _.isUndefined(filterServerType)
    && _.isUndefined(filterGeoLayer)
    && _.isUndefined(filterHidden)
    && _.isUndefined(filterBaseLayer)) {
    return this._layers;
  }
  var layers = [];
  _.forEach(this._layers, function(layer, key) {
    layers.push(layer);
  });


  if (typeof filterActive == 'boolean') {
    layers = _.filter(layers, function(layer) {
      return filterActive == !layer.isDisabled();
    });
  }

  if (typeof filterQueryable == 'boolean') {
    layers = _.filter(layers, function(layer) {
      return filterQueryable == layer.isQueryable();
    });
  }

  if (typeof filterFilterable == 'boolean') {
    layers = _.filter(layers,function(layer) {
      return filterFilterable == layer.isFilterable();
    });
  }

  if (typeof filterEditable == 'boolean') {
    layers = _.filter(layers,function(layer) {
      return filterEditable == layer.isEditable();
    });
  }

  if (typeof filterVisible == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterVisible == layer.isVisible();
    });
  }

  if (typeof filterCached == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterCached == layer.isCached();
    });
  }

  if (typeof filterSelected == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterSelected == layer.isSelected();
    });
  }

  if (typeof filterBaseLayer == 'boolean') {
    layers = _.filter(layers, function(layer){
      return filterBaseLayer == layer.isBaseLayer();
    });
  }

  if (typeof filterGeoLayer == 'boolean') {
    layers = _.filter(layers,function(layer) {
      return filterGeoLayer == layer.state.geolayer;
    });
  }

  if (typeof filterHidden == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterHidden == layer.isHidden();
    });
  }

  if (typeof filterServerType == 'string' && filterServerType!='') {
    layers = _.filter(layers,function(layer){
      return filterServerType = layer.getServerType();
    });
  }
  // filtra solo i selezionati
  if (filterSelectedOrAll) {
    var _layers = layers;
    layers = _.filter(layers,function(layer){
      return layer.isSelected();
    });
    layers = layers.length ? layers : _layers;
  }

  // filtra solo i quelli non selezionati
  if (filterAllNotSelected) {
    var _layers = layers;
    layers = _.filter(layers,function(layer){
      return !layer.isSelected();
    });
    layers = layers.length ? layers : _layers;
  }
  return layers;
};

// ritorna l'array dei layers (con opzioni di ricerca)
proto.getLayers = function(options) {
  var layers = this.getLayersDict(options);
  return _.values(layers);
};

proto.getBaseLayers = function() {
  return this.getLayersDict({
    BASELAYER: true
  });
};

proto.getLayerById = function(layerId) {
  return this.getLayersDict()[layerId];
};

proto.getLayerByName = function(name) {
  var layer = null;
  _.forEach(this.getLayersDict(),function(layer){
    if (layer.getName() == name){
      layer = _layer;
    }
  });
  return layer;
};

proto.getLayerAttributes = function(layerId){
  return this.getLayerById(layerId).getAttributes();
};

proto.getLayerAttributeLabel = function(layerId,name){
  return this.getLayerById(layerId).getAttributeLabel(name);
};

proto.getGeoLayers = function() {
  return this.getLayers({
    GEOLAYER: true
  })
};

proto.toggleLayer = function(layerId,visible){
  var layer = this.getLayerById(layerId);
  var visible = visible || !layer.state.visible;
  this.setLayersVisible([layerId],visible);
};

proto.toggleLayers = function(layersIds,visible){
  this.setLayersVisible(layersIds,visible);
};

proto.selectLayer = function(layerId){
  this.setLayerSelected(layerId, true);
};

proto.unselectLayer = function(layerId) {
  this.setLayerSelected(layerId, false);
};

proto.getProjection = function() {
  return this.config.projection;
};

proto.getExtent = function() {
  return this.config.extent;
};

proto.getInitExtent = function() {
  return this.config.initextent;
};

proto.getWmsUrl = function() {
  return this.config.wmsUrl;
};

// funzione che setta il layersstree deli layers del layersstore
proto.setLayersTree = function(layerstree,name) {
  var self = this;
  function traverse(obj) {
    _.forIn(obj, function (layer, key) {
      //verifica che il nodo sia un layer e non un folder
      if (!_.isNil(layer.id)) {
        obj[key] = self.getLayerById(layer.id).getState();
      }
      if (!_.isNil(layer.nodes)){
        traverse(layer.nodes);
      }
    });
  }
  traverse(layerstree);
  // questo server per raggruppare ogni albero dei layer
  // al proprio gruppo che sia un progetto, un plugin o altro
  // quando viene creato il layersstore
  this.state.layerstree.splice(0,0,{
    title: name || this.config.id,
    expanded: true,
    nodes: layerstree
  });
};

// funzione che posso sfruttare dai plugin per costruire un
// layerstree senza tanto stare acreare  e ricordarmi come creare un layerstrree
// naturalmente è ad una dimanesione altrimenti c'è da studiare
// come creare un layers tree cosa innestata forse paasando un layertree nella configurazione
proto.createLayersTree = function(groupName, options) {
  var options = options || {};
  var full = options.full || false;
  var _layerstree = options.layerstree || null;
  var layerstree = [];
  if (_layerstree) {
    if (full === true) {
      return this.state.layerstree;
    }
    else {
      function traverse(obj,newobj) {
        _.forIn(obj, function (layer) {
          var lightlayer = {};
          if (!_.isNil(layer.id)) {
            lightlayer.id = layer.id;
          }
          if (!_.isNil(layer.nodes)){
            lightlayer.title = layer.name;
            lightlayer.expanded = layer.expanded;
            lightlayer.nodes = [];
            traverse(layer.nodes,lightlayer.nodes)
          }
          newobj.push(lightlayer);
        });
      }
      traverse(_layerstree,layerstree);
    }
  } else {
    _.forEach(this.getGeoLayers(), function (layer) {
      layerstree.push({
        id: layer.getId(),
        name: layer.getName(),
        title: layer.getTitle(),
        visible: layer.isVisible() || false
      })
    });
  }  
  this.setLayersTree(layerstree, groupName);
};

proto.removeLayersTree = function(id) {
  this.state.layerstree.splice(0,this.state.layerstree.length);
};

proto.getLayersTree = function() {
  return this.state.layerstree;
};


module.exports = LayersStore;

},{"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],44:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interfaccia per registare i layers
function LayersStoresRegistry() {
  var self = this;
  this.stores = {};
  this.storesArray = [];
  // questi setters mi servono per far reagire  le varie parti dell'applicazione
  // che dipendono o sono legate ai layersStores
  this.setters = {
    addLayersStore: function(layersStore, idx) {
      this._addLayersStore(layersStore, idx);
    },
    removeLayersStore: function(layerStore) {
      this._removeLayersStore(layerStore);
    },
    removeLayersStores: function() {
      this._removeLayersStores();
    }
  };

  base(this);
}

inherit(LayersStoresRegistry, G3WObject);

proto = LayersStoresRegistry.prototype;

proto.getLayers = function(filter) {
  var layers = [];
  _.forEach(this.stores, function(layersStore, storeId) {
    layers = layers.concat(layersStore.getLayers(filter))
  });
  return layers;
};

proto.getLayersStore = function(id) {
  return this.stores[id];
};

proto.getLayersStores = function() {
  var self = this;
  var stores = [];

  _.forEach(this.storesArray,function(storeId){
    stores.push(self.stores[storeId]);
  });

  return stores;
};

// funzione che aggiunge un layersstore al registro della
proto._addLayersStore = function(layersStore, idx) {
  // usiamo un array per garantire ordine di inserimento, poi potremo gestire richieste di inserimento in una specifica posizione
  var storeId = layersStore.getId();
  this.stores[storeId] = layersStore;
  if (!_.isNil(idx)) {
    this.storesArray.splice(idx,0, storeId);
  } else {
    this.storesArray.push(storeId);
  }
};

proto._removeLayersStore = function(layerStore) {
  if (layerStore) {
    var storeId = layerStore.getId();
    var idx = this.storesArray.indexOf(storeId);
    delete this.stores[storeId];
    this.storesArray.splice(idx, 1);
  }
};

// rimuove tutti i layersstore salvati
proto._removeLayersStores = function() {
  var length = this.storesArray.length;
  this.storesArray.splice(0, length);
  this.stores = {};
};


module.exports = LayersStoresRegistry;
},{"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],45:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function GEOJSONDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'geojson';
}

inherit(GEOJSONDataProvider, DataProvider);

var proto = GEOJSONDataProvider.prototype;

proto.getFearures = function() {
  var d = $.Deferred();
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
  var d = $.Deferred();
  // attravercso il layer name e il base url
  // chiedo la server di inviarmi la configurazione editing del laye
  $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
  var d = $.Deferred();
  var lock = this.getMode() == 'w' ? true : false;
  var apiUrl;
  if (lock) {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
  } else {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
  }
  $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

module.exports = GEOJSONDataProvider;


},{"core/layers/providers/provider":47,"core/utils/utils":80}],46:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function KMLDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'kml';
}

inherit(KMLDataProvider, DataProvider);

var proto = KMLDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};


module.exports = KMLDataProvider;
},{"core/layers/providers/provider":47,"core/utils/utils":80}],47:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var Feature = require('core/layers/features/feature');


function Provider(options) {
  options = options || {};
  this._isReady = false;
  this._name = 'provider';
  this._layer = options.layer;
  base(this);
}

inherit(Provider, G3WObject);

var proto = Provider.prototype;

proto.getFeatures = function() {
  console.log('da sovrascrivere')
};

proto.query = function(options) {
  console.log('metodo da sovrascrivere')
};

proto.setReady = function(bool) {
  this._isReady = bool;
};

proto.isReady = function() {
  return this._isReady;
};

proto.error = function() {
  //TODO
};

proto.isValid = function() {
  console.log('deve essere implementatato dai singoli provider');
};

proto.getName = function() {
  return this._name;
};

proto.extractGML=  function (response) {
  if (response.substr(0,2) != '--') {
    return response;
  }
  var gmlTag1 = new RegExp("<([^ ]*)FeatureCollection");
  var gmlTag2 = new RegExp("<([^ ]*)msGMLOutput");
  var boundary = '\r\n--';
  var parts = response.split(new RegExp(boundary));

  for (var i=0; i<parts.length; i++) {
    var part = parts[i];
    var isGmlPart = false;
    isGmlPart = part.search(gmlTag1) > -1 ? true : part.search(gmlTag2) > -1 ? true : false;
    if (isGmlPart) {
      var gml = part.substr(part.indexOf("<?xml"));
      return gml;
    }
  }
};



// Messo qui generale la funzione che si prende cura della trasformazione dell'xml di risposta
// dal server così da avere una risposta coerente in termini di formato risultati da presentare
// nel componente QueryResults
proto.handleQueryResponseFromServer = function(response, ogcservice) {
  var self = this;
  var format = new ol.format.WMSGetFeatureInfo(({
    layers: [this._layer.getId()]
  }));
  var features = format.readFeatures(response);
  return [{
    layer: this._layer,
    features: features
  }];
  switch (this._layer.getInfoFormat()) {
    case 'json':
      parser = this._parseLayerGeoJSON;
      data = response.vector.data;
      features = parser.call(self, data, ogcservice);
      break;
    default:
      response = this.extractGML(response);
      var format = new ol.format.WMSGetFeatureInfo(({
          layers: [this._layer.getId()]
        }));
      features = format.readFeatures(response);
  }
  return [{
    layer: this._layer,
    features: features,
    error: error
  }];
};

// Brutto ma per ora unica soluzione trovata per dividere per layer i risultati di un doc xml wfs.FeatureCollection.
// OL3 li parserizza tutti insieme non distinguendo le features dei diversi layers
proto._parseLayerFeatureCollection = function(data, ogcService) {
  var layerName = (ogcService == 'wfs') ? this._layer.getWMSLayerName().replace(/ /g,'_'): this._layer.getWMSLayerName().replace(/ /g,''); // QGIS SERVER rimuove gli spazi dal nome del layer per creare l'elemento FeatureMember
  var layerData = _.cloneDeep(data);
  layerData.FeatureCollection.featureMember = [];
  var featureMembers = data.FeatureCollection.featureMember;
  featureMembers = _.isArray(featureMembers) ? featureMembers : [featureMembers];
  _.forEach(featureMembers,function(featureMember){
    var isLayerMember = _.get(featureMember,layerName);
    if (isLayerMember) {
      layerData.FeatureCollection.featureMember.push(featureMember);
    }
  });
  var x2js = new X2JS();
  var layerFeatureCollectionXML = x2js.json2xml_str(layerData);
  var parser = new ol.format.WMSGetFeatureInfo();
  return parser.readFeatures(layerFeatureCollectionXML);
};

// mentre con i risultati in msGLMOutput (da Mapserver) il parser può essere istruito per parserizzare in base ad un layer di filtro
proto._parseLayermsGMLOutput = function(data) {
  var layers = this._layer.getQueryLayerOrigName();
  var parser = new ol.format.WMSGetFeatureInfo({
    layers: layers
  });
  return parser.readFeatures(data);
};


proto._parseLayerGeoJSON = function(data) {
  var geojson = new ol.format.GeoJSON({
    defaultDataProjection: this.crs,
    geometryName: "geometry"
  });
  return geojson.readFeatures(data);
};


module.exports = Provider;
},{"core/g3wobject":30,"core/layers/features/feature":34,"core/utils/utils":80}],48:[function(require,module,exports){
var Providers = {
  geojson: require('./geojsonprovider'),
  kml: require('./kmlprovider'),
  xml: require('./xmlprovider'),
  qgis: require('./qgisprovider'),
  wms: require('./wmsprovider'),
  wfs: require('./wfsprovider')
};

var ProvidersForServerTypes = {
  'QGIS': {
    'postgres': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.qgis,
      search: Providers.qgis
    },
    'spatialite': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.qgis,
      search: Providers.qgis
    },
    'ogr': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: null,
      search: Providers.qgis
    },
    'delimitedtext': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: null,
      search: null
    },
    'wms': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: null,
      search: null
    },
    'wfs': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.wfs,
      search: Providers.qgis
    },
    'gdal': {
      query: Providers.wms,
      filter: null,
      data: null,
      search: null
    }
  },
  'OGC': {
    'wms': {
      query: Providers.wms,
      filter: null,
      data: null,
      search: null
    }
  }
};

function ProviderFactory() {
  this.build = function(providerType,serverType,sourceType,options) {
    // ritorna l'sitanza del provider selezionato
    var providerClass = this.get(providerType,serverType,sourceType);
    if (providerClass) {
      return new providerClass(options);
    }
    return null;
  };

  this.get = function(providerType,serverType,sourceType) {
    return ProvidersForServerTypes[serverType][sourceType][providerType];
  }
}

module.exports = new ProviderFactory();

},{"./geojsonprovider":45,"./kmlprovider":46,"./qgisprovider":49,"./wfsprovider":50,"./wmsprovider":51,"./xmlprovider":52}],49:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');
var Feature = require('core/layers/features/feature');
var Parsers = require('core/parsers/parsers');

function QGISProvider(options) {
  options = options || {};
  base(this);
  this._name = 'qgis';
  this._layer = options.layer || null;
  this._unlockUrl = this._layer.getUrl('unlock');
  // url riferito alle query
  this._queryUrl = this._layer.getUrl('query');
  // editing url api
  this._editingUrl = this._layer.getUrl('editing');
  this._commitUrl = this._layer.getUrl('commit');
  // url riferito ai dati;
  this._dataUrl = this._layer.getUrls('data');
  // url per prendere la configurazione del layer dal server
  this._configUrl = this._layer.getUrl('config');
  // layer name
  this._layerName = this._layer.getName() || null; // prendo sempre il name del layer di QGIS, perché le query sono proxate e gestiteda g3w-server
  this._infoFormat = this._layer.getInfoFormat() || 'application/vnd.ogc.gml';
}

inherit(QGISProvider, DataProvider);

var proto = QGISProvider.prototype;

//metodo per le interrogazioni tramite filtri
proto.query = function(options) {
  var self = this;
  var d = $.Deferred();
  options = options || {};
  var filter = options.filter || null;
  if (filter) {
    var filterType = filter.getType();
    var url = this._queryUrl;
      $.get( url, {
          SERVICE: 'WMS',
          VERSION: '1.3.0',
          REQUEST: 'GetFeatureInfo',
          LAYERS: this._layerName,
          QUERY_LAYERS: this._layerName,
          INFO_FORMAT: this._infoFormat,
          FEATURE_COUNT: 200,
          FILTER: filter.get()
        }
      ).done(function(response) {
        var featuresForLayers = self.handleQueryResponseFromServer(response, self._infoFormat, self._layerName);
        var response = {
          data: featuresForLayers,
          query: null
        };
        d.resolve(response);
      })
        .fail(function(){
          d.reject();
        });
    }
  return d.promise();
};

// ci vuole un metodo per prendere la configurazione dal server
// del layer
proto.getConfig = function(options) {
  options = options || {};
  var d = $.Deferred();
  var url = this._configUrl;
  if (!url) {
    d.reject('Url non valido');
    return;
  }
  $.get(url)
    .then(function(config) {
      d.resolve(config);
    })
    .fail(function(err) {
      d.reject(err);
    });
  return d.promise();
};

// unlock feature
proto.unlock = function() {
  var d = $.Deferred();
  $.post(this._unlockUrl)
    .then(function(response) {
      d.resolve(response);
    })
    .fail(function(err) {
      d.reject(err);
    });
  return d.promise()
};

// funzione commit
proto.commit = function(commitItems) {
  var d = $.Deferred();
  // verifico nel passaggio di opzioni se è stato richiesto editing o meno;
  var url = this._commitUrl;
  var jsonCommits = JSON.stringify(commitItems);
  $.post({
    url: url,
    data: jsonCommits,
    contentType: "application/json"
  })
    .then(function(response) {
      d.resolve(response);
    })
    .fail(function(err) {
      d.reject(err);
    });
  return d.promise();
};

// METODI LOADING EDITING FEATURES E STABILISCE SE IN LETTURA O SCRITTURA/LETTURA //
proto.getFeatures = function(options) {
  var self = this;
  var d = $.Deferred();
  options = options || {};
  var layerType = options.type || 'vector'; //tipo di layer
  // verifico nel passaggio di veridico se i dati sono richiesti in editing o sola lettura;
  var url = options.editing ? this._editingUrl : this._dataUrl;
  var filter = options.filter || null;
  if (filter) {
    var bbox = filter.bbox;
    filter = {in_bbox: bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3]};
  }
  var pk = this._layer.getPk();
  if (!url) {
    d.reject('Url non valido');
    return;
  }
  var features = [];
  var jsonFilter = JSON.stringify(filter);
  $.post({
    url: url,
    data: jsonFilter,
    contentType: "application/json"
  })
    .then(function(response) {
      var vector = response.vector;
      var featurelocks = response.featurelocks;
      var data = vector.data;
      var parser = Parsers[layerType].get({
        type: 'json',
        pk: pk
      });
      _.forEach(parser(data), function(feature) {
        features.push(new Feature({
          feature: feature,
          pk: pk
        }))
      });
      // risolvo passando le features loccate e le features caricate
      d.resolve({
        features: features,
        featurelocks: featurelocks
      });
    })
    .fail(function(err) {
      d.reject(err);
    });
  return d.promise();
};

// funzione principale, starting point, chiamata dal plugin per
// il recupero dei vettoriali (chiamata verso il server)
proto._loadLayerData = function(mode, customUrlParameters) {
  // il parametro mode mi di è in scrittura, lettura etc ..
  var self = this;
  var deferred = $.Deferred();

  //verifica se sono stati caricati i vettoriali dei layer
  // attraverso la proprietà vector del layer passato dal plugin
  _.forEach(this._layers, function(layer, layerCode) {
    // verifico se l'attributo vector è nullo
    if (_.isNull(layer.vector)) {
      noVectorlayerCodes.push(layerCode);
    }
  });
  // eseguo le richieste delle configurazioni e mi tengo le promesse
  var vectorLayersSetup = _.map(noVectorlayerCodes, function(layerCode) {
    return self._setupVectorLayer(layerCode);
  });
  // emetto l'evento loadingvectorlayersstart (il pluginservice è in ascolto)
  self.emit('loadingvectorlayersstart');
  // aspetto tutte le promesse del setup vector
  $.when.apply(this, vectorLayersSetup)
  // una volta che tutte le configurazioni dei layer vecor
  // sono state prese dal server e dopo aver assegnato all'attributo vector
  // del layer plugin il layer vettoriale costruito con le configurazioni
  // di sopra
    .then(function() {
      // le promesse ritornano il layerCode del layer vettoriale appena costuito
      var vectorLayersCodes = Array.prototype.slice.call(arguments);
      // emtto evento che inzia il recupero dei dati dei layer vettoriali (geojson)
      self.emit('loadingvectolayersdatastart');
      // inizio a caricare tutti i vettoriali dopo aver caricato le configurazioni
      self.loadAllVectorsData(vectorLayersCodes)
        .then(function() {
          self._vectorLayersCodes = vectorLayersCodes;
          deferred.resolve(vectorLayersCodes);
          // emtto evento che ho ricevuto i layers
          self.emit('loadingvectorlayersend');
          // ora il loader è pronto
          self.setReady(true);

        })
        .fail(function() {
          // risetto tutti i layer veetotiali a null
          _.forEach(self._layers, function(layer) {
            layer.vector = null;
          });
          deferred.reject();
          // emttto che c'è stato un errore nel loading dei dati che vengono dal server
          self.emit('errorloadingvectorlayersend');
          self.setReady(false);
        })
    })
    .fail(function() {
      self.setReady(false);
      self.emit('errorloadingvectorlayersend');
      deferred.reject();
    });
  return deferred.promise();
};

proto.setVectorLayersCodes = function(vectorLayersCodes) {
  this._vectorLayersCodes = vectorLayersCodes;
};

proto.getVectorLayersCodes = function() {
  return this._vectorLayersCodes;
};

proto.getLayers = function() {
  return this._layers;
};

// funzione che fa il reload che rihiede di nuovo il dati del vetor layer
// caso in cui si lavora con un layer vettoriale e non si usa un wms per fare la query
proto.reloadVectorData = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  var bbox = this._mapService.state.bbox;
  self._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
          self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
          vectorLayer.setData(vectorDataResponse.vector.data);
          deferred.resolve(vectorLayer);
        });
    });
  return deferred.promise();
};

//funzione che permette di ottenere tutti i dati relativi ai layer vettoriali caricati
//prima si è ottenuta la coinfigurazione, ora si ottengono i dati veri e propri
proto.loadAllVectorsData = function(layerCodes) {
  var self = this;
  var deferred = $.Deferred();
  var layers = this._layers;
  // verifico che il BBOX attuale non sia stato già  caricato
  // prondo il bbox
  var bbox = this._mapService.state.bbox;
  var loadedExtent = this._loadedExtent;
  if (loadedExtent && ol.extent.containsExtent(loadedExtent, bbox)) {
    return resolvedValue();
  }
  if (!loadedExtent) {
    this._loadedExtent = bbox;
  } else {
    this._loadedExtent = ol.extent.extend(loadedExtent, bbox);
  }
  if (layerCodes) {
    layers = [];
    _.forEach(layerCodes, function(layerCode) {
      layers.push(self._layers[layerCode]);
    });
  }
  //per ogni layer del plugin che non ha il layer vado a caricare i dati del layer vettoriale
  var vectorDataRequests = _.map(layers, function(Layer) {
    return self._loadVectorData(Layer.vector, bbox);
  });

  $.when.apply(this, vectorDataRequests)
    .then(function() {
      deferred.resolve(layerCodes);
    })
    .fail(function(){
      deferred.reject();
    });

  return deferred.promise();
};

proto._setCustomUrlParameters = function(customUrlParameters) {
  this._customUrlParameters = customUrlParameters;
};

proto._checkVectorGeometryTypeFromConfig = function(vectorConfig) {
  switch (vectorConfig.geometrytype) {
    case 'Line':
      vectorConfig.geometrytype = 'LineString';
      break;
    case 'MultiLine':
      vectorConfig.geometrytype = 'MultiLineString';
      break;
  }
  return vectorConfig;
};


proto._createVectorLayerFromConfig = function(layerCode) {
  var self = this;
  // recupero la configurazione del layer settata da plugin service
  var layerConfig = this._layers[layerCode];
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._getVectorLayerConfig(layerConfig[this._editingApiField])
    .then(function(vectorConfigResponse) {
      var vectorConfig = vectorConfigResponse.vector;
      // vado a verificare la correttezza del geometryType (caso di editing generico)
      vectorConfig = self._checkVectorGeometryTypeFromConfig(vectorConfig);
      // una volta ottenuta dal server la configurazione vettoriale,
      // provvedo alla creazione del layer vettoriale
      var crsLayer = layerConfig.crs || self._mapService.getProjection().getCode();
      var vectorLayer = self._createVectorLayer({
        geometrytype: vectorConfig.geometrytype,
        format: vectorConfig.format,
        crs: self._mapService.getProjection().getCode(),
        crsLayer : crsLayer,
        id: layerConfig.id,
        name: layerConfig.name,
        pk: vectorConfig.pk,
        editing: self._editingMode
      });
      // setto i campi del layer
      vectorLayer.setFields(vectorConfig.fields);
      vectorLayer.setCrs(crsLayer);
      // questo è la proprietà della configurazione del config layer
      // che specifica se esistono relazioni con altri layer
      // sono array di oggetti che specificano una serie di
      // informazioni su come i layer sono relazionati (nome della relazione == nome layer)
      // foreign key etc ..
      var relations = vectorConfig.relations;
      // nel caso il layer abbia relazioni (array non vuoto)
      if (relations) {
        // per dire a vectorLayer che i dati
        // delle relazioni verranno caricati solo quando
        // richiesti (es. aperture form di editing)
        vectorLayer.lazyRelations = true;
        //vado a settare le relazioni del vector layer
        vectorLayer.setRelations(relations);
      }
      // setto lo stile del layer OL
      if (layerConfig.style) {
        vectorLayer.setStyle(layerConfig.style);
      }
      // risolve con il nome del vectorLayer
      deferred.resolve(vectorLayer);
    })
    .fail(function(){
      deferred.reject();
    });
  return deferred.promise();
};

// funzione che dato la configurazione del layer fornito dal plugin (style, editor, vctor etc..)
// esegue richieste al server al fine di ottenere configurazione vettoriale del layer
proto._setupVectorLayer = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      var layerConfig = self._layers[layerCode];
      // assegno il vetorLayer appena creato all'attributo vector del layer
      layerConfig.vector = vectorLayer;
      // risolve con il nome del layerCode
      deferred.resolve(layerCode);
    })
    .fail(function() {
      deferred.reject();
    });
  return deferred.promise();
};

//in base all bbox e la layer chiedo al server di restituirmi il vettoriale (geojson) del layer
proto._loadVectorData = function(vectorLayer, bbox) {
  var self = this;
  // eseguo le richieste dei dati al server al fine di ottenere il geojson,
  // vettoriale, del layer richiesto
  return self._getVectorLayerData(vectorLayer, bbox)
    .then(function(vectorDataResponse) {
      self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
      // setto i dati vettoriali del layer vettoriale
      // e verifico se siamo in editingMode write e se ci sono featurelocks
      if (self._editingMode && vectorDataResponse.featurelocks) {
        // nel cso in cui sia in editing (mode w) e che si siano featureLocks
        // setto tale features al layervettoriale
        self.setVectorFeaturesLock(vectorLayer, vectorDataResponse.featurelocks);
      }
      //setto i dati del layer vettoriale (geojson)
      vectorLayer.setData(vectorDataResponse.vector.data);
      if (self._)
        return vectorDataResponse;
    })
    .fail(function() {
      return false;
    })
};

proto.getVectorLayerData = function(layerCode) {
  return this._vectorLayersData[layerCode];
};

proto.getVectorLayersData = function() {
  return this._vectorLayersData;
};

proto.setVectorLayerData = function(layerCode, vectorLayerData) {
  this._vectorLayersData[layerCode] = vectorLayerData;
};

//funzione che setta le features lock del layer vettoriale
proto.setVectorFeaturesLock = function(vectorLayer, featureslock) {
  //vado a pescare le fifferenze tra le featureidlock già caricati id
  var newFeaturesLockIds = _.differenceBy(featureslock, vectorLayer.getFeatureLocks(), 'featureid');
  _.forEach(newFeaturesLockIds, function(newLockId) {
    vectorLayer.addLockId(newLockId)
  });
};

proto.cleanVectorFeaturesLock = function(vectorLayer) {
  vectorLayer.cleanFeatureLocks();
};

proto.lockFeatures = function(layerName) {
  var self = this;
  var d = $.Deferred();
  var bbox = this._mapService.state.bbox;
  var vectorLayer = this._layers[layerName].vector;
  $.get(this._baseUrl+layerName+"/?lock" + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      self.setVectorFeaturesLock(vectorLayer, data.featurelocks);
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
  var d = $.Deferred();
  // attravercso il layer name e il base url
  // chiedo la server di inviarmi la configurazione editing del laye
  $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
  var d = $.Deferred();
  var lock = this.getMode() == 'w' ? true : false;
  var apiUrl;
  if (lock) {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
  } else {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
  }
  $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};
// funzione per creare il layer vettoriale
proto._createVectorLayer = function(options) {
  var vector = new VectorLayer(options);
  return vector;
};
//funzione chiamata dal plugin quando si vuole fare un cleanUp dei layers
// !!! -- DA RIVEDERE -- !!!
proto.cleanUpLayers = function() {
  this._loadedExtent = null;
};

module.exports = QGISProvider;
},{"core/layers/features/feature":34,"core/layers/providers/provider":47,"core/parsers/parsers":64,"core/utils/utils":80}],50:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var resolve = require('core/utils/utils').resolve;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');
var Filter = require('core/layers/filter/filter');

function WFSDataProvider(options) {
  options = options || {};
  base(this, options);
  this._name = 'wfs';
}

inherit(WFSDataProvider, DataProvider);

var proto = WFSDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};

// metodo del provider che risponde alla query del layer
proto.query = function(options) {
  var self = this;
  var filter = options.filter;
  var d = $.Deferred();
  this._doRequest(filter)
    .done(function(response) {
      var featuresForLayers = self.handleQueryResponseFromServer(response,'wfs');
      d.resolve({
        data: featuresForLayers
      });
    })
    .fail(function(e){
      d.reject(e);
    });
  return d.promise();
};

proto._post = function(url, params) {
  url = url + '/';
  return  $.post(url, params)

};

// get request
proto._get = function(url, params) {
  // trasformo i parametri
  var urlParams = $.param(params);
  url = url + '?' + urlParams;
  return $.get(url)
};

//funzione che si occupa di fare la richiesta al server
proto._doRequest = function(filter) {
  filter = filter || null;
  // verifico che il filtro sia istanza della classe Filter
  if (!(filter instanceof Filter)) {
    return resolve();
  }
  var layer = this._layer;
  var url = layer.getQueryUrl();
  var crs = layer.getProjection().getCode();
  var infoFormat = layer.getInfoFormat();

  var params = {
    SERVICE: 'WFS',
    VERSION: '1.3.0',
    REQUEST: 'GetFeature',
    TYPENAME: layer.getQueryLayerName().replace(/ /g,'_'),
    OUTPUTFORMAT: infoFormat,
    SRSNAME:  crs
  };
  var filterType = filter.getType();
  var filter = filter.get();
  if (filter) {
    var f = ol.format.filter;
    switch (filterType) {
      case 'bbox':
        var featureRequest = new ol.format.WFS().writeGetFeature({
          featureTypes: [layer],
          filter: f.bbox('the_geom', filter)
        });
        break;
      case 'geometry':
        var featureRequest = new ol.format.WFS().writeGetFeature({
          featureTypes: [layer],
          filter: f.intersects('the_geom', filter)
        });
        break;
      case 'expression':
        var featureRequest = new ol.format.WFS().writeGetFeature({
          featureTypes: [layer],
          filter: null
        });
      default:
        break;
    }
    params.FILTER = featureRequest.children[0].innerHTML;
    request = this._post(url, params);
    return request
  }
};


module.exports = WFSDataProvider;
},{"core/layers/filter/filter":38,"core/layers/providers/provider":47,"core/utils/utils":80}],51:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var utils = require('core/utils/utils');
var geoutils = require('g3w-ol3/src/utils/utils');
var DataProvider = require('core/layers/providers/provider');
//vado a sovrascrivere il metodo per leggere le feature
// da un geojson
var PIXEL_TOLERANCE = 10;
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];

function WMSDataProvider(options) {
  options = options || {};
  base(this, options);
  this._name = 'wms';
  this._url = this._layer.getQueryUrl();
  this._layerName = this._layer.getName() || null; // prendo sempre il name del layer di QGIS, perché le query sono proxate e gestite da g3w-server
  this._infoFormat = this._layer.getInfoFormat() || 'application/vnd.ogc.gml';
}

inherit(WMSDataProvider, DataProvider);

var proto = WMSDataProvider.prototype;


proto._getRequestUrl = function(url, extent, size, pixelRatio, projection, params) {

  params['CRS'] = projection.getCode();

  if (!('STYLES' in params)) {
    params['STYLES'] = '';
  }

  params['DPI'] = 90 * pixelRatio;
  params['WIDTH'] = size[0];
  params['HEIGHT'] = size[1];

  var axisOrientation = projection.getAxisOrientation();

  var bbox;
  if (axisOrientation.substr(0, 2) == 'ne') {
    bbox = [extent[1], extent[0], extent[3], extent[2]];
  } else {
    bbox = extent;
  }
  params['BBOX'] = bbox.join(',');

  return utils.appendParams(url, params);
};

// funzione che deve esserere "estratta dal mapservice"
proto._getGetFeatureInfoUrlForLayer = function(url, coordinates,resolution, params) {
  var extent = geoutils.getExtentForViewAndSize(coordinates, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);

  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': '1.3.0',
    'REQUEST': 'GetFeatureInfo',
    'FORMAT': 'image/png',
    'TRANSPARENT': true,
    'QUERY_LAYERS': this._layer.getName()
  };

  _.merge(baseParams, params);

  var x = Math.floor((coordinates[0] - extent[0]) / resolution);
  var y = Math.floor((extent[3] - coordinates[1]) / resolution);
  baseParams[ 'I' ] = x;
  baseParams['J'] = y;

  return this._getRequestUrl(
    url, extent, GETFEATUREINFO_IMAGE_SIZE,
    1, this._layer.getProjection(), baseParams);
};

proto.query = function(options) {
  var d = $.Deferred();
  var coordinates = options.coordinates || [];
  var resolution = options.resolution || null;
  var url = this._url;
  var sourceParam = url.split('SOURCE');
  if (sourceParam.length) {
    url = sourceParam[0];
    
    if (sourceParam.length > 1) {
      sourceParam = '&SOURCE' + sourceParam[1];
    } else {
      sourceParam = '';
    }
  }
  var params = {
    LAYERS: this._layerName,
    QUERY_LAYERS: this._layerName,
    INFO_FORMAT: this._infoFormat,
    FEATURE_COUNT: 10,
    // PARAMETRI DI TOLLERANZA PER QGIS SERVER
    FI_POINT_TOLERANCE: PIXEL_TOLERANCE,
    FI_LINE_TOLERANCE: PIXEL_TOLERANCE,
    FI_POLYGON_TOLERANCE: PIXEL_TOLERANCE,
    G3W_TOLERANCE: PIXEL_TOLERANCE * resolution
  };
  var getFeatureInfoUrl = this._getGetFeatureInfoUrlForLayer(url, coordinates, resolution, params);
  var queryString = getFeatureInfoUrl.split('?')[1];
  url += '?'+queryString + sourceParam;

  this.makeQueryForLayer(url, coordinates, resolution)
    .then(function(response) {
      d.resolve(response)
    })
    .fail(function(e){
      d.reject(e);
    });
  return d.promise();
};

proto.makeQueryForLayer = function(url, coordinates, resolution) {
  var d = $.Deferred();
  var queryInfo = {
    coordinates: coordinates,
    resolution: resolution
  };
  this.doRequestAndParse(url)
    .then(function(response){
      d.resolve({
        data: response,
        query: queryInfo
      });
    })
    .fail(function(e){
      d.reject(e);
    });
  return d.promise()
};

proto.doRequestAndParse = function(url) {
  var self = this;
  var d = $.Deferred();
  $.get(url)
    .done(function(response) {
      var featuresForLayers = self.handleQueryResponseFromServer(response, self._infoFormat, self._layerName);
      d.resolve(featuresForLayers);
    })
    .fail(function(){
      d.reject();
    });
  return d;
};



module.exports = WMSDataProvider;

},{"core/layers/providers/provider":47,"core/utils/utils":80,"g3w-ol3/src/utils/utils":114}],52:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function XMLDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'xml';
}

inherit(XMLDataProvider, DataProvider);

var proto = XMLDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};

module.exports = XMLDataProvider;
},{"core/layers/providers/provider":47,"core/utils/utils":80}],53:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var Layer = require('./layer');
var Editor = require('core/editing/editor');
var FeaturesStore = require('./features/featuresstore');
var Feature = require('./features/feature');
var Relations = require('core/relations/relations');


// Layer di base su cui si possono fare operazioni di editing
function TableLayer(config, options) {
  options = options || {}; // queste mi servono per aggiungere altre infoemazioni oltra alla configurazione del layer setsso
  var ProjectsRegistry = require('core/project/projectsregistry');
  var self = this;
  // setters
  this.setters = {
    // cancellazione di tutte le features del layer
    clearFeatures: function () {
      this._clearFeatures();
    },
    addFeature: function (feature) {
      this._addFeature(feature);
    },
    deleteFeature: function (feature) {
      this._deleteFeature(feature);
    },
    updateFeature: function (feature) {
      this._updateFeature(feature);
    },
    setFeatures: function (features) {
      this._setFeatures(features);
    },
    // funzione che recupera i dati da qualsisasi fonte (server, wms, etc..)
    // mediante il provider legato al fetauresstore
    getFeatures: function (options) {
      var self = this;
      var d = $.Deferred();
      // qui mi ritorna la promessa del setter (G3WOBJECT)
      this._featuresStore.getFeatures(options)
        .then(function (promise) {
          promise.then(function (features) {
            self.emit('getFeatures', features);
            return d.resolve(features);
          }).fail(function (err) {
            return d.reject(err);
          })
        })
        .fail(function (err) {
          d.reject(err);
        });
      return d.promise();
    },
    commit: function(commitItems, featurestore) {
      var d = $.Deferred();
      this._featuresStore.commit(commitItems, featurestore)
        .then(function (promise) {
          promise
            .then(function (response) {
              // se tutto andato a buon fine il commit
              if (featurestore)
                var features = _.clone(featurestore.readFeatures());
                _.forEach(features, function(feature) {
                  feature.clearState();
                });
                self._featuresStore.setFeatures(features);
              self._applyCommitResponse(response);
              return d.resolve(response);
            })
            .fail(function (err) {
              return d.reject(err);
          })
        })
        .fail(function (err) {
          d.reject(err);
        });
      return d.promise();
    }
  };
  /*
   * composizione url editing api
   * la chimata /api/vector/<tipo di richiesta: data/editing/config>/<project_type>/<project_id>/<layer_id>
   * esempio /api/vector/config/qdjango/10/punti273849503023
   *
  */
  this.type = Layer.LayerTypes.TABLE;
  // istanzia un editor alla sua creazione
  this._editor = new Editor({
    layer: this
  });
  // colore
  this._color = null;
  var currentProject = options.project || ProjectsRegistry.getCurrentProject();
  // vado a settare urls che mi servono
  var projectType = currentProject.getType();
  var projectId = currentProject.getId();
  var vectorUrl = initConfig.vectorurl;
  var suffixUrl = projectType + '/' + projectId + '/' + config.id + '/';
  // vado ad aggiungere gli url che mi servono
  config.urls = {
    editing: vectorUrl + 'editing/' + suffixUrl ,
    commit:vectorUrl + 'commit/' + suffixUrl ,
    data: vectorUrl + 'data/' + suffixUrl ,
    config: vectorUrl + 'config/' + suffixUrl,
    unlock: vectorUrl + 'unlock/' + suffixUrl
  };

  // aggiungo alla configurazione la parte di editing
  config.editing = {
    pk: null, // campo primary kaey
    fields: [] // campi utili all'editing,
  };
  // vado a chiamare il Layer di base
  base(this, config);
  var projectRelations = currentProject.getRelations();
  // vado a creare le relazioni
  this._relations = null;
  this._createRelations(projectRelations);
  // aggiungo nformazioni allo state che sono solo necessarie a layer
  // di possibile editing
  this.state = _.merge({
    editing: {
      started: false,
      modified: false,
      ready: false,
      ispkeditable: false
    }
  }, this.state);
  // vado a recuperare la configurazione dal server

  this.getEditingConfig()
  .then(function(config) {
    self.config.editing.pk = config.vector.pk;
    self.config.editing.fields = config.vector.fields;
    self.config.editing.format = config.vector.format;
    self._setOtherConfigParameters(config);
    self._setPkEditable(self.config.editing.fields);
    self.setReady(true);
  })
  .fail(function(err) {
    self.setReady(false);
  });
  // viene istanziato un featuresstore e gli viene associato
  // il data provider
  this._featuresStore = new FeaturesStore({
    provider: this.providers.data
  });
}

inherit(TableLayer, Layer);

var proto = TableLayer.prototype;

proto.setColor = function(color) {
  this._color = color;
};

proto.getColor = function() {
  return this._color;
};

// funzione che restituisce il layer per l'editing
proto.getLayerForEditing = function() {
  // nel caso fosse già un vector layer ritorna se stesso
  var editingLayer = _.cloneDeep(this);
  //editingLayer.config.capabilities = null;
  return editingLayer;
};

proto.isFieldRequired = function(fieldName) {
  var required = false;
  _.forEach(this.getFields(), function(field) {
    if (fieldName == field.name) {
      required = !!field.validate.required;
      return false;
    }
  });
  return required;
};

// funzione che permette di applicare l'eventuale risposta dal server
// nel caso di inserimento di una nuova feature
// nel caso di inserimento di una nuova feature
proto._applyCommitResponse = function(response) {
  var self = this;
  var data = response.vector ? response.vector.data : null;
  if (data) {
    var feature;
    var ids = data.response.new;
    var lockids = data.response.new_lockids;
    _.forEach(ids, function(idobj) {
      feature = self._featuresStore.getFeatureById(idobj.clientid);
      feature.setId(idobj.id);
    });
    this._featuresStore.addLockIds(lockids);
  }
};

// unlock editng features
proto.unlock = function() {
  var d = $.Deferred();
  this._featuresStore.unlock()
    .then(function() {
      d.resolve()
    })
    .fail(function(err) {
      d.reject(err);
    });
  return d.promise();
};

proto._setOtherConfigParameters = function(config) {
  // questa funzione verrà sovrascritta ad esempio dal vector layer
};

// funzione che restituisce i campi del layer
proto.getFields = function() {
  return this.config.editing.fields;
};

proto.getDataFormat = function() {
  return this.config.editing.format;
};

proto.getPk = function() {
  return this.config.editing.pk;
};

proto._setPkEditable = function(fields) {
  var self = this;
  _.forEach(fields, function(field) {
    if (field.name == self.getPk()) {
      self.state.editing.ispkeditable = field.editable;
      return false;
    }
  })
};

// funzione che restituisce l'array (configurazione) dei campi utlizzati per l'editing
proto.getEditingFields = function() {
  return this.config.editing.fields;
};

// funzione che restituisce il formato dei dati grezzi
proto.getEditingFormat = function() {
  return this.config.editing.format;
};

proto.isReady = function() {
  return this.state.editing.ready;
};

proto.setReady = function(bool) {
  this.state.editing.ready = _.isBoolean(bool) ? bool : false;
};

proto.isPkEditable = function() {
  return this.state.editing.ispkeditable;
};

// funzione che recuprera la configurazione di editing del layer
proto.getEditingConfig = function(options) {
  var d = $.Deferred();
  options = options || {};
  var provider = this.getProvider('data');
  // ritorno la promise del provider
  provider.getConfig(options)
    .then(function(config) {
      d.resolve(config);
    })
    .fail(function(err) {
      d.reject()
    });
  return d.promise()
};

proto.getCommitUrl = function() {
  return this.config.urls.commit;
};

proto.setCommitUrl = function(url) {
  this.config.urls.commit = url;
};

proto.getEditingUrl = function() {
  return this.config.urls.editing;
};

proto.setEditingUrl = function(url) {
  this.config.urls.editing = url;
};

proto.getUnlockUrl = function() {
  this.config.url.unlock;
};

proto.setUnlockUrl = function(url) {
  this.config.urls.unlock = url;
};

// funzione che server per settare il data url
proto.setDataUrl = function(url) {
  this.config.urls.data = url;
};

proto.getDataUrl = function() {
  return this.config.urls.data;
};

// url dedicato a ricevere la struttura del layer
proto.getConfigUrl = function() {
  return this.config.urls.config;
};

proto.setConfigUrl = function(url) {
  this.config.urls.config = url;
};

proto.getEditor = function() {
  return this._editor;
};

proto.setEditor = function(editor) {
  this._editor = editor;
};

proto.getFeaturesStore = function() {
  return this._featuresStore;
};

proto.setFeaturesStore = function(featuresstore) {
  this._featuresStore = featuresstore;
};

// la funzione che permette di settare il source delle features
// di default è il featuresstore che istanzia al momento in cui
// viene creato il layer
proto.setSource = function(source) {
  this.setFeaturesStore(source);
};

//funzione che va a sostiuire le features al featuresstore del layer
proto._setFeatures = function(features) {
  this._featuresStore.setFeatures(features);
};

proto.addFeatures = function(features) {
  var self = this;
  _.forEach(features, function(feature) {
    self.addFeature(feature);
  });
};

//metodo che ha lo scopo di aggiungere la feature all featuresstore del layer
proto._addFeature = function(feature) {
  this._featuresStore.addFeature(feature);
};

proto._deleteFeature = function(feature) {
  var featureId = feature.getId();
};

proto._updateFeature = function(feature) {
  //
};

proto._clearFeatures = function() {
  this._featuresStore.clearFeatures();
};

proto.addLockIds = function(lockIds) {
  this._featuresStore.addLockIds(lockIds);
};

// viene chamato quando si preme ad esempio Salva sul Form degli
// attributi di una feature
proto.setFieldsWithValues = function(feature, fields) {
  var attributes = {};
  var pkValue;
  _.forEach(fields, function(field) {
    // vado a verificares se il campo è primary key e se è editable
    if (feature.getPk() == field.name && field.editable) {
      pkValue = field.type == "integer" ? 1* field.value : field.value;
      feature.setId(pkValue);
    } else {
      // mi serve nel caso delle select ch devo forzare il valore a 'null'
      if (field.value == 'null') {
        field.value = null;
      }
      attributes[field.name] = field.value;
    }
  });
  // setto i campi della feature con i valori editati nel form
  feature.setProperties(attributes);

};

// funzione che server per associare campi a valori
proto.getFieldsWithValues = function(obj, options) {
  var self = this;
  options = options || {};
  var exclude = options.exclude || [];
  // clono i fields in quanto non voglio modificare i valori originali
  var fields = _.cloneDeep(this.getFields());
  var feature, attributes;
  // il metodo accetta sia feature che fid
  if (obj instanceof Feature){
    feature = obj;
  }
  else if (obj){
    feature = this.getFeatureById(obj);
  }
  // se c'è una feature ne prendo le proprietà
  if (feature) {
    attributes = feature.getProperties();
  }
  fields = _.filter(fields, function(field) {
    return exclude.indexOf(field.name) == -1;
  });
  // scorro sui campi della feature
  _.forEach(fields, function(field) {
    if (feature) {
      // verifico se è campo pk
      if (field.name == self.config.editing.pk) {
        // verifico che
        if (feature.getId() && self.isPkEditable()) {
          field.value = feature.getId();
        } else {
          field.value = null;
        }
      } else {
        field.value = attributes[field.name];
      }
    }
    else{
      field.value = null;
    }
  });
  return fields;
};

//Metodi legati alle relazioni
proto._createRelations = function(projectRelations) {
  var relations = [];
  var layerId = this.getId();
  _.forEach(projectRelations, function(relation) {
    if ([relation.referencedLayer, relation.referencingLayer].indexOf(layerId) != -1)
      relations.push(relation);
  });
  if (!!relations.length) {
    this._relations = new Relations({
      relations: relations
    });
  }
};

proto.createNewFeature = function() {
  var feature = new ol.Feature();
  var properties = {};
  _.forEach(this.getFields(), function(field) {
    properties[field.name] = null;
  });
  feature.setProperties(properties);
  feature = new Feature({
    feature : feature,
    pk: this.getPk()
  });
  feature.setNew();
  return feature;
};

// restituisce tutte le relazioni legati a quel layer
proto.getRelations = function() {
  return this._relations
};


//restituisce gli attributi fields di una deterninata relazione
proto.getRelationAttributes = function(relationName) {
  var fields = [];
  _.forEach(this._relations, function(relation) {
    if (relation.name == relationName) {
      fields = relation.fields;
      return false
    }
  });
  return fields;
};

// retituisce un oggetto contenente nome relazione e fileds(attributi) associati
proto.getRelationsAttributes = function() {
  var fields = {};
  _.forEach(this.state.relations, function(relation) {
    fields[relation.name] = relation.fields;
  });
  return fields;
};

// metodo che restituisce true o false se il layer è figlio
proto.isChild = function() {
  if (!this.getRelations())
    return false;
  return this._relations.isChild(this.getId());
};

// metodo che restituisce true o false se il layer è padre
proto.isFather = function() {
  if (!this.getRelations())
    return false;
  return this._relations.isFather(this.getId());
};

// ritorna i figli sono dopo che è stato verificato che è un padre
proto.getChildren = function() {
  if (!this.isFather())
    return [];
  return this._relations.getChildren(this.getId());
};

// ritorna i padri dopo aver verificato che è un figlio
proto.getFathers = function() {
  if (!this.isChild())
    return [];
  return this._relations.getFathers(this.getId());
};

proto.hasChildren = function() {
  if (!this.hasRelations())
    return false;
  return this._relations.hasChildren(this.getId());
};

proto.hasFathers = function() {
  if (!this.hasRelations())
    return false;
  return this._relations.hasFathers(this.getId());
};

proto.hasRelations = function() {
  return !!this._relations;
};


module.exports = TableLayer;
},{"./features/feature":34,"./features/featuresstore":35,"./layer":41,"core/editing/editor":26,"core/project/projectsregistry":74,"core/relations/relations":77,"core/utils//utils":80,"core/utils/utils":80}],54:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var mixin = require('core/utils/utils').mixin;
var Layer = require('./layer');
var TableLayer = require('./tablelayer');
var GeoLayerMixin = require('./geolayermixin');

function VectorLayer(config) {
  base(this, config);
  this.type = Layer.LayerTypes.VECTOR;
  // mi server un layer ol per la visualizzazionei
  // vado a modificare lo state aggiungendo il bbox e l'informazione geolayer
  this.setup(config);
}

inherit(VectorLayer, TableLayer);

mixin(VectorLayer, GeoLayerMixin);

var proto = VectorLayer.prototype;

proto._setOtherConfigParameters = function(config) {
  this.config.editing.geometrytype = config.vector.geometrytype;
};

proto.getEditingGeometryType = function() {
  return this.config.editing.geometrytype;
};


module.exports = VectorLayer;
},{"./geolayermixin":39,"./layer":41,"./tablelayer":53,"core/utils//utils":80,"core/utils/utils":80}],55:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function BingLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(BingLayer,MapLayer);

var proto = BingLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;

  var olLayer;
  var subtype = this.layer.state.source ? this.layer.state.source.subtype : null
  switch(subtype) {
    case 'streets':
      olLayer = BaseLayers.BING.Road;
      break;
    case 'aerial':
      olLayer = BaseLayers.BING.Aerial;
      break;
    case 'aerialwithlabels':
      olLayer = BaseLayers.BING.AerialWithLabels;
      break;
    default:
      olLayer = BaseLayers.BING.Aerial;
      break;
  }
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto._updateLayer = function(mapState,extraParams){
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = BingLayer;

},{"core/map/layer/maplayer":58,"core/utils/geo":79,"core/utils/utils":80,"g3w-ol3/src/layers/bases":108}],56:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function LoaderLayerService() {
  this._layers = {};
  this._type = 'tipo di layers';
  this._isReady = false;
  base(this);
}
inherit(LoaderLayerService, G3WObject);

var proto = LoaderLayerService.prototype;

proto.getLoaderType = function() {
    return this._type;
};

proto.getLayers = function() {
  return this._layers;
};

proto.getLayer = function(layerName) {
  return this._layers[layerName];
};

proto.loadLayer = function(url, options) {
  //TODO
};
proto.loadLayers = function() {
  //TODO
};

proto.cleanUpLayers = function() {
  //TODO
};

proto.setReady = function(bool) {
  this._isReady = bool;
};

proto.isReady = function() {
  return this._isReady;
};

// setto il modo di caricare il layer
proto.setMode = function(mode) {
  switch(mode){
    case 'w':
      this._editingMode = true;
      break;
    case 'r':
      this._editingMode = false;
      break;
    default:
      mode = 'w';
      this._editingMode = true;
  }
  this._mode = mode;
  this.emit('setmode', mode);
};

proto.getMode = function() {
  return this._mode;
};



module.exports = LoaderLayerService;
},{"core/g3wobject":30,"core/utils/utils":80}],57:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var resolvedValue = require('core/utils/utils').resolve;
var VectorLayer = require('core/map/layer/vectorlayer');
var LoaderLayer = require('./loaderlayer');

function VectorLoaderLayer() {
  this._layer = {};
  this._type = 'vector';
  this._layerCodes = [];
  this._baseUrl = '';
  this._mapService = null;
  this._loadedExtent = null;
  this._editingMode = false;
  this._customUrlParameters = '';
  //mi tengo i vectorLayersCodes dei layer caricati
  this._vectorLayersCodes = [];
  this._vectorLayersData = {};
  base(this);
  //setto le proprià che mi interessano
  this.init = function(options) {
    //i layers provenienti dal plugin
    this._layers = options.layers || {};
    // il base url per poter fare richieste al server
    this._baseUrl = options.baseurl || '';
    // il map service per ineragire con la mappa
    // recuperando il bbox del layer vettoriale
    this._mapService = options.mapService || null;
    // i codice dei layers per poter recuperare le informazioni
    // dei layers passati dal plugin
    this._layerCodes = _.keys(this._layers);
    // questo mi permette di gestire e generalizzare il valore del campo del layer
    // a cui passare all'apiEditing
    this._editingApiField = options.editingApiField || 'name';
  };
}

inherit(VectorLoaderLayer, LoaderLayer);

var proto = VectorLoaderLayer.prototype;
// funzione principale, starting point, chiamata dal plugin per
// il recupero dei vettoriali (chiamata verso il server)
proto.loadLayers = function(mode, customUrlParameters) {
    // il parametro mode mi di è in scrittura, lettura etc ..
  var self = this;
  var deferred = $.Deferred();
  // tiene conto dei codici dei layer che non sono stati
  // i dati vettoriali
  var noVectorlayerCodes = [];
  // setto il mode (r/w)
  this.setMode(mode);
  //verifico che ci siano parametri custom (caso di alcuni plugin) da aggiungere alla base url
  // per fare le chiamate al server
  if (customUrlParameters) {
    this._setCustomUrlParameters(customUrlParameters)
  }
  //verifica se sono stati caricati i vettoriali dei layer
  // attraverso la proprietà vector del layer passato dal plugin
  _.forEach(this._layers, function(layer, layerCode) {
    // verifico se l'attributo vector è nullo
    if (_.isNull(layer.vector)) {
      noVectorlayerCodes.push(layerCode);
    }
  });
  // eseguo le richieste delle configurazioni e mi tengo le promesse
  var vectorLayersSetup = _.map(noVectorlayerCodes, function(layerCode) {
    return self._setupVectorLayer(layerCode);
  });
    // emetto l'evento loadingvectorlayersstart (il pluginservice è in ascolto)
  self.emit('loadingvectorlayersstart');
  // aspetto tutte le promesse del setup vector
  $.when.apply(this, vectorLayersSetup)
    // una volta che tutte le configurazioni dei layer vecor
    // sono state prese dal server e dopo aver assegnato all'attributo vector
    // del layer plugin il layer vettoriale costruito con le configurazioni
    // di sopra
    .then(function() {
      // le promesse ritornano il layerCode del layer vettoriale appena costuito
      var vectorLayersCodes = Array.prototype.slice.call(arguments);
      // emtto evento che inzia il recupero dei dati dei layer vettoriali (geojson)
      self.emit('loadingvectolayersdatastart');
      // inizio a caricare tutti i vettoriali dopo aver caricato le configurazioni
      self.loadAllVectorsData(vectorLayersCodes)
      .then(function() {
        self._vectorLayersCodes = vectorLayersCodes;
        deferred.resolve(vectorLayersCodes);
        // emtto evento che ho ricevuto i layers
        self.emit('loadingvectorlayersend');
        // ora il loader è pronto
        self.setReady(true);

      })
      .fail(function() {
        // risetto tutti i layer veetotiali a null
        _.forEach(self._layers, function(layer) {
          layer.vector = null;
        });
        deferred.reject();
        // emttto che c'è stato un errore nel loading dei dati che vengono dal server
        self.emit('errorloadingvectorlayersend');
        self.setReady(false);
      })
  })
  .fail(function() {
    self.setReady(false);
    self.emit('errorloadingvectorlayersend');
    deferred.reject();
  });
  return deferred.promise();
};

proto.setVectorLayersCodes = function(vectorLayersCodes) {
  this._vectorLayersCodes = vectorLayersCodes;
};

proto.getVectorLayersCodes = function() {
  return this._vectorLayersCodes;
};

proto.getLayers = function() {
  return this._layers;
};

// funzione che fa il reload che rihiede di nuovo il dati del vetor layer
// caso in cui si lavora con un layer vettoriale e non si usa un wms per fare la query
proto.reloadVectorData = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  var bbox = this._mapService.state.bbox;
  self._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
          self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
          vectorLayer.setData(vectorDataResponse.vector.data);
          deferred.resolve(vectorLayer);
        });
    });
  return deferred.promise();
};

//funzione che permette di ottenere tutti i dati relativi ai layer vettoriali caricati
//prima si è ottenuta la coinfigurazione, ora si ottengono i dati veri e propri
proto.loadAllVectorsData = function(layerCodes) {
    var self = this;
    var deferred = $.Deferred();
    var layers = this._layers;
    // verifico che il BBOX attuale non sia stato già  caricato
  // prondo il bbox
    var bbox = this._mapService.state.bbox;
    var loadedExtent = this._loadedExtent;
    if (loadedExtent && ol.extent.containsExtent(loadedExtent, bbox)) {
      return resolvedValue();
    }
    if (!loadedExtent) {
      this._loadedExtent = bbox;
    } else {
      this._loadedExtent = ol.extent.extend(loadedExtent, bbox);
    }
    if (layerCodes) {
      layers = [];
      _.forEach(layerCodes, function(layerCode) {
        layers.push(self._layers[layerCode]);
      });
    }
    //per ogni layer del plugin che non ha il layer vado a caricare i dati del layer vettoriale
    var vectorDataRequests = _.map(layers, function(Layer) {
        return self._loadVectorData(Layer.vector, bbox);
    });

    $.when.apply(this, vectorDataRequests)
        .then(function() {
            deferred.resolve(layerCodes);
        })
        .fail(function(){
            deferred.reject();
        });

    return deferred.promise();
};

proto._setCustomUrlParameters = function(customUrlParameters) {
  this._customUrlParameters = customUrlParameters;
};

proto._checkVectorGeometryTypeFromConfig = function(vectorConfig) {
  switch (vectorConfig.geometrytype) {
    case 'Line':
      vectorConfig.geometrytype = 'LineString';
      break;
    case 'MultiLine':
      vectorConfig.geometrytype = 'MultiLineString';
      break;
  }
  return vectorConfig;
};


proto._createVectorLayerFromConfig = function(layerCode) {
  var self = this;
  // recupero la configurazione del layer settata da plugin service
  var layerConfig = this._layers[layerCode];
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._getVectorLayerConfig(layerConfig[this._editingApiField])
    .then(function(vectorConfigResponse) {
      var vectorConfig = vectorConfigResponse.vector;
      // vado a verificare la correttezza del geometryType (caso di editing generico)
      vectorConfig = self._checkVectorGeometryTypeFromConfig(vectorConfig);
      // una volta ottenuta dal server la configurazione vettoriale,
      // provvedo alla creazione del layer vettoriale
      var crsLayer = layerConfig.crs || self._mapService.getProjection().getCode();
      var vectorLayer = self._createVectorLayer({
        geometrytype: vectorConfig.geometrytype,
        format: vectorConfig.format,
        crs: self._mapService.getProjection().getCode(),
        crsLayer : crsLayer,
        id: layerConfig.id,
        name: layerConfig.name,
        pk: vectorConfig.pk,
        editing: self._editingMode
      });
      // setto i campi del layer
      vectorLayer.setFields(vectorConfig.fields);
      vectorLayer.setCrs(crsLayer);
      // questo è la proprietà della configurazione del config layer
      // che specifica se esistono relazioni con altri layer
      // sono array di oggetti che specificano una serie di
      // informazioni su come i layer sono relazionati (nome della relazione == nome layer)
      // foreign key etc ..
      var relations = vectorConfig.relations;
      // nel caso il layer abbia relazioni (array non vuoto)
      if (relations) {
        // per dire a vectorLayer che i dati
        // delle relazioni verranno caricati solo quando
        // richiesti (es. aperture form di editing)
        vectorLayer.lazyRelations = true;
        //vado a settare le relazioni del vector layer
        vectorLayer.setRelations(relations);
      }
      // setto lo stile del layer OL
      if (layerConfig.style) {
        vectorLayer.setStyle(layerConfig.style);
      }
      // risolve con il nome del vectorLayer
      deferred.resolve(vectorLayer);
    })
    .fail(function(){
      deferred.reject();
    });
  return deferred.promise();
};

// funzione che dato la configurazione del layer fornito dal plugin (style, editor, vctor etc..)
// esegue richieste al server al fine di ottenere configurazione vettoriale del layer
proto._setupVectorLayer = function(layerCode) {
    var self = this;
    var deferred = $.Deferred();
    // eseguo le richieste delle configurazioni
    this._createVectorLayerFromConfig(layerCode)
        .then(function(vectorLayer) {
            var layerConfig = self._layers[layerCode];
            // assegno il vetorLayer appena creato all'attributo vector del layer
            layerConfig.vector = vectorLayer;
            // risolve con il nome del layerCode
            deferred.resolve(layerCode);
        })
        .fail(function() {
            deferred.reject();
        });
    return deferred.promise();
};

//in base all bbox e la layer chiedo al server di restituirmi il vettoriale (geojson) del layer
proto._loadVectorData = function(vectorLayer, bbox) {
    var self = this;
    // eseguo le richieste dei dati al server al fine di ottenere il geojson,
    // vettoriale, del layer richiesto
    return self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
            self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
            // setto i dati vettoriali del layer vettoriale
            // e verifico se siamo in editingMode write e se ci sono featurelocks
            if (self._editingMode && vectorDataResponse.featurelocks) {
              // nel cso in cui sia in editing (mode w) e che si siano featureLocks
              // setto tale features al layervettoriale
              self.setVectorFeaturesLock(vectorLayer, vectorDataResponse.featurelocks);
            }
            //setto i dati del layer vettoriale (geojson)
            vectorLayer.setData(vectorDataResponse.vector.data);
          if (self._)
            return vectorDataResponse;
        })
      .fail(function() {
        return false;
      })
};

proto.getVectorLayerData = function(layerCode) {
  return this._vectorLayersData[layerCode];
};

proto.getVectorLayersData = function() {
  return this._vectorLayersData;
};

proto.setVectorLayerData = function(layerCode, vectorLayerData) {
  this._vectorLayersData[layerCode] = vectorLayerData;
};

//funzione che setta le features lock del layer vettoriale
proto.setVectorFeaturesLock = function(vectorLayer, featureslock) {
  //vado a pescare le fifferenze tra le featureidlock già caricati id
  var newFeaturesLockIds = _.differenceBy(featureslock, vectorLayer.getFeatureLocks(), 'featureid');
  _.forEach(newFeaturesLockIds, function(newLockId) {
    vectorLayer.addLockId(newLockId)
  });
};

proto.cleanVectorFeaturesLock = function(vectorLayer) {
  vectorLayer.cleanFeatureLocks();
};

proto.lockFeatures = function(layerName) {
  var self = this;
  var d = $.Deferred();
  var bbox = this._mapService.state.bbox;
  var vectorLayer = this._layers[layerName].vector;
  $.get(this._baseUrl+layerName+"/?lock" + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      self.setVectorFeaturesLock(vectorLayer, data.featurelocks);
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
    var d = $.Deferred();
    // attravercso il layer name e il base url
    // chiedo la server di inviarmi la configurazione editing del laye
    $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
        .done(function(data) {
            d.resolve(data);
        })
        .fail(function(){
            d.reject();
        });
    return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
    var d = $.Deferred();
    var lock = this.getMode() == 'w' ? true : false;
    var apiUrl;
    if (lock) {
      apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
    } else {
      apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
    }
    $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
        .done(function(data) {
            d.resolve(data);
        })
        .fail(function(){
            d.reject();
        });
    return d.promise();
};
// funzione per creare il layer vettoriale
proto._createVectorLayer = function(options) {
  var vector = new VectorLayer(options);
  return vector;
};
//funzione chiamata dal plugin quando si vuole fare un cleanUp dei layers
// !!! -- DA RIVEDERE -- !!!
proto.cleanUpLayers = function() {
    this._loadedExtent = null;
};

module.exports = VectorLoaderLayer;
},{"./loaderlayer":56,"core/map/layer/vectorlayer":60,"core/utils/utils":80}],58:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function MapLayer(config){
  this.config = config || {};
  this.id = config.id;
  this.projection = config.projection;
  this._olLayer = null;
  base(this);
}

inherit(MapLayer, G3WObject);

var proto = MapLayer.prototype;

proto.getId = function(){
  return this.id;
};

module.exports = MapLayer;

},{"core/g3wobject":30,"core/utils/utils":80}],59:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function OSMLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(OSMLayer,MapLayer);

var proto = OSMLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;

  
  var olLayer = BasesLayers.OSM;
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto._updateLayer = function(mapState,extraParams){
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = OSMLayer;

},{"core/map/layer/maplayer":58,"core/utils/geo":79,"core/utils/utils":80,"g3w-ol3/src/layers/bases":108}],60:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var truefnc = require('core/utils/utils').truefnc;
var resolve = require('core/utils/utils').resolve;
var reject = require('core/utils/utils').reject;
var G3WObject = require('core/g3wobject');

function VectorLayer(config) {
  var config = config || {};
  this.geometrytype = config.geometrytype || null;
  this.format = config.format || null;
  this.crs = config.crs  || null;
  this.crsLayer = config.crsLayer || this.crs;
  this.id = config.id || null;
  this.name = config.name || "";
  this.pk = config.pk || "id";
  this._olSource = new ol.source.Vector({
    features: new ol.Collection()
  });
  this._olLayer = new ol.layer.Vector({
    name: this.name,
    source: this._olSource
  });
  this._isReady = false;
  /*
   * Array di oggetti:
   * {
   *  name: Nome dell'attributo,
   *  type: integer | float | string | boolean | date | time | datetime,
   *  input: {
   *    label: Nome del campo di input,
   *    type: select | check | radio | coordspicker | boxpicker | layerpicker | fielddepend,
   *    options: {
   *      Le opzioni per lo spcifico tipo di input (es. "values" per la lista di valori di select, check e radio)
   *    }
   *  }
   * }
  */
  this._PKinAttributes = false;
  this._featuresFilter = null;
  this._fields = null;
  this._relationsDataLoaded = {};
  this.lazyRelations = true;
  this._relations = null;
  this._editingMode = config.editing || false;
  this._loadedIds = [];
  this._featureLocks = [];
  this._crs = null;
}

inherit(VectorLayer,G3WObject);

module.exports = VectorLayer;

var proto = VectorLayer.prototype;

proto.getPk = function() {
  return this.pk;
};

proto.setData = function(featuresData) {
  var self = this;
  var Ids = [];
  var features;
  if (this.format) {
    switch (this.format){
      case "GeoJSON":
        var geojson = new ol.format.GeoJSON({
          geometryName: "geometry"
        });
        features = geojson.readFeatures(featuresData, {
          dataProjection: self.crsLayer,
          featureProjection: self.crs
        });
        break;
    }
    if (this._editingMode && this._featureLocks) {
      features = _.filter(features, function(feature) {
        var hasFeatureLock = false;
        _.forEach(self._featureLocks,function(featureLock){
          if (featureLock.featureid == feature.getId()) {
            hasFeatureLock = true;
            Ids.push(feature.getId());
          }
        });
        return hasFeatureLock;
      })
    }
    
    if (features && features.length) {
      if (!_.isNull(this._featuresFilter)){
        features = _.map(features,function(feature){
          return self._featuresFilter(feature);
        });
      }
      var featuresToLoad = _.filter(features,function(feature) {
        return !_.includes(self._loadedIds,feature.getId());
      });

      this._olSource.addFeatures(featuresToLoad);
      // verifico, prendendo la prima feature, se la PK è presente o meno tra gli attributi
      var attributes = this.getSource().getFeatures()[0].getProperties();
      this._PKinAttributes = _.get(attributes,this.pk) ? true : false;
      this._loadedIds = _.union(this._loadedIds, Ids);
    }
  }
  else {
    console.log("VectorLayer format not defined");
  }
};
proto.cleanFeatureLocks = function() {
  this._featureLocks = [];
};

proto.setFeatureLocks = function(featurelocks) {
  this._featureLocks = featurelocks;
};

proto.getFeatureLocks = function() {
  return this._featureLocks;
};

proto.addLockId = function(lockId) {
  this._featureLocks.push(lockId);
};

proto.addFeature = function(feature) {
  this.getSource().addFeature(feature);
};

proto.addFeatures = function(features) {
  this.getSource().addFeatures(features);
};

proto.modifyFeatureGeometry = function(featureId, geometry) {
  var features = this.getFeatures();
  var feature = null;
  _.forEach(features, function(feature, index) {
    if (feature.getId() == featureId) {
      features[index].setGeometry(geometry);
      feature = feature[index];
      return feature
    }
  });
  return feature;
};

proto.setFeaturesFilter = function(featuresFilter){
  this._featuresFilter = featuresFilter;
};

proto.setFields = function(fields) {
  this._fields = fields;
};

proto.setCrs = function(crs) {
  this._crs = crs;
};

proto.getCrs = function() {
  return this._crs;
};

proto.setPkField = function(){
  var self = this;
  var pkfieldSet = false;
  _.forEach(this._fields,function(field){
    if (field.name == self.pk ){
      pkfieldSet = true;
    }
  });
  
  if (!pkfieldSet) {
    this._fields;
  }
};

proto.getFeatures = function() {
  return this.getSource().getFeatures();
};

proto.getFeatureIds = function(){
  var featureIds = _.map(this.getSource().getFeatures(), function(feature){
    return feature.getId();
  });
  return featureIds
};

// funzione che recurepa le feature del vector layer in base alla geometria passata
proto.getIntersectedFeatures = function(geometry) {
  var features = [];
  _.forEach(this.getFeatures(), function(feature) {
    if (geometry.intersectsExtent(feature.getGeometry().getExtent())) {
      features.push(feature);
    }
  });
  return features
};


proto.getFields = function(){
  return _.cloneDeep(this._fields);
};

// funzione che mi server per la query result nel caso di vector layer
proto.getAttributes = function() {
  return this._fields;
};

proto.getFieldsNames = function(){
  return _.map(this._fields,function(field){
    return field.name;
  });
};
// funzione che serve ad esempio all'openEditorFor per popolare
// il form con i campi della feature e i relativi valori (nel caso di editing di una feature esistente)
proto.getFieldsWithValues = function(obj) {
  var self = this;
  // clono i fields in quanto non voglio modificare i valori originali
  var fields = _.cloneDeep(this._fields);
  var feature, attributes;
  // il metodo accetta sia feature che fid
  if (obj instanceof ol.Feature){
    feature = obj;
  }
  else if (obj){
    feature = this.getFeatureById(obj);
  }
  // se c'è una feature ne prendo le proprietà
  if (feature) {
    attributes = feature.getProperties();
  }
  _.forEach(fields, function(field){
    if (feature){
      if (!this._PKinAttributes && field.name == self.pk) {
        if (self.isNewFeature(feature.getId())) {
          field.value = null;
        } else {
          field.value = feature.getId();
        }
      } else {
        
        field.value = attributes[field.name];
      }
    }
    else{
      field.value = null;
    }
  });

  return fields;
};

// funzione che setta e relazione del layer vettoriale
proto.setRelations = function(relations) {
  // assegno al valore _relations l'array relazioni
  this._relations = relations;
  // è un array contenete le relazioni con altri layers
  _.forEach(relations, function(relation) {
    // per ogni relazione scorro sull'attributo fields (array) di oggetti
    // che descrivono  i campi del layer relazione
    _.forEach(relation.fields, function(field, idx) {
      if (field.name == relation.pk) {
        // aggiung ll'atributo pkFieldIndex
        // che mi servirà per recuperare il campo
        // primary del layer relazione
        // setto indice del campo chiave primaria
        relation.pkFieldIndex = idx
      }
    })
  })
};
// resituisce le relazioni
proto.getRelations = function() {
  return this._relations;
};

// retituisce un oggetto contenente nome relazione e fileds(attributi) associati
proto.getRelationsAttributes = function() {
  var fields = {};
  _.forEach(this._relations, function(relation) {
    fields[relation.name] = relation.fields;
  });
  return fields;
};
proto.getRelation = function(relationName) {
  var relation;
  _.forEach(this._relations,function(_relation){
    if (_relation.name == relationName) {
      relation = _relation;
    }
  });
  return relation;
};

proto.hasRelations = function() {
  return !_.isNull(this._relations);
};

proto.getRelationPkFieldIndex = function(relation) {
  var pkFieldIndex;
  _.forEach(relation.fields,function(field,idx){
    if (field.name == relation.pk) {
      pkFieldIndex = idx;
    }
  });
  return pkFieldIndex;
};

proto.getRelationElementPkValue = function(relation,element) {
  var pkFieldIndex = this.getRelationPkFieldIndex(relation);
  return element.fields[pkFieldIndex].value;
};

proto.getRelationsFksKeys = function(){
  var fks = [];
  _.forEach(this._relations,function(relation){
    fks.push(relation.fk);
  });
  return fks;
};

proto.getRelationFields = function(relation) {
  return relation.fields;
};

proto.getRelationFieldsNames = function(relation){
  return _.map(relationFields,function(field){
    return field.name;
  });
};

// ottengo le relazioni a partire dal fid di una feature esistente
proto.getRelationsWithValues = function(fid) {
  var self = this;
  if (!this._relations) {
    // se non ha nessuna relazione
    // rirotno array vuoto
    resolve([]);
  }
  // altrimenti creo un clone dell'attributo relations
  var relations = _.cloneDeep(this._relations);
  // se non è stato settao l'id della feature e quindi la feature non esiste
  // vado a creare la strutture lelations element (array)
  if (!fid && !this.getFeatureById(fid)) {
    _.forEach(relations, function(relation) {
      relation.elements = [];
    });
    return resolve(relations);
  }
  else {
    if (this.lazyRelations) {
      //verifico se sono già state caricate le relazioni di quella feature
      if (!self._relationsDataLoaded[fid]) {
        var deferred = $.Deferred();
        var attributes = this.getFeatureById(fid).getProperties();
        var fks = {};
        _.forEach(relations, function(relation) {
          var keyVals = [];
          _.forEach(relation.fk, function(fkKey) {
            // verifico che la foreingkey sia la primary key del layer e a questo punto
            // prendo il fid altrimenti prendo il valore dell'attributo della feature
            if (fkKey == self.pk)  {
              fks[fkKey] = fid;
            } else {
              fks[fkKey] = attributes[fkKey];
            }
          });
        });
        this.getRelationsWithValuesFromFks(fks)
          .then(function(relationsResponse){
            self._relationsDataLoaded[fid] = relationsResponse;
            deferred.resolve(relationsResponse);
          })
          .fail(function(){
            deferred.reject();
          });
        return deferred.promise();
      }
      else {
        return resolve(this._relationsDataLoaded[fid]);
      }
    }
    else {
      return resolve(this._relations); // vuol dire che gli elementi delle relazioni sono stati già inseriti in fase di creazione del vettoriale
    }
  }
};

// ottengo le relazioni valorizzate a partire da un oggetto con le chiavi FK come keys e i loro valori come values
proto.getRelationsWithValuesFromFks = function(fks, newRelation) {
  var self = this;
  var relations = _.cloneDeep(this._relations);
  var relationsRequests = [];

  _.forEach(relations,function(relation){
    relation.elements = []; // creo la proprietà che accoglierà gli elementi della relazione ( e che quindi li cacherà)
    var url = relation.url;
    var keyVals = [];
    _.forEach(relation.fk,function(fkKey){
      var fkValue = fks[fkKey];
      keyVals.push(fkKey+"="+fkValue);
    });
    var fkParams = _.join(keyVals,"&");
    url += "?"+fkParams;
    relationsRequests.push($.get(url)
      .then(function(relationsElements){
        if (relationsElements.length) {
          _.forEach(relationsElements,function(relationElement){
            var element = {};
            element.fields = _.cloneDeep(relation.fields); // i campi li metto anche in ogni elemento, in modo da poterne assegnarne i valori
            _.forEach(element.fields,function(field){ // assegno i valori ai campi
              field.value = relationElement[field.name];
              if (field.name == relation.pk) {
                element.id = field.value; // aggiungo element.id dandogli il valore della chiave primaria della relazione
                var state = newRelation ? 'NEW' : 'OLD';
                element.state = state; // flag usato per identificare elemento: 'NEW', 'OLD', 'DELETED'
              }
            });
            relation.elements.push(element);
          })
        }
      })
    )
  });
  
  return $.when.apply(this,relationsRequests)
  .then(function(){
    return relations; // le relazioni e i loro elementi sono immutabili; le modifiche vanno nei RelationEditBuffer
  });
};

proto.getNewRelationsWithValuesFromFks = function(fks){
  return this.getRelationsWithValuesFromFks(fks, true)
};

// data una feature verifico se ha tra gli attributi i valori delle FK delle (eventuali) relazioni
proto.featureHasRelationsFksWithValues = function(feature){
  var attributes = feature.getProperties();
  var fksKeys = this.getRelationsFksKeys();
  return _.every(fksKeys,function(fkKey){
    var value = attributes[fkKey];
    return (!_.isNil(value) && value != '');
  })
};

// data una feature popolo un oggetto con chiavi/valori delle FK delle (eventuali) relazione
proto.getRelationsFksWithValuesForFeature = function(feature){
  var attributes = feature.getProperties();
  var fks = {};
  var fksKeys = this.getRelationsFksKeys();
  _.forEach(fksKeys,function(fkKey){
    fks[fkKey] = attributes[fkKey];
  });
  return fks;
};

//vado a settare le nuove relaioni dopo che ho fatto save del form
proto.setRelationsData = function (fid, relationsData) {
  this._relationsDataLoaded[fid] = relationsData;
};

proto.setStyle = function(style){
  this._olLayer.setStyle(style);
};

proto.getMapLayer = function(){
  return this._olLayer;
};

proto.getSource = function(){
  return this._olLayer.getSource();
};

proto.getFeatureById = function(fid){
  if (fid) {
    return this._olLayer.getSource().getFeatureById(fid);
  }
};

proto.isVisible = function() {
  return this._olLayer.getVisible();
};

proto.setVisible = function(bool) {
  this._olLayer.setVisible(bool);
};

proto.clear = function(){
  this.getSource().clear();
};

proto.addToMap = function(map){
  map.addLayer(this._olLayer);
};

proto.isNewFeature = function(fid){
  if (fid) {
    return fid.toString().indexOf(this._newPrefix) == 0;
  }
  return true;
};


},{"core/g3wobject":30,"core/utils/utils":80}],61:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

function WMSLayer(options,extraParams){
  var self = this;
  this.LAYERTYPE = {
    LAYER: 'layer',
    MULTILAYER: 'multilayer'
  };

  this.extraParams = extraParams;
  this.layers = [];
  
  base(this,options);
}

inherit(WMSLayer, MapLayer);

var proto = WMSLayer.prototype;

proto.getOLLayer = function(withLayers){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer(withLayers);
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getInfoFormat = function() {
  return 'application/vnd.ogc.gml';
};

proto.getGetFeatureInfoUrl = function(coordinate,resolution,epsg,params){
  return this.getOLLayer().getSource().getGetFeatureInfoUrl(coordinate,resolution,epsg,params);
};

proto.getLayerConfigs = function(){
  return this.layers;
};

proto.addLayer = function(layer){
  this.layers.push(layer);
};

proto.toggleLayer = function(layer){
  _.forEach(this.layers,function(_layer){
    if (_layer.id == layer.id){
      _layer.visible = layer.visible;
    }
  });
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayers(mapState, extraParams);
};

proto.isVisible = function(){
  return this._getVisibleLayers().length > 0;
};

proto.getQueryUrl = function(){
  var layer = this.layers[0];
  if (layer.infourl && layer.infourl != '') {
    return layer.infourl;
  }
  return this.config.url;
};

proto.getQueryableLayers = function(){ 
  return _.filter(this.layers,function(layer){
    return layer.isQueryable();
  });
};

proto._getVisibleLayers = function(mapState){
  var self = this;
  var visibleLayers = [];
  _.forEach(this.layers,function(layer){
    var resolutionBasedVisibility = layer.state.maxresolution ? (layer.state.maxresolution && layer.state.maxresolution > mapState.resolution) : true;
    if (layer.state.visible && resolutionBasedVisibility) {
      visibleLayers.push(layer);
    }    
  });
  return visibleLayers;
};

proto._makeOlLayer = function(withLayers){
  var self = this;
  var wmsConfig = {
    url: this.config.url,
    id: this.config.id
  };
  
  if (withLayers) {
    wmsConfig.layers = _.map(this.layers,function(layer){
      return layer.getWMSLayerName();
    });
  }
  
  var representativeLayer = this.layers[0]; //BRUTTO, DEVO PRENDERE UN LAYER A CASO (IL PRIMO) PER VEDERE SE PUNTA AD UN SOURCE DIVERSO (dovrebbe accadere solo per i layer singoli, WMS esterni)
  
  if (representativeLayer.state.source && representativeLayer.state.source.type == 'wms' && representativeLayer.state.source.url){
    wmsConfig.url = representativeLayer.state.source.url;
  }
  
  var olLayer = new RasterLayers.WMSLayer(wmsConfig,this.extraParams);
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto.checkLayerDisabled = function(layer,resolution) {
  var enabled = true;
  if (layer.config.scalebasedvisibility) {
    var scale = geo.resToScale(resolution);
    if (layer.config.maxresolution){
      enabled = enabled && (layer.config.maxresolution > resolution);
    }
    if (layer.config.minresolution){
      enabled = enabled && (layer.config.minresolution < resolution);
    }
    if (layer.config.minscale) {
      enabled = enabled && (layer.config.minscale > scale);
    }
    if (layer.config.maxscale) {
      enabled = enabled && (layer.config.maxscale < scale);
    }
  }
  layer.state.disabled = !enabled;
};

proto.checkLayersDisabled = function(resolution){
  var self = this;
  _.forEach(this.layers,function(layer){
    self.checkLayerDisabled(layer,resolution);
  });
};

proto._updateLayers = function(mapState,extraParams){
  this.checkLayersDisabled(mapState.resolution);
  var visibleLayers = this._getVisibleLayers(mapState);
  if (visibleLayers.length > 0) {
    var params = {
      LAYERS: _.join(_.map(visibleLayers, function(layer) {
        return layer.getWMSLayerName();
      }),',')
    };
    if (extraParams) {
      params = _.assign(params,extraParams);
    }
    this._olLayer.setVisible(true);
    this._olLayer.getSource().updateParams(params);
  }
  else {
    this._olLayer.setVisible(false);
  }
};

module.exports = WMSLayer;

},{"core/map/layer/maplayer":58,"core/utils/geo":79,"core/utils/utils":80,"g3w-ol3/src/layers/rasters":109}],62:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

var GENERCI_GRID_EXTENT = [0,0,8388608,8388608];
var STANDARD_PROJECTIONS = [3857,900913,4326];

function XYZLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(XYZLayer,MapLayer);

var proto = XYZLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};

proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;
  
  var projection = this.projection ? this.projection : this.layer.getProjection();

  var layerOptions = {
    url: this.layer.getCacheUrl()+"/{z}/{x}/{y}.png",
    maxZoom: 20
  };

  /*if (STANDARD_PROJECTIONS.indexOf(crs) < 0) {
    layerOptions.projection = new ol.proj.Projection({
      code: "EPSG:"+crs,
      extent: GENERIC_GRID_EXTENT
    })
  }*/

  layerOptions.projection = projection;

  var olLayer = RasterLayers.XYZLayer(layerOptions);

  olLayer.getSource().on('imageloadstart', function() {
    self.emit("loadstart");
  });
  olLayer.getSource().on('imageloadend', function() {
    self.emit("loadend");
  });

  return olLayer
};

proto._updateLayer = function(mapState, extraParams) {
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = XYZLayer;

},{"core/map/layer/maplayer":58,"core/utils/geo":79,"core/utils/utils":80,"g3w-ol3/src/layers/rasters":109}],63:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var LayersStoresRegistry = require('core/layers/layersstoresregistry');

function MapLayersStoresRegistry() {
  base(this);
}

inherit(MapLayersStoresRegistry, LayersStoresRegistry);

module.exports = new MapLayersStoresRegistry();
},{"core/layers/layersstoresregistry":44,"core/utils//utils":80,"core/utils/utils":80}],64:[function(require,module,exports){
var Parsers = {
  vector: require('./vector/parser'),
  table: require('./table/parser')
};

module.exports = Parsers;
},{"./table/parser":65,"./vector/parser":66}],65:[function(require,module,exports){
var TableParser = function() {
  var pk;
  // funzione che permette di recuprarer il parser addatto alla richiesta
  this.get = function(options) {
    options = options || {};
    var type = options.type;
    pk = options.pk || 'id';
    var parser;
    switch (type) {
      case 'json':
        parser = this._parserJSON;
        break;
      default: 
        parser = this._parserJSON;
    }
    return parser;
  };
  
  this._parserJSON = function(data) {
    var features = [];
    var feature;
    _.forEach(data, function(properties) {
      feature = new ol.Feature();
      //vado a settare le proprietà
      feature.setProperties(properties);
      //vado a settare l'id univoco della feature
      feature.setId(properties[pk]);
      features.push(feature)
    });
    return features;
  }
};

module.exports = new TableParser();


},{}],66:[function(require,module,exports){
var VectorParser = function() {
  // funzione che permette di recuprarer il parser addatto alla richiesta
  this.get = function(options) {
    options = options || {};
    var type = options.type;
    var parser;
    switch (type) {
      case 'json':
        parser = this._parseLayerGeoJSON;
        break;
      case 'gml':
        parser = this._parseLayermsGMLOutput;
        break;
    }
    return parser;
  };

  // Brutto ma per ora unica soluzione trovata per dividere per layer i risultati di un doc xml wfs.FeatureCollection.
  // OL3 li parserizza tutti insieme non distinguendo le features dei diversi layers
  this._parseLayerFeatureCollection = function(data, ogcService) {
    var layerName = (ogcService == 'wfs') ? this._layer.getWMSLayerName().replace(/ /g,'_'): this._layer.getWMSLayerName().replace(/ /g,''); // QGIS SERVER rimuove gli spazi dal nome del layer per creare l'elemento FeatureMember
    var layerData = _.cloneDeep(data);
    layerData.FeatureCollection.featureMember = [];
    var featureMembers = data.FeatureCollection.featureMember;
    featureMembers = _.isArray(featureMembers) ? featureMembers : [featureMembers];
    _.forEach(featureMembers,function(featureMember){
      var isLayerMember = _.get(featureMember,layerName);
      if (isLayerMember) {
        layerData.FeatureCollection.featureMember.push(featureMember);
      }
    });
    var x2js = new X2JS();
    var layerFeatureCollectionXML = x2js.json2xml_str(layerData);
    var parser = new ol.format.WMSGetFeatureInfo();
    return parser.readFeatures(layerFeatureCollectionXML);
  };

// mentre con i risultati in msGLMOutput (da Mapserver) il parser può essere istruito per parserizzare in base ad un layer di filtro
  this._parseLayermsGMLOutput = function(data) {
    var layers = this._layer.getQueryLayerOrigName();
    var parser = new ol.format.WMSGetFeatureInfo({
      layers: layers
    });
    return parser.readFeatures(data);
  };
  
  this._parseLayerGeoJSON = function(data) {
    var geojson = new ol.format.GeoJSON({
      defaultDataProjection: this.crs,
      geometryName: "geometry"
    });
    return geojson.readFeatures(data);
  };

};

module.exports = new VectorParser();
},{}],67:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('./pluginsregistry');

var Plugin = function() {

  base(this);
  this.name = '(no name)';
  this.config = null;
  this.service = null;

};

inherit(Plugin,G3WObject);

var proto = Plugin.prototype;

//recuperare il servizio associato al plugin
proto.getService = function() {
  return this.service
};

//settare un servizio
proto.setService = function(service) {
  this.service = service;
};

//recupero il nome
proto.getName = function() {
  return this.name;
};

//setto il nome
proto.setName = function(name) {
  this.name = name;
};

//recupero la configurazione del plugin dal registro dei plugins
proto.getConfig = function(name) {
  name = name || this.name;
  return PluginsRegistry.getPluginConfig(name);
};

proto.setConfig = function(config) {
  this.config = config;
};

//verifica la compatibilià con il progetto corrente
proto.isCurrentProjectCompatible = function(projectId) {
  var project = ProjectsRegistry.getCurrentProject();
  return projectId == project.getGid();
};

//registrazione plugin se compatibile con il progetto corrente
proto.registerPlugin = function(projectId) {
  if (this.isCurrentProjectCompatible(projectId)) {
    PluginsRegistry.registerPlugin(this);
    return true;
  }
  return false;
};

// setup dell'interfaccia
proto.setupGui = function() {
  //al momento niente non so se verrà usata
};

// caso di sgancaimento del plugin (caso cambio progetto)
proto.unload  = function() {
  //console.log('UNLOAD deve essere sovrascritto eventalmente dal plugin');
};

// funzione che viene lanciata quando si fa il load del plugin
proto.load = function() {
  //console.log('LOAD deve essere sovrascritto eventalmente dal plugin');
};

module.exports = Plugin;

},{"./pluginsregistry":69,"core/g3wobject":30,"core/project/projectsregistry":74,"core/utils/utils":80}],68:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

// classe utilizzata dai plugin per il servizo
// al momento inizilaizza il config
function PluginService(options) {
  var options = options || {};
  base(this, options);
  this.init = function(config) {
    this.config = config;
    //TODO
  }
}

inherit(PluginService, G3WObject);

var proto = PluginService.prototype;

proto.getConfig = function() {
  return this.config;
};

proto.setConfig = function(config) {
  this.config = config;
};



module.exports = PluginService;
},{"core/g3wobject":30,"core/utils/utils":80}],69:[function(require,module,exports){
var base = require('core/utils/utils').base;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function PluginsRegistry() {
  var self = this;
  this.config = null;
  // un domani questo sarà dinamico
  this._plugins = {};
  this._loadedPluginUrls = [];
  this.setters = {
    //setters che server per registrare il plugin
    registerPlugin: function(plugin) {
      if (!self._plugins[plugin.name]) {
        self._plugins[plugin.name] = plugin;
      }
    }
  };
  base(this);

  // funzione di inizializzazione dei plugin
  this.init = function(options) {
    var self = this;
    this.pluginsBaseUrl = options.pluginsBaseUrl;
    // oggetto contenente la configuarzione dei vvari plugins (che sono le chiavi dell'oggetto)
    this.pluginsConfigs = options.pluginsConfigs;
    // configurazione altri plugin
    this.otherPluginsConfig = options.otherPluginsConfig;
    this.setOtherPlugins();
        //ciclo sull'oggetto plugins per fare il setup dei vari plugin legati al progetto
    _.forEach(this.pluginsConfigs, function(pluginConfig, name) {
      self._setup(name, pluginConfig);
    })
  };

  this.setOtherPlugins = function() {
    //da vedere poi come cutomizzare il law plugin
    if (this.otherPluginsConfig && this.otherPluginsConfig.law && this.otherPluginsConfig.law.length) {
      this.pluginsConfigs['law'] =  this.otherPluginsConfig.law;
    }
  };

  // funzione che serve per fare il reload dei plugins
  this.reloadPlugins = function(project) {
    var self = this;
    var ApplicationService = require('core/applicationservice');
    //forzo la varibile globale initConfig a null affinche venga ricaricato
    // la configurazione iniziale
    window.initConfig = null;
    //vado a riottenere l'initConfig
    ApplicationService.obtainInitConfig()
      .then(function(initConfig) {
        // prendo vado a rimuovere i tools
        GUI.getComponent('tools').getService().removeTools();
        // setto il pluginsConfig
        self.setPluginsConfig(initConfig.group.plugins);
        // devo ricaricare quelli con custom
        self.setOtherPlugins();
        // prendo dal documento tutti gli scripts
        var scripts = $('script');
        // va do a scorrere sui plugin registrati e verifico se il plugin esisteva oppure  no
        // se non esiste devo chiamare il metodo unload per sganciare tutte le sue cose (se previsto)
        // e implementato dal plugin
        _.forEach(self.getPlugins(), function(plugin, pluginName) {
          // verifico che il plugin non sia presente nella nuoav configurazione dei plugin
          //e quindi chieamo l'unload (se implementato) del plugin prima di
          // rimuovere lo script
          if (_.keys(self.pluginsConfigs).indexOf(pluginName) == -1) {
            // chaimo il metodo unload del plugin
            plugin.unload();
            // rimuovo il plugin anche dai pugin registrati
            delete self._plugins[pluginName];
            // cliclo sugli script vado a togliere gli script che contengono plugin
            _.forEach(scripts, function(scr) {
              _.forEach(self._loadedPluginUrls, function(pluginUrl, idx) {
                if (scr.getAttribute('src') == pluginUrl && pluginUrl.indexOf(pluginName) != -1) {
                  scr.parentNode.removeChild( scr );
                  //vado a cancellare lo script associato a quel plugin
                  self._loadedPluginUrls.splice(idx, 1);
                  return false;
                }
              })
            });
          } else {
            plugin.load();
            // lo devo togliere dalla configurazione
            delete self.pluginsConfigs[pluginName];
          }
        });
        _.forEach(self.pluginsConfigs, function(pluginConfig, pluginName) {
          self._setup(pluginName, pluginConfig);
        })
      });
  };

  this.setPluginsConfig = function(config) {
    this.pluginsConfigs = config;
  };

  //funzione che permette il caricamento dello script del plugin
  this._setup = function(name, pluginConfig) {
    // verifico che il plugin config la configurazione del
    // plugin non sia nulla per caricare il plugin
    if (!_.isNull(pluginConfig)) {
      var url = this.pluginsBaseUrl+name+'/js/plugin.js?'+Date.now();
      $script(url);
      // vado ad aggiunguere il plugin all'array dei plugin caricati
      this._loadedPluginUrls.push(url);
    }
  };
  
  this.getPluginConfig = function(pluginName) {
    return this.pluginsConfigs[pluginName];
  };

  this.getPlugins = function() {
    return this._plugins;
  };
  
  this.getPlugin = function(pluginName) {
    return this._plugins[pluginName];
  }

}

inherit(PluginsRegistry,G3WObject);

module.exports = new PluginsRegistry;

},{"core/applicationservice":22,"core/g3wobject":30,"core/utils/utils":80,"gui/gui":132}],70:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var PrinterProvider = require('./providers/printerprovider');

function PrintService() {
  base(this);
  // funzione generica nel caso volessi lanciare il print
  // senza ottenere il printer
  this.print = function(options) {
    /* options è un oggetto che contiene:
     type: tipo di printer server
     url: url a cui effettuare la richiesta
     params : oggetto contenete i parametri necessari alla creazione della richiesta
              come ad esempio filter etc ..
    */
    var options = options || {};
    var type = options.type || 'QGIS';
    var provider = new PrinterProvider(type);
    var url = provider.print(options);
    return $.get(url)
  };
}

inherit(PrintService, G3WObject);

module.exports = new PrintService;

},{"./providers/printerprovider":71,"core/g3wobject":30,"core/utils/utils":80}],71:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
// providers

var PrinterQGISProvider = require('./qgis/printerQGISProvider');

var Providers = {
  'QGIS': PrinterQGISProvider
};

// classe costruttore che permette a seconda delle caratteristiche dei layers
// ogcservice etc... di chiamare il proprio providers per effettuare le chiamte al server
function PrinterProvider(options) {
  var options = options || {};
  var serverType = options.serverType || 'QGIS';
  this._provider = Providers[serverType];
  this.print = function(options) {
    return this._provider.print(options);
  };
  base(this);
}

inherit(PrinterProvider, G3WObject);

module.exports =  PrinterProvider;


},{"./qgis/printerQGISProvider":72,"core/g3wobject":30,"core/utils/utils":80}],72:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var resolve = require('core/utils/utils').resolve;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');


function PrinterQGISProvider() {
  base(this);

  this._getPrintUrl = function(options) {
    var options = options || {};
    var layersStore =   ProjectsRegistry.getCurrentProject().getLayersStore();
    var templateMap = options.map || 'map0';
    var url = layersStore.getWmsUrl();
    // devo fare il reverse perchè l'odine conta sulla visualizzazione del print
    var layers = _.reverse(layersStore.getLayers({
      ACTIVE: true,
      VISIBLE: true,
      SERVERTYPE: 'QGIS'
    }));
    layers = _.map(layers,function(layer){
      return layer.getQueryLayerName()
    });
    var params = {
      SERVICE: 'WMS',
      VERSION: '1.3.0',
      REQUEST: 'GetPrint',
      TEMPLATE: options.template,
      DPI: options.dpi,
      FORMAT: 'pdf',
      CRS:layersStore.getProjection().getCode(),
      LAYERS: layers.join()
    };
    // AL comento commento
    params[templateMap+':SCALE'] = options.scale;
    params[templateMap+':EXTENT'] = options.extent;
    params[templateMap+':ROTATION'] = options.rotation;
    url = url + '?' + $.param(params);
    return url;
  };

  this.print = function(options) {
    /* options è un oggetto che contiene:
     type: tipo di printer server
     url: url a cui effettuare la richiesta
     params : oggetto contenete i parametri necessari alla creazione della richiesta
     come ad esempio filter etc ..
     */
    var options = options || {};
    return this._getPrintUrl(options);
  };
}

inherit(PrinterQGISProvider, G3WObject);

module.exports = new PrinterQGISProvider;


/*
 http://localhost/fcgi-bin/qgis_mapserver/qgis_mapserv.fcgi?MAP=/home/marco/geodaten/projekte/composertest.qgs&SERVICE=WMS&VERSION=1.3.0
 &REQUEST=GetPrint&TEMPLATE=Composer 1&
 map0:extent=693457.466131,227122.338236,700476.845177,230609.807051&
 BBOX=693457.466131,227122.338236,700476.845177,230609.807051&
 CRS=EPSG:21781&WIDTH=1467&HEIGHT=729&LAYERS=layer0,layer1&
 STYLES=,&FORMAT=pdf&DPI=300&TRANSPARENT=true

 In detail, the following parameters can be used to set properties for composer maps:

 <mapname>:EXTENT=<xmin,ymin,xmax, ymax> //mandatory
 <mapname>:ROTATION=<double> //optional, defaults to 0
 <mapname>:SCALE=<double> //optional. Forces scale denominator as server and client may have different scale calculations
 <mapname>:LAYERS=<comma separated list with layer names> //optional. Defaults to all layer in the WMS request
 <mapname>:STYLES=<comma separated list with style names> //optional
 <mapname>:GRID_INTERVAL_X=<double> //set the grid interval in x-direction for composer grids
 <mapname>:GRID_INTERVAL_Y=<double> //set the grid interval in x-direction for composer grids
 */
},{"core/g3wobject":30,"core/project/projectsregistry":74,"core/utils/utils":80}],73:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var LayerFactory = require('core/layers/layerfactory');
var ImageLayer = require('core/layers/imagelayer');
var LayersStore = require('core/layers/layersstore');
var Projections = require('g3w-ol3/src/projection/projections');

function Project(projectConfig) {
  var self = this;
  /* struttura oggetto 'project'
  {
    id,
    type,
    gid,
    name,
    crs,
    proj4,
    extent,
    initextent,
    layers,
    layerstree,
    overviewprojectgid,
    baselayers,
    initbaselayer
  }
  */
  this.state = projectConfig;
  this._processLayers();
  // recupero la
  this._projection = Projections.get(this.state.crs,this.state.proj4);
  this._layersStore = this._buildLayersStore();

  this.setters = {
    setBaseLayer: function(id) {
      _.forEach(self.state.baselayers, function(baseLayer) {
        baseLayer.visible = (baseLayer.id == id || (baseLayer.fixed === true));
      })
    }
  };

  base(this);
}

inherit(Project, G3WObject);

var proto = Project.prototype;

proto.getRelations = function() {
  return this.state.relations;
};

// funzione che processa i layers di progetto
proto._processLayers = function() {
  var self = this;
  // attraverso il tree dei layers (layerstree)
  // e aggiungo informazioni utili ad esempio al catalogo
  function traverse(obj) {
    _.forIn(obj, function (layer, key) {
      //verifica che il nodo sia un layer e non un folder
      if (!_.isNil(layer.id)) {
        var fulllayer;
        _.forEach(self.state.layers, function(lyr) {
          if (layer.id == lyr.id) {
            lyr.wmsUrl = self.getWmsUrl();
            lyr.project = self;
            fulllayer = _.merge(lyr, layer);
            return false
          }
        });
        obj[parseInt(key)] = fulllayer;
      }
      if (!_.isNil(layer.nodes)){
        // aggiungo proprietà title per l'albero
        layer.title = layer.name;
        traverse(layer.nodes);
      }
    });
  }
  traverse(this.state.layerstree);

  _.forEach(this.state.baselayers, function(layerConfig) {
    var visible = false;

    if (self.state.initbaselayer) {
      visible = (layerConfig.id == (self.state.initbaselayer));
    }

    if (layerConfig.fixed) {
      visible = layerConfig.fixed;
    }

    layerConfig.visible = visible;
    layerConfig.baselayer = true;
  });
};

// funzione che fa il buil del layers store
// lo istanzia  crea il layersstree
proto._buildLayersStore = function() {
  var self = this;
  // creo il layersStore
  var layersStore = new LayersStore();
  var overviewprojectgid = this.state.overviewprojectgid ? this.state.overviewprojectgid.gid : null;
  layersStore.setOptions({
    id: this.state.gid,
    projection: this._projection,
    extent: this.state.extent,
    initextent: this.state.initextent,
    wmsUrl: this.state.WMSUrl,
    catalog: this.state.gid != overviewprojectgid
  });

  // vado a ciclare su tutti i layers per poterli istanziare
  // e aggiungere al layersstore
  _.forEach(this.getLayers(), function(layerConfig) {
    // aggiungo la proiezione
    layerConfig.projection = self._projection;
    var layer = LayerFactory.build(layerConfig, {
      project: self
    });
    layersStore.addLayer(layer);
  });

  // funzione che crea il layerstree del layersstore
  layersStore.createLayersTree(this.state.name, {
    layerstree: this.state.layerstree
  });

  return layersStore;
};

proto.getLayers = function() {
  return _.concat(this.state.layers,this.state.baselayers);
};

proto.getState = function() {
  return this.state;
};

// funzione che ritorna id
proto.getId = function() {
  return this.state.id;
};

//funzione che ritorna il tipo
proto.getType = function() {
  return this.state.type;
};

proto.getGid = function() {
  return this.state.gid;
};

proto.getName = function() {
  return this.state.name;
};

proto.getOverviewProjectGid = function() {
  return this.state.overviewprojectgid ? this.state.overviewprojectgid.gid : null;
};

proto.getCrs = function() {
  return this._projection.getCode();
};

proto.getProjection = function() {
  return this._projection;
};

proto.getWmsUrl = function() {
  return this.state.WMSUrl;
};

proto.getInfoFormat = function() {
  return 'application/vnd.ogc.gml';
};

proto.getLayersStore = function() {
  return this._layersStore;
};

module.exports = Project;

},{"core/g3wobject":30,"core/layers/imagelayer":40,"core/layers/layerfactory":42,"core/layers/layersstore":43,"core/utils//utils":80,"core/utils/utils":80,"g3w-ol3/src/projection/projections":112}],74:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var reject = require('core/utils/utils').reject;
var G3WObject = require('core/g3wobject');
var Project = require('core/project/project');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');
var MapLayersStoresRegistry = require('core/map/maplayersstoresregistry');

/* service
Funzione costruttore contentente tre proprieta':
    setup: metodo di inizializzazione
    getLayersState: ritorna l'oggetto LayersState
    getLayersTree: ritorna l'array layersTree dall'oggetto LayersState
*/

// Public interface
function ProjectsRegistry() {
  var self = this;
  this.config = null;
  this.initialized = false;
  //tipo di progetto
  this.projectType = null;
  this.setters = {
    setCurrentProject: function(project) {
      if (this.state.currentProject) {
        CatalogLayersStoresRegistry.removeLayersStores();
        MapLayersStoresRegistry.removeLayersStores();
      }
      self.state.currentProject = project;
      //aggiunto tipo progetto
      self.setProjectType(project.state.type);
      var projectLayersStore = project.getLayersStore();
      // lo mette sempre in prima posizione mi serve per il catalogo
      CatalogLayersStoresRegistry.addLayersStore(projectLayersStore, 0);
      // lo mette sempre in prima posizione mi serve per la mappa
      MapLayersStoresRegistry.addLayersStore(projectLayersStore, 0);
    }
  };
  //stato del registro progetti
  this.state = {
    baseLayers: {},
    minScale: null,
    maxscale: null,
    currentProject: null
  };
  
  // tutte le configurazioni di base dei progetti, ma di cui non è detto che
  // sia ancora disponibile l'istanza (lazy loading)
  this._pendingProjects = [];
  this._projects = {};
  
  base(this);
}

inherit(ProjectsRegistry, G3WObject);

var proto = ProjectsRegistry.prototype;

proto.init = function(config) {
  var self = this;
  var deferred = $.Deferred();
  //verifico se è già stato inizilizzato
  if (!this.initialized) {
    this.initialized = true;
    //salva la configurazione
    this.config = config;
    // salvo l'overviewproject
    this.overviewproject = config.overviewproject;
    //setta lo state
    this.setupState();
    // vado a prendere la configurazione del progetto corrente
    this.getProject(config.initproject)
    .then(function(project) {
      // vado a settare il progetto corrente
      self.setCurrentProject(project);
      deferred.resolve(project);
    })
    .fail(function() {
      deferred.reject();
    })
  }
  return deferred.promise();
};

proto.setProjectType = function(projectType) {
   this.projectType = projectType;
};

proto.getConfig = function() {
  return this.config;
};


proto.getState = function() {
  return this.state;
};

proto.setupState = function() {
  var self = this;
  self.state.baseLayers = self.config.baselayers;
  self.state.minScale = self.config.minscale;
  self.state.maxScale = self.config.maxscale;
  self.state.crs = self.config.crs;
  self.state.proj4 = self.config.proj4;
  // setto  quale progetto deve essere impostato come overview
  //questo è settato da django-admin
  var overViewProject = (self.config.overviewproject && self.config.overviewproject.gid) ? self.config.overviewproject : null;
  //per ogni progetto ciclo e setto tutti gli attributi comuni
  // come i base layers etc ..
  self.config.projects.forEach(function(project) {
    project.baselayers = _.cloneDeep(self.config.baselayers);
    project.minscale = self.config.minscale;
    project.maxscale = self.config.maxscale;
    project.crs = self.config.crs;
    project.proj4 = self.config.proj4;
    project.overviewprojectgid = overViewProject;
    //aggiungo tutti i progetti ai pending project
    self._pendingProjects.push(project);
  });
};

proto.getProjectType = function() {
  return this.projectType;
};

proto.getPendingProjects = function() {
  return this._pendingProjects;
};

proto.getProjects = function() {
  return this._pendingProjects;
};

proto.getListableProjects = function() {
  var currentProjectId = this.getCurrentProject().getId();
  return _.filter(this.getProjects(), function(project) {
    if (!_.isNil(project.listable)) {
      return project.listable;
    }
    //resituisce solo quelli diversi da overviewprojetc
    // nel caso si stato settato
    if ((project.overviewprojectgid && project.gid != project.overviewprojectgid.gid && project.id != currentProjectId) || (project.id != currentProjectId)) {
      return project;
    }
  })
};

//recupera il progetto corrente
proto.getCurrentProject = function(){
  return this.state.currentProject;
};

// ottengo il progetto dal suo gid;
// ritorna una promise nel caso non fosse stato ancora scaricato
// il config completo (e quindi non sia ancora istanziato Project)
proto.getProject = function(projectGid) {
  var self = this;
  var d = $.Deferred();
  var pendingProject;
  var project = null;
  // scorro atraverso i pending project che contengono oggetti
  // di configurazione dei progetti del gruppo
  this._pendingProjects.forEach(function(_pendingProject) {
    if (_pendingProject.gid == projectGid) {
      pendingProject = _pendingProject;
      project = self._projects[projectGid];
    }
  });
  if (!pendingProject) {
    return reject("Project doesn't exist");
  }

  if (project) {
    return d.resolve(project);
  } else {
    return this._getProjectFullConfig(pendingProject)
    .then(function(projectFullConfig){
      var projectConfig = _.merge(pendingProject,projectFullConfig);
      projectConfig.WMSUrl = self.config.getWmsUrl(projectConfig);
      var project = new Project(projectConfig);
      // aggiungo/ registro il progetto
      self._projects[projectConfig.gid] = project;
      return d.resolve(project);
    })
    .fail(function() {
      return d.reject();
    })
  }
};
  
//ritorna una promises che verrà risolta con la
// configuarzione del progetto corrente
proto._getProjectFullConfig = function(projectBaseConfig) {
  var deferred = $.Deferred();
  var url = this.config.getProjectConfigUrl(projectBaseConfig);
  $.get(url)
    .done(function(projectFullConfig) {
      deferred.resolve(projectFullConfig);
    })
    .fail(function() {
      deferred.reject();
    });
  return deferred.promise();
};


module.exports = new ProjectsRegistry();

},{"core/catalog/cataloglayersstoresregistry":23,"core/g3wobject":30,"core/map/maplayersstoresregistry":63,"core/project/project":73,"core/utils/utils":80}],75:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function QueryService(){
  base(this);
}
inherit(QueryService, G3WObject);

var proto = QueryService.prototype;

//dato l'oggetto filter restituito dal server ricostruisco la struttura del filterObject

module.exports =  new QueryService;


},{"core/g3wobject":30,"core/utils/utils":80,"gui/gui":132}],76:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Relation(config) {
  config = config || {};
  var uniqueSuffix = Date.now();
  // config per le pari statiche
  this.state = {
    id: config.id || 'id_' + uniqueSuffix ,
    name: config.name || 'name_' + uniqueSuffix,
    father: config.referencedLayer,
    child: config.referencingLayer,
    fatherField: config.fieldRef.referencedField,
    childField: config.fieldRef.referencingField,
    type: config.type
  };
  
  base(this);
}

inherit(Relation, G3WObject);

var proto = Relation.prototype;

proto.getId = function() {
  return this.state.id;
};

proto.setId = function(id) {
  this.state.id = id;
};

proto.getName = function() {
  return this.state.name;
};

proto.setName = function(name) {
  this.state.name = name;
};

proto.getChild = function() {
  return this.state.child;
};

proto.getFather = function() {
  return this.state.father;
};

proto.getState = function() {
  return this.state;
};

proto.getType = function() {
  return this.state.type;
};

proto.getFields = function() {
  var fields = {
    father: this.state.fatherField,
    child: this.state.childField
  };
  return fields;
};

proto.getFatherField = function() {
  return this.state.fatherField;
};

proto.getChildField = function() {
  return this.state.childField;
};



module.exports = Relation;
},{"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],77:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var Relation = require('./relation');

// clase Relations
function Relations(options) {
  var self = this;
  options = options || {};
  var relations = options.relations;
  // qui conservo tutte le relazioni
  this._relations = {};
  this._length = relations ? relations.length: 0;
  // qui mi serve per costruire tutte le relazioni tra i layers
  this._relationsInfo = {
    children: {}, // contiene l'array dei figli (id unici)
    fathers: {}, // contiene l'array dei padri (unici)
    father_child: {} // contiene oggetti informazione padre figlio relazione
  };
  var relation;
  //vado a polpolare le relazioni
  _.forEach(relations, function(relationConfig) {
    // vado a creare la relazione
    relation = new Relation(relationConfig);
    // aggiungo all'oggetto relations
    self._relations[relation.getId()] = relation;
  });
  this._createRelationsInfo();
  base(this);
}

inherit(Relations, G3WObject);

var proto = Relations.prototype;

proto._createRelationsInfo = function() {
  var self = this;
  var father;
  var child;
  _.forEach(this._relations, function(relation, relationKey) {
    // scooro tra le relazioni create e vado ad aggiunfere informazioni
    // per velocizzare le richieste
    father = relation.getFather();
    child = relation.getChild();
    self._relationsInfo.father_child[father+child] = relationKey;
    if (!self._relationsInfo.fathers[father]) {
      self._relationsInfo.fathers[father] = [];
    }
    if (!self._relationsInfo.children[child]) {
      self._relationsInfo.children[child] = [];
    }
    self._relationsInfo.fathers[father].push(child);
    self._relationsInfo.children[child].push(father);
  });
};

proto._clearRelationsInfo = function() {
  this._relationsInfo = {
    children: {},
    fathers: {},
    father_children: {}
  };
};

proto._reloadRelationsInfo = function() {
  this._clearRelationsInfo();
  this._createRelationsInfo();
};

// restituisce il numero di relazioni
proto.getLength = function() {
  return this._length
};

// retituisce tutte le relazini create
proto.getRelations = function() {
  return this._relations;
};

// funzione che restituisce array delle relazioni
proto.getArray = function() {
  var relations = [];
  _.forEach(this._relations, function(relation) {
    relations.push(relation);
  });
  return relations;
};

proto.setRelations = function(relations) {
  this._relations = _.isArray(relations) ? relations : [];
};

proto.getRelationById = function(id) {
  return this._relations[id];
};

proto.getRelationByFatherChildren = function(father, child) {
  var relationId = this._relationsInfo.father_child[father+child];
  return this.getRelationById(relationId);
};

proto.addRelation = function(relation) {
  if (relation instanceof Relation) {
    this._relations[relation.getId()] = relation;
    this._reloadRelationsInfo();
  }
};

proto.removeRelation = function(relation) {
  var relationId;
  if (relation instanceof Relation) {
    relationId = relation.getId();
    delete this._relations[relationId];
    this._reloadRelationsInfo();
  }
};

proto.hasChildren = function(childId) {
  var children = this.getChildren(childId);
  return  children ? !!children.length: false;
};

proto.hasFathers = function(fatherId) {
  var fathers = this.getFathers(fatherId);
  return fathers ? !!fathers.length : false;
};

// vado a recuperare i figli a seconda se passato il parametro fatherId o no
proto.getChildren = function(fatherId) {
  if (!this.isFather(fatherId)) {
    return null;
  }
  return this._relationsInfo.fathers[fatherId];
};

// vado a recuperare i figli a seconda se passato il parametro childrenId o no
proto.getFathers = function(childId) {
  if (!this.isChild(childId)) {
    return null;
  }
  return this._relationsInfo.children[childId];
};

// verifico se è un figlio o no
proto.isChild = function(id) {
  return !!this._relationsInfo.children[id];
};

// verifico se è un padre o no
proto.isFather = function(id) {
  return !!this._relationsInfo.fathers[id];
};


module.exports = Relations;
},{"./relation":76,"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],78:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Base64 = require('core/utils/utils').Base64;
var G3WObject = require('core/g3wobject');

/*
 * RouterService basato su History.js (https://github.com/browserstate/history.js) e Crossroads (https://github.com/millermedeiros/crossroads.js)
 * Il concetto di base è una RouteQuery, del tipo "map?point=21.2,42.1&zoom=12", 
 * che viene inserito nello stato dell'history del browser e nella URL come parametro querystring in forma codificata (q=map@point!21.2,41.1|zoom!12).
 * Per invocare una RouteQuery:
 * 
 * RouterService.goto("map?point=21.2,42.1&zoom=12");
 * 
 * Chiunque voglia rispondere ad una RouteQuery deve aggiungere una route con RouterService.addRoute(pattern, callback). Es.:
 * 
 * var route = RouterService.addRoute('map/{?query}',function(query){
 *  console.log(query.point);
 *  console.log(query.zoom);
 * });
 * 
 * Patterns:
 *  "map/{foo}": la porzione "foo" è richiesta, ed viene passata come parametro alla callback
 *  "map/:foo:": la porzione "foo" è opzionale, ed eventualmente viene passata come parametro alla callback
 *  "map/:foo*: tutto quello che viene dopo "map/"
 *  "map/{?querystring}": obbligatoria querystring, passata alla callback come oggetto dei parametri
 *  "map/:?querystring:": eventuale querystring, passata alla callback come oggetto dei parametri
 * 
 * Per rimuovere una route:
 * RouterService.removeRoute(route);
*/

// altrimenti due chiamate successive alla stessa route verrebbero ignorate
// e può capitare di tornare a chiamare la stessa route senza averne chiamate prima (perché non tutta la GUI è comandata tramite Router)
crossroads.ignoreState = true;
// tutte le route vengono innescate da un url, invece di feramrsi alla prima (com'è di default)
crossroads.greedy = true;

var RouterService = function(){
  var self = this;
  this._initialLocationQuery;
  this._routeQuery = '';
  this.setters = {
    setRouteQuery: function(routeQuery){
      this._routeQuery = routeQuery;
      crossroads.parse(routeQuery);
    }
  };
  
  base(this);
};
inherit(RouterService,G3WObject);

var proto = RouterService.prototype;

proto.init = function(){
  var query = window.location.search;
  this._setRouteQueryFromLocationQuery(query);
};

proto.addRoute = function(pattern,handler,priority) {
  return crossroads.addRoute(pattern,handler,priority);
};

proto.removeRoute = function(route) {
  return crossroads.removeRoute(route);
};

proto.removeAllRoutes = function() {
  return crossroads.removeAllRoutes();
};

proto.parse = function(request,defaultArgs) {
  return crossroads.parse(request,defaultArgs);
};

proto.goto = function(routeQuery){
  if (!this._initialQuery) {
    this._initialLocationQuery = this._stripInitialQuery(location.search.substring(1));
  }
  if (routeQuery) {
    this.setRouteQuery(routeQuery);
  }
};

proto.makePermalink = function(routeQuery) {
  if (!this._initialQuery) {
    this._initialLocationQuery = this._stripInitialQuery(location.search.substring(1));
  }
  var encodedRouteQuery = this._encodeRouteQuery(routeQuery);
  //encodedRouteQuery = Base64.encode(encodedRouteQuery);
  return '?'+this._initialLocationQuery + '&q='+this._encodeRouteQuery(routeQuery);
};

proto.makeQueryString = function(queryParams){};

proto.slicePath = function(path){
  return path.split('?')[0].split('/');
};
  
proto.sliceFirst = function(path){
  var pathAndQuery = path.split('?');
  var queryString = pathAndQuery[1];
  var pathArr = pathAndQuery[0].split('/');
  var firstPath = pathArr[0];
  path = pathArr.slice(1).join('/');
  path = [path,queryString].join('?');
  return [firstPath,path];
};
  
proto.getQueryParams = function(query){
  query = query.replace('?','');
  var queryParams = {};
  var queryPairs = [];
  if (query != "" && query.indexOf("&") == -1) {
    queryPairs = [query];
  }
  else {
    queryPairs = query.split('&');
  }
  try {
    _.forEach(queryPairs,function(queryPair){
      var pair = queryPair.split('=');
      var key = pair[0];
      var value = pair[1];
      queryParams[key] = value;
    });
  }
  catch (e) {}
  return queryParams;
};

proto.getQueryString = function(path){
  return path.split('?')[1];
};

proto._getQueryPortion = function(query,queryKey){
  var queryPortion;
  try {
    var queryPairs = query.split('&');
    var queryParams = {};
    _.forEach(queryPairs,function(queryPair){
      var pair = queryPair.split('=');
      var key = pair[0];
      if (key == queryKey) {
        queryPortion = queryPair;
      }
    });
  }
  catch (e) {}
  return queryPortion;
};

proto._encodeRouteQuery = function(routeQuery) {
  routeQuery = routeQuery.replace('?','@');
  routeQuery = routeQuery.replace('&','|');
  routeQuery = routeQuery.replace('=','!');
  return routeQuery;
};

proto._decodeRouteQuery = function(routeQuery) {
  routeQuery = routeQuery.replace('@','?');
  routeQuery = routeQuery.replace('|','&');
  routeQuery = routeQuery.replace('!','=');
  return routeQuery;
};

proto._setRouteQueryFromLocationQuery = function(locationQuery) {
  var encodedRouteQuery = this._getRouteQueryFromLocationQuery(locationQuery);
  //encodedRouteQuery = Base64.decode(encodedRouteQuery);
  if (encodedRouteQuery) {
    var routeQuery = this._decodeRouteQuery(encodedRouteQuery);
    this.setRouteQuery(routeQuery);
  }
};

proto._getRouteQueryFromLocationQuery = function(locationQuery) {
  return this.getQueryParams(locationQuery)['q'];
};

proto._stripInitialQuery = function(locationQuery) {
  var previousQuery = this._getQueryPortion(locationQuery,'q');
  if (previousQuery) {
    var previousQueryLength = previousQuery.length;
    var previousQueryPosition = locationQuery.indexOf(previousQuery);
    queryPrefix = _.trimEnd(locationQuery.substring(0,previousQueryPosition),"&");
    querySuffix = locationQuery.substring(previousQueryPosition+previousQueryLength);
    querySuffix = (queryPrefix != "") ? querySuffix : _.trimStart(querySuffix,"&");
    locationQuery = queryPrefix + querySuffix;
  }
  return locationQuery;
};

module.exports = new RouterService;

},{"core/g3wobject":30,"core/utils/utils":80}],79:[function(require,module,exports){
var OGC_PIXEL_WIDTH = 0.28;
var OGC_DPI = 25.4/OGC_PIXEL_WIDTH;

module.exports = {
  resToScale: function(res, unit) {
    var unit = unit || 'm';
    var scale;
    switch (unit) {
      case 'm':
        var scale = (res*1000) / OGC_PIXEL_WIDTH;
        break;
    }
    return scale;
  },
  scaleToRes: function(scale, unit) {
    var unit = unit || 'm';
    var resolution;
    switch (unit) {
      case 'm':
        var resolution = (scale * OGC_PIXEL_WIDTH) / 1000;
        break
    }
    return resolution;
  }
};

},{}],80:[function(require,module,exports){

/**
 * Decimal adjustment of a number.
 *
 * @param {String}  type  The type of adjustment.
 * @param {Number}  value The number.
 * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).
 * @returns {Number} The adjusted value.
 */
function decimalAdjust(type, value, exp) {
  // If the exp is undefined or zero...
  if (typeof exp === 'undefined' || +exp === 0) {
    return Math[type](value);
  }
  value = +value;
  exp = +exp;
  // If the value is not a number or the exp is not an integer...
  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
    return NaN;
  }
  // Shift
  value = value.toString().split('e');
  value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
  // Shift back
  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
}

// Decimal round
if (!Math.round10) {
  Math.round10 = function(value, exp) {
    return decimalAdjust('round', value, exp);
  };
}
// Decimal floor
if (!Math.floor10) {
  Math.floor10 = function(value, exp) {
    return decimalAdjust('floor', value, exp);
  };
}
// Decimal ceil
if (!Math.ceil10) {
  Math.ceil10 = function(value, exp) {
    return decimalAdjust('ceil', value, exp);
  };
}

String.prototype.hashCode = function() {
  var hash = 0, i, chr, len;
  if (this.length === 0) return hash;
  for (i = 0, len = this.length; i < len; i++) {
    chr   = this.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0;
  }
  return hash;
};

var Base64 = {_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",encode:function(e){var t="";var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f<e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t="";var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,"");while(f<e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s<<2|o>>4;r=(o&15)<<4|u>>2;i=(u&3)<<6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,"n");var t="";for(var n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r)}else if(r>127&&r<2048){t+=String.fromCharCode(r>>6|192);t+=String.fromCharCode(r&63|128)}else{t+=String.fromCharCode(r>>12|224);t+=String.fromCharCode(r>>6&63|128);t+=String.fromCharCode(r&63|128)}}return t},_utf8_decode:function(e){var t="";var n=0;var r=c1=c2=0;while(n<e.length){r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r);n++}else if(r>191&&r<224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&31)<<6|c2&63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&15)<<12|(c2&63)<<6|c3&63);n+=3}}return t}};


var utils = {
  basemixin: function mixin(destination, source) {
      return utils.merge(destination.prototype, source);
  },
  
  mixin: function mixininstance(destination,source){
      var sourceInstance = new source;
      utils.merge(destination, sourceInstance);
      utils.merge(destination.prototype, source.prototype);
  },


  merge: function merge(destination, source) {
      var key;
      for (key in source) {
          if (utils.hasOwn(source, key)) {
              destination[key] = source[key];
          }
      }
  },

  hasOwn: function hasOwn(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
  },
  
  inherit:function(childCtor, parentCtor) {
    function tempCtor() {}
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    childCtor.prototype.constructor = childCtor;
  },
  
  base: function(me, opt_methodName, var_args) {
    var caller = arguments.callee.caller;
    if (caller.superClass_) {
      // This is a constructor. Call the superclass constructor.
      return caller.superClass_.constructor.apply(
          me, Array.prototype.slice.call(arguments, 1));
    }
    var args = Array.prototype.slice.call(arguments, 2);
    var foundCaller = false;
    for (var ctor = me.constructor;
         ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
      if (ctor.prototype[opt_methodName] === caller) {
        foundCaller = true;
      } else if (foundCaller) {
        return ctor.prototype[opt_methodName].apply(me, args);
      }
    }

    // If we did not find the caller in the prototype chain,
    // then one of two things happened:
    // 1) The caller is an instance method.
    // 2) This method was not called by the right caller.
    if (me[opt_methodName] === caller) {
      return me.constructor.prototype[opt_methodName].apply(me, args);
    } else {
      throw Error(
          'base called from a method of one name ' +
          'to a method of a different name');
    }
  },
  
  noop: function(){},
  
  truefnc: function(){return true},
  
  falsefnc: function(){return true},
  
  resolve: function(value){
    var deferred = $.Deferred();
    deferred.resolve(value);
    return deferred.promise();
  },
  
  reject: function(value){
    var deferred = $.Deferred();
    deferred.reject(value);
    return deferred.promise();
  },
  // Appends query parameters to a URI
  appendParams: function(uri, params) {
    var keyParams = [];
    // Skip any null or undefined parameter values
    Object.keys(params).forEach(function (k) {
      if (params[k] !== null && params[k] !== undefined) {
        keyParams.push(k + '=' + encodeURIComponent(params[k]));
      }
    });
    var qs = keyParams.join('&');
    // remove any trailing ? or &
    uri = uri.replace(/[?&]$/, '');
    // append ? or & depending on whether uri has existing parameters
    uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
    return uri + qs;
  },
  
  Base64: Base64
};

module.exports = utils;

},{}],81:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

//classe che permette di attivare il flusso del workflow
// passando trai i vari steps
function Flow() {
  var self = this;
  var steps = [];
  var inputs;
  var counter = 0;
  var context = null;
  var workflow;
  var d;

  //metodo start del workflow
  this.start = function(workflow) {
    d = $.Deferred();
    if (counter > 0) {
      console.log("reset workflow before restarting");
    }
    workflow = workflow;
    //prendo gli inputs passati al workflow
    inputs = workflow.getInputs();
    // prendo il contex su cui agisce il workflow
    context = workflow.getContext();
    //recupero gli steps che il workflow deve fare
    steps = workflow.getSteps();
    // verifico che ci siano steps
    if (steps && steps.length) {
      // faccio partire il primo step
      //passando gli inputs assegannti al worflow
      this.runStep(steps[0], inputs, context);
    }
    // ritono la promessa che verrà risolta solo
    // se tutti gli steps vanno a buon fine
    return d.promise();
  };

  //funzione che fa il rloun dello step
  this.runStep = function(step, inputs) {
    // faccio partire il run dello step 
    // che non fa altro che far partire il run del task e ritorna una promise
    step.run(inputs, context)
      // se andato tutto a buon fine lo step o meglio il task
      // è stato risolto chiamo la funzione
      // ondone che deciderà se chiamare altro step (se esiste) o risolverà il flusso
      .then(function(outputs) {
        self.onDone(outputs);
      })
      // c'è stato un erore (task rigettato) per errore o voluto
      .fail(function(error) {
        self.onError(error);
      })

  };

  //funzione che verifica se siamo arrivati alla fine degli steps
  // se si risolve
  this.onDone = function(outputs) {
    //vado ad aumentare di uno il counter degli steps andati a buon fine e verifico
    // se sono arrivato alla fine degli steps oppure no
    counter++;
    if (counter == steps.length) {
      console.log('sono arrivato in fondo agli steps senza errori');
      // setto di nuovo il counter a 0
      counter = 0;
      // risolvo con il valore degli outputs
      d.resolve(outputs);
      return;
    }
    this.runStep(steps[counter], outputs);
  };

  // funzione che viene chaima in caso di errore
  this.onError = function(err) {
    // nel caso di errore di uno step
    console.log('step error: ', err);
    // risetto il counter a 0
    counter = 0;
    d.reject(err);
  };

  // stop flow
  this.stop = function() {
    var d = $.Deferred();
    console.log('Flow stopping ...');
    //verifico a che punto è il counter se all'inizio
    steps[counter].isRunning() ? steps[counter].stop() : null;
    if (counter > 0) {
      // setto il counter a 0
      counter = 0;
      // faccio un reject dell flow
      d.reject();
    } else {
      // altrimenti faccio un reject che mi porterà
      //a fare un rollback della sessione
      d.resolve();
    }
    return d.promise();
  };

  base(this)
}

inherit(Flow, G3WObject);

module.exports = Flow;


},{"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],82:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Step(options) {
  base(this);
  options = options || {};
  this._inputs = options.inputs || null;
  this._task = options.task || null;
  this._outputs = options.outputs || null;

  //stato dinamico dello step
  this.state = {
    id: options.id || null,
    name: options.name || null,
    help: options.help || null, // help che verrà visualizzato per descrivere a cosa serve
    running: false, // se è in fase di lavorazione
    error: null, // riporta se c'è stato un errore
    message: options.message || null // eventuale messaggio da presentare all'utente
  }
}

inherit(Step, G3WObject);

var proto = Step.prototype;

// metodo chiamato per far partire il task
proto.run = function(inputs, context) {
  var self = this;
  var d = $.Deferred();
  if (this._task) {
    try {
      // metto lo stato dello step a running
      this.state.running = true;
      // al metodo run del task gli viene passato sia
      // gli inputs che il context
      this._task.run(inputs, context)
        .then(function(outups) {
          self.stop(); //ripetuto ma non mi piace
          d.resolve(outups);
        })
        .fail(function(err) {
          self.stop();//ripetuto ma non mi piace
          d.reject(err);
        })
    }
    catch(err) {
      this.state.error = err;
      this.state.error = 'Si è verificato un problema ..';
      this.stop();
      d.reject(err);
    }
  }
  return d.promise();
};

//funzione che mi va  a fare lo spo dello step e in particolare del
//task associato
proto.stop = function() {
  // chiamo lo stop del task così mi pulisce tutte le cose legate al task
  this._task.stop();
  // setta lo step a runninf false
  this.state.running = false;
};

// faccio il revert del task
proto.revert = function() {
  if (this._task && this._task.revert) {
   this._task.revert();
  }
};

//lancio il panic del task
proto.panic = function() {
  if (this._task && this._task.panic){
    this._task.panic();
  }
};

// id dello step
proto.getId = function() {
  return this.state.id;
};

proto.getName = function() {
  return this.state.name;
};

proto.getHelp = function() {
  return this.state.help;
};

proto.getError = function() {
  return this.state.error;
};

proto.getMessage = function() {
  return this.state.message;
};

proto.isRunning = function() {
  return this.state.running;
};

proto.setInputs = function(inputs) {
  this._inputs = inputs;
};

proto.getInputs = function() {
  return this._inputs;
};

proto.setTask = function(task) {
  this._task = task;
};

proto.getTask = function() {
  return this._task;
};

proto.setOutputs = function(outputs) {
  this._outputs = outputs;
};

proto.getOutputs = function() {
  return this._outputs;
};


module.exports = Step;
},{"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],83:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Task(options) {
  base(this, options);
  // eventuali attributi reattivi sul task
  this.state = {};
}

inherit(Task, G3WObject);

var proto = Task.prototype;

// funzione che ha il compito di fare un (undo)
// di quello che il task ha fatto 
proto.revert = function() {
  console.log('Revert da implementare ');
};

// punzione che viene chiamata se qualcosa va storto
// errore nel completare un task
proto.panic = function() {
  console.log('Panic da Implementare ..');
};

// funzione adibita allo stop del task che avrà lo scopo verosimilmente
// di fare un clean di tutti gli oggetti che sono serviti o che servono
// a portare aanti quel determinato task
proto.stop = function() {
  console.log('Task Stop da imlementare ..');
};

// funzione base che devere essere sovrascritta dal task
// per par partire l'editing
proto.run = function() {
  console.log('Se appare quasto messaggio significa che non è stato sovrascritto il metodo run() dalla sottoclasse');
};

proto.setRoot = function(task) {
  this.state.root = task;
};



module.exports = Task;
},{"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],84:[function(require,module,exports){
var resolve = require('core/utils/utils').resolve;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var Flow = require('./flow');
var WorkflowsStack = require('./workflowsstack');
//classe che ha lo scopo generico di gestire un flusso
// ordinato di passi (steps)
function Workflow(options) {
  base(this);
  options = options || {};
  // oggetto che conterrà tutti
  // i dati necessari a lavorare con l'editing
  this._inputs = options.inputs || null;
  //oggetto che determina il contesto in cui
  // opera il workflow
  this._context = options.context || null;
  // flow oggetto che mi permette di stabilile come
  // mi devo muovere all'interno del worflow
  this._flow = options.flow || new Flow();
  // sono i vari passi con i relativi task
  // nei quali l'inpust verranno aggiornati
  this._steps = options.steps || [];
  // qui viene messo il child del workflow
  this._child = null;
  // indice dello stack dei workflow
  this._stackIndex = null;
}

inherit(Workflow, G3WObject);

var proto = Workflow.prototype;

proto.getStackIndex = function() {
  return this._stackIndex;
};

proto.addChild = function(workflow) {
  if (this._child)
    this._child.addChild(workflow);
  else {
    this._child = workflow;
  }
};

proto.removeChild = function() {
  if (this._child) {
    var index = this._child.getStackIndex();
    WorkflowsStack.removeAt(index);
  }

  this._child = null;
};

proto._setInputs = function(inputs) {
 this._inputs = inputs;
};

proto.getInputs = function() {
  return this._inputs;
};

proto.setContext = function(context) {
 this._context = context;
};

proto.getContext = function() {
  return this._context;
};

proto.getFlow = function() {
  return this._flow;
};

proto.setFlow = function(flow) {
  this._flow = flow;
};

proto.addStep = function(step) {
  this._steps.push(step);
};

proto.setSteps = function(steps) {
  this._steps = steps;
};

proto.getSteps = function() {
  return this._steps;
};

proto.getStep = function(index) {
  return this._steps[index];
};

proto.getLastStep = function() {
  var length = this._steps.length;
  if (length) {
    return this._steps[length]
  }
  return null;
};

proto.getRunningStep = function() {
  var runningStep = null;
  _.forEach(this._steps, function(step) {
    if (step.isRunning()) {
      runningStep = step;
    }
  });
  return runningStep;
};

//funzione cha va a stoppare tutti i figli del worflow
proto._stopChild = function() {
  return this._child ? this._child.stop(): resolve();
};

// metodo principale al lancio del workflow
proto.start = function(options) {
  options = options || {};
  var d = $.Deferred();
  this._inputs = options.inputs;
  //oggetto che mi server per operare su elementi utili
  this._context = options.context || {};
  // verifico se ci sono workflow già presenti in corso
  if (WorkflowsStack.getLength() && WorkflowsStack.getLast() != this)
    WorkflowsStack.getLast().addChild(this);
  this._stackIndex = WorkflowsStack.push(this);
  this._flow = options.flow || this._flow;
  this._steps = options.steps || this._steps;
  this._flow.start(this)
    .then(function(outputs) {
      // ritorna l'outputs
      d.resolve(outputs);
    })
    .fail(function(error) {
      d.reject(error);
    });
  return d.promise();
};

// metodo stop utilizzato per eventualmente stoppare
// il workflow durante il suo flusso
proto.stop = function() {
  var self = this;
  ////console.log('Workflow stopping .... ');
  var d = $.Deferred();
  // chiamo lo stop del child workflow che arà una sua vita  indipendente dal padre
  this._stopChild()
    // in ogni caso faccio il removechild
    .always(function() {
      self.removeChild();
      WorkflowsStack.removeAt(self.getStackIndex());
      // vado a chiamare lo stop del flow
      self._flow.stop() // ritorna una promessa
        .then(function() {
          d.resolve()
        })
        .fail(function(err) {
          // mi serve per capire cosa fare
          d.reject(err)
        });
  });
  return d.promise();
};

module.exports = Workflow;
},{"./flow":81,"./workflowsstack":85,"core/g3wobject":30,"core/utils//utils":80,"core/utils/utils":80}],85:[function(require,module,exports){
// Oggetto che tiene conto di tutti i workflow
// che sono stati attivati

var WorkFlowsStack = function() {
  this._workflows = [];
  this.push = function(workflow) {
    if (this._workflows.indexOf(workflow) == -1)
      return this._workflows.push(workflow) - 1;
    return this._workflows.indexOf(workflow);
  };

  this.pop = function() {
   return this._workflows.pop()
  };

  this.getLength = function() {
    return this._workflows.length;
  };

  this.getLast = function() {
    var length = this._workflows.length;
    return  length ? this._workflows[length -1] : null;
  };

  this.getFirst = function() {
    return this._workflows[0];
  };

  this.removeAt = function(index) {
    this._workflows.splice(index, 1);
  };

  this.getAt = function(index) {
    return this._workflows[index];
  };

  this.insertAt = function(index, workflow) {
    this._workflows[index] = workflow;
  }

};

module.exports = new WorkFlowsStack;
},{}],86:[function(require,module,exports){
var Control = require('./control');
function AddLayersControl() {
  var options = {
    name: "addlayer",
    tipLabel: "AddLayer",
    label: "\ue907"
  };
  Control.call(this, options);
  this._layerstore = null;
}

ol.inherits(AddLayersControl, Control);

var proto = AddLayersControl.prototype;

proto.setMap = function(map) {
  var self = this;
  Control.prototype.setMap.call(this,map);
  $(this.element).on('click', function() {
    self.dispatchEvent('addlayer');
  })
};

proto.layout = function(map) {
  Control.prototype.layout.call(this, map);
};

proto.getLayersSore = function() {
  return this._layerstore;
};

proto.setLayersStore = function(layersStore) {
  this._layerstore = layersStore;
};

module.exports = AddLayersControl;

},{"./control":88}],87:[function(require,module,exports){
var utils = require('../utils');
var AreaIteraction = require('../interactions/areainteraction');
var MeasureControl = require('./measurecontrol');

var AreaControl = function(options) {
  var _options = {
    name: "Area",
    label: "\ue909",
    interactionClass: AreaIteraction
  };
  options = utils.merge(options,_options);
  MeasureControl.call(this, options);
};

ol.inherits(AreaControl, MeasureControl);


module.exports = AreaControl;

},{"../interactions/areainteraction":102,"../utils":113,"./measurecontrol":92}],88:[function(require,module,exports){
var Control = function(options) {
  var name = options.name || "?";
  this.name = name.split(' ').join('-').toLowerCase();
  this.id = this.name+'_'+(Math.floor(Math.random() * 1000000));
  this.positionCode = options.position || 'tl';
  this.priority = options.priority || 0;
  if (!options.element) {
    var className = "ol-"+this.name.split(' ').join('-').toLowerCase();
    var tipLabel = options.tipLabel || this.name;
    var label = options.label || "?";
    options.element = $('<div class="'+className+' ol-unselectable ol-control"><button type="button" title="'+tipLabel+'">'+label+'</button></div>')[0];
  }
  $(options.element).addClass("ol-control-"+this.positionCode);
  var buttonClickHandler = options.buttonClickHandler || Control.prototype._handleClick.bind(this);
  $(options.element).on('click',buttonClickHandler);
  ol.control.Control.call(this, options);
  this._postRender();

};

// sotto classse della classe Control di OL3
ol.inherits(Control, ol.control.Control);

var proto = Control.prototype;

proto.getPosition = function(positionCode) {
  var positionCode = positionCode || this.positionCode;
  var position = {};
  position['top'] = (positionCode.indexOf('t') > -1) ? true : false;
  position['left'] = (positionCode.indexOf('l') > -1) ? true : false;
  return position;
};

proto._handleClick = function(event) {
  event.preventDefault();
  var self = this;
  var map = this.getMap();
  var resetControl = null;
  // remove all the other, eventually toggled, interactioncontrols
  var controls = map.getControls();
  controls.forEach(function(control){
    if(control.id && control.toggle && (control.id != self.id)) {
      control.toggle(false);
      if (control.name == 'reset') {
        resetControl = control;
      }
    }
  });
  if (!self._toggled && resetControl) {
    resetControl.toggle(true);
  }
  this.dispatchEvent('controlclick');
};

//funzione che fa lo shift della posizione
proto.shiftPosition = function(position) {
  $(this.element).css(hWhere, position+'px');
};

// funzione che gestisce il layout
proto.layout = function(map) {
  if (map) {
    var position =  this.getPosition();
    var viewPort = map.getViewport();
    // vado a verificare se trovo elementi con lo stessa classe .ol-control-t o .ol-control-tl(che sono i default di ol3)
    var previusControls = $(viewPort).find('.ol-control-'+this.positionCode+':visible');
    if (previusControls.length) {
      previusControl = previusControls.last();
      var previousOffset = position.left ? previusControl.position().left : previusControl.position().top;
      var hWhere = position.left ? 'left' : 'top';
      var previousWidth = previusControl[0].offsetWidth;
      var hOffset = $(this.element).position()[hWhere] + previousOffset + previousWidth;
      $(this.element).css(hWhere,hOffset+'px');
    }
  }
};

// funzione che viene chiamata al momento che il controllo viene
// aggiunto alla mappa
proto.setMap = function(map) {
  if (map) {
    this.layout(map);
    ol.control.Control.prototype.setMap.call(this, map);
  }
};

// funzione che nasconde il controllo e sposta tutti i controlli a destra
// senza lasciare il buco
proto.hideControl = function() {
  var position = $(this.element).position().left
  var controlWidth = $(this.element).outerWidth();
  var newPosition = position;
  var controls = $(this.element).siblings('.ol-control-tl');
  controls.each(function() {
    if ($(this).position().left > position) {
      newPosition = $(this).position().left;
      if (controlWidth > $(this).outerWidth()) {
        position = position + (controlWidth - $(this).outerWidth())
      } 
      $(this).css('left', position+'px');
      position = newPosition;
      controlWidth = $(this).outerWidth();
    }
  });
  $(this.element).hide();
};

proto._postRender = function() {};

module.exports = Control;

},{}],89:[function(require,module,exports){
var Control = require('./control');
function GeolocationControl() {
  var options = {
    name: "geolocation",
    tipLabel: "Geolocation",
    label: "\ue904"
  };
  Control.call(this, options);
}

ol.inherits(GeolocationControl, Control);

var proto = GeolocationControl.prototype;

proto.setMap = function(map) {
  var self = this;
  Control.prototype.setMap.call(this,map);
  // faccio la gestione tutta interna alla rimozione del controllo
  var geolocation = new ol.Geolocation({
    projection: map.getView().getProjection(),
    tracking: true
  });
  //mi metto in ascolto del proprety change in particolare quando viene settato allow o block
  geolocation.once('change:position', function(e) {
    if (this.getPosition()) {
      $(self.element).removeClass('g3w-ol-disabled');
      $(self.element).on('click', function() {
        var map = self.getMap();
        var view = map.getView();
        coordinates = geolocation.getPosition();
        view.setCenter(coordinates);
        self.dispatchEvent({
          type: 'click',
          coordinates: coordinates
        })
      });
    } else {
      self.hideControl();
    }
  });
  geolocation.once('error', function(e) {
    self.hideControl();
    if (e.code != 1) {
      self.dispatchEvent('error');
    }
  });
};

proto.layout = function(map) {
  Control.prototype.layout.call(this, map);
  $(this.element).addClass('g3w-ol-disabled');
};


module.exports = GeolocationControl;
},{"./control":88}],90:[function(require,module,exports){
var Control = require('./control');

var InteractionControl = function(options) {
  this._toggled = this._toggled || false;
  this._interactionClass = options.interactionClass || null;
  this._interaction = null;
  this._autountoggle = options.autountoggle || false;
  this._geometryTypes = options.geometryTypes || []; // array con tipologie di geometria layer
  this._onSelectLayer = options.onselectlayer || false;
  this._enabled = (options.enabled === false) ? false : true;
  this._onhover = options.onhover || false;
  this._help = options.help  || null;
  this._modalHelp = this._help ? (options.modalHelp || toastr) : null;
  options.buttonClickHandler = InteractionControl.prototype._handleClick.bind(this);
  Control.call(this, options);
  // vado a creare il modal help se esiste un messaggio
  if (this._help) {
    this._createModalHelp();
  }
};

ol.inherits(InteractionControl, Control);

var proto = InteractionControl.prototype;

proto._clearModalHelp = function(id) {
  var self = this;
  $('body').delegate('#'+id,'change', function() {
    self._modalHelp = null;
  });
};

//funzione che si occupa di  visualizzazre la modeal dell'help
proto._showModalHelp = function() {
  var previousToastPositionClass = toastr.options.positionClass;
  // qui c'è una dipendenza con l'app template
  var contentDiv = $('#g3w-view-content');
  if (this._modalHelp) {
    toastr.options.positionClass = 'toast-top-right';
    // se già presente un modale lo chiudo
    this._modalHelp.clear();
    var helpElement = this._modalHelp.info(this._help);
    if (contentDiv) {
      var right = contentDiv.css('width');
      $(helpElement).css('right', right);
    }
    toastr.options.positionClass = previousToastPositionClass;
  }
};

// funzione che crea la help modal
proto._createModalHelp = function() {
  var self = this;
  var id = "close_button"+Math.floor(Math.random()*1000000)+""+Date.now();
  this._help += '<label for="'+id+'" style="float:right">Non mostrare più</label><input type="checkbox" id="'+id+'" class="pull-right"/>';
  // verifico se abilitato e se settato proprietà onhover
  if (this._onhover) {
    $(this.element).on('mouseenter', function() {
      if (!self._enabled) {
        self._showModalHelp();
      }
    });
  }
  this._clearModalHelp(id);
};

proto.getGeometryTypes = function() {
  return this._geometryTypes;
};

proto.getInteraction = function() {
  return this._interaction;
};

proto.isToggled = function() {
  return this._toggled;
};

// funzione per la gestione premuto non premuto
proto.toggle = function(toggle) {
  var toggle = toggle !== undefined ? toggle : !this._toggled;
  //stato del toogle;
  this._toggled = toggle;
  var controlButton = $(this.element).find('button').first();
  if (toggle) {
    this._showModalHelp();
    if (this._interaction) {
      this._interaction.setActive(true);
    }
    controlButton.addClass('g3w-ol-toggled');
  }
  else {
    if (this._interaction) {
      this._interaction.setActive(false);
    }
    controlButton.removeClass('g3w-ol-toggled');
  }
};

// funzione che abilita e disabilita il controllo
proto.setEnable = function(bool) {
  var controlButton = $(this.element).find('button').first();
  if (bool)  {
    controlButton.removeClass('g3w-ol-disabled');
  } else {
    controlButton.addClass('g3w-ol-disabled');
    controlButton.removeClass('g3w-ol-toggled');
    if (this._interaction) {
      this._interaction.setActive(false);
    }
  }
  this._enabled = bool;
};

proto.getEnable = function() {
  return this._enabled;
};

proto.getGeometryTypes = function() {
  return this._geometryTypes;
};

proto.setGeometryTypes = function(types) {
  this._geometryTypes = types;
};

proto.onSelectLayer = function() {
  return this._onSelectLayer;
};

proto.setMap = function(map) {
  if (!this._interaction && this._interactionClass) {
    this._interaction = new this._interactionClass;
    map.addInteraction(this._interaction);
    this._interaction.setActive(false);
  }
  Control.prototype.setMap.call(this,map);
};

proto._handleClick = function(e) {
  if (this._enabled) {
    this.toggle();
    Control.prototype._handleClick.call(this,e);
  }
};

proto.getIteraction = function() {
  return this._interaction;
};


module.exports = InteractionControl;

},{"./control":88}],91:[function(require,module,exports){
var utils = require('../utils');
var LenghtIteraction = require('../interactions/lengthinteraction');
var MeasureControl = require('./measurecontrol');

var LengthControl = function(options) {
  var _options = {
    name: "Lunghezza",
    label: "\ue908",
    interactionClass: LenghtIteraction
  };

  options = utils.merge(options,_options);
  MeasureControl.call(this, options);
};

ol.inherits(LengthControl, MeasureControl);


module.exports = LengthControl;

},{"../interactions/lengthinteraction":104,"../utils":113,"./measurecontrol":92}],92:[function(require,module,exports){
var InteractionControl = require('./interactioncontrol');

var MeasureControl = function(options) {
  this._map = null;
  this._projection = null;
  InteractionControl.call(this, options);
};

ol.inherits(MeasureControl, InteractionControl);

var proto = MeasureControl.prototype;

proto.setMap = function(map) {
  InteractionControl.prototype.setMap.call(this, map);
};

proto.toggle = function(toggle) {
  InteractionControl.prototype.toggle.call(this, toggle);
  if (!this.isToggled()) {
    //vado a fare il clen del measure control che erara stato eventualmente acceso
    // esempio area se attivo su lenght e viceversa
    this.getIteraction().clear();
  }
};

module.exports = MeasureControl;

},{"./interactioncontrol":90}],93:[function(require,module,exports){
var Control = require('./control');
function NominatimControl() {
  var self = this;
  this.options = {
    provider: 'osm',
    placeholder: 'Città, indirizzo ... ',
    targetType: 'text-input',
    lang: 'it-IT',
    limit: 5,
    keepOpen: true,
    preventDefault: false,
    autoComplete: false,
    autoCompleteMinLength: 4,
    debug: false
  };

  var inputQueryId = "gcd-input-query";
  var inputResetId = "gcd-input-reset";
  var cssClasses = {
    "namespace": "ol-geocoder",
    "spin": "gcd-pseudo-rotate",
    "hidden": "gcd-hidden",
    "country": "gcd-country",
    "city": "gcd-city",
    "road": "gcd-road",
    "olControl": "ol-control",
    "glass": {
      "container": "gcd-gl-container",
      "control": "gcd-gl-control",
      "button": "gcd-gl-btn",
      "input": "gcd-gl-input",
      "expanded": "gcd-gl-expanded",
      "reset": "gcd-gl-reset",
      "result": "gcd-gl-result"
    },
    "inputText": {
      "container": "gcd-txt-container",
      "control": "gcd-txt-control",
      "input": "gcd-txt-input",
      "reset": "gcd-txt-reset",
      "icon": "gcd-txt-glass",
      "result": "gcd-txt-result"
    }
  };

  var targetType = {
    GLASS: 'glass-button',
    INPUT: 'text-input'
  };
  var vars = Object.freeze({
    inputQueryId: inputQueryId,
    inputResetId: inputResetId,
    cssClasses: cssClasses,
    default: {
      inputQueryId: inputQueryId,
      inputResetId: inputResetId,
      cssClasses: cssClasses
    }
  });

  var utils = {
    toQueryString: function toQueryString(obj) {
      var this$1 = this;
      return Object.keys(obj).reduce(function (a, k) {
        a.push(
          typeof obj[k] === 'object' ?
            this$1.toQueryString(obj[k]) :
            encodeURIComponent(k) + '=' + encodeURIComponent(obj[k])
        );
        return a;
      }, []).join('&');
    },
    encodeUrlXhr: function encodeUrlXhr(url, data) {
      if(data && typeof data === 'object') {
        var str_data = this.toQueryString(data);
        url += (/\?/.test(url) ? '&' : '?') + str_data;
      }
      return url;
    },
    json: function json(url, data) {
      return $.get(url, data)
      },
    jsonp: function jsonp(url, key, callback) {
        // https://github.com/Fresheyeball/micro-jsonp/blob/master/src/jsonp.js
        var head = document.head,
          script = document.createElement('script'),
          // generate minimally unique name for callback function
          callbackName = 'f' + Math.round(Math.random() * Date.now());

        // set request url
        script.setAttribute('src',
          /*  add callback parameter to the url
           where key is the parameter key supplied
           and callbackName is the parameter value */
          (url + (url.indexOf('?') > 0 ? '&' : '?') + key + '=' + callbackName));

        /*  place jsonp callback on window,
         the script sent by the server should call this
         function as it was passed as a url parameter */
        window[callbackName] = function (json) {
          window[callbackName] = undefined;

          // clean up script tag created for request
          setTimeout(function () {
            head.removeChild(script);
          }, 0);

          // hand data back to the user
          callback(json);
        };

        // actually make the request
        head.appendChild(script);
      },
      now: function now() {
        // Polyfill for window.performance.now()
        // @license http://opensource.org/licenses/MIT
        // copyright Paul Irish 2015
        // https://gist.github.com/paulirish/5438650
        if('performance' in window === false) {
          window.performance = {};
        }

        Date.now = (Date.now || function () {  // thanks IE8
          return new Date().getTime();
        });

        if('now' in window.performance === false) {

          var nowOffset = Date.now();

          if(performance.timing && performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart;
          }

          window.performance.now = function now() {
            return Date.now() - nowOffset;
          };
        }
        return window.performance.now();
      },

      flyTo: function flyTo(map, coord, duration, resolution) {
        resolution = resolution || 2.388657133911758;
        duration = duration || 500;
        var view = map.getView();
        view.animate({duration: duration, resolution: resolution},
          {duration: duration, center: coord});
      },
      randomId: function randomId(prefix) {
        var id = this.now().toString(36);
        return prefix ? prefix + id : id;
      },
      isNumeric: function isNumeric(str) {
        return /^\d+$/.test(str);
      },
      classRegex: function classRegex(classname) {
        return new RegExp(("(^|\\s+) " + classname + " (\\s+|$)"));
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String|Array<String>} classname Class or array of classes.
       * For example: 'class1 class2' or ['class1', 'class2']
       * @param {Number|undefined} timeout Timeout to remove a class.
       */
      addClass: function addClass(element, classname, timeout) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.addClass(each, classname);
          });
          return;
        }

        var array = (Array.isArray(classname))
          ? classname
          : classname.split(/\s+/);
        var i = array.length;

        while (i--) {
          if(!this$1.hasClass(element, array[i])) {
            this$1._addClass(element, array[i], timeout);
          }
        }
      },
      _addClass: function _addClass(el, klass, timeout) {
        var this$1 = this;

        // use native if available
        if(el.classList) {
          el.classList.add(klass);
        } else {
          el.className = (el.className + ' ' + klass).trim();
        }

        if(timeout && this.isNumeric(timeout)) {
          window.setTimeout(function () {
            this$1._removeClass(el, klass);
          }, timeout);
        }
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String|Array<String>} classname Class or array of classes.
       * For example: 'class1 class2' or ['class1', 'class2']
       * @param {Number|undefined} timeout Timeout to add a class.
       */
      removeClass: function removeClass(element, classname, timeout) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.removeClass(each, classname, timeout);
          });
          return;
        }

        var array = (Array.isArray(classname))
          ? classname
          : classname.split(/\s+/);
        var i = array.length;

        while (i--) {
          if(this$1.hasClass(element, array[i])) {
            this$1._removeClass(element, array[i], timeout);
          }
        }
      },
      _removeClass: function _removeClass(el, klass, timeout) {
        var this$1 = this;

        if(el.classList) {
          el.classList.remove(klass);
        } else {
          el.className = (el.className.replace(this.classRegex(klass), ' ')).trim();
        }
        if(timeout && this.isNumeric(timeout)) {
          window.setTimeout(function () {
            this$1._addClass(el, klass);
          }, timeout);
        }
      },
      /**
       * @param {Element} element DOM node.
       * @param {String} classname Classname.
       * @return {Boolean}
       */
      hasClass: function hasClass(element, c) {
        // use native if available
        return element.classList
          ? element.classList.contains(c)
          : this.classRegex(c).test(element.className);
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String} classname Classe.
       */
      toggleClass: function toggleClass(element, classname) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.toggleClass(each, classname);
          });
          return;
        }

        // use native if available
        if(element.classList) {
          element.classList.toggle(classname);
        } else {
          if(this.hasClass(element, classname)) {
            this._removeClass(element, classname);
          } else {
            this._addClass(element, classname);
          }
        }
      },
      /**
       * Abstraction to querySelectorAll for increased
       * performance and greater usability
       * @param {String} selector
       * @param {Element} context (optional)
       * @param {Boolean} find_all (optional)
       * @return (find_all) {Element} : {Array}
       */
      find: function find(selector, context, find_all) {
        if(context === void 0) context = window.document;
        var simpleRe = /^(#?[\w-]+|\.[\w-.]+)$/,
          periodRe = /\./g,
          slice = Array.prototype.slice,
          matches = [];

        // Redirect call to the more performant function
        // if it's a simple selector and return an array
        // for easier usage
        if(simpleRe.test(selector)) {
          switch (selector[0]) {
            case '#':
              matches = [this.$(selector.substr(1))];
              break;
            case '.':
              matches = slice.call(context.getElementsByClassName(
                selector.substr(1).replace(periodRe, ' ')));
              break;
            default:
              matches = slice.call(context.getElementsByTagName(selector));
          }
        } else {
          // If not a simple selector, query the DOM as usual
          // and return an array for easier usage
          matches = slice.call(context.querySelectorAll(selector));
        }
        return (find_all) ? matches : matches[0];
      },
      $: function $(id) {
        id = (id[0] === '#') ? id.substr(1, id.length) : id;
        return document.getElementById(id);
      },
      isElement: function isElement(obj) {
        // DOM, Level2
        if('HTMLElement' in window) {
          return (!!obj && obj instanceof HTMLElement);
        }
        // Older browsers
        return (!!obj && typeof obj === 'object' && obj.nodeType === 1 &&
        !!obj.nodeName);
      },
      getAllChildren: function getAllChildren(node, tag) {
        return [].slice.call(node.getElementsByTagName(tag));
      },
      isEmpty: function isEmpty(str) {
        return (!str || 0 === str.length);
      },
      emptyArray: function emptyArray(array) {
        while (array.length) {
          array.pop();
        }
      },
      anyMatchInArray: function anyMatchInArray(source, target) {
        return source.some(function (each) {
          return target.indexOf(each) >= 0;
        });
      },
      everyMatchInArray: function everyMatchInArray(arr1, arr2) {
        return arr2.every(function (each) {
          return arr1.indexOf(each) >= 0;
        });
      },
      anyItemHasValue: function anyItemHasValue(obj, has) {
        var this$1 = this;
        if(has === void 0) has = false;

        var keys = Object.keys(obj);
        keys.forEach(function (key) {
          if(!this$1.isEmpty(obj[key])) {
            has = true;
          }
        });
        return has;
      },
      removeAllChildren: function removeAllChildren(node) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      },
      removeAll: function removeAll(collection) {
        var node;
        while ((node = collection[0])) {
          node.parentNode.removeChild(node);
        }
      },
      getChildren: function getChildren(node, tag) {
        return [].filter.call(
          node.childNodes, function (el) {
            return tag
              ? el.nodeType === 1 && el.tagName.toLowerCase() === tag
              : el.nodeType === 1;
          }
        );
      },
      template: function template(html, row) {
        var this$1 = this;

        return html.replace(/\{ *([\w_-]+) *\}/g, function (htm, key) {
          var value = (row[key] === undefined) ? '' : row[key];
          return this$1.htmlEscape(value);
        });
      },
      htmlEscape: function htmlEscape(str) {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      },
      /**
       * Overwrites obj1's values with obj2's and adds
       * obj2's if non existent in obj1
       * @returns obj3 a new object based on obj1 and obj2
       */
      mergeOptions: function mergeOptions(obj1, obj2) {
        var obj3 = {};
        for (var attr1 in obj1) {
          obj3[attr1] = obj1[attr1];
        }
        for (var attr2 in obj2) {
          obj3[attr2] = obj2[attr2];
        }
        return obj3;
      },
      createElement: function createElement(node, html) {
        var elem;
        if(Array.isArray(node)) {
          elem = document.createElement(node[0]);

          if(node[1].id) {
            elem.id = node[1].id;
          }
          if(node[1].classname) {
            elem.className = node[1].classname;
          }

          if(node[1].attr) {
            var attr = node[1].attr;
            if(Array.isArray(attr)) {
              var i = -1;
              while (++i < attr.length) {
                elem.setAttribute(attr[i].name, attr[i].value);
              }
            } else {
              elem.setAttribute(attr.name, attr.value);
            }
          }
        } else {
          elem = document.createElement(node);
        }
        elem.innerHTML = html;
        var frag = document.createDocumentFragment();

        while (elem.childNodes[0]) {
          frag.appendChild(elem.childNodes[0]);
        }
        elem.appendChild(frag);
        return elem;
      },
      assert: function assert(condition, message) {
        if(message === void 0) message = 'Assertion failed';

        if(!condition) {
          if(typeof Error !== 'undefined') {
            throw new Error(message);
          }
          throw message; // Fallback
        }
      }
    };

    var klasses = vars.cssClasses;
    var klasses$1 = vars.cssClasses;

  // classe Html //
  var Html = function Html(base) {
    this.options = base.options;
    this.els = this.createControl();
  };

  Html.prototype.createControl = function createControl () {
    var container, containerClass, elements;

    if (this.options.targetType === targetType.INPUT) {
      containerClass = klasses.namespace + ' ' + klasses.inputText.container;
      container = utils.createElement(
        ['div', { classname: containerClass }], Html.input);
      elements = {
        container: container,
        control: utils.find('.' + klasses.inputText.control, container),
        input: utils.find('.' + klasses.inputText.input, container),
        reset: utils.find('.' + klasses.inputText.reset, container),
        result: utils.find('.' + klasses.inputText.result, container)
      };
    } else {
      containerClass = klasses.namespace + ' ' + klasses.glass.container;
      container = utils.createElement(
        ['div', { classname: containerClass }], Html.glass);
      elements = {
        container: container,
        control: utils.find('.' + klasses.glass.control, container),
        button: utils.find('.' + klasses.glass.button, container),
        input: utils.find('.' + klasses.glass.input, container),
        reset: utils.find('.' + klasses.glass.reset, container),
        result: utils.find('.' + klasses.glass.result, container)
      };
    }
    //set placeholder from options
    elements.input.placeholder = this.options.placeholder;
    return elements;
  };

  /* eslint-disable indent */
  Html.glass = [
    '<div class="', klasses.glass.control, ' ', klasses.olControl, '">',
    '<button type="button" class="', klasses.glass.button, '"></button>',
    '<input type="text"',
    ' id="', vars.inputQueryId, '"',
    ' class="', klasses.glass.input, '"',
    ' autocomplete="off" placeholder="Search ...">',
    '<a',
    ' id="', vars.inputResetId, '"',
    ' class="', klasses.glass.reset, ' ', klasses.hidden, '"',
    '></a>',
    '</div>',
    '<ul class="', klasses.glass.result, '"></ul>'
  ].join('');

  Html.input = [
    '<div class="', klasses.inputText.control, '">',
    '<input type="text"',
    ' id="', vars.inputQueryId, '"',
    ' class="', klasses.inputText.input, '"',
    ' autocomplete="off" placeholder="Search ...">',
    '<button type="button" class="btn btn-primary" id="search_nominatim"><i class="fa fa-search" aria-hidden="true"></i></button>',
    '<button type="button"',
    ' id="', vars.inputResetId, '"',
    ' class="', klasses.inputText.reset, ' ', klasses.hidden, '"',
    '></button>',
    '</div>',
    '<ul class="', klasses.inputText.result, '"></ul>'
  ].join('');

  // classe Html fine //

  // classe OpenStreet //

  var OpenStreet = function OpenStreet() {

    this.settings = {
      url: '//nominatim.openstreetmap.org/search/',
      params: {
        q: '',
        format: 'json',
        addressdetails: 1,
        limit: 10,
        countrycodes: 'IT',
        'accept-language': 'it-IT'
      }
    };
  };


  OpenStreet.prototype.getParameters = function getParameters(options) {
    return {
      url: this.settings.url,
      params: {
        q: options.query,
        format: 'json',
        addressdetails: 1,
        limit: options.limit || this.settings.params.limit,
        countrycodes: options.countrycodes || this.settings.params.countrycodes,
        'accept-language': options.lang || this.settings.params['accept-language']
      }
    };
  };

  OpenStreet.prototype.handleResponse = function handleResponse(results) {
    return results.map(function (result) {
      return ({
        lon: result.lon,
        lat: result.lat,
        address: {
          name: result.address.neighbourhood || '',
          road: result.address.road || '',
          postcode: result.address.postcode,
          city: result.address.city || result.address.town,
          state: result.address.state,
          country: result.address.country
        },
        original: {
          formatted: result.display_name,
          details: result.address
        }
      });
    });
  };

  // classe OpenStreet fine //

  // classe Nomitatim //

  var Nominatim = function Nominatim(base, els) {
    this.Base = base;
    this.options = base.options;
    this.options.provider = this.options.provider.toLowerCase();
    this.els = els;
    this.lastQuery = '';
    this.container = this.els.container;
    this.registeredListeners = { mapClick: false };
    this.setListeners();
    this.OpenStreet = new OpenStreet();

  };

  Nominatim.prototype.setListeners = function setListeners () {
    var this$1 = this;
    var timeout, lastQuery;
    var openSearch = function () {
      utils.hasClass(this$1.els.control, klasses$1.glass.expanded) ?
        this$1.collapse() : this$1.expand();
    };
    var query = function (evt) {
      var value = evt.target.value.trim();
      var hit = evt.key ? evt.key === 'Enter' :
        evt.which ? evt.which === 13 :
          evt.keyCode ? evt.keyCode === 13 : false;

      if (hit) {
        evt.preventDefault();
        this$1.query(value);
      }
    };
    var reset = function (evt) {
      this$1.els.input.focus();
      this$1.els.input.value = '';
      this$1.lastQuery = '';
      utils.addClass(this$1.els.reset, klasses$1.hidden);
      this$1.clearResults();
    };
    var handleValue = function (evt) {
      var value = evt.target.value.trim();

      value.length
        ? utils.removeClass(this$1.els.reset, klasses$1.hidden)
        : utils.addClass(this$1.els.reset, klasses$1.hidden);

      if (this$1.options.autoComplete && value !== lastQuery) {
        lastQuery = value;
        timeout && clearTimeout(timeout);
        timeout = setTimeout(function () {
          if (value.length >= this$1.options.autoCompleteMinLength) {
            this$1.query(value);
          }
        }, 200);
      }
    };
    this.els.input.addEventListener('keyup', query, false);
    this.els.input.addEventListener('input', handleValue, false);
    this.els.reset.addEventListener('click', reset, false);
    if (this.options.targetType === targetType.GLASS) {
      this.els.button.addEventListener('click', openSearch, false);
    }
  };

  Nominatim.prototype.query = function query (q) {
    var this$1 = this;
    var ajax = {}, options = this.options;
    var provider = this.getProvider({
      query: q,
      provider: options.provider,
      key: options.key,
      lang: options.lang,
      countrycodes: options.countrycodes,
      limit: options.limit
    });
    if (this.lastQuery === q && this.els.result.firstChild) { return; }
    this.lastQuery = q;
    this.clearResults();
    utils.addClass(this.els.reset, klasses$1.spin);
    ajax.url = document.location.protocol + provider.url;
    ajax.data = provider.params;
    utils.json(ajax)
      .done(function(res) {
        utils.removeClass(this$1.els.reset, klasses$1.spin);
            //will be fullfiled according to provider
            var res_= res.length ? this$1.OpenStreet.handleResponse(res) : undefined;
            this$1.createList(res_);
            if (res_) {
              this$1.listenMapClick();
            }

      })
      .fail(function(error){
        utils.removeClass(this$1.els.reset, klasses$1.spin);
            var li = utils.createElement(
              'li', '<h5>  Il server non risponde</h5>');
            this$1.els.result.appendChild(li);
      })

  };

  Nominatim.prototype.createList = function createList (response) {
    var this$1 = this;
    var ul = this.els.result;
    if (response) {
      response.forEach(function (row) {
        var addressHtml = this$1.addressTemplate(row.address),
          html = ['<a href="#">', addressHtml, '</a>'].join(''),
          li = utils.createElement('li', html);
        li.addEventListener('click', function (evt) {
          evt.preventDefault();
          this$1.chosen(row, addressHtml, row.address, row.original);
        }, false);
        ul.appendChild(li);
      });
    } else {
      li = utils.createElement('li', 'Nessun Risultato');
      ul.appendChild(li);
    }

  };

  Nominatim.prototype.chosen = function chosen(place, addressHtml, addressObj, addressOriginal) {
    var map = this.Base.getMap();
    var coord_ = [parseFloat(place.lon), parseFloat(place.lat)];
    var projection = map.getView().getProjection();
    var coord = ol.proj.transform(coord_, 'EPSG:4326', projection);
    var address = {
      formatted: addressHtml,
      details: addressObj,
      original: addressOriginal
    };
    this.options.keepOpen === false && this.clearResults(true);
    this.Base.dispatchEvent({
      type: 'addresschosen',
      address: address,
      coordinate: coord
    });
  };

  Nominatim.prototype.addressTemplate = function addressTemplate (address) {
    var html = [];
    if (address.name) {
      html.push(['<div class="', klasses$1.road, '">{name}</div>'].join(''));
    }
    if (address.road || address.building || address.house_number) {
      html.push([
        '<div class="', klasses$1.road,
        '">{building} {road} {house_number}</div>'
      ].join(''));
    }
    if (address.city || address.town || address.village) {
      html.push([
        '<div class="', klasses$1.city,
        '">{postcode} {city} {town} {village}</div>'
      ].join(''));
    }
    if (address.state || address.country) {
      html.push([
        '<div class="', klasses$1.country, '">{state} {country}</div>'
      ].join(''));
    }
    return utils.template(html.join('<br>'), address);
  };

  Nominatim.prototype.getProvider = function getProvider (options) {
    return this.OpenStreet.getParameters(options);
  };

  Nominatim.prototype.expand = function expand () {
    var this$1 = this;

    utils.removeClass(this.els.input, klasses$1.spin);
    utils.addClass(this.els.control, klasses$1.glass.expanded);
    window.setTimeout(function () { return this$1.els.input.focus(); }, 100);
    this.listenMapClick();
  };

  Nominatim.prototype.collapse = function collapse () {
    this.els.input.value = '';
    this.els.input.blur();
    utils.addClass(this.els.reset, klasses$1.hidden);
    utils.removeClass(this.els.control, klasses$1.glass.expanded);
    this.clearResults();
  };

  Nominatim.prototype.listenMapClick = function listenMapClick () {
    // already registered
    if (this.registeredListeners.mapClick) { return; }

    var this_ = this;
    var mapElement = this.Base.getMap().getTargetElement();
    this.registeredListeners.mapClick = true;

    //one-time fire click
    mapElement.addEventListener('click', {
      handleEvent: function (evt) {
        this_.clearResults(true);
        mapElement.removeEventListener(evt.type, this, false);
        this_.registeredListeners.mapClick = false;
      }
    }, false);
  };

  Nominatim.prototype.clearResults = function clearResults (collapse) {
    collapse && this.options.targetType === targetType.GLASS ?
      this.collapse() : utils.removeAllChildren(this.els.result);
  };

  Nominatim.prototype.getSource = function getSource () {
    return this.layer.getSource();
  };

  Nominatim.prototype.addLayer = function addLayer () {
    var this$1 = this;

    var found = false;
    var map = this.Base.getMap();

    map.getLayers().forEach(function (layer) {
      if (layer === this$1.layer) { found = true; }
    });
    if (!found) { map.addLayer(this.layer); }
  };

  // classe Nomitatim fine //

  var $html = new Html(this);
  this.container = $html.els.container;
  this.nominatim = new Nominatim(this, $html.els);
  this.layer = this.nominatim.layer;
  Control.call(this, {
    element: this.container,
    name: "nominatim"
  });
}

ol.inherits(NominatimControl, Control);

proto = NominatimControl.prototype;


module.exports = NominatimControl;

},{"./control":88}],94:[function(require,module,exports){
var OLControl = function(options){
  this._control = null;
  this.positionCode = options.position || 'tl';
  
  switch (options.type) {
    case 'zoom':
      this._control = new ol.control.Zoom(options);
      break;
    case 'zoomtoextent':
      this._control = new ol.control.ZoomToExtent(options);
      break;
    case 'scaleline':
      this._control = new ol.control.ScaleLine(options);
      break;
    case 'overview':
      this._control = new ol.control.OverviewMap(options);
  }
  
  $(this._control.element).addClass("ol-control-"+this.positionCode);
  
  ol.control.Control.call(this,{
    element: this._control.element
  });
};

// sotto classe della classe control di OL3
ol.inherits(OLControl, ol.control.Control);
module.exports = OLControl;

var proto = OLControl.prototype;

proto.getPosition = function(positionCode) {
  var positionCode = positionCode || this.positionCode;
  var position = {};
  position['top'] = (positionCode.indexOf('t') > -1) ? true : false;
  position['left'] = (positionCode.indexOf('l') > -1) ? true : false;
  return position;
};

proto.layout = function(map) {
  if (map) {
    var position =  this.getPosition();
    var viewPort = map.getViewport();
    var previusControls = $(viewPort).find('.ol-control-'+this.positionCode);
    if (previusControls.length) {
      previusControl = previusControls.last();
      var previousOffset = position.left ? previusControl.position().left : previusControl.position().right;
      var hWhere = position.left ? 'left' : 'right';
      var previousWidth = previusControl[0].offsetWidth;
      var hOffset = $(this.element).position()[hWhere] + previousOffset + previousWidth + 2;
      $(this.element).css(hWhere,hOffset+'px');
    }
  }
};

proto.setMap = function(map){
  this.layout(map);
  this._control.setMap(map);
};

},{}],95:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var QueryBBoxControl = function(options){
  this._startCoordinate = null;
  var _options = {
    name: "querybbox",
    tipLabel: "Query BBox layer",
    label: "\ue902",
    interactionClass: ol.interaction.DragBox,
    help: '<h4>Guida - Query BBox layer</h4><ul><li>Disegna un rettangolo per interrogare gli strati evidenziati in giallo</li></ul>'
  };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(QueryBBoxControl, InteractionControl);

var proto = QueryBBoxControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });
  this._interaction.on('boxend',function(e){
    var start_coordinate = self._startCoordinate;
    var end_coordinate = e.coordinate;
    var extent = ol.extent.boundingExtent([start_coordinate,end_coordinate]);
    self.dispatchEvent({
      type: 'bboxend',
      extent: extent
    });
    self._startCoordinate = null;
    if (self._autountoggle) {
      self.toggle();
    }
  })
};

module.exports = QueryBBoxControl;

},{"../utils":113,"./interactioncontrol":90}],96:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');

var QueryByPolygonControl = function(options){
  var _options = {
    name: "querybypolygon",
    tipLabel: "Query By Polygon",
    label: "\ue903",
    geometryTypes: ['Polygon', 'MultiPolygon'],
    onselectlayer: true,
    interactionClass: PickCoordinatesInteraction,
    help: '<h4>Guida - Query By Polygon</h4><ul><li>Seleziona uno strato poligonale</li><li>Clicca su una feature dello strato selezionato per lanciare la selezione</li></ul>',
    onhover: true
  };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(QueryByPolygonControl, InteractionControl);

var proto = QueryByPolygonControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });

  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
  this.setEnable(false);
};

module.exports = QueryByPolygonControl;

},{"../interactions/pickcoordinatesinteraction":106,"../utils":113,"./interactioncontrol":90}],97:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');

var QueryControl = function(options){
  var _options = {
    name: "querylayer",
    tipLabel: "Query layer",
    label: "\uea0f",
    interactionClass: PickCoordinatesInteraction
  };
  options = utils.merge(options, _options);
  InteractionControl.call(this, options);
};

ol.inherits(QueryControl, InteractionControl);

var proto = QueryControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });

  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
};

module.exports = QueryControl;

},{"../interactions/pickcoordinatesinteraction":106,"../utils":113,"./interactioncontrol":90}],98:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var ResetControl = function(options){
  this._toggled = true;
  this._startCoordinate = null;
  var _options = {
      name: "reset",
      tipLabel: "Pan",
      label: "\ue901"
    };
  
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);

};

ol.inherits(ResetControl, InteractionControl);

module.exports = ResetControl;

var proto = ResetControl.prototype;

proto._postRender = function(){
  this.toggle(true);
};

},{"../utils":113,"./interactioncontrol":90}],99:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');


var StreetViewControl = function(options) {
  var _options = {
    name: "streetview",
    tipLabel: "StreetView",
    label: "\ue905",
    interactionClass: PickCoordinatesInteraction
  };
  this._sv = null;
  this._panorama = null;
  this._map = null;
  this._projection = null;
  this._streetViewFeature = new ol.Feature();
  this._streetViewFeature.setStyle(style = new ol.style.Style({
    text: new ol.style.Text({
      text: '\ue905',
      font: 'bold 30px icomoon',
      textBaseline: 'Bottom',
      fill: new ol.style.Fill({
        color: '#3c8dbc'
      })
    })
  }));
  var streetVectorSource = new ol.source.Vector({
    features: []
  });

  this._layer = new ol.layer.Vector({
    source: streetVectorSource
  });
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(StreetViewControl, InteractionControl);

var proto = StreetViewControl.prototype;


proto.getLayer = function() {
  return this._layer;
};

proto.setProjection = function(projection) {
  this._projection = projection;
};

proto.setPosition = function(position) {
  var self = this;
  var lnglat;
  var pixel;
  if (!this._sv) {
    this._sv = new google.maps.StreetViewService();
  }
  this._sv.getPanorama({location: position}, function (data) {
    self._panorama = new google.maps.StreetViewPanorama(
      document.getElementById('streetview')
    );
    self._panorama.addListener('position_changed', function() {
      if (self.isToggled()) {
        lnglat = ol.proj.transform([this.getPosition().lng(), this.getPosition().lat()], 'EPSG:4326', self._projection.getCode());
        self._layer.getSource().getFeatures()[0].setGeometry(
          new ol.geom.Point(lnglat)
        );
        pixel = self._map.getPixelFromCoordinate(lnglat);
        if ((pixel[0] + 15) > self._map.getSize()[0] || (pixel[1] + 15) > self._map.getSize()[1] || pixel[0] < 15 || pixel [1] < 15 ) {
          self._map.getView().setCenter(lnglat);
        }
      }
    });
    if (data && data.location) {
      self._panorama.setPov({
        pitch: 0,
        heading: 0
      });
      self._panorama.setPosition(data.location.latLng);
    }
  })
};

proto.setMap = function(map) {
  var self = this;
  this._map = map;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
};

proto.clear = function() {
  this._layer.getSource().clear();
  this._streetViewFeature.setGeometry(null);
};

proto.toggle = function(toggle) {
  InteractionControl.prototype.toggle.call(this, toggle);
  if (!this.isToggled()) {
    this.clear()
  } else {
    this._layer.getSource().addFeatures([this._streetViewFeature]);
  }
};

module.exports = StreetViewControl;

},{"../interactions/pickcoordinatesinteraction":106,"../utils":113,"./interactioncontrol":90}],100:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var ZoomBoxControl = function(options){
  var self = this;
  this._startCoordinate = null;
  var _options = {
      name: "zoombox",
      tipLabel: "Zoom to box",
      label: "\ue901",
      interactionClass: ol.interaction.DragBox
    };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);

};
ol.inherits(ZoomBoxControl, InteractionControl);
module.exports = ZoomBoxControl;

var proto = ZoomBoxControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });
  
  this._interaction.on('boxend',function(e){
    var start_coordinate = self._startCoordinate;
    var end_coordinate = e.coordinate;
    var extent = ol.extent.boundingExtent([start_coordinate,end_coordinate]);
    self.dispatchEvent({
      type: 'zoomend',
      extent: extent
    });
    self._startCoordinate = null;
    if (self._autountoggle) {
      self.toggle();
    }
  });
};


},{"../utils":113,"./interactioncontrol":90}],101:[function(require,module,exports){
var utils = require('./utils');
var maphelpers = require('./map/maphelpers');

(function (name, root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  }
  else if (typeof exports === 'object') {
    module.exports = factory();
  }
  else {
    root[name] = factory();
  }
})('g3wol3', this, function () {
  'use strict';
  
  var helpers = utils.merge({},maphelpers);
  
  return {
    helpers: helpers
  }
});

},{"./map/maphelpers":110,"./utils":113}],102:[function(require,module,exports){
var MeasureInteraction = require('./measureinteraction');

// Area

var AreaIteraction = function() {
  var options = {};
  options.geometryType = "Polygon";
  MeasureInteraction.call(this, options);
};

ol.inherits(AreaIteraction, MeasureInteraction);

module.exports = AreaIteraction;
},{"./measureinteraction":105}],103:[function(require,module,exports){
var DeleteInteractionEvent = function(type, layer, features, coordinate) {
  this.type = type;
  this.features = features;
  this.coordinate = coordinate;
};

var DeleteInteraction = function(options) {
  ol.interaction.Pointer.call(this, {
    handleDownEvent: DeleteInteraction.handleDownEvent_,
    handleMoveEvent: DeleteInteraction.handleMoveEvent_,
    handleUpEvent: DeleteInteraction.handleUpEvent_,
    handleEvent: DeleteInteraction.handleEvent_
  });

  this.previousCursor_ = undefined;
  this.startCursor_ = undefined;
  this.lastCoordinate_ = null;
  this.features_ = options.features !== undefined ? options.features : null;
  this.layer_ = options.layer !== undefined ? options.layer : null;
  this.map_ = null;
};

ol.inherits(DeleteInteraction, ol.interaction.Pointer);

DeleteInteraction.handleEvent_ = function(mapBrowserEvent) {
  if (mapBrowserEvent.type == 'keydown'){
    if(this.features_.getArray().length && mapBrowserEvent.originalEvent.keyCode == 46) {
      // un evento può essere una stringa o un oggetto con un attributo type
      this.dispatchEvent(
          new DeleteInteractionEvent(
              'deleteend',
              this.layer_,
              this.features_,
              event.coordinate));
      return true;
    }
  }
  else {
    return ol.interaction.Pointer.handleEvent.call(this,mapBrowserEvent);
  }
};

DeleteInteraction.handleDownEvent_ = function(event) {
  this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  if (this.lastFeature_) {
    DeleteInteraction.handleMoveEvent_.call(this, event);
    this.dispatchEvent(
            new DeleteInteractionEvent(
                'deleteend',
                this.layer_,
                this.features_,
                event.coordinate));
    return true;
  }
  return false;
};

DeleteInteraction.handleMoveEvent_ = function(event) {
  var self = this;
  this.map_ = event.map;
  var elem = this.map_.getTargetElement();
  if (this.startCursor_ === undefined) {
    this.startCursor_ = elem.style.cursor;
  }
  var intersectingFeature = this.map_.forEachFeatureAtPixel(event.pixel,
      function(feature, layer) {
        // vado a verificare che il layer sia quello in editing in quel momento
        feature = (layer == self.layer_) ? feature : null;
        return feature;
      });
  if (intersectingFeature) {
    this.previousCursor_ = elem.style.cursor;
    elem.style.cursor =  'pointer';

  } else {
    elem.style.cursor = this.previousCursor_ !== undefined ?
        this.previousCursor_ : '';
    this.previousCursor_ = undefined;
  }
};

DeleteInteraction.prototype.featuresAtPixel_ = function(pixel, map) {
  var found = null;
  var intersectingFeature = map.forEachFeatureAtPixel(pixel,
      function(feature) {
        return feature;
      });
  if (this.features_ &&
     _.includes(this.features_.getArray(), intersectingFeature)) {
    found = intersectingFeature;
  }
  return found;
};


DeleteInteraction.prototype.clear = function() {
  var elem;
  if (this.map_) {
    elem = this.map_.getTargetElement();
    elem.style.cursor = this.startCursor_;
  }
};


module.exports = DeleteInteraction;

},{}],104:[function(require,module,exports){
var MeasureInteraction = require('./measureinteraction');

// LenghtInteracion
var LengthIteraction = function() {
  var options = {};
  options.geometryType = "LineString";
  MeasureInteraction.call(this, options)
};

ol.inherits(LengthIteraction, MeasureInteraction);


module.exports = LengthIteraction;
},{"./measureinteraction":105}],105:[function(require,module,exports){
// MeasureInteracion

var MeasureIteraction = function(options) {
  this._helpTooltip;
  this._measureTooltipElement;
  this._measureTooltip;
  this._featureGeometryChangelistener;
  this._poinOnMapMoveListener;

  var measureStyle = new ol.style.Style({
    fill: new ol.style.Fill({
      color: 'rgba(255, 255, 255, 0.2)'
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(0, 0, 0, 0.5)',
      lineDash: [10, 10],
      width: 3
    }),
    image: new ol.style.Circle({
      radius: 5,
      stroke: new ol.style.Stroke({
        color: 'rgba(0, 0, 0, 0.7)'
      }),
      fill: new ol.style.Fill({
        color: 'rgba(255, 255, 255, 0.2)'
      })
    })
  });
  var geometryType = options.geometryType || 'LineString';
  this._formatMeasure = null;
  this._helpMsg = null;
  // funzione che serve per gestire il keydow della cancellazione ultimo vertice disegnato
  this._keyDownEventHandler = null;
  switch (geometryType) {
    case 'LineString':
     this._formatMeasure = function(feature) {
        var length;
        length = Math.round(feature.getLength() * 100) / 100;
        var output;
        if (length > 1000) {
          output = (Math.round(length / 1000 * 1000) / 1000) +
            ' ' + 'km';
        } else {
          output = (Math.round(length * 100) / 100) +
            ' ' + 'm';
        }
        return output;
      };
      this._helpMsg = "Clicca sulla mappa per continuare a disegnare la linea.<br>CANC se si vuole cancellare l'ultimo vertice inserito";
      break;
    case 'Polygon':
      this._formatMeasure = function(feature) {
        var area;
        area = Math.round(feature.getArea() * 100) / 100;
        var output;
        if (area > 1000) {
          output = (Math.round(area / 1000 * 1000) / 1000) +
            ' ' + 'km<sup>2</sup>';
        } else {
          output = (Math.round(area * 100) / 100) +
            ' ' + 'm<sup>2</sup>';
        }
        return output;
      };
      this._helpMsg = "Click per continuare a disegnare il poligono.<br>CANC se si vuole cancellare l'ultimo vertice inserito";
      break;
  }
  var source = new ol.source.Vector();
  this._helpTooltipElement;
  this._map = null;
  this._feature = null;
  this._layer = new ol.layer.Vector({
    source: source,
    style: function(feature) {
      var styles = [
        // linestring
        new ol.style.Style({
          stroke: new ol.style.Stroke({
            lineDash: [10, 10],
            width: 3
          }),
          fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
          })
        })
      ];
      return styles;
    }
  });
  ol.interaction.Draw.call(this, {
    source: source,
    type: geometryType,
    style: measureStyle
  });

  this.set('beforeRemove', this.clear);
  this.set('layer', this._layer);

  // registro gli eventi sulle due interaction
  this.on('drawstart', this._drawStart);
  this.on('drawend', this._drawEnd);

};

ol.inherits(MeasureIteraction, ol.interaction.Draw);


var proto = MeasureIteraction.prototype;

proto.clear = function() {
  this._layer.getSource().clear();
  this._clearMessagesAndListeners();
  if (this._map) {
    this._map.removeOverlay(this._measureTooltip);
    this._map.removeLayer(this._layer);
  }
};

proto._clearMessagesAndListeners = function() {
  this._feature = null;
  // unset tooltip so that a new one can be created
  if (this._map) {
    this._measureTooltipElement = null;
    this._helpTooltipElement.innerHTML = '';
    this._helpTooltipElement.classList.add('hidden');
    ol.Observable.unByKey(this._featureGeometryChangelistener);
    ol.Observable.unByKey(this._poinOnMapMoveListener);
    $(document).off('keydown', this._keyDownEventHandler);
  }
};

proto._removeLastPoint = function(event) {
  var geom = this._feature.getGeometry();
  if (event.keyCode === 46) {
    if( geom instanceof ol.geom.Polygon && geom.getCoordinates()[0].length > 2) {
      this.removeLastPoint();
    } else if(geom instanceof ol.geom.LineString && geom.getCoordinates().length > 1) {
      this.removeLastPoint();
    }
  }
};

//funzione drawStart
proto._drawStart = function(evt) {
  var self = this;
  this._map = this.getMap();
  this._createMeasureTooltip();
  this._createHelpTooltip();
  this._feature = evt.feature;
  this._keyDownEventHandler = _.bind(this._removeLastPoint, this);
  $(document).on('keydown', this._keyDownEventHandler);
  // vado a ripulire tutte le features
  this._layer.getSource().clear();
  this._poinOnMapMoveListener = this._map.on('pointermove', function(evt) {
    if (evt.dragging) {
      return;
    }
    if (self._feature) {
      helpMsg = self._helpMsg;
    }
    self._helpTooltipElement.innerHTML = helpMsg;
    self._helpTooltip.setPosition(evt.coordinate);
    self._helpTooltipElement.classList.remove('hidden');
  });
  var tooltipCoord = evt.coordinate;
  this._featureGeometryChangelistener = this._feature.getGeometry().on('change', function(evt) {
    var geom = evt.target;
    var output;
    if (geom instanceof ol.geom.Polygon) {
      tooltipCoord = geom.getInteriorPoint().getCoordinates();
    } else if (geom instanceof ol.geom.LineString) {
      tooltipCoord = geom.getLastCoordinate();
    }
    output = self._formatMeasure(geom);
    self._measureTooltipElement.innerHTML = output;
    self._measureTooltip.setPosition(tooltipCoord);
  });
};

//funzione drawEnd
proto._drawEnd = function() {
  this._measureTooltipElement.className = 'mtooltip mtooltip-static';
  this._measureTooltip.setOffset([0, -7]);
  this._clearMessagesAndListeners();
  this._map.addLayer(this._layer);
};

/**
 * Creates a new help tooltip
 */
proto._createHelpTooltip = function() {
  if (this._helpTooltipElement) {
    this._helpTooltipElement.parentNode.removeChild(this._helpTooltipElement);
  }
  if (this._helpTooltip) {
    this._map.removeOverlay(this._helpTooltip);
  }
  this._helpTooltipElement = document.createElement('div');
  this._helpTooltipElement.className = 'mtooltip hidden';
  this._helpTooltip = new ol.Overlay({
    element: this._helpTooltipElement,
    offset: [15, 0],
    positioning: 'center-left'
  });
  this._map.addOverlay(this._helpTooltip);
};


/**
 * Creates a new measure tooltip
 */
proto._createMeasureTooltip = function() {
  if (this._measureTooltipElement) {
    this._measureTooltipElement.parentNode.removeChild(this._measureTooltipElement);
  }
  if (this._measureTooltip) {
    this._map.removeOverlay(this._measureTooltip);
  }
  this._measureTooltipElement = document.createElement('div');
  this._measureTooltipElement.className = 'mtooltip mtooltip-measure';
  this._measureTooltip = new ol.Overlay({
    element: this._measureTooltipElement,
    offset: [0, -15],
    positioning: 'bottom-center'
  });
  this._map.addOverlay(this._measureTooltip);
};
// END MEASURE CONTROLS //

module.exports = MeasureIteraction;
},{}],106:[function(require,module,exports){
var PickCoordinatesEventType = {
  PICKED: 'picked'
};

var PickCoordinatesEvent = function(type, coordinate) {
  this.type = type;
  this.coordinate = coordinate;
};

var PickCoordinatesInteraction = function(options) {
  this.previousCursor_ = null;
  
  ol.interaction.Pointer.call(this, {
    handleDownEvent: PickCoordinatesInteraction.handleDownEvent_,
    handleUpEvent: PickCoordinatesInteraction.handleUpEvent_,
    handleMoveEvent: PickCoordinatesInteraction.handleMoveEvent_,
  });
};
ol.inherits(PickCoordinatesInteraction, ol.interaction.Pointer);

PickCoordinatesInteraction.handleDownEvent_ = function(event) {
  return true;
};

PickCoordinatesInteraction.handleUpEvent_ = function(event) {
  this.dispatchEvent(
          new PickCoordinatesEvent(
              PickCoordinatesEventType.PICKED,
              event.coordinate));
  return true;
};

PickCoordinatesInteraction.handleMoveEvent_ = function(event) {
  var elem = event.map.getTargetElement();
  elem.style.cursor =  'pointer';
};

PickCoordinatesInteraction.prototype.shouldStopEvent = function(){
  return false;
};

PickCoordinatesInteraction.prototype.setActive = function(active){
  var map = this.getMap();
  if (map) {
    var elem = map.getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setActive.call(this,active);
};

PickCoordinatesInteraction.prototype.setMap = function(map){
  if (!map) {
    var elem = this.getMap().getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setMap.call(this,map);
};

module.exports = PickCoordinatesInteraction;

},{}],107:[function(require,module,exports){
var PickFeatureEventType = {
  PICKED: 'picked'
};

var PickFeatureEvent = function(type, coordinate, feature) {
  this.type = type;
  this.feature = feature;
  this.coordinate = coordinate;
};

var PickFeatureInteraction = function(options) {

  var self = this;
  ol.interaction.Pointer.call(this, {
    handleDownEvent: PickFeatureInteraction.handleDownEvent_,
    handleUpEvent: PickFeatureInteraction.handleUpEvent_,
    handleMoveEvent: PickFeatureInteraction.handleMoveEvent_
  });
  this.features_ = options.features || null;
  this.layers_ = options.layers || null;
  this.pickedFeature_ = null;
  this.layerFilter_ = function(layer) {
    return _.includes(self.layers_, layer);
  };
};
ol.inherits(PickFeatureInteraction, ol.interaction.Pointer);

PickFeatureInteraction.handleDownEvent_ = function(event) {
  this.pickedFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  return true;
};

PickFeatureInteraction.handleUpEvent_ = function(event) {
  if(this.pickedFeature_){
    this.dispatchEvent(
            new PickFeatureEvent(
                PickFeatureEventType.PICKED,
                event.coordinate,
                this.pickedFeature_));
  }
  return true;
};

PickFeatureInteraction.handleMoveEvent_ = function(event) {
  var elem = event.map.getTargetElement();
  var intersectingFeature = this.featuresAtPixel_(event.pixel, event.map);
  if (intersectingFeature) {
    elem.style.cursor =  'pointer';
  } else {
    elem.style.cursor = '';
  }
};

PickFeatureInteraction.prototype.featuresAtPixel_ = function(pixel, map) {
  var featureFound = null;
  var self = this;
  var intersectingFeature = map.forEachFeatureAtPixel(pixel,
      function(feature) {
        if (self.features_) {
          if (self.features_.indexOf(feature) > -1){
            return feature
          }
          else{
            return null;
          }
        }
        return feature;
      }, {
        layerFilter: self.layerFilter_,
        hitTolerance: (isMobile && isMobile.any) ? 10 : 0
      });
  if (intersectingFeature) {
    featureFound = intersectingFeature;
  }
  return featureFound;
};

PickFeatureInteraction.prototype.shouldStopEvent = function(){
  return false;
};

PickFeatureInteraction.prototype.setMap = function(map){
  if (!map) {
    var elem = this.getMap().getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setMap.call(this,map);
};

module.exports = PickFeatureInteraction;

},{}],108:[function(require,module,exports){
var BaseLayers = {};

BaseLayers.OSM = new ol.layer.Tile({
  source: new ol.source.OSM({
    attributions: [
      new ol.Attribution({
        html: 'All maps &copy; ' +
            '<a href="http://www.openstreetmap.org/">OpenStreetMap</a>'
      }),
      ol.source.OSM.ATTRIBUTION
    ],
    url: 'http://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    crossOrigin: null
  }),
  id: 'osm',
  title: 'OSM',
  basemap: true
});

BaseLayers.BING = {};

BaseLayers.BING.Road = new ol.layer.Tile({
  name:'Road',
  visible: false,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'Road'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

BaseLayers.BING.AerialWithLabels = new ol.layer.Tile({
  name: 'AerialWithLabels',
  visible: true,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'AerialWithLabels'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

BaseLayers.BING.Aerial = new ol.layer.Tile({
  name: 'Aerial',
  visible: false,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'Aerial'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

module.exports = BaseLayers;

},{}],109:[function(require,module,exports){
var utils = require('../utils');
var RasterLayers = {};

RasterLayers.TiledWMSLayer = function(layerObj,extraParams){
  var options = {
    layerObj: layerObj,
    extraParams: extraParams || {},
    tiled: true
  };
  return RasterLayers._WMSLayer(options);
};

RasterLayers.WMSLayer = function(layerObj,extraParams){
  var options = {
    layerObj: layerObj,
    extraParams: extraParams || {}
  };
  return RasterLayers._WMSLayer(options);
};

RasterLayers._WMSLayer = function(options){
  var layerObj = options.layerObj;
  var extraParams = options.extraParams;
  var tiled = options.tiled || false;
  
  var params = {
    LAYERS: layerObj.layers || '',
    VERSION: '1.3.0',
    TRANSPARENT: true,
    SLD_VERSION: '1.1.0'
  };
  
  params = utils.merge(params,extraParams);
  
  var sourceOptions = {
    url: layerObj.url,
    params: params,
    ratio: 1
  };
  
  var imageOptions = {
    id: layerObj.id,
    name: layerObj.name,
    opacity: layerObj.opacity || 1.0,
    visible:layerObj.visible,
    maxResolution: layerObj.maxResolution
  };
  
  var imageClass;
  var source;
  if (tiled) {
    source = new ol.source.TileWMS(sourceOptions);
    imageClass = ol.layer.Tile;
    //imageOptions.extent = [1134867,3873002,2505964,5596944];
  }
  else {
    source = new ol.source.ImageWMS(sourceOptions);
    imageClass = ol.layer.Image;
  }
  
  imageOptions.source = source;
  
  return new imageClass(imageOptions);
};

RasterLayers.XYZLayer = function(options){
  if (!options.url){
    return;
  }

  var sourceOptions = {
    url: options.url
  };

  if (options.projection){
    sourceOptions.projection = options.projection;
  }
  if (options.maxZoom) {
    sourceOptions.maxZoom = options.maxZoom;
  }
  if (options.minZoom) {
    sourceOptions.minZoom = options.minZoom;
  }

  return new ol.layer.Tile({
    source: new ol.source.XYZ(sourceOptions)
  });
};

/*RasterLayers.TiledWMSLayer = function(layerObj){
  var layer = new ol.layer.Tile({
    name: layerObj.name,
    opacity: 1.0,
    source: new ol.source.TileWMS({
      url: layerObj.url,
      params: {
        LAYERS: layerObj.layers || '',
        VERSION: '1.3.0',
        TRANSPARENT: true
      }
    }),
    visible: layerObj.visible
  });
  
  return layer;
};*/

module.exports = RasterLayers;


},{"../utils":113}],110:[function(require,module,exports){
BaseLayers = require('../layers/bases');

var MapHelpers = {
  createViewer: function(opts){
    return new _Viewer(opts);
  }
};

var _Viewer = function(opts){
  var controls = ol.control.defaults({
    attributionOptions: {
      collapsible: false
    },
    zoom: false,
    attribution: false
  });//.extend([new ol.control.Zoom()]);
  
  var interactions = ol.interaction.defaults()
    .extend([
      new ol.interaction.DragRotate()
    ]);
  interactions.removeAt(1);// rimuovo douclickzoom
  
  var view;
  if (opts.view instanceof ol.View) {
    view = opts.view;
  }
  else {
    view = new ol.View(opts.view);
  }
  var options = {
    controls: controls,
    interactions: interactions,
    ol3Logo: false,
    view: view,
    keyboardEventTarget: document
  };
  if (opts.id){
    options.target = opts.id;
  }
  var map  = new ol.Map(options);
  this.map = map;
};

_Viewer.prototype.destroy = function(){
  if (this.map) {
    this.map.dispose();
    this.map = null
  }
};

_Viewer.prototype.getView = function() {
  return this.map.getView();
};

_Viewer.prototype.updateMap = function(mapObject){};

_Viewer.prototype.updateView = function(){};

_Viewer.prototype.getMap = function(){
  return this.map;
};

_Viewer.prototype.setTarget = function(id){
  this.map.setTarget(id);
};

_Viewer.prototype.goTo = function(coordinates, options) {
  var options = options || {};
  var animate = options.animate || true;
  var zoom = options.zoom || false;
  var view = this.map.getView();
  if (animate) {
    var panAnimation = {
      duration: 500,
      center: coordinates
    };
    if (zoom) {
      var zoomAnimation = {
        duration: 500,
        zoom: zoom
      };
    } else {
      var zoomAnimation = {
        duration: 500,
        resolution: view.getResolution()
      };
    }
    view.animate(panAnimation,zoomAnimation);
  } else {
    view.setCenter(coordinates);
    if (zoom) {
      view.setZoom(zoom);
    }
  }
};

_Viewer.prototype.goToRes = function(coordinates, options){
  var options = options || {};
  var animate = options.animate || true;
  var view = this.map.getView();
  var resolution = options.resolution || view.getResolution();
  
  if (animate) {
    var panAnimation = {
      duration: 300,
      center: coordinates
    };
    var zoomAnimation = {
      duration: 300,
      resolution: resolution
    };
    view.animate(panAnimation,zoomAnimation);
  } else {
    view.setCenter(coordinates);
    view.setResolution(resolution);
  }
};

_Viewer.prototype.fit = function(geometry, options){
  var view = this.map.getView();
  
  var options = options || {};
  var animate = options.animate || true;
  
  if (animate) {
    var panAnimation = view.animate({
      duration: 300,
      center: view.getCenter()
    });
    var zoomAnimation = view.animate({
      duration: 300,
      resolution: view.getResolution()
    });
    //this.map.getView().animate(panAnimation,zoomAnimation);
  }
  
  if (options.animate) {
    delete options.animate; // non lo passo al metodo di OL3 perché è un'opzione interna
  }
  options.constrainResolution = options.constrainResolution || true;
  
  view.fit(geometry,this.map.getSize(),options);
};

_Viewer.prototype.getZoom = function(){
  var view = this.map.getView();
  return view.getZoom();
};

_Viewer.prototype.getResolution = function(){
  var view = this.map.getView();
  return view.getResolution();
};

_Viewer.prototype.getCenter = function(){
  var view = this.map.getView();
  return view.getCenter();
};

_Viewer.prototype.getBBOX = function(){
  return this.map.getView().calculateExtent(this.map.getSize());
};

_Viewer.prototype.getLayerByName = function(layerName) {
  var layers = this.map.getLayers();
  var length = layers.getLength();
  for (var i = 0; i < length; i++) {
    if (layerName === layers.item(i).get('name')) {
      return layers.item(i);
    }
  }
  return null;
};

_Viewer.prototype.removeLayerByName = function(layerName){
  var layer = this.getLayerByName(layerName);
  if (layer){
    this.map.removeLayer(layer);
    delete layer;
  }
};

_Viewer.prototype.getActiveLayers = function(){
  var activelayers = [];
  this.map.getLayers().forEach(function(layer) {
    var props = layer.getProperties();
    if (props.basemap != true && props.visible){
       activelayers.push(layer);
    }
  });
  
  return activelayers;
};

_Viewer.prototype.removeLayers = function(){
  this.map.getLayers().clear();
};

_Viewer.prototype.getLayersNoBase = function(){
  var layers = [];
  this.map.getLayers().forEach(function(layer) {
    var props = layer.getProperties();
    if (props.basemap != true){
      layers.push(layer);
    }
  });
  
  return layers;
};

_Viewer.prototype.addBaseLayer = function(type){
  var layer;
  type ? layer = BaseLayers[type]:  layer = BaseLayers.BING.Aerial;
  this.map.addLayer(layer);
};

_Viewer.prototype.changeBaseLayer = function(layerName){
  var baseLayer = this.getLayerByName(layername);
  var layers = this.map.getLayers();
  layers.insertAt(0, baseLayer);
};

module.exports = MapHelpers;

},{"../layers/bases":108}],111:[function(require,module,exports){
var GENERIC_GRID_EXTENT = [0,0,8388608,8388608];

var Projection = function(options) {
  if (!options.crs) {
    return null;
  }

  if (options.proj4def) {
    proj4.defs(options.crs,options.proj4def);
  }

  ol.proj.Projection.call(this, {
    code: options.crs,
    extent: options.extent ? options.extent : GENERIC_GRID_EXTENT
  });

  // riespongo axisOrientation_ perché in OL è prinvata
  this._axisOrientation = options.axisOrientation ? options.axisOrientation : 'enu';
  if (options.proj4def) {
    var proj4def = proj4.defs(options.crs);
    if ( proj4def.axis != undefined) {
      this._axisOrientation = proj4def.axis;
    }
  }

};

ol.inherits(Projection, ol.proj.Projection);

var proto = Projection.prototype;

proto.getAxisOrientation = function() {
  return this._axisOrientation;
};

module.exports = Projection;
},{}],112:[function(require,module,exports){
var Projection = require('./projection');

var STANDARD_PROJECTIONS = [3857,900913,4326];

var Projections = {
  get: function(crs,proj4,extent) {
    crs = Projections.normalizeCrs(crs);
    var _proj =  ol.proj.projections? ol.proj.projections : ol.proj;
    var cachedProjection = _proj.get(crs);

    if (cachedProjection) {
      return cachedProjection;
    }

    var projection = new Projection({
      crs: crs,
      proj4def: proj4,
      extent: extent
    });

    _proj.add ? _proj.add(crs, projection) : _proj.addProjection(projection);

    return projection;
  },
  normalizeCrs: function(crs) {
    if (typeof crs == 'number') {
      return "EPSG:"+crs
    }
    crs = crs.replace(/[^\d\.\-]/g, "");
    if (crs != '') {
      return "EPSG:"+parseInt(crs);
    }
  }
};

module.exports = Projections;
},{"./projection":111}],113:[function(require,module,exports){
var utils = {
  merge: function(obj1,obj2){
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }
}

module.exports = utils;

},{}],114:[function(require,module,exports){
var utils = {
  getExtentForViewAndSize: function(center, resolution, rotation, size) {
    var dx = resolution * size[0] / 2;
    var dy = resolution * size[1] / 2;
    var cosRotation = Math.cos(rotation);
    var sinRotation = Math.sin(rotation);
    var xCos = dx * cosRotation;
    var xSin = dx * sinRotation;
    var yCos = dy * cosRotation;
    var ySin = dy * sinRotation;
    var x = center[0];
    var y = center[1];
    var x0 = x - xCos + ySin;
    var x1 = x - xCos - ySin;
    var x2 = x + xCos - ySin;
    var x3 = x + xCos + ySin;
    var y0 = y - xSin - yCos;
    var y1 = y - xSin + yCos;
    var y2 = y + xSin + yCos;
    var y3 = y + xSin - yCos;
    return [Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3)]
  }
};

module.exports = utils;

},{}],115:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');

function CatalogService() {
  var self = this;
  this.state = {
    prstate: ProjectsRegistry.state,
    highlightlayers: false,
    externallayers:[],
    layerstrees: []
  };
  this.setters = {};
  this.addExternalLayer = function(layer) {
    this.state.externallayers.push(layer);
  };
  this.removeExternalLayer = function(name) {
    var self = this;
    _.forEach(this.state.externallayers, function(layer, index) {
      if (layer.name == name) {
        self.state.externallayers.splice(index, 1);
        return false
      }
    });
  };

  // funzione che verifica se il layerssore aggiunto è addatttao per essere aggiunto
  // al layerstrees del catalogo e quindi visibile come albero dei layer
  this.addLayersStoreToLayersTrees = function(layersStore) {
    this.state.layerstrees.push({
      tree: layersStore.getLayersTree(),
      storeid: layersStore.getId()
    });
  };

  base(this);
  // vado a popolare cosa c'è già
  var layersStores = CatalogLayersStoresRegistry.getLayersStores();
  _.forEach(layersStores, function(layersStore) {
    self.addLayersStoreToLayersTrees(layersStore);
  });

  // resto in ascolto di eventuali layersStore aggiunti
  CatalogLayersStoresRegistry.onafter('addLayersStore', function(layersStore) {
    self.addLayersStoreToLayersTrees(layersStore);
  });

  //registro l'eventuale rimozione del layersSore dal LayersRegistryStore
  CatalogLayersStoresRegistry.onafter('removeLayersStore', function(layersStore) {
    _.forEach(self.state.layerstrees, function(layersTree, idx) {
      if (layersTree.storeid == layersStore.getId()) {
        self.state.layerstrees.splice(idx, 1);
        return false;
      }
    });
  });
  //registro l'eventuale rimozione di tuuti i layersStores dal LayersRegistryStore
  CatalogLayersStoresRegistry.onafter('removeLayersStores', function() {
    _.forEach(self.state.layerstrees, function(layersTree, idx) {
      self.state.layerstrees.splice(idx, 1);
      return false;
    });
  });
}

inherit(CatalogService, G3WObject);

module.exports = CatalogService;

},{"core/catalog/cataloglayersstoresregistry":23,"core/g3wobject":30,"core/project/projectsregistry":74,"core/utils/utils":80}],116:[function(require,module,exports){
module.exports = "<!-- item template -->\n<div id=\"catalog\" @contextmenu.prevent.stop=\"\" class=\"tabbable-panel catalog\">\n  <!--<div class=\"title\">{{ title }}</div>-->\n  <div class=\"tabbable-line\">\n    <ul class=\"nav nav-tabs\" role=\"tablist\">\n      <li role=\"presentation\" class=\"active\" :style=\"{width: hasBaseLayers ? '32%' : '48%'}\"><a href=\"#tree\" aria-controls=\"tree\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"tree\">Data</a></li>\n      <li v-if=\"hasBaseLayers\" role=\"presentation\" style=\"width: 32%\"><a href=\"#baselayers\" aria-controls=\"baselayers\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"baselayers\">Layer Base</a></li>\n      <li role=\"presentation\" :style=\"{width: hasBaseLayers ? '32%' : '48%'}\"><a href=\"#legend\" aria-controls=\"legend\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"legend\">Legenda</a></li>\n    </ul>\n    <div  class=\"tab-content\">\n      <div role=\"tabpanel\" class=\"tab-pane active tree\" id=\"tree\">\n        <ul class=\"tree-root\" v-for=\"_layerstree in state.layerstrees\">\n          <tristate-tree  :highlightlayers=\"state.highlightlayers\" :layerstree=\"layerstree\" class=\"item\" v-for=\"layerstree in _layerstree.tree\" :storeid=\"_layerstree.storeid\" :key=\"layerstree.id\">\n          </tristate-tree>\n        </ul>\n        <!--<ul>\n          <tristate-tree  :externallayers=\"state.externallayers\" :layerstree=\"layerstree\" class=\"item\" v-for=\"layerstree in state.externallayers\" :key=\"layerstree.id\">\n          </tristate-tree>\n        </ul>-->\n      </div>\n      <div v-if=\"hasBaseLayers\" role=\"tabpanel\" class=\"tab-pane baselayers\" id=\"baselayers\">\n        <form>\n          <ul>\n            <li v-if=\"!baselayer.fixed\" v-for=\"baselayer in baselayers\">\n              <div class=\"radio\">\n                <label><input type=\"radio\" name=\"baselayer\" v-checked=\"baselayer.visible\" @click=\"setBaseLayer(baselayer.id)\">{{ baselayer.title }}</label>\n              </div>\n            </li>\n          </ul>\n        </form>\n      </div>\n      <layerslegend v-for=\"_layerstree in state.layerstrees\" :layerstree=\"_layerstree\" :key=\"_layerstree.id\"></layerslegend>\n    </div>\n  </div>\n  <ul id=\"layer-menu\" v-click-outside-layer-menu=\"closeLayerMenu\"  tabindex=\"-1\" v-if=\"layerMenu.show\"  :style=\"{top: layerMenu.top + 'px', left: layerMenu.left + 'px' }\">\n    <li @click.prevent.stop=\"zoomToLayer\"><span class=\"glyphicon glyphicon-search\"> </span> Zoom to Layer</li>\n    <li @click.prevent.stop=\"startEditing\"><span class=\"glyphicon glyphicon-pencil\"> </span> Start Editing</li>\n    <li @click.prevent.stop=\"\" v-if=\"layerMenu.layer.external\" @mouseleave.self=\"showColorMenu(false,$event)\" @mouseover.self=\"showColorMenu(true,$event)\"> Setta/Cambia Colore <i class=\"fa fa-chevron-right\" style=\"padding-left:10px;\" aria-hidden=\"true\"></i>\n      <ul v-if=\"layerMenu.colorMenu.show\" style=\"position:fixed\" :style=\"{ top: layerMenu.colorMenu.top + 'px', left: layerMenu.colorMenu.left +   'px' }\">\n        <li style=\"padding:0;\">\n          <chrome-picker @click.prevent.stop=\"\" v-model=\"layerMenu.colorMenu.color\" @change-color=\"onChangeColor\" style=\"width: 100%\"></chrome-picker>\n        </li>\n      </ul>\n    </li>\n  </ul>\n</div>\n";

},{}],117:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ComponentsRegistry = require('gui/componentsregistry');
var GUI = require('gui/gui');
var ControlsRegistry = require('gui/map/control/registry');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');
var Service = require('../catalogservice');
var ChromeComponent = VueColor.Chrome;
var CatalogEventHub = new Vue();

var vueComponentOptions = {
  template: require('./catalog.html'),
  data: function() {
    return {
      state: null,
      //oggetto per la visualizzazione del contextmenu
      // tasto destro
      layerMenu: {
        show: false,
        top:0,
        left:0,
        name: '',
        layer: null,
        //oggetto colorMenu
        colorMenu: {
          show: false,
          top:0,
          left: 0,
          color: null
        }
      }

    }
  },
  directives: {
    //creo la direttiva per il click fuori dal contextmenu
    'click-outside-layer-menu': {
      bind: function (el, binding, vnode) {
        this.event = function (event) {
          if(!(el == event.target || el.contains(event.target))) {
            vnode.context[binding.expression](event);
          }
        };
        //aggiungo event listener click
        document.body.addEventListener('click', this.event)
      },
      unbind: function (el) {
        document.body.removeEventListener('click', this.event)
      }
    }
  },
  components: {
    'chrome-picker': ChromeComponent
  },
  computed: {
    project: function() {
      return this.state.prstate.currentProject
    },
    title: function() {
      return this.project.state.name;
    },
    baselayers: function(){
      return this.project.state.baselayers;
    },
    hasBaseLayers: function(){
      return this.project.state.baselayers.length>0;
    }
  },
  methods: {
    setBaseLayer: function(id) {
      this.project.setBaseLayer(id);
    },
    zoomToLayer: function() {
      var bbox;
      if (this.layerMenu.layer.bbox) {
        bbox = [this.layerMenu.layer.bbox.minx, this.layerMenu.layer.bbox.miny, this.layerMenu.layer.bbox.maxx, this.layerMenu.layer.bbox.maxy] ;
      }
      var mapService = GUI.getComponent('map').getService();
      mapService.goToBBox(bbox);
      this.layerMenu.show = false;
    },
    startEditing: function() {
      var layer;
      var self = this;
      _.forEach(CatalogLayersStoresRegistry.getLayersStores(), function(layerStore) {
        layer = layerStore.getLayerById(self.layerMenu.layer.id);
        if (layer)
          return false;
      });
      layer.getLayerForEditing();
    },
    closeLayerMenu: function() {
      this.layerMenu.show = false;
      this.showColorMenu(false);
    },
    onChangeColor: function(val) {
      var mapService = GUI.getComponent('map').getService();
      this.layerMenu.colorMenu.color = val;
      var layer = mapService.getLayerByName(this.layerMenu.name);
      layer.setStyle(mapService.setExternalLayerColor(val));
    },
    showColorMenu: function(bool, evt) {
      if(bool) {
        var elem = $(evt.target);
        this.layerMenu.colorMenu.top = elem.offset().top;
        this.layerMenu.colorMenu.left = elem.offset().left + elem.width() + ((elem.outerWidth() - elem.width()) /2);
      }
      this.layerMenu.colorMenu.show = bool;
    }
  },
  mounted: function() {
    var self = this;
    CatalogEventHub.$on('treenodetoogled',function(storeid, node) {
      if (node.external) {
        var mapService = GUI.getComponent('map').getService();
        var layer;
        layer = mapService.getLayerByName(node.name);
        layer.setVisible(!layer.getVisible());
        node.visible = !node.visible;
      } else {
        CatalogLayersStoresRegistry.getLayersStore(storeid).toggleLayer(node.id);
      }
    });

    CatalogEventHub.$on('treenodestoogled',function(storeid, nodes,parentChecked) {
      var layersIds = [];
      function checkNodes(obj) {
        if (obj.nodes) {
          _.forEach(obj.nodes, function(node) {
            checkNodes(node);
          });
        } else {
          layersIds.push(obj.id);
        }
      }
      _.map(nodes,checkNodes);
      CatalogLayersStoresRegistry.getLayersStore(storeid).toggleLayers(layersIds, parentChecked);
    });

    CatalogEventHub.$on('treenodeselected',function(storeid,node) {
      var mapservice = GUI.getComponent('map').getService();
      var layer = CatalogLayersStoresRegistry.getLayersStore(storeid).getLayerById(node.id);
      if (!layer.isSelected()) {
        CatalogLayersStoresRegistry.getLayersStore(storeid).selectLayer(node.id);
        // emetto il segnale layer selezionato dal catalogo
        mapservice.emit('cataloglayerselected', layer);
      } else {
        CatalogLayersStoresRegistry.getLayersStore(storeid).unselectLayer(node.id);
        mapservice.emit('cataloglayerunselected', layer);
      }
    });

    CatalogEventHub.$on('showmenulayer', function(layerstree, evt) {
      self.layerMenu.top = evt.y;
      self.layerMenu.left = evt.x;
      self.layerMenu.name = layerstree.name;
      self.layerMenu.layer = layerstree;
      self.layerMenu.show = true;
      self.layerMenu.colorMenu.color = layerstree.color;
    });

    ControlsRegistry.onafter('registerControl', function(id, control) {
      if (id == 'querybbox') {
        control.getInteraction().on('propertychange', function(evt) {
          if (evt.key == 'active') {
            self.state.highlightlayers=!evt.oldValue;
          }
        })
      }
    });
    $('input:file').filestyle({
      buttonText: "",
      input: false,
      buttonName: "btn-primary",
      iconName: "glyphicon glyphicon-plus"
    });
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);

// se lo voglio usare come componente come elemento html
Vue.component('g3w-catalog', vueComponentOptions);


/* COMPONENTI FIGLI */

// tree component


Vue.component('tristate-tree', {
  template: require('./tristate-tree.html'),
  props: {
    layerstree: {},
    storeid: null,
    //eredito il numero di childs dal parent
    checked: false,
    //highlightlayers: false,
    parentFolder: false,
    externallayers: null
  },
  data: function () {
    return {
      expanded: this.layerstree.expanded,
      parentChecked: !this.checked,
      controltoggled: false,
      n_childs: null
    }
  },
  watch: {
    'checked': function(val) {
      this.layerstree.visible = val;
    }
  },
  computed: {
    isFolder: function () {
      var _visibleChilds = 0;
      var _childsLength = 0;
      (function countLayersVisible(layerstree) {
        _.forEach(layerstree.nodes, function(layer) {
          if (!layer.nodes) _childsLength+=1;
          if (layer.visible) {
            _visibleChilds += 1;
          } else if (layer.nodes) {
            countLayersVisible(layer);
          }
        });
      })(this.layerstree);
      // lo metto qui n_childs perchè nel caso del reload ltiene quello precedente
      this.n_childs = _childsLength;//this.layerstree.nodes ? this.layerstree.nodes.length : 0;
      var isFolder = this.n_childs ? true : false;
      if (isFolder) {
        this.n_parentChilds = this.n_childs - _visibleChilds;
      } 
      return isFolder
    },
    isHidden: function() {
      return this.layerstree.hidden && (this.layerstree.hidden === true);
    },
    selected: function() {
      var isSelected = this.layerstree.selected ? "SI" : "NO";
      return isSelected;
    },
    isHighLight: function() {
      if (this.layerstree.id) {
        // da sostituire con una proprietà precalcolata nello state del layer
        //this.layer = LayersStoresRegistry.getLayersStore().getLayerById(this.layerstree.id);
        //return this.highlightlayers && layer.isWFS() && layer.getProject() && layer.getProject().getProjection() == layer.getProjection();
        //
      }
      return false;
    }

  },
  methods: {
    toggle: function (checkAllLayers) {
      var checkAll = checkAllLayers == 'true' ? true : false;
      if (this.isFolder && !checkAll) {
        this.layerstree.expanded = !this.layerstree.expanded;

      }
      else if (checkAll) {
        if (this.parentChecked && !this.n_parentChilds){
          this.parentChecked = false;
        } else if (this.parentChecked && this.n_parentChilds) {
          this.parentChecked = true;
        }
        else {
          this.parentChecked = !this.parentChecked;
        }
        CatalogEventHub.$emit('treenodestoogled',this.storeid, this.layerstree.nodes, this.parentChecked);
      }
      else {
        CatalogEventHub.$emit('treenodetoogled',this.storeid,this.layerstree);
      }
    },
    select: function () {
      if (!this.isFolder && !this.layerstree.external) {
        CatalogEventHub.$emit('treenodeselected',this.storeid,this.layerstree);
      }
    },
    triClass: function () {
      if (!this.n_parentChilds) {
        return 'fa-check-square-o';
      } else if ((this.n_parentChilds > 0) && (this.n_parentChilds < this.n_childs)) {
        return 'fa-square';
      } else {
        return 'fa-square-o';
      }
    },
    removeExternalLayer: function(name) {
      var mapService = GUI.getComponent('map').getService();
      var layer = mapService.getLayerByName(name);
      mapService.removeExternalLayer(name);
    },
    showLayerMenu: function(layerstree, evt) {
      if (!this.isFolder) {
        CatalogEventHub.$emit('showmenulayer', layerstree, evt);
      }
    }
  }
});

Vue.component('layerslegend',{
    template: require('./legend.html'),
    props: ['layerstree'],
    data: function() {
      return {
        //data qui
      }
    },
    computed: {
      visiblelayers: function(){
        var _visiblelayers = [];
        var layerstree = this.layerstree.tree;
        function traverse(obj){
        _.forIn(obj, function (layer, key) {
              //verifica che il valore dell'id non sia nullo
              if (!_.isNil(layer.id) && layer.visible) {
                  _visiblelayers.push(layer);
              }
              if (!_.isNil(layer.nodes)) {
                  traverse(layer.nodes);
              }
          });
        }
        traverse(layerstree);
        return _visiblelayers;
      }
    },
    watch: {
      'layerstree': {
        handler: function(val, old){
          //codice qui
        },
        deep: true
      }
    },
    mounted: function() {
      Vue.nextTick(function() {
        $('.legend-item').perfectScrollbar();
      });
    }
});

Vue.component('layerslegend-item',{
  template: require('./legend_item.html'),
  props: ['layer'],
  computed: {
    legendurl: function(){
      var self = this;
      var _legendurl;
      _.forEach(CatalogLayersStoresRegistry.getLayersStores(), function(layerStore) {
        if (layerStore.getLayerById(self.layer.id)){
          _legendurl = layerStore.getLayerById(self.layer.id).getLegendUrl();
          return false
        }
      });
      return _legendurl;
    }
  },
  methods: {
    updateLegendScroll: function(evt) {
      $(evt.target).perfectScrollbar('update');
    }
  }
});

/* FINE COMPONENTI FIGLI */

/* INTERFACCIA PUBBLICA */
function CatalogComponent(options) {
  base(this);
  var self = this;
  this.id = "catalog-component";
  this.title = "catalog";
  this.mapComponentId = options.mapcomponentid;
  var service = options.service || new Service;
  this.setService(service);
  this.setInternalComponent(new InternalComponent({
    service: service
  }));
  this.internalComponent.state = this.getService().state;
  function listenToMapVisibility(map) {
    var mapService = map.getService();
    self.state.visible = !mapService.state.hidden;
    mapService.onafter('setHidden',function(hidden) {
      self.state.visible = !mapService.state.hidden;
      self.state.expanded = true;
    })
  }
  if (this.mapComponentId) {
    var map = GUI.getComponent(this.mapComponentId);
    if (!map) {
      ComponentsRegistry.on('componentregistered',function(component){
        if (component.getId() == self.mapComponentId) {
          listenToMapVisibility(component);
        }
      })
    }
    else {
      listenToMapVisibility(map)
    }
  }
  //mergio opzioni con proprità di default del componente
  merge(this, options);
}

inherit(CatalogComponent, Component);

module.exports = CatalogComponent;

},{"../catalogservice":115,"./catalog.html":116,"./legend.html":118,"./legend_item.html":119,"./tristate-tree.html":120,"core/catalog/cataloglayersstoresregistry":23,"core/utils/utils":80,"gui/componentsregistry":122,"gui/gui":132,"gui/map/control/registry":148,"gui/vue/component":182}],118:[function(require,module,exports){
module.exports = "<div role=\"tabpanel\" class=\"tab-pane\" id=\"legend\">\n  <layerslegend-item :layer=\"layer\" v-for=\"layer in visiblelayers\" :key=\"layer.id\"></layerslegend-item>\n</div>\n";

},{}],119:[function(require,module,exports){
module.exports = "  <div class=\"legend-item\" @mouseenter=\"updateLegendScroll($event)\">\n    <img :src=\"legendurl\">\n    <span class=\"divider\"></span>\n  </div>\n";

},{}],120:[function(require,module,exports){
module.exports = "<li class=\"tree-item\" @contextmenu.prevent.stop=\"showLayerMenu(layerstree, $event)\" @click=\"select()\" :class=\"{selected: !isFolder ? layerstree.selected : false, itemmarginbottom: !isFolder }\">\n  <span :class=\"{bold: isFolder, 'fa-chevron-down': layerstree.expanded, 'fa-chevron-right': !layerstree.expanded}\" @click=\"toggle\" v-if=\"isFolder\" class=\"root fa\"></span>\n  <span v-if=\"isFolder\" @click.stop=\"toggle('true')\" :class=\"[triClass()]\" class=\"fa\"></span>\n  <span v-show=\"!layerstree.hidden\" v-else @click.stop=\"toggle\" :class=\"[layerstree.visible  ? 'fa-check-square-o': 'fa-square-o',layerstree.disabled  ? 'disabled': '',  parentFolder ? 'child' : 'root' ]\" class=\"fa checkbox-layer\"></span>\n  <span v-show=\"!layerstree.hidden || isFolder\" class=\"tree-node-title\" :class=\"{bold: isFolder, disabled: layerstree.disabled, highlightlayer: isHighLight }\">{{ layerstree.title }}</span><i v-if=\"layerstree.external\" class=\"glyphicon glyphicon glyphicon-trash link trash pull-right\" @click=\"removeExternalLayer(layerstree.name)\"></i>\n  <ul v-show=\"layerstree.expanded\" v-if=\"isFolder\">\n    <tristate-tree :parentFolder=\"isFolder\" :n_parent-childs=\"n_parentChilds\" :layerstree=\"layerstree\" :storeid=\"storeid\" v-for=\"layerstree in layerstree.nodes\" :key=\"layerstree.id\">\n    </tristate-tree>\n  </ul>\n</li>";

},{}],121:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var merge = require('core/utils/utils').merge;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var VUECOMPONENTSATTRIBUTES = ['methods', 'computed', 'data', 'components'];

// Classe componente base
var Component = function(options) {
  options = options || {};
  // compontente interno vue
  this.internalComponent = null;
  // componenti che faranno parte del template
  this._components = [];
  this.id = options.id || Math.random() * 1000;
  // titolo
  this.title = options.title || '';
  // stato del componente
  this.state = {
    visible: options.visible || true, // visibile
    open: options.open || false // open
  };
  //setters
  this.setters = {
    setOpen: function(bool) {
      this.state.open = bool;
      this._setOpen();
    },
    setVisible: function(bool) {
      this.state.visible = bool;
      this._setVisible();
    },
    reload: function() {
      this._reload();
    }
  };
  // funzione che automatizza l'inizializzazione del componente
  // altimenti ognuno deve ridefinire tutto il flusso ogni volta
  this.init = function(options) {
    options = options || {};
    // lo devo fare per problemi con compoents
    this.vueComponent = this.createVueComponent(options.vueComponentObject);
    this._components = options.components || [];
    // vado a settasre il service
    this.setService(options.service);
    // inizializzo il servizio
    this._service.init ? this._service.init(options): null;
    // setto il template interno
    this.setInternalComponentTemplate(options.template);
    // funzione che permette di settare il componente interno
    this.setInternalComponent = function() {
      var InternalComponent = Vue.extend(this.vueComponent);
      this.internalComponent = new InternalComponent({
        service: this._service,
        template: this.getInternalTemplate()
      });
      // associo lo state del componente interno a quello del service
      // perchè le funzioni che maipolano lo stato del componente sono delegate al service nella
      // maggior parte dei casi
      this.internalComponent.state = this.getService().state;
      this.internalComponent.state.components = this._components;
    };
    this.setInternalComponent();
  };
  base(this);
};

inherit(Component, G3WObject);

var proto = Component.prototype;

// restituisce id del componente
proto.getId = function() {
  return this.id;
};

// setta id del component
proto.setId = function(id) {
  this.id = id;
};

proto.getOpen = function() {
  return this.state.open;
};

proto.getVisible = function() {
  return this.state.visible;
};

// restituice il titolo del componente
proto.getTitle = function() {
  return this.state.title;
};

//setta il titolo del componente
proto.setTitle = function(title) {
  this.state.title = title;
};

//implementati due metodi per poter unificare il metodo di recupero del servizio
//legato al componente
// resituisce il service del componente
proto.getService = function() {
  return this._service;
};

// setta il service del componente
proto.setService = function(service) {
  this._service = service;
};

proto.insertComponentAt = function(index, Component) {
  this._components.splice(index, 0, Component);
};

proto.removeCompomentAt = function(index) {
  this._components.splice(index, 1);
};

proto.addComponent = function(Component) {
  this._components.push(Component);
};

proto.popComponent = function() {
  return this._components.pop();
};


proto.removeComponent = function(Component) {
  var self = this;
  _.forEach(this._components, function(component, index) {
    if (component == Component) {
      self.splice(index, 1);
      return false;
    }
  })
};

proto.setComponents = function(components) {
  this._components = _.isArray(components) ? components: [];
};

proto.exendComponents = function(components) {
  _.merge(this._components, components);
};
// restituisce il componente vue interno
proto.getInternalComponent = function() {
  return this.internalComponent;
};

// setta il nuovo internalcomponent
proto.setInternalComponent = function(internalComponent) {
  if (!internalComponent && this.internalComponentClass) {
    this.internalComponent = new this.internalComponentClass;
  }
  else {
    // internal component è un'istanza e non una classe
    this.internalComponent = internalComponent;
  }
};

// fa un clone deep di un oggetto atto ad essere utilizzato
proto.createVueComponent = function (vueObjOptions) {
  return _.cloneDeep(vueObjOptions);
};

// aggiunge dati all'internalComponent
proto.addInternalComponentData = function(data) {
  _.merge(this.internalComponent, data)
};

// sovrascrive il metodo del service originale con uno nuovo
proto.overwriteServiceMethod = function(methodName, method) {
  this._service[methodName] = method;
};

// sovrascrive i metodi che hanno chiave uguale a quelli presenti nel servizio
proto.overwriteServiceMethods = function(methodsOptions) {
  var self = this;
  _.forEach(methodsOptions, function(method, methodName) {
    self.overwriteServiceMethod(methodName, method);
  })
};

// estendo il servizio con nuovi metodi
proto.extendService = function(serviceOptions) {
  if (this._service) {
    merge(this._service, serviceOptions);
  }
};

// estende in modo generico il vue component
proto.extendInternalComponent = function(internalComponentOptions) {
  var self = this;
  if (this.vueComponent) {
    // faccio il clone altrimenti ho problem con i components
    _.forEach(internalComponentOptions, function(value, key) {
      // verifico che ci sia uno chiame appartenete agli attributi previsti dal compoennte vue
      if (VUECOMPONENTSATTRIBUTES.indexOf(key) > -1) {
        switch (key) {
          case 'methods':
            self.extendInternalComponentMethods(value);
            break;
          case 'components':
            self.extendInternalComponentComponents(value);
            break;
          default:
            merge(self.vueComponent[key], value);
        }
      }
    });
  } else {
    this.vueComponent = internalComponentOptions;
  }
};

//funzione che estende l'attributo components dell'oggetto vue Component
proto.extendInternalComponentComponents = function(components) {
  if (components) {
    merge(this.vueComponent.components, components);
  }
};

// funzione che fa quello che fa sopra ma chiamata in modo più appropriato
proto.extendComponents = function(components) {
  this.extendInternalComponentComponents(components);
};

//funzione che estende l'attributo components dell'oggetto vue Component
proto.addComponent = function(component) {
  if (component) {
    this.vueComponent.components[component.key] = component.value;
  }
};

// estende i methods il vue component
proto.extendInternalComponentMethods = function(methods) {
  if (methods) {
    // ciclo sulle chiavi dell'oggetto per verificare che sia una funzione
    _.forEach(methods, function (value, key) {
      if (!(value instanceof Function)){
        delete methods[key];
      }
    });
    merge(this.vueComponent.methods, methods);
  }
};

// estende i computed del vue component
proto.extendInternalComponentComputed = function(computed) {
  if (computed) {
    // ciclo sulle chiavi dell'oggetto per verificare che sia una funzione
    _.forEach(computed, function (value, key) {
      if (!(value instanceof Function)){
        delete computed[key];
      }
    });
    merge(this.vueComponent.computed, computed);
  }
};

//setto il template del componente vue
proto.setInternalComponentTemplate = function(template) {
  // dovrò poi aggiungere regole per verificare se il
  // tenplate è compatibile ad un template o no
  if (template) {
    this.vueComponent.template = template;
  }
};

// resituisce il template
proto.getInternalTemplate = function() {
  return this.vueComponent.template;
};

////////// fine metodi Service Components //////////
/* HOOKS */
/* 
 * Il metodo permette al componente di montarsi nel DOM
 * parentEl: elemento DOM padre, su cui inserirsi; 
 * ritorna una promise, risolta nel momento in cui sarà terminato il montaggio
*/
proto.mount = function(parent) {};

/*
 * Metodo richiamato quando si vuole rimuovere il componente.
 * Ritorna una promessa che sarà risolta nel momento in cui il componente avrà completato la propria rimozione (ed eventuale rilascio di risorse dipendenti)
*/
proto.unmount = function() {};

proto.ismount = function() {
  return true;
};

// se si vuole usare il componete lo deve ridefinire
// è un hook per eventuali chiamate post pre open
proto._setOpen = function() {
};


// se si vuole usare il componete lo deve ridefinire
proto._setVisible = function() {};


//funzione che dovrà essere sovrascritta dai singoli componenti
proto._reload = function() {
};

/*
 * Metodo (opzionale) che offre l'opportunità di ricalcolare proprietà dipendenti dalle dimensioni del padre
 * parentHeight: nuova altezza del parent
 * parentWidth: nuova larghezza del parent
 * richiamato ogni volta che il parent subisce un ridimensionamento
*/
proto.layout = function(parentWidth, parentHeight) {};


module.exports = Component;

},{"core/g3wobject":30,"core/utils/utils":80}],122:[function(require,module,exports){
var G3WObject = require('core/g3wobject');
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;

//classe Componet Registry (singleton)
// ha lo scopo di salvare tutti i componenti aggiunti
function ComponentsRegistry() {
  // attributo componets che tiene traccia
  // dei componenti registrati
  this.components = {};
  // funzione per refgistrare il componente
  this.registerComponent = function(component) {
    // recupera l'id del componente
    var id = component.getId();
    // se non è stato precedentemente registrato
    if (!this.components[id]) {
      this.components[id] = component;
      this.emit('componentregistered', component);
    }
  }; 
  //funzione che retituisce il componente in base all'id
  this.getComponent = function(id) {
    return this.components[id];
  };

  this.getComponents = function() {
    return this.components;
  };

  // toglie dal registro dei componenti il componete che si vuole eliminare
  this.unregisterComponent = function(id) {
    var component = this._components[id];
    // verifica che sia presente il componete con l'id passato
    if (component) {
      //verifico che estista la funzione destroy dell'oggetto componente
      if (_.isFunction(component.destroy)) {
        // nel caso lo ditruggo (togliendolo anche visivamente)
        component.destroy();
      }
      //elimino il componente e lo setto a null per evitare
      // che se in un secondo momento lo registro di nuovo
      // questa venga ignorato
      delete component;
      this._components[id] = null;
    }
  };
  base(this);
}
inherit(ComponentsRegistry,G3WObject);

module.exports = new ComponentsRegistry;

},{"core/g3wobject":30,"core/utils/utils":80}],123:[function(require,module,exports){
module.exports = "<div class=\"g3w-form-component_body nano\">\n  <form class=\"form-horizontal g3w-form nano-content\">\n    <div class=\"box box-primary\">\n      <div class=\"box-body\">\n        <template v-for=\"(field, index) in state.fields\" v-if=\"reloadLayout(index)\">\n          <component\n            @changeinput=\"changeInput\"\n            @addinput=\"addToValidate\"\n            :state=\"field\"\n            :is=\"field.type+'_input'\">\n          </component>\n        </template>\n      </div>\n    </div>\n  </form>\n</div>\n";

},{}],124:[function(require,module,exports){
var BodyTemplate = require('./body.html');
var Inputs = require('gui/inputs/inputs');

var BodyFormComponent = Vue.extend({
  template: BodyTemplate,
  props: ['state'],
  components: Inputs,
  methods: {
    addToValidate: function(input) {
      // aggiunge l'input da validare
      this.$emit('addtovalidate', input.validate);
    },
    changeInput: function(input) {
      this.$emit('changeinput', input);
    },
    reloadLayout: function(index) {
      if (index == this.state.fields.length - 1) {
        this.$emit('reloadlayout');
      }
      return true
    }
  }
});

module.exports = BodyFormComponent;
},{"./body.html":123,"gui/inputs/inputs":136}],125:[function(require,module,exports){
module.exports = "<div class=\"g3w-form-component_footer\">\n  <div  style=\"margin: 0 auto; width: 100%\">\n    <div class=\"form-group\">\n      <div class=\"col-sm-offset-4 col-sm-8\">\n        <div style=\"margin:10px\">\n          <span>* Campi richiesti</span>\n        </div>\n        <button v-for=\"button in state.buttons\" class=\"btn \" :class=\"[button.class]\" @click.stop.prevent=\"exec(button.cbk)\" v-disabled=\"!btnEnabled(button)\">{{ button.title }}</button>\n      </div>\n    </div>\n  </div>\n</div>";

},{}],126:[function(require,module,exports){
var FooterTemplate = require('./footer.html');
var FooterFormComponent = Vue.extend({
  template: FooterTemplate,
  props: ['state'],
  methods: {
    exec: function(cbk) {
      _.isFunction(cbk) ? cbk(this.state.fields): (function() { return this.state.fields})();
    },
    btnEnabled: function(button) {
      return button.type != 'save' || (button.type == 'save' && this.isValid());
    },
    isValid: function() {
      return this.state.valid
    }
  }
});

module.exports = FooterFormComponent;
},{"./footer.html":125}],127:[function(require,module,exports){
module.exports = "<div class=\"box-header with-border g3w-form-component_header\" style=\"background-color: #ffffff;\">\n  <h3 class=\"box-title\">{{ state.title }}</h3>\n  <div class=\"box-tools pull-right\">\n  </div>\n</div>";

},{}],128:[function(require,module,exports){
var HeaderFormComponent = Vue.extend({
  template: require('./header.html'),
  props: ['state']
});

module.exports = HeaderFormComponent;
},{"./header.html":127}],129:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function FormService() {
  this.state = null;
  this.eventBus = new Vue();
  this.setters = {
    setInitForm: function(options) {
      this._setInitForm(options);
    },
    // setter sul cambio dei campi
    setFormFields: function (fields) {
      this.state.fields = fields;
    },
    setupFields: function() {
      this._setupFields();
    },
    // setter sull'inserimento dei dati del form
    setFormData: function(fields) {
      this.setFormFields(fields);
    },
    // setter del singolo field
    setField: function(field) {},
    // settere dello state
    setState: function(state) {
      this._setState(state);
    },
    // setter sull'aggiunta di un'azione sul form
    addActionsForForm: function (actions) {
      // un opportunità per i listener per aggiungere azioni a form
    },
    postRender: function (element) {
      // un opportunità per i listener di intervenire sul DOM
    }
  };
  // inizializzo il form con l'opzioni passate dall'editor al momento del'apertura del form
  this._setInitForm = function(options) {
    options = options || {};
    this.title = options.title || 'Form';
    this.formId = options.formId;
    this.name = options.name; // nome del form
    this.pk = options.pk || null; // eventuale chiave primaria (non tutti i form potrebbero avercela o averne bisogno
    this.buttons = options.buttons || []; // qui dovrò mettere i bottoni standar del form
    this._pickedPromise = null;
    // setto lo stato che lo divido per compoennti del form totale
    this.state = {
      title: this.title,
      fields: null,
      buttons: this.buttons,
      disabled: false,
      valid: true, // la validazione generale del form inzialmente è a true
        // verrà cambiata con un and generale a true false per ogni modfica dei campi singoli
      tovalidate: [] // contiene array di oggetti che deveono essere validati. Sono oggetti che contengono almeno il campo valid
    };
    //chiamo i setter
    this.setFormFields(options.fields);
  };
  // funzione che mi restituisco lo stato generale del form
  // ogni singolo input, al cambiamento del suo valore, comunicherà se è valido o no
  // e quiesto andrà ad inficiare lo stato generale del form
  this.isValid = function() {
    var bool = true;
    _.forEach(this.state.tovalidate, function(tovalidate) {
      if (!tovalidate.valid) {
        bool = false;
        return false;
      }
    });
    this.state.valid = bool;
  };
  this.addToValidate = function(validate) {
    this.state.tovalidate.push(validate);
  };
  
  this.getState = function () {
    return this.state;
  };
  this._setState = function(state) {
    this.state = state;
  };
  //funzione che retituisce i fields
  this.getFields = function() {
    return this.state.fields;
  };
  
  this._getField = function(fieldName){
    var field = null;
    _.forEach(this.state.fields,function(f){
      if (f.name == fieldName){
        field = f;
      }
    });
    return field;
  };
  
  this.getEventBus = function() {
    return this.eventBus;
  };
  
  // funzione di inzializzazione
  this.init = function(options) {
    this._setInitForm(options);
  };
  
  base(this);
}

// Make the public service en Event Emitter
inherit(FormService, G3WObject);

module.exports = FormService;
},{"core/g3wobject":30,"core/utils/utils":80}],130:[function(require,module,exports){
module.exports = "<div>\n  <component\n    @reloadlayout=\"reloadLayout\"\n    @addtovalidate=\"addToValidate\"\n    @changeinput=\"changeInput\"\n    :state=\"state\"\n    :is=\"component\" v-for=\"component in state.components\">\n  </component>\n</div>";

},{}],131:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var Component = require('gui/vue/component');
var Service = require('../formservice');
var base = require('core/utils/utils').base;
var Template = require('./form.html');
var HeaderFormComponent = require('../components/header/vue/header');
var BodyFormComponent = require('../components/body/vue/body');
var FooterFormComponent = require('../components/footer/vue/footer');


//Definisco l'oggetto che contiene i dati necessari per instanziare un vue component
var vueComponentObject = {
  template: null,
  data: function() {
    return {
      state: null
    }
  },
  transitions: {'addremovetransition': 'showhide'},
  methods: {
    changeInput: function(input) {
      //vado ad emettere un chenge input del body input
      this.$options.service.eventBus.$emit('changeinput', input);
      return this.$options.service.isValid();
    },
    addToValidate: function(validate) {
      this.$options.service.addToValidate(validate);
    },
    // funzione che fa il reload del layout
    reloadLayout: function() {
      var height = $(this.$el).height();
      var width = $(this.$el).width();
      // verifico altezza altrimenti esco
      if (!height)
        return;
      var isHeader = false; // verifco elemento is header
      var isFooter = false; // verifico elemento is footer
      var formElement = $(this.$el).find("div[class*=\"g3w-form-component\"]");
      var externalElement = [];
      var centralElements = [];
      var notBodyElementHeight = 0;
      var centralElementsNumber = 0;
      formElement.each(function() {
        isFooter = $(this).hasClass('g3w-form-component_footer');
        if (!isHeader || isFooter) {
          externalElement.push($(this));
          notBodyElementHeight += $(this).height();
        }
        else {
          if (!$(this).hasClass('g3w-form-component_body'))
            centralElements.push($(this));
          centralElementsNumber += 1;
        }
        isHeader = !isHeader ? $(this).hasClass('g3w-form-component_header') : true;
      });
      // vado a calcolare la possibile altezza del body
      var centralHeight = height - (notBodyElementHeight); // altezza dedidcata alla parte centrale del form
      var heightToAppy = (centralHeight/ centralElementsNumber) - 15; // altezza che possono essere assegnate alle varie parti
      // verifico l'altezza del bosy (se settata
      var bodyElementHeight = $(this.$el).find(".g3w-form-component_body .box-primary").outerHeight() + 20; // prendo l'altezza del bosy
      bodyElementHeight =  bodyElementHeight > heightToAppy ? heightToAppy: bodyElementHeight ; // verifico se è maggiore dell'altezza prevsta
      $(this.$el).find(".g3w-form-component_body").height(bodyElementHeight);
      centralHeight = centralHeight - bodyElementHeight; // ricalcolo l'altezza che devo assegnare alle altre parti in base all'altezza del body
      centralElementsNumber-=1; // tolgo un elemento
      heightToAppy = (centralHeight/ centralElementsNumber) - 15;
      _.forEach(centralElements, function(element) {
        element.height(heightToAppy)
      });
      $(".nano").nanoScroller();
    }
  },
  mounted: function() {
    var self = this;
    this.$options.service.getEventBus().$on('addtovalidate', this.addToValidate);
    this.$nextTick(function() {
      this.reloadLayout();
      self.$options.service.postRender();
    });
  }
};

function FormComponent(options) {
  options = options || {};
  // vado a settare il'id del componente
  options.id = options.id || 'form';
  // qui vado a tenere traccia delle tre cose che mi permettono di customizzare
  // vue component, service e template
  // proprietà necessarie. In futuro le mettermo in una classe Panel
  // da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  base(this, options);
  //settor il service del component (lo istanzio tutte le volte che inizializzo un componente
  options.service = options.service ?  new options.service : new Service;
  options.vueComponentObject = options.vueComponentObject  || vueComponentObject;
  options.template = options.template || Template;
  // qui vado a settare i componenti del form altrimenti setto quelli standard
  options.components = options.components || [HeaderFormComponent, BodyFormComponent, FooterFormComponent];
  // lancio l'inizializzazione del componente
  this.init(options);

  this.addComponentBeforeBody = function(Component) {
    this.insertComponentAt(1, Component);
  };

  this.addComponentAfterBody = function(Component) {
    this.insertComponentAt(2, Component)
  };

  this.addComponentBeforeFooter = function() {
   //TODO
  };

  this.addComponentAfterFooter = function(Component) {
    //TODO
  };
  // Sovrascrivo il metodo mount padre. Viene richiamato dalla toolbar quando
  // il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
  this.mount = function(parent, append) {
    var self = this;
    // richiama il mont padre
    return base(this, 'mount', parent, append)
      // una volta footo il mount
    .then(function() {
      // setto il modale a true
      GUI.setModal(true);
      //vado a validare subito il form
      self.getService().isValid();
    });
  };
  this.layout = function() {
    this.internalComponent.reloadLayout();
  }
}

inherit(FormComponent, Component);

module.exports = FormComponent;


},{"../components/body/vue/body":124,"../components/footer/vue/footer":126,"../components/header/vue/header":128,"../formservice":129,"./form.html":130,"core/utils/utils":80,"gui/gui":132,"gui/vue/component":182}],132:[function(require,module,exports){
var noop = require('core/utils/utils').noop;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var RouterService = require('core/router');
var ComponentsRegistry = require('gui/componentsregistry');

// rappresenta l'interfaccia globale dell'API della GUI. 
// metodi devono essere implementati (definiti) dall'applicazione ospite
// l'app ospite dovrebbe chiamare anche la funzione GUI.ready() quando la UI è pronta
function GUI() {
  this.ready = false;
  // url delle risorse (immagini, ecc.)
  this.getResourcesUrl = noop;
  // show a Vue form
  this.showForm = noop;
  this.closeForm = noop;
  // mostra una lista di oggetti (es. lista di risultati)
  this.showListing = noop;
  this.closeListing = noop;
  this.hideListing = noop;
  // options conterrà i vari dati sui risultati. Sicuramente avrà la prprietà options.features
  // nel caso di queryByLocation avrà anche options.coordinate
  this.showQueryResults = function(options) {};
  this.hideQueryResults = noop;
  /* editing */
  this.showPanel = noop;
  this.hidePanel = noop;
  //metodi componente
  // aggiunge (e registra) un componente in un placeholder del template - Metodo implementato dal template
  this.addComponent = function(component, placeholder) {};
  this.removeComponent = function(id) {};
  // registra globalmente un componente (non legato ad uno specifico placeholder. Es. componente per mostrare risultati interrogazion)
  this.setComponent = function(component) {
    ComponentsRegistry.registerComponent(component);
  };
  // funzione che mi permette di prendere il componente
  // registrato in base al suo id
  this.getComponent = function(id) {
    return ComponentsRegistry.getComponent(id);
  };
  // funzione che prende tutti i componenti registrati
  this.getComponents = function() {
    return ComponentsRegistry.getComponents();
  };
  //fine metodi componente

  this.goto = function(url) {
    RouterService.goto(url);
  };

  this.ready = function(){
    this.emit('ready');
    this.ready = true;
  };
  
  this.guiResized = function() {
    this.emit('guiresized');
  };

  /* spinner */
  this.showSpinner = function(options){};

  this.hideSpinner = function(id){};

  
  this.notify = noop;
  this.dialog = noop;
}

inherit(GUI,G3WObject);

module.exports = new GUI;

},{"core/g3wobject":30,"core/router":78,"core/utils/utils":80,"gui/componentsregistry":122}],133:[function(require,module,exports){
module.exports = "<div class=\"form-group has-feedback\">\n  <slot name=\"inputlabel\">\n    <label :for=\"state.name\" class=\"col-sm-4 control-label\">{{ state.label }}\n      <span v-if=\"state.validate && state.validate.required\">*</span>\n    </label>\n  </slot>\n  <div class=\"col-sm-8\">\n    <slot name=\"inputelement\">\n      <input\n        @keyup=\"change()\"\n        v-disabled=\"!isEditable()\"\n        :field=\"state.name\"\n        class=\"form-control\"\n        v-model=\"state.value\"\n        :class=\"{'input-error-validation' : !state.validate.valid}\"\n        :id=\"state.name\"\n        :placeholder=\"state.input.label\">\n    </slot>\n    <p class=\"error-input-message\">{{ state.validate.message }}</p>\n  </div>\n</div>";

},{}],134:[function(require,module,exports){
// oggetto base per che definisce i metodi comuni per tutti gli inputs
var Service = require('./service');
//Definisco un baseInput object per permetterere all'input di ereditare
// metododi etc .. da questo
var BaseInput = {
  props: ['state'],
  data: function() {
    return {
      // definisco il service per chi non lo sovrascrive
      service: new Service({
        state: this.state // passo lo state
      })
    }
  },
  template: require('./baseinput.html'),
  methods: {
    // metodo che viene scaturito quando cambia il valore dell'input
    change: function() {
      //vado a validare il valore
      this.service.validate();
      // emette il segnale che è cambiato un input
      this.$emit('changeinput', this.state);
    },
    isEditable: function() {
      return this.service.isEditable();
    },
    isVisible: function() {

    }
  },
  // vado a emettere l'evento addinput
  mounted: function() {
    var self = this;
    // setto la proprietà reattiva valid
    Vue.set(this.state.validate, 'valid', true);
    Vue.set(this.state.validate, 'message', null);
    this.change();
    this.$nextTick(function() {
      // emetto il segnale di aggiunta input e passo l'oggetto validate
      self.$emit('addinput', this.state);
    })
  }
};

//vado a definire un componente BaseInput che sarà parte del componente input
var BaseInputComponent = Vue.extend({
  mixins: [BaseInput]
});


module.exports = {
  BaseInput: BaseInput,
  BaseInputComponent: BaseInputComponent
};
},{"./baseinput.html":133,"./service":141}],135:[function(require,module,exports){
var BaseInput = require('./baseinput').BaseInput;
var BaseInputComponent= require('./baseinput').BaseInputComponent;
var Input = {
  props: ['state'],
  mixins: [BaseInput], // eredito dall'oggetto BaseInput
  components: {
    baseinput: BaseInputComponent // definisco il componente BaseInput che mi servirà poi
                                  // come base per modificare la label e l'input element
  }
};

module.exports = Input;
},{"./baseinput":134}],136:[function(require,module,exports){
// rappresenta l'oggetto ponte per raccogliere
// tutti i tipi di inputs. Mi serve per evitare di chiamare
// tutte le volte nel require tutto il percorso

var InputsComponents = {
  'text_input': require('./text/vue/text'),
  'textarea_input': require('./textarea/vue/textarea'),
  'integer_input': require('./integer/vue/integer'),
  'string_input':require('./text/vue/text'), //temporaneo
  'float_input': require('./integer/vue/integer') // temporaneo
};

module.exports = InputsComponents;
},{"./integer/vue/integer":140,"./text/vue/text":142,"./textarea/vue/textarea":143}],137:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Service = require('gui/inputs/service');
var IntegerValidator = require('./validator');

function IntegerService(options) {
  options = options || {};
  options.validator = IntegerValidator;
  base(this, options);
}

inherit(IntegerService, Service);

var proto = IntegerService.prototype;

module.exports = IntegerService;
},{"./validator":138,"core/utils/utils":80,"gui/inputs/service":141}],138:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Validator = require('gui/inputs/validator');

function IntegerValidator() {
  base(this);
  this.validate = function(value) {
    var integer = 1*value;
    return !_.isNaN(integer) ? _.isNumber(1*value) : false;

  } 
}

inherit(IntegerValidator, Validator);

module.exports = new IntegerValidator;
},{"core/utils/utils":80,"gui/inputs/validator":144}],139:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <input\n    @change=\"change\"\n    style=\"width:100%\"\n    v-disabled=\"!isEditable()\"\n    :class=\"{'input-error-validation' : !state.validate.valid}\"\n    v-model=\"state.value\"\n    slot=\"inputelement\"\n    type=\"number\"\n    min=\"0\">\n</baseinput>\n";

},{}],140:[function(require,module,exports){
// oggetto base utilizzato per i mixins
var Input = require('gui/inputs/input');
var Service = require('../service');

var IntegerInput = Vue.extend({
  mixins: [Input],
  data: function() {
    return {
      service: new Service({
        state: this.state
      })
    }
  },
  template: require('./integer.html')
});

module.exports = IntegerInput;
},{"../service":137,"./integer.html":139,"gui/inputs/input":135}],141:[function(require,module,exports){
var Validator = require('./validator');
var t = require('core/i18n/i18n.service').t;
function Service(options) {
  options = options || {};
  this.state = options.state || {};
  // serve il validatore per verificare se è valido il valore inserito
  this._validator = options.validator || new Validator;
}

var proto = Service.prototype;

// rsitutisce lo state
proto.getState = function() {
  return this.state;
};

// setta un eventuale nuovo stato
proto.setState = function(state) {
  this.state = _.isObject(state) ? state : {};
};

// resituisce il validator
proto.getValidator = function() {
  return this._validator;
};

// setta il nuovo validator
proto.setValidator = function(validator) {
  this._validator = validator;
};

// funzione generica che permette di verificare se
// il valore dello state del campo è valido o no
proto.validate = function() {
  if (!_.isEmpty(_.trim(this.state.value)))
    this.state.validate.valid = this._validator.validate(this.state.value);
  else
      this.state.validate.valid = !!!this.state.validate.required;
  this.state.validate.message = this.state.validate.valid ? null : t("input_validation_error")  ;
  return this.state.valid;
};

proto.isEditable = function() {
  return this.state.editable;
};

module.exports = Service;
},{"./validator":144,"core/i18n/i18n.service":33}],142:[function(require,module,exports){
// oggetto base utilizzato per i mixins
var Input = require('gui/inputs/input');

var TextInput = Vue.extend({
  mixins: [Input]
});

module.exports = TextInput;
},{"gui/inputs/input":135}],143:[function(require,module,exports){
// oggetto base utilizzato per i mixins
var Input = require('gui/inputs/input');

var TextAreaInput = Vue.extend({
  mixins: [Input]
});

module.exports = TextAreaInput;
},{"gui/inputs/input":135}],144:[function(require,module,exports){
function InputValidator() {
  this.validate = function() {
    return true; // risponde sempre true
  }
}

module.exports = InputValidator;
},{}],145:[function(require,module,exports){
module.exports = "<div>\n  Lista di oggetti\n</div>\n";

},{}],146:[function(require,module,exports){
var resolve = require('core/utils/utils').resolve;
var reject = require('core/utils/utils').reject;
var GUI = require('gui/gui');
//var MapService = require('core/map/mapservice');

var ListPanelComponent = Vue.extend({
  template: require('./listpanel.html'),
  methods: {
    exec: function(cbk){
      var relations = this.state.relations || null;
      cbk(this.state.fields,relations);
      GUI.closeForm();
    }
  }
});


function ListPanel(options){
  // proprietà necessarie. In futuro le mettermo in una classe Panel da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  this.panelComponent = null;
  this.options =  options || {};
  this.id = options.id || null; // id del form
  this.name = options.name || null; // nome del form
  
  this.state = {
    list: options.list || []
  };
  
  this._listPanelComponent = options.listPanelComponent || ListPanelComponent;
}

var proto = ListPanel.prototype;

// viene richiamato dalla toolbar quando il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
proto.onShow = function(container){
  var panel = this._setupPanel();
  this._mountPanel(panel,container);
  return resolve(true);
};

// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso
proto.onClose = function(){
  this.panelComponent.$destroy(true);
  this.panelComponent = null;
  return resolve(true);
};

proto._setupPanel = function(){
  var panel = this.panelComponent = new this._listPanelComponent({
    panel: this
  });
  panel.state = this.state;
  return panel
};

proto._mountPanel = function(panel,container){
  panel.$mount().$appendTo(container);
};

module.exports = {
  ListPanelComponent: ListPanelComponent,
  ListPanel: ListPanel
};

},{"./listpanel.html":145,"core/utils/utils":80,"gui/gui":132}],147:[function(require,module,exports){
var ResetControl = require('g3w-ol3/src/controls/resetcontrol');
var QueryControl = require('g3w-ol3/src/controls/querycontrol');
var ZoomBoxControl = require('g3w-ol3/src/controls/zoomboxcontrol');
var QueryBBoxControl = require('g3w-ol3/src/controls/querybboxcontrol');
var QueryByPolygonControl = require('g3w-ol3/src/controls/querybypolygoncontrol');
var GeolocationControl = require('g3w-ol3/src/controls/geolocationcontrol');
var StreetViewControl = require('g3w-ol3/src/controls/streetviewcontrol');
var AddLayersControl = require('g3w-ol3/src/controls/addlayers');
var LengthControl = require('g3w-ol3/src/controls/lengthcontrol');
var AreaControl = require('g3w-ol3/src/controls/areacontrol');
var Control = require('g3w-ol3/src/controls/control');
var OLControl = require('g3w-ol3/src/controls/olcontrol');
var NominatimControl = require('g3w-ol3/src/controls/nominatimcontrol');

var ControlsFactory = {
  create: function(options) {
    var control;
    var ControlClass = ControlsFactory.CONTROLS[options.type];
    var layers = options.layers; // opzione che mi server per far visualizzare o meno il controllo
    if (ControlClass) {
      // istanzio il controllo
      control = new ControlClass(options);
    }
    // nel caso siano stati specificati i layers del progetto su cui interrogare
    if (layers && control instanceof Control) {
      // nel caso l'array dei layer è vuoto non visualizzo il controllo
      if (!layers.length) {
        return null
      }
      // ricavo le geometry su cui deve essere fatto i layer
      var controlGeometryTypes = control.getGeometryTypes();
      // imposto il valore iniziale di visible se è un array vuoto vuol dire che non ho specificato nessuna
      // geometria rilevante e quindi deve essere visible
      var visible = (controlGeometryTypes.length) ? false : true;
      _.forEach(layers, function (layer) {
        if (controlGeometryTypes.indexOf(layer.getGeometryType()) > -1) {
          visible = true;
          return false;
        }
      });
      // se visibile allora restituisco il controllo altrimenti null
      if (visible) {
        return control;
      } else {
        return null;
      }
    } else {
      return control;
    }
  }
};

ControlsFactory.CONTROLS = {
  'reset': ResetControl,
  'zoombox': ZoomBoxControl,
  'zoomtoextent': OLControl,
  'query': QueryControl,
  'querybbox': QueryBBoxControl,
  'querybypolygon': QueryByPolygonControl,
  'geolocation': GeolocationControl,
  'streetview': StreetViewControl,
  'zoom': OLControl,
  'scaleline': OLControl,
  'overview': OLControl,
  'nominatim': NominatimControl,
  'addlayers': AddLayersControl,
  'length': LengthControl,
  'area': AreaControl
};

module.exports = ControlsFactory;

},{"g3w-ol3/src/controls/addlayers":86,"g3w-ol3/src/controls/areacontrol":87,"g3w-ol3/src/controls/control":88,"g3w-ol3/src/controls/geolocationcontrol":89,"g3w-ol3/src/controls/lengthcontrol":91,"g3w-ol3/src/controls/nominatimcontrol":93,"g3w-ol3/src/controls/olcontrol":94,"g3w-ol3/src/controls/querybboxcontrol":95,"g3w-ol3/src/controls/querybypolygoncontrol":96,"g3w-ol3/src/controls/querycontrol":97,"g3w-ol3/src/controls/resetcontrol":98,"g3w-ol3/src/controls/streetviewcontrol":99,"g3w-ol3/src/controls/zoomboxcontrol":100}],148:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function ControlsRegistry() {

  this._controls = {};
  this.setters = {
    registerControl : function(id, control) {
      this._registerControl(id, control)
    }
  };

  this._registerControl = function(id, control) {
    this._controls[id] = control;
  };

  this.getControl = function(id) {
    return this._controls[id];
  };

  this.getControls = function() {
    return this._controls;
  };

  this.unregisterControl = function(id) {
    var control = this.getControl(id);
    var mapService = GUI.getComponet('map').getService();
    var map = mapService.getMap();
    if (control) {
      map.removeControl(control);
      delete this._controls[id];
      return true
    }
    return false
  };
  base(this);
}

inherit(ControlsRegistry, G3WObject);

module.exports = new ControlsRegistry;

},{"core/g3wobject":30,"core/utils/utils":80,"gui/gui":132}],149:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var ApplicationService = require('core/applicationservice');
var ProjectsRegistry = require('core/project/projectsregistry');
var Layer = require('core/layers/layer');
var Geometry = require('core/geometry/geometry');
var MapLayersStoreRegistry = require('core/map/maplayersstoresregistry');
var LayersStore = require('core/layers/layersstore');
var Filter = require('core/layers/filter/filter');
var WFSProvider = require('core/layers/providers/wfsprovider');
var ol3helpers = require('g3w-ol3/src/g3w.ol3').helpers;
var WMSLayer = require('core/map/layer/wmslayer');
var XYZLayer = require('core/map/layer/xyzlayer');
var ControlsFactory = require('gui/map/control/factory');
var StreetViewService = require('gui/streetview/streetviewservice');
var ControlsRegistry = require('gui/map/control/registry');


function MapService(options) {
  var self = this;
  this.viewer = null;
  this.target = null;
  this._layersStoresEventKeys = {};
  this.project   = null;
  this._mapControls = [];
  this._mapLayers = [];
  this.mapBaseLayers = {};
  this.layersExtraParams = {};
  this.state = {
      bbox: [],
      resolution: null,
      center: null,
      loading: false,
      hidden: true
  };

  this._greyListenerKey = null;
  this._drawShadow = {
    type: 'coordinate',
    outer: [],
    inner: [],
    scale: null,
    rotation: null
  };
  this.config = options.config || ApplicationService.getConfig();
  this._howManyAreLoading = 0;
  this._incrementLoaders = function(){
    if (this._howManyAreLoading == 0){
      this.emit('loadstart');
      GUI.showSpinner({
        container: $('#map-spinner'),
        id: 'maploadspinner',
        style: 'blue'
      });
    }
    this._howManyAreLoading += 1;
  };
  
  this._decrementLoaders = function(){
    this._howManyAreLoading -= 1;
    if (this._howManyAreLoading == 0){
      this.emit('loadend');
      GUI.hideSpinner('maploadspinner');
    }
  };

  if(!_.isNil(options.project)) {
    this.project = options.project;
  } else {
    this.project = ProjectsRegistry.getCurrentProject();
    ProjectsRegistry.onafter('setCurrentProject',function(project){
      self._removeListeners();
      self.project = project;
      self._setupLayers();
      self._resetView();
    })
  }
  this._setupListeners();
  this._marker = null;

  this.setters = {
    setMapView: function(bbox, resolution, center) {
      this.state.bbox = bbox;
      this.state.resolution = resolution;
      this.state.center = center;
      this.updateMapLayers(this._mapLayers);
    },
    setHidden: function(bool) {
      this.state.hidden = bool;
    },
    setupViewer: function(width,height){
      if (width == 0 || height == 0) {
        return
      }
      if (self.viewer) {
        self.viewer.destroy();
        self.viewer = null;
      }
      self._setupViewer(width, height);
      self.state.bbox = this.viewer.getBBOX();
      self.state.resolution = this.viewer.getResolution();
      self.state.center = this.viewer.getCenter();
      self.setupControls();
      self._setupLayers();
      self.emit('viewerset');
    },
    controlClick: function() {}
  };
  
  this.on('cataloglayerselected', function(layer) {
   if (layer) {
     _.forEach(this._mapControls, function(mapcontrol) {
       if (_.indexOf(_.keysIn(mapcontrol.control), 'onSelectLayer') > -1 && mapcontrol.control.onSelectLayer()) {
         if (mapcontrol.control.getGeometryTypes().indexOf(layer.getGeometryType()) > -1 ) {
           mapcontrol.control.setEnable(true);
         } else {
           mapcontrol.control.setEnable(false);
         }
       }
     })
   }
  });

  this.on('cataloglayerunselected', function(layer) {
    _.forEach(this._mapControls, function(mapcontrol) {
      if (_.indexOf(_.keysIn(mapcontrol.control),'onSelectLayer') > -1 && mapcontrol.control.onSelectLayer()) {
        mapcontrol.control.setEnable(false);
      }
    })
  });

  // vado a registrare gli eventi sui layerstores esistesenti nel registro al momento
  // dell'istanziamaneto del mapService
  _.forEach(MapLayersStoreRegistry.getLayersStores(), function(layerStore) {
    self._setUpEventsKeysToLayersStore(layerStore);
  });

  // sto in ascolto di evantuali aggiunte di layersStore per poter eventualmente
  // aggiungere i suoi layers alla mappa
  MapLayersStoreRegistry.onafter('addLayersStore', function(layerStore) {
    self._setUpEventsKeysToLayersStore(layerStore);
  });
  // sto in ascolto di evantuali aggiunte di layersStore per poter eventualmente
  // aggiungere i suoi layers alla mappa
  MapLayersStoreRegistry.onafter('removeLayersStore', function(layerStore) {
    self._removeEventsKeysToLayersStore(layerStore);
  });
  base(this);
}


inherit(MapService, G3WObject);

var proto = MapService.prototype;

proto.createOlLayer = function(options) {
  options = options || {};
  var id = options.id;
  var geometryType = options.geometryType;
  var color = options.color;
  var style;
  // vado a creare il layer ol per poter essere aggiunto alla mappa
  var olSource = new ol.source.Vector({
    features: new ol.Collection()
  });
  var olLayer = new ol.layer.Vector({
    id: id,
    source: olSource
  });
  switch (geometryType) {
    case 'Point' || 'MultiPoint':
      style = new ol.style.Style({
                image: new ol.style.Circle({
                  radius: 5,
                  fill: new ol.style.Fill({
                    color: color
                  })
                })
              });
      break;
    case 'Line' || 'MultiLine':
      style = new ol.style.Style({
            stroke: new ol.style.Stroke({
              width: 3,
              color: color
            })
          });
      break;
    case 'Polygon' || 'MultiPolygon':
      style =  new ol.style.Style({
            stroke: new ol.style.Stroke({
              color:  color,
              width: 3
            }),
            fill: new ol.style.Fill({
              color: color
            })
          });
      olLayer.setOpacity(0.6);
  }
  olLayer.setStyle(style);
  return olLayer;
};

// rende questo mapservice slave di un altro MapService
proto.slaveOf = function(mapService, sameLayers) {
  // se impostare i layer iniziali uguali a quelli del mapService master
  var sameLayers = sameLayers || false;
};

proto.setLayersExtraParams = function(params,update){
  this.layersExtraParams = _.assign(this.layersExtraParams,params);
  this.emit('extraParamsSet',params,update);
};

proto.getProject = function() {
  return this.project;
};

proto.getMap = function() {
  return this.viewer.map;
};

// funzione che server per definire una proiezione non standard
proto.defineProjection = function(crs) {
  switch(crs) {
    case '3003':
      proj4.defs("EPSG:" + crs, "+proj=tmerc +lat_0=0 +lon_0=9 +k=0.9996 +x_0=1500000 +y_0=0 +ellps=intl +units=m +no_defs");
      break;
  }
};

proto.getProjection = function() {
  return this.project.getProjection();
};

proto.getCrs = function() {
  return this.getProjection().getCode();
};

proto.getViewerElement = function(){
  return this.viewer.map.getTargetElement();
};

proto.getViewport = function(){
  return this.viewer.map.getViewport();
};

proto.getResolution = function() {
  return this.viewer.map.getView().getResolution();
};

proto.getEpsg = function() {
  return this.viewer.map.getView().getProjection().getCode();
};

proto.getGetFeatureInfoUrlForLayer = function(layer,coordinates,resolution,epsg,params) {
  var mapLayer = this.getMapLayerForLayer(layer);
  return mapLayer.getGetFeatureInfoUrl(coordinates,resolution,epsg,params);
};

proto.showMarker = function(coordinates, duration) {
  duration = duration || 1000;
  var self = this;
  this._marker.setPosition(coordinates);
  setTimeout(function(){
    self._marker.setPosition();
  }, duration)
};

// ritorna il layer nella mappa in base al name
proto.getLayerByName = function(name) {
  var map = this.viewer.map;
  var layer = null;
  map.getLayers().forEach(function(lyr) {
    if (lyr.get('name') == name) {
      layer = lyr;
      return false
    }
  });
  return layer;
};

// ritorna il layer della mappa in base all'id
proto.getLayerById = function(id) {
  var layer;
  var map = this.viewer.map;
  map.getLayers().forEach(function(lyr) {
    if (lyr.get('id') == id) {
      layer = lyr;
      return false
    }
  });
  return layer;
};


proto.setupControls = function(){
  var self = this;
  if (this.config && this.config.mapcontrols) {
    _.forEach(this.config.mapcontrols, function(controlType) {
      var control;
      switch (controlType) {
        case 'reset':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
          }
          self.addControl(controlType,control);
          break;
        case 'zoom':
          control = ControlsFactory.create({
            type: controlType,
            zoomInLabel: "\ue98a",
            zoomOutLabel: "\ue98b"
          });
          self.addControl(controlType,control);
          break;
        case 'zoombox':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('zoomend', function (e) {
              self.viewer.fit(e.extent);
            });
            self.addControl(controlType,control);
          }
          break;
        case 'zoomtoextent':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType,
              label: "\ue98c",
              extent: self.project.state.initextent
            });
            self.addControl(controlType,control);
          }
          break;
        case 'query':
          control = ControlsFactory.create({
            type: controlType
          });
          control.on('picked', function(e) {
            var coordinates = e.coordinates;
            // visualizzo il marker per far vederee il punto dove ho cliccato
            self.showMarker(coordinates);
            var showQueryResults = GUI.showContentFactory('query');
            // recupero i layers che hanno le caratteristiche di esserere interrogabili
            var layers = self.getLayers({
              QUERYABLE: true,
              SELECTEDORALL: true
            });
            var queryPromises = [];// raccoglie tutte le promises dei provider del layer
            // ciclo sui layer e per ogni layer chiamo il metodo query
            // passando alcune opzioni)
            _.forEach(layers, function(layer) {
              queryPromises.push(layer.query({
                  coordinates: coordinates,
                  resolution: self.getResolution()
              }))
            });
            //faccio query by location su i layers selezionati o tutti
            var queryResultsPanel = showQueryResults('interrogazione');
            $.when.apply(this, queryPromises)
              .then(function() {
                layersResults = arguments;
                var results = {
                  query: layersResults[0].query,
                  data: []
                };
                _.forEach(layersResults, function(result) {
                  results.data.push(result.data[0]);
                });
                queryResultsPanel.setQueryResponse(results, coordinates, self.state.resolution);
                })
              .fail(function() {
                GUI.notify.error('Si è verificato un errore nella richiesta al server');
                GUI.closeContent();
              })
          });
          self.addControl(controlType,control);
          break;
        case 'querybypolygon':
          var controlLayers = self.getLayers({
            QUERYABLE: true,
            SELECTEDORALL: true
          });
          control = ControlsFactory.create({
            type: controlType,
            layers: controlLayers
          });
          if (control) {

            var showQueryResults = GUI.showContentFactory('query');
            control.on('picked', function (e) {
              var results = {};
              var response = [];
              var queryPromises = [];// raccoglie tutte le promises dei provider del layer
              var geometry;
              var coordinates = e.coordinates;
              var layers = self.getLayers({
                QUERYABLE: true,
                SELECTED: true
              });
              _.forEach(layers, function (layer) {
                queryPromises.push(layer.query({
                  coordinates: coordinates,
                  resolution: self.getResolution()
                }));
              });

              $.when.apply(this, queryPromises)
                .then(function () {
                  queryPromises = [];
                  response = arguments;
                  results = {};
                  // vado ad unificare i rusltati delle promises
                  results.query = response[0].query;
                  var data = [];
                  _.forEach(response, function (result) {
                    data.push(result.data[0]);
                  });
                  results.data = data;
                  if(results && results.data && results.data.length) {
                    geometry = results.data[0].features[0].getGeometry();
                    var filter = new Filter();
                    filter.setGeometry(geometry);
                    var queryLayers = self.getLayers({
                      QUERYABLE: true,
                      ALLNOTSELECTED: true,
                      FILTERABLE: true
                    });
                    _.forEach(queryLayers, function (layer) {
                      queryPromises.push(layer.query({
                          filter: filter
                        })
                      )
                    });

                    self.highlightGeometry(geometry);
                    var queryResultsPanel = showQueryResults('interrogazione');
                    $.when.apply(this, queryPromises)
                      .then(function () {
                        layersResults = arguments;
                        var results = {
                          query: layersResults[0].query,
                          data: []
                        };
                        _.forEach(layersResults, function(result) {
                          results.data.push(result.data[0]);
                        });
                        queryResultsPanel.setQueryResponse(results, geometry, self.state.resolution);
                      })
                      .fail(function () {
                        GUI.notify.error('Si è verificato un errore nella richiesta al server');
                        GUI.closeContent();
                      })
                      .always(function () {
                        self.clearHighlightGeometry();
                      });
                  }
                })
                .fail(function () {
                  GUI.notify.error('Si è verificato un errore nella richiesta al server');
                  GUI.closeContent();
                })
            });

            self.addControl(controlType, control);
          }
          break;
        case 'querybbox':
          if (!isMobile.any && self.filterableLayersAvailable()) {
            var controlLayers = self.getLayers({
              QUERYABLE: true,
              SELECTEDORALL: true,
              WFS: true
            });
            control = ControlsFactory.create({
              type: controlType,
              layers: controlLayers
            });
            if (control) {
              control.on('bboxend', function (e) {
                var bbox = e.extent;
                var layers = self.getLayers({
                  QUERYABLE: true,
                  SELECTEDORALL: true,
                  FILTERABLE: true
                });
                var queryPromises = [];// raccoglie tutte le promises dei provider del layer
                _.forEach(layers, function(layer) {
                  var filter = new Filter();
                  filter.setBBOX(bbox);
                  queryPromises.push(layer.query({
                    filter: filter
                  }))
                });
                var showQueryResults = GUI.showContentFactory('query');
                var queryResultsPanel = showQueryResults('interrogazione');
                $.when.apply(this, queryPromises)
                  .then(function() {
                    layersResults = arguments;
                    var results = {
                      query: layersResults[0].query,
                      data: []
                    };
                    _.forEach(layersResults, function(result) {
                      results.data.push(result.data[0]);
                    });
                    queryResultsPanel.setQueryResponse(results, bbox, self.state.resolution);
                  })
                  .fail(function(error) {
                    var msg = 'Si è verificato un errore nella richiesta al server';
                    if (error) {
                      msg += ' '+error;
                    }
                    GUI.notify.error(msg);
                    GUI.closeContent();
                  })
                });
              self.addControl(controlType, control);
            }
          }
          break;
        case 'streetview':
          // streetview
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.setProjection(self.getProjection());
            self.addControl(controlType, control);
            self.on('viewerset', function() {
              self.viewer.map.addLayer(control.getLayer());
            });
            $script("https://maps.googleapis.com/maps/api/js?key=AIzaSyBCHtKGx3yXWZZ7_gwtJKG8a_6hArEFefs",
              function() {
                var position = {
                  lat: null,
                  lng: null
                };
                var streetViewService = new StreetViewService();
                streetViewService.onafter('postRender', function(position) {
                  control.setPosition(position);
                });
                if (control) {
                  control.on('picked', function(e) {
                    var coordinates = e.coordinates;
                    var lonlat = ol.proj.transform(coordinates, self.getProjection().getCode(), 'EPSG:4326');
                    position.lat = lonlat[1];
                    position.lng = lonlat[0];
                    streetViewService.showStreetView(position);
                  });
                  control.on('disabled', function() {
                    if (panorama) {
                      panorama = null;
                    }
                  })
                }
              }
            )
          }
          break;
        case 'scaleline':
          control = ControlsFactory.create({
            type: controlType,
            position: 'br'
          });
          self.addControl(controlType,control);
          break;
        case 'overview':
          if (!isMobile.any) {
            if (!self.config.overviewproject) {
              return
            }
            var overviewProjectGid = self.config.overviewproject.gid;
            if (overviewProjectGid) {
              ProjectsRegistry.getProject(overviewProjectGid)
              .then(function(project) {
                var overViewMapLayers = self.getOverviewMapLayers(project);
                control = ControlsFactory.create({
                  type: controlType,
                  position: 'bl',
                  className: 'ol-overviewmap ol-custom-overviewmap',
                  collapseLabel: $('<span class="glyphicon glyphicon-menu-left"></span>')[0],
                  label: $('<span class="glyphicon glyphicon-menu-right"></span>')[0],
                  collapsed: false,
                  layers: overViewMapLayers,
                  view: new ol.View({
                    projection: self.getProjection()
                  })
                });
                self.addControl(controlType,control);
              });
            }
          }
          break;
        case 'nominatim':
          control = ControlsFactory.create({
            type: controlType
          });
          control.on('addresschosen', function (evt) {
            var coordinate = evt.coordinate;
            var geometry =  new ol.geom.Point(coordinate);
            self.highlightGeometry(geometry);
          });
          self.addControl(controlType,control);
          $('#search_nominatim').click(function() {
            control.nominatim.query($('input.gcd-txt-input').val());
          });
          $('.gcd-txt-result').perfectScrollbar();
          break;
        case 'geolocation':
          // nel caso in cui esista il geolocation control o siamo sul mobile
          if (!isMobile.any) {
            // creo il controllo
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('click', function(evt) {
              self.showMarker(evt.coordinates);
            });
            control.on('error', function(e) {
              GUI.notify.error('Non è possibile calcolare la tua posizione. Si è verificato un errore di connessione al server')
            });
            self.addControl(controlType, control);
          }
          break;
        case 'addlayers':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('addlayer', function() {
              if (!control.getLayersStore()) {
                var layersSore = new LayersStore()
              }
              self.emit('addexternallayer');
            });
            self.addControl(controlType, control);
          }
          break;
        case 'length':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            self.addControl(controlType, control);
          }
          break;
        case 'area':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            self.addControl(controlType, control);
          }
          break;
      }
    });
  }
};

// funzione che recupera i layers dagli stores
proto.getLayers = function(filter) {
  filter = filter || {};
  var mapFilter = {
    GEOLAYER: true,
    HIDDEN: false
  };
  filter = _.merge(filter, mapFilter);
  var layers = [];
  _.forEach(MapLayersStoreRegistry.getLayersStores(), function(layerStore) {
    _.merge(layers, layerStore.getLayers(filter));
  });
  return layers;
};

// verifica se esistono layer filtrabili
proto.filterableLayersAvailable = function() {
  var self = this;
  var layers = this.getLayers({
    QUERYABLE: true,
    FILTERABLE: true,
    SELECTEDORALL: true
  });
  return _.some(layers, function(layer) {
    // nel caso il provider dei filtri sia WFS verifico che sia lo stesso sistema di riferimento del progetto, perché QGIS ancora non supporta riproiezione su WFS
    if (layer.getProvider('filter') instanceof WFSProvider) {
      return layer.getProjection().getCode() == self.project.getLayersStore().getProjection().getCode();
    }
    return true;
  });
};

proto.addControl = function(type, control) {
  var self = this;
  this.viewer.map.addControl(control);
  this._mapControls.push({
    type: type,
    control: control,
    visible: true
  });
  control.on('controlclick', function() {
    self.controlClick();
  });
  // vado a registrare il controllo aggiunto
  ControlsRegistry.registerControl(type, control);
};

// mostra uno dei controlli disponibili (ovvero già istanziati in base alla configurazione)
proto.showControl = function(type) {
  this.showControls([type]);
};

// nasconde uno dei controlli disponibili (ovvero già istanziati in base alla configurazione)
proto.hideControl = function(type) {
  this.hideControls([type]);
};

// come sopra ma per un array di tipi di controlli. Es. mapService.showControls(['zoombox','query'])
proto.showControls = function(types) {
  this.toggleControls(true,types);
};

// come sopra ma per un array di tipi di controlli. Es. mapService.hideControls(['zoombox','query'])
proto.hideControls = function(types) {
 this.toggleControls(false,types);
};

// riattiva tutti i controlli disponibili
proto.showAllControls = function() {
  this.toggleControls(true);
};

// rimuove tutti i controlli
proto.hideAllControls = function() {
  this.toggleControls(false);
};

proto.toggleControls = function(toggle, types) {
  var self = this;
  this._removeControls();
  _.forEach(this._mapControls,function(controlObj){
    if (types) {
      if (types.indexOf(controlObj.type) > -1) {
        controlObj.visible = toggle;
      }
    }
    else {
      controlObj.visible = toggle;
    }
  });
  this._layoutControls();
};

proto._layoutControls = function() {
  var self = this;
  _.forEach(this._mapControls,function(controlObj){
    if (controlObj.visible) {
      self.viewer.map.addControl(controlObj.control);
    }
  })
};

proto.removeControl = function(type) {
  var self = this;
  _.forEach(this._mapControls,function(controlObj, ctrlIdx) {
    if (type == controlObj.type) {
      self._mapControls.splice(ctrlIdx,1);
      self.viewer.map.removeControl(controlObj.control);
      return false;
    }
  })
};

proto._removeControls = function() {
  var self = this;
  _.forEach(this._mapControls,function(controlObj){
    self.viewer.map.removeControl(controlObj.control);
  })
};

proto._unToggleControls = function() {
  _.forEach(this._mapControls,function(controlObj) {
    // verifico che sia un controllo con la funzione is Toggled e se questo è stata settata a true
    if (controlObj.control.isToggled && controlObj.control.isToggled()) {
      controlObj.control.toggle(false);
      GUI.closeContent();
    }
  });

};

proto.addMapLayer = function(mapLayer) {
  this._mapLayers.push(mapLayer);
};

proto.getMapLayers = function() {
  return this._mapLayers;
};

proto.getMapLayerForLayer = function(layer) {
  var mapLayer;
  var multilayerId = 'layer_'+layer.getMultiLayerId();
  _.forEach(this.getMapLayers(), function(_mapLayer) {
    if (_mapLayer.getId() == multilayerId) {
      mapLayer = _mapLayer;
      return false;
    }
  });
  return mapLayer;
};

proto.getProjectLayer = function(layerId) {
  return this.layersstore.getLayerById(layerId);
};

proto._resetView = function() {
  var width = this.viewer.map.getSize()[0];
  var height = this.viewer.map.getSize()[1];
  var extent = this.project.state.extent;
  var maxxRes = ol.extent.getWidth(extent) / width;
  var minyRes = ol.extent.getHeight(extent) / height;
  var maxResolution = Math.max(maxxRes,minyRes) > this.viewer.map.getView().getMaxResolution() ? Math.max(maxxRes,minyRes): this.viewer.map.getView().getMaxResolution();
  var view = new ol.View({
    extent: extent,
    projection: this.viewer.map.getView().getProjection(),
    center: this.viewer.map.getView().getCenter(),
    resolution: this.viewer.map.getView().getResolution(),
    maxResolution: maxResolution
  });
  this.viewer.map.setView(view);
};

// funzione che setta la view basata sulle informazioni del progetto
proto._setupViewer = function(width,height) {
  var self = this;
  var projection = this.getProjection();
  // ricavo l'estensione iniziale del progetto)
  var initextent = self.project.state.initextent;
  // ricavo l'estensione del progetto
  var extent = self.project.state.extent;

  var maxxRes = ol.extent.getWidth(extent) / width;
  var minyRes = ol.extent.getHeight(extent) / height;
  // calcolo la massima risoluzione
  var maxResolution = Math.max(maxxRes,minyRes);

  var initxRes = ol.extent.getWidth(initextent) / width;
  var inityRes = ol.extent.getHeight(initextent) / height;
  var initResolution = Math.max(initxRes,inityRes);

  this.viewer = ol3helpers.createViewer({
    id: this.target,
    view: {
      projection: projection,
      /*center: this.config.initcenter || ol.extent.getCenter(extent),
       zoom: this.config.initzoom || 0,
       extent: this.config.constraintextent || extent,
       minZoom: this.config.minzoom || 0, // default di OL3 3.16.0
       maxZoom: this.config.maxzoom || 28 // default di OL3 3.16.0*/
      center: ol.extent.getCenter(initextent),
      extent: extent,
      //minZoom: 0, // default di OL3 3.16.0
      //maxZoom: 28 // default di OL3 3.16.0
      maxResolution: maxResolution
    }
  });

  if (this.config.background_color) {
    $('#' + this.target).css('background-color', this.config.background_color);
  }

  $(this.viewer.map.getViewport()).prepend('<div id="map-spinner" style="position:absolute;right:0px;"></div>');

  this.viewer.map.getInteractions().forEach(function(interaction){
    self._watchInteraction(interaction);
  });

  this.viewer.map.getInteractions().on('add',function(interaction){
    self._watchInteraction(interaction.element);
  });

  this.viewer.map.getInteractions().on('remove',function(interaction){
    //self._onRemoveInteraction(interaction);
  });

  this.viewer.map.getView().setResolution(initResolution);

  this.viewer.map.on('moveend',function(e) {
    self._setMapView();
  });

  this._marker = new ol.Overlay({
    position: undefined,
    positioning: 'center-center',
    element: document.getElementById('marker'),
    stopEvent: false
  });

  this.viewer.map.addOverlay(this._marker);

  this.emit('ready');
};

proto._removeListeners = function() {

  if (this._setBaseLayerListenerKey) {
    this.project.un('setBaseLayer',this._setBaseLayerListenerKey);
  }
};

// vado a registrare tuti gli ebventi del layersStore
proto._removeEventsKeysToLayersStore = function(layerStore) {
  var self = this;
  var layerStoreId = layerStore.getId();
  if (self._layersStoresEventKeys[layerStoreId]) {
    _.forEach(self._layersStoresEventKeys[layerStoreId], function(eventObj) {
      _.forEach(eventObj, function(eventKey, event) {
        layerStore.un(event, eventKey);
      })
    })
  }
};

// vado a registrare tuti gli eventi del layersStore
proto._setUpEventsKeysToLayersStore = function(layerStore) {
  var self = this;
  var layerStoreId = layerStore.getId();
  if (!this._layersStoresEventKeys[layerStoreId]) {
    this._layersStoresEventKeys[layerStoreId] = [];
    //evento cambio visibilità al layer
    var layerVisibleKey = layerStore.onafter('setLayersVisible', function (layersIds) {
      var mapLayers = _.map(layersIds, function(layerId) {
        var layer = layerStore.getLayerById(layerId);
        return self.getMapLayerForLayer(layer);
      });
      self.updateMapLayers(mapLayers);
    });
    this._layersStoresEventKeys[layerStore.getId()].push({
      setLayersVisible:layerVisibleKey
    });

    //evento aggiunta Layer al layerStore
    var addLayerKey = layerStore.onafter('addLayer', function(layer) {
      if (layer.getType() == 'vector') {
        //creo il layer OL
        var olLayer = self.createOlLayer({
          id: layer.getId(),
          geometryType: layer.getGeometryType(),
          color: layer.getColor()
        });
        // lo aggiungo alla mappa
        self.viewer.map.addLayer(olLayer);
      }
    });

    this._layersStoresEventKeys[layerStore.getId()].push({
      addLayer: addLayerKey
    });

    //evento aggiunta Layer al layerStore
    var removeLayerKey = layerStore.onafter('removeLayer', function (layer) {
      if (layer.getType() == 'vector') {
        var layerId = layer.getId();
        var olLayer = self.getLayerById(layerId);
        // lo aggiungo alla mappa
        self.viewer.map.removeLayer(olLayer);
      }
    });

    this._layersStoresEventKeys[layerStore.getId()].push({
      removeLayer: removeLayerKey
    });
  }
};

proto._setupListeners = function() {
  this._setBaseLayerListenerKey = this.project.onafter('setBaseLayer',function(){
    self.updateMapLayers(self.mapBaseLayers);
  });
};

proto._setupBaseLayers = function(){
  var self = this;
  var baseLayers = self.getLayers({
    BASELAYER: true
  });
  if (!baseLayers.length){
    return;
  }
  this.mapBaseLayers = {};
  _.forEach(baseLayers,function(layer){

    if (layer.isWMS()) {
      var config = {
        url: layer.getWmsUrl(),
        id: layer.state.id,
        tiled: layer.state.tiled
      };
      var mapLayer = new WMSLayer(config);
    }

    else {
      switch(layer.getServerType()){
        case 'OSM':
          var OSMLayer = require('core/map/layer/osmlayer');
          var mapLayer = new OSMLayer({
            id: layer.state.id
          });
          break;
        case 'Bing':
          var BingLayer = require('core/map/layer/binglayer');
          var mapLayer = new BingLayer({
            id: layer.state.id
          });
          break;
      }
    }

    self.addMapLayer(mapLayer);
    self.registerListeners(mapLayer);
    mapLayer.addLayer(layer);
    self.mapBaseLayers[layer.getId()] = mapLayer;
  });

  _.forEach(_.values(this.mapBaseLayers).reverse(),function(mapLayer){
    self.viewer.map.addLayer(mapLayer.getOLLayer());
    mapLayer.update(self.state);
  });
};

proto._setupLayers = function(){
  var self = this;
  this.viewer.removeLayers();
  this._setupBaseLayers();
  this._reset();
  // recupero i layers dai vari layerstore mettendo coem condizione HIDDEN e GEOLAYER
  var layers = this.getLayers();
  //raggruppo per valore del multilayer con chiave valore multilayer
  // e valore array
  var multiLayers = _.groupBy(layers, function(layer){
    return layer.getMultiLayerId();
  });
  //una volta raggruppati per multilayer dove la chiave è il valore del multilayer
  // e il valore è un array di uno o più Layers, distinguo tra layers singoli o multipli e tra layer cachati o non
  _.forEach(multiLayers, function(layers, id) {
    var multilayerId = 'layer_'+id;
    var mapLayer;
    var layer = layers[0];
    if (layers.length == 1 && layer.isCached()) {
      mapLayer = new XYZLayer({
        id: multilayerId,
        projection: self.getProjection()
      });
      self.addMapLayer(mapLayer);
      self.registerListeners(mapLayer);
      mapLayer.addLayer(layer);
    }
    // in casi di multilayers
    else {
      // creo configurazione per costruire il layer wms
      //creo il wms layer
      mapLayer = new WMSLayer({
        // getWMSUrl funzione creata in fase di inizializzazione dell'applicazione
        url: layer.getWmsUrl(),
        id: multilayerId
      }, self.layersExtraParams);
      self.addMapLayer(mapLayer);
      self.registerListeners(mapLayer);
      // lo aggiungo alla lista dei mapLayers
      _.forEach(layers.reverse(), function(sub_layer) {
        // per ogni layer appartenete allo stesso multilayer (è un array)
        // viene aggiunto al mapLayer (WMSLayer) perecedentemente creato
        mapLayer.addLayer(sub_layer);
      });
    }
  });

  // una volta creati tutti i mapLayer apparteneti alla mappa
  _.forEach(this.getMapLayers().reverse(), function(mapLayer) {
    // scorro sui mapLayer (reverse) e aggiungo alla mappa
    self.viewer.map.addLayer(mapLayer.getOLLayer());
    mapLayer.update(self.state, self.layersExtraParams);
  });
  return this.mapLayers;
};

proto.getOverviewMapLayers = function(project) {
  var projectLayers = project.getLayersStore().getLayers({
    VISIBLE: true,
    GEOLAYER: true,
    HIDDEN: false
  });
  

  var multiLayers = _.groupBy(projectLayers,function(layer){
    return layer.getMultiLayerId();
  });
  
  var overviewMapLayers = [];
  _.forEach(multiLayers,function(layers,id){
    var multilayerId = 'overview_layer_'+id;
    var tiled = layers[0].state.tiled;
    var config = {
      url: project.getWmsUrl(),
      id: multilayerId,
      tiled: tiled
    };
    var mapLayer = new WMSLayer(config);
    _.forEach(layers.reverse(),function(layer){
      mapLayer.addLayer(layer);
    });
    overviewMapLayers.push(mapLayer.getOLLayer(true));
  });
  
  return overviewMapLayers.reverse();
};

proto.updateMapLayers = function(mapLayers) {
  var self = this;
  _.forEach(mapLayers, function(mapLayer) {
    mapLayer.update(self.state, self.layersExtraParams);
  })
};
// funzione che registra i listeners sulla creazione del mapLayers
proto.registerListeners = function(mapLayer) {

  var self = this;
  mapLayer.on('loadstart',function(){
    self._incrementLoaders();
  });
  mapLayer.on('loadend',function(){
    self._decrementLoaders(false);
  });
  
  this.on('extraParamsSet',function(extraParams,update){
    if (update) {
      mapLayer.update(this.state,extraParams);
    }
  })
};

proto.setTarget = function(elId){
  this.target = elId;
};

// al momento dell'aggiunta di una iterazione
proto.addInteraction = function(interaction) {
  //vado a fare l'untoggle di tutti i control della mappa
  this._unToggleControls();
  this.viewer.map.addInteraction(interaction);
  interaction.setActive(true);
};

proto.removeInteraction = function(interaction){
  this.viewer.map.removeInteraction(interaction);

};

// emetto evento quando viene attivata un interazione di tipo Pointer
// (utile ad es. per disattivare/riattivare i tool di editing)
proto._watchInteraction = function(interaction) {
  var self = this;
  interaction.on('change:active',function(e) {
    if ((e.target instanceof ol.interaction.Pointer) && e.target.getActive()) {
      self.emit('mapcontrol:active',e.target);
    }
  })
};

proto.goTo = function(coordinates,zoom) {
  var options = {
    zoom: zoom || 6
  };
  this.viewer.goTo(coordinates,options);
};

proto.goToRes = function(coordinates,resolution){
  var options = {
    resolution: resolution
  };
  this.viewer.goToRes(coordinates,options);
};

proto.goToBBox = function(bbox) {
  this.viewer.fit(bbox);
};


proto.goToWGS84 = function(coordinates,zoom){
  var coordinates = ol.proj.transform(coordinates,'EPSG:4326','EPSG:'+this.project.state.crs);
  this.goTo(coordinates,zoom);
};

proto.extentToWGS84 = function(extent){
  return ol.proj.transformExtent(extent,'EPSG:'+this.project.state.crs,'EPSG:4326');
};

proto.getResolutionForMeters = function(meters) {
  var viewport = this.viewer.map.getViewport();
  return meters / Math.max(viewport.clientWidth,viewport.clientHeight);
};

var highlightLayer = null;
var animatingHighlight = false;

proto.highlightGeometry = function(geometryObj,options) {
  var self = this;
  this.clearHighlightGeometry();
  var options = options || {};
  var zoom = (typeof options.zoom == 'boolean') ? options.zoom : true;
  var highlight = (typeof options.highlight == 'boolean') ? options.highlight : true;
  var duration = options.duration || 2000;
  var view = this.viewer.map.getView();
  
  var geometry;
  if (geometryObj instanceof ol.geom.Geometry){
    geometry = geometryObj;
  }
  else {
    var format = new ol.format.GeoJSON;
    geometry = format.readGeometry(geometryObj);
  }

  if (options.fromWGS84) {
    geometry.transform('EPSG:4326','EPSG:'+ProjectService.state.project.crs);
  }
  
  var geometryType = geometry.getType();
  if (zoom) {
    if (geometryType == 'Point' || (geometryType == 'MultiPoint' && geometry.getPoints().length == 1)) {
      var coordinates = geometryType == 'Point' ? geometry.getCoordinates() : geometry.getPoint(0).getCoordinates();
      if (this.project.state.crs != 4326 && this.project.state.crs != 3857) {
        // zoom ad una risoluzione in cui la mappa copra 100m
        var res = this.getResolutionForMeters(100);
        self.goToRes(coordinates,res);
      }
      else {
        zoom = self.viewer.map.getView().getZoom() > 6 ? self.viewer.map.getView().getZoom() : 6;
        self.goTo(coordinates, zoom);
      }
    }
    else {
      this.viewer.fit(geometry,options);
    }
  }

  if (highlight) {
    var feature = new ol.Feature({
      geometry: geometry
    });

    if (!highlightLayer) {
      highlightLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: function(feature){
          var styles = [];
          var geometryType = feature.getGeometry().getType();
          if (geometryType == 'LineString' || geometryType == 'MultiLineString') {
            var style = new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'rgb(255,255,0)',
                width: 4
              })
            });
            styles.push(style);
          }
          else if (geometryType == 'Point' || geometryType == 'MultiPoint') {
            var style = new ol.style.Style({
              image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                  color: 'rgb(255,255,0)'
                })
              }),
              zIndex: Infinity
            });
            styles.push(style);
          } else if (geometryType == 'MultiPolygon' || geometryType == 'Polygon') {
            var style = new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'rgb(255,255,0)',
                width: 4
              }),
              fill: new ol.style.Fill({
                color: 'rgba(255, 255, 0, 0.5)'
              })
            });
            styles.push(style);
          }
          return styles;
        }
      });
      highlightLayer.setMap(this.viewer.map);
    }

    highlightLayer.getSource().clear();
    highlightLayer.getSource().addFeature(feature);

    if (duration) {
      animatingHighlight = true;
      setTimeout(function(){
        highlightLayer.getSource().clear();
        animatingHighlight = false;
      },duration);
    }
  }
};

proto.clearHighlightGeometry = function() {
  if (highlightLayer && ! animatingHighlight) {
    highlightLayer.getSource().clear();
  }
};

proto.refreshMap = function() {
  _.forEach(this._mapLayers, function(wmsLayer) {
    wmsLayer.getOLLayer().getSource().updateParams({"time": Date.now()});
  });
};

// funzione mi server per poter in pratica
// fare l'updatesize della mappa qundo il div che la contine cambia
// in questo modo la mappa non si streccia (chimata dalla viewport)
proto.layout = function(width, height) {
  if (!this.viewer) {
    this.setupViewer(width,height);
  }
  if (this.viewer) {
    this.setHidden((width == 0 || height == 0));
    this.getMap().updateSize();
    this._setMapView();
  }
};

proto._reset = function() {
  this._mapLayers = [];
};


proto.getMapBBOX = function() {
  return this.viewer.getBBOX();
};

proto._setMapView = function() {
  var bbox = this.viewer.getBBOX();
  var resolution = this.viewer.getResolution();
  var center = this.viewer.getCenter();
  this.setMapView(bbox, resolution, center);
};

proto.getMapSize = function() {
  var map = this.viewer.map;
  return map.getSize();
};

proto.setInnerGreyCoverScale = function(scale) {
  this._drawShadow.scale = scale;
};

proto._resetDrawShadowInner = function() {
  this._drawShadow = {
    type: 'coordinate',
    outer: [],
    inner: [],
    scale: null,
    rotation: null
  };
};

proto.setInnerGreyCoverBBox = function(options) {
  var options = options || {};
  var map = this.viewer.map;
  var type = options.type || 'coordinate'; // di solito sollo coordinate
  var inner = options.inner || null;
  var rotation = options.rotation;
  var scale = options.scale;
  var lowerLeftInner;
  var upperRightInner;
  if (inner) {
    switch (type) {
      case 'coordinate':
        lowerLeftInner = map.getPixelFromCoordinate([inner[0], inner[1]]);
        upperRightInner = map.getPixelFromCoordinate([inner[2], inner[3]]);
        break;
      case 'pixel':
        lowerLeftInner = [inner[0], inner[1]];
        upperRightInner = [inner[2], inner[3]];
        break
    }
    var y_min = lowerLeftInner[1] * ol.has.DEVICE_PIXEL_RATIO;
    var x_min = lowerLeftInner[0] * ol.has.DEVICE_PIXEL_RATIO;
    var y_max = upperRightInner[1] * ol.has.DEVICE_PIXEL_RATIO;
    var x_max = upperRightInner[0] * ol.has.DEVICE_PIXEL_RATIO;
    this._drawShadow.inner[0] = x_min;
    this._drawShadow.inner[1] = y_min;
    this._drawShadow.inner[2] = x_max;
    this._drawShadow.inner[3] = y_max;
  }
  if (_.isNil(scale)) {
    this._drawShadow.scale = this._drawShadow.scale || 1;
  } else {
    this._drawShadow.scale = scale;
  }
  if (_.isNil(rotation)) {
    this._drawShadow.rotation = this._drawShadow.rotation || 0;
  } else {
    this._drawShadow.rotation = rotation;
  }
  if (this._drawShadow.outer) {
    map.render();
  }
};

// funzione grigio mappa precompose mapcompose
proto.startDrawGreyCover = function() {
  var self = this;
    // after rendering the layer, restore the canvas context
  var map = this.viewer.map;
  var x_min, x_max, y_min, y_max, rotation, scale;
  //verifico che non ci sia già un greyListener
  if (this._greyListenerKey) {
      this.stopDrawGreyCover();
  }

  function postcompose(evt) {
    var ctx = evt.context;
    var size = this.getSize();
    // Inner polygon,must be counter-clockwise
    var height = size[1] * ol.has.DEVICE_PIXEL_RATIO;
    var width = size[0] * ol.has.DEVICE_PIXEL_RATIO;
    self._drawShadow.outer = [0,0,width, height];
    ctx.restore();
    ctx.beginPath();
    // Outside polygon, must be clockwise
    ctx.moveTo(0, 0);
    ctx.lineTo(width, 0);
    ctx.lineTo(width, height);
    ctx.lineTo(0, height);
    ctx.lineTo(0, 0);
    ctx.closePath();
    // fine bbox esterno (tutta la mappa-)
    if (self._drawShadow.inner.length) {
      ctx.save();
      x_min = self._drawShadow.inner[0];
      y_min = self._drawShadow.inner[3];
      x_max = self._drawShadow.inner[2];
      y_max = self._drawShadow.inner[1];
      rotation = self._drawShadow.rotation;
      scale = self._drawShadow.scale;
      // Inner polygon,must be counter-clockwise antiorario
      ctx.translate((x_max+x_min)/2, (y_max+y_min)/2);
      ctx.rotate(rotation*Math.PI / 180);
      ctx.moveTo(-((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.lineTo(((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.lineTo(((x_max-x_min)/2),-((y_max-y_min)/2));
      ctx.lineTo(-((x_max-x_min)/2),-((y_max-y_min)/2));
      ctx.lineTo(-((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.closePath();
      // fine bbox interno
    }
    ctx.fillStyle = 'rgba(0, 5, 25, 0.40)';
    ctx.fill();
    ctx.restore();
  }
  this._greyListenerKey = map.on('postcompose', postcompose);
};

proto.stopDrawGreyCover = function() {
  var map = this.viewer.map;
  ol.Observable.unByKey(this._greyListenerKey);
  this._greyListenerKey = null;
  if (this._drawShadow.inner.length) {
    this._resetDrawShadowInner();
  }
  map.render();
};

// funzione che rimuove layer aggiunti esterni
proto.removeExternalLayer = function(name) {
  var layer = this.getLayerByName(name);
  var catalogService = GUI.getComponent('catalog').getService();
  var QueryResultService = GUI.getComponent('queryresults').getService();
  QueryResultService.unregisterVectorLayer(layer);
  this.viewer.map.removeLayer(layer);
  catalogService.removeExternalLayer(name);
};

// funzione che aggiunge layer esterni
proto.addExternalLayer = function(externalLayer) {

  //funzione che mippermette di fare il loadind del layer sulla mappa
  function loadExternalLayer(format, data) {
    features = format.readFeatures(data, {
      dataProjection: 'EPSG:'+ crs,
      featureProjection: self.getEpsg()
    });
    vectorSource = new ol.source.Vector({
      features: features
    });
    vectorLayer = new ol.layer.Vector({
      source: vectorSource,
      //style: styleFunction,
      name: name
    });
    //vado a settare il colore al vector layer
    vectorLayer.setStyle(self.setExternalLayerColor(color));
    extent = vectorLayer.getSource().getExtent();
    //setto il bbox perchè mi servirà nel catalog
    externalLayer.bbox = {
      minx: extent[0],
      miny: extent[1],
      maxx: extent[2],
      maxy: extent[3]
    };
    map.addLayer(vectorLayer);
    //vado a registrae il layer vettoriale per la query
    QueryResultService.registerVectorLayer(vectorLayer);
    //vado ad aggiungere il layer esterno
    catalogService.addExternalLayer(externalLayer);
    map.getView().fit(vectorSource.getExtent());
  }

  var self = this;
  var format,
    features,
    vectorSource,
    vectorLayer,
    extent;
  var map = this.viewer.map;
  var name = externalLayer.name;
  var color = externalLayer.color;
  var type = externalLayer.type;
  var crs = externalLayer.crs;
  var data = externalLayer.data;
  var catalogService = GUI.getComponent('catalog').getService();
  var QueryResultService = GUI.getComponent('queryresults').getService();
  // cerco di verificare se esiste già un layer nella mappa
  var layer = this.getLayerByName(name);
  // aggiungo solo nel caso di layer non presente
  if (!layer) {
    // nel caso in cui i sistemi di riferimento del layer e della mappa sono diversi
    // vado a definirne il sistema (caso a sistemi di proiezione non standard in OL3 diversi da 3857 e 4326)
    if (crs != self.getCrs()) {
      self.defineProjection(crs);
    }
    //verifico il tipo di file uplodato
    switch (type) {
      case 'geojson':
        format = new ol.format.GeoJSON();
        loadExternalLayer(format, data);
        break;
      case 'kml':
        format = new ol.format.KML({
          extractStyles: false
        });
        loadExternalLayer(format, data);
        break;
      case 'zip':
        // qui non specifico l'epsg in quanto lo legge da solo
        // dal file prj
        var geoJSONFile;
        loadshp({
          url: data,
          encoding: 'big5',
          EPSG: crs
        }, function(geojson) {
          if (!geoJSONFile) {
            geoJSONFile = geojson;
            crs = '4326';
            data = JSON.stringify(geojson);
            format = new ol.format.GeoJSON();
            loadExternalLayer(format, data);
          }
        });
        break;
    }
  } else {
    GUI.notify.info('Layer già aggiunto');
  }
};

// setta il colore al layer caricati esternamente
proto.setExternalLayerColor = function(color) {
  // stile
  var color = color.rgba;
  color = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ','  + color.a + ')';
  var defaultStyle = {
    'Point': new ol.style.Style({
      image: new ol.style.Circle({
        fill: new ol.style.Fill({
          color: color
        }),
        radius: 5,
        stroke: new ol.style.Stroke({
          color: color,
          width: 1
        })
      })
    }),
    'LineString': new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'Polygon': new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(255,255,255,0.5)'
      }),
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'MultiPoint': new ol.style.Style({
      image: new ol.style.Circle({
        fill: new ol.style.Fill({
          color: color
        }),
        radius: 5,
        stroke: new ol.style.Stroke({
          color: color,
          width: 1
        })
      })
    }),
    'MultiLineString': new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'MultiPolygon': new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(255,255,255,0.5)'
      }),
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    })
  };
  var styleFunction = function(feature, resolution) {
    var featureStyleFunction = feature.getStyleFunction();
    if (featureStyleFunction) {
      return featureStyleFunction.call(feature, resolution);
    } else {
      return defaultStyle[feature.getGeometry().getType()];
    }
  };

  return styleFunction
};

module.exports = MapService;

},{"core/applicationservice":22,"core/g3wobject":30,"core/geometry/geometry":32,"core/layers/filter/filter":38,"core/layers/layer":41,"core/layers/layersstore":43,"core/layers/providers/wfsprovider":50,"core/map/layer/binglayer":55,"core/map/layer/osmlayer":59,"core/map/layer/wmslayer":61,"core/map/layer/xyzlayer":62,"core/map/maplayersstoresregistry":63,"core/project/projectsregistry":74,"core/utils/utils":80,"g3w-ol3/src/g3w.ol3":101,"gui/gui":132,"gui/map/control/factory":147,"gui/map/control/registry":148,"gui/streetview/streetviewservice":176}],150:[function(require,module,exports){
module.exports = "<!-- Modal -->\n<div class=\"modal fade\" id=\"modal-addlayer\" role=\"dialog\">\n  <div class=\"modal-dialog\">\n    <!-- Modal content-->\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\">&times;</button>\n        <h4 class=\"modal-title\">Aggiungi Layer</h4>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"form-group\">\n          <label for=\"proiezione-layer\">Seleziona il sistema di proiezione del layer</label>\n          <select class=\"form-control\" id=\"proiezione-layer\" v-model=\"layer.crs\">\n            <option value=\"3003\">EPSG:3003</option>\n            <option value=\"3857\">EPSG:3857</option>\n            <option value=\"4326\">EPSG:4326</option>\n          </select>\n        </div>\n        <p style=\"font-weight: 700;\">Seleziona il colore del layer</p>\n        <chrome-picker v-model=\"layer.color\" @change-color=\"onChangeColor\" style=\"width:90%;margin:auto\"></chrome-picker>\n        <form id=\"addcustomlayer\">\n          <input type=\"file\" title=\" \" @change=\"onAddLayer($event)\" accept=\".kml,.geojson, .KML, .GEOJSON, .zip\">\n          <h4>Trascina qui il file o clicca sull'area</h4>\n          <h4 v-if=\"layer.name\">{{ layer.name }}</h4>\n          <div>\n            <i class=\"fa fa-cloud-upload fa-5x\" aria-hidden=\"true\"></i>\n          </div>\n          <p>.geojson, .kml, .zip(shapefile)</p>\n        </form>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default pull-left\" @click=\"addLayer\" data-dismiss=\"modal\">Aggiungi</button>\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\" @click=\"clearLayer\">Chiudi</button>\n      </div>\n    </div>\n  </div>\n</div>";

},{}],151:[function(require,module,exports){
module.exports = "<div :id=\"target\" style=\"width:100%;height:100%\">\n  <div style=\"display: none;\">\n    <div id=\"marker\"></div>\n  </div>\n  <addlayer :service=\"service\"></addlayer>\n</div>\n\n\n";

},{}],152:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var MapService = require('../mapservice');
//componente vue.color
var ChromeComponent = VueColor.Chrome;
// setto la funzione mounted così tutti i componenti erediteranno da questo
ChromeComponent.mounted =  function() {
  this.$nextTick(function() {
    //vado a rimuovere elementi che non mi servono
    $('.vue-color__chrome__toggle-btn').remove();
    $('.vue-color__editable-input__label').remove();
    $('.vue-color__chrome__saturation-wrap').css('padding-bottom','100px');
    $('.vue-color__chrome').css({
      'box-shadow': '0 0 0 0',
      'border': '1px solid #97A1A8'
    });
  });
};

var AddLayerComponent = {
  template: require('./addlayer.html'),
  props: ['service'],
  data: function() {
    return {
      layer: {
        name: null,
        type: null,
        crs: null,
        color: {
          hex: '#194d33',
          rgba: {
            r: 25,
            g: 77,
            b: 51,
            a: 1
          },
          a: 1
        },
        data: null,
        visible: true,
        title: null,
        id: null,
        external: true
      }
    }
  },
  components: {
    'chrome-picker': ChromeComponent
  },
  mounted: function(){
    this.layer.crs = this.service.getCrs();
    this.service.on('addexternallayer', function() {
      $('#modal-addlayer').modal('show');
    });
  },
  methods: {
    onChangeColor: function(val) {
      this.layer.color = val;
    },
    onAddLayer: function(evt) {
      var self = this;
      var reader = new FileReader();
      var name = evt.target.files[0].name;
      this.layer.name = name;
      this.layer.title = name;
      this.layer.id = name;
      var type = evt.target.files[0].name.split('.');
      this.layer.type = type[type.length-1].toLowerCase();
      if (this.layer.type == 'zip') {
        self.layer.data = evt.target.files[0];
        $('input:file').val(null);
      } else {
        reader.onload = function(evt) {
          self.layer.data = evt.target.result;
          // vado a rimuovere il valore del layer ultimo aggiunto per
          // fare in mdo che l'evento change possa scattare
          $('input:file').val(null);
        };
        reader.readAsText(evt.target.files[0]);
      }
    },
    addLayer: function() {
      if (this.layer.name) {
        //devo fare il cloen al fine di evitare che quando
        // riapro la modale ci si sempre il
        var layer = _.cloneDeep(this.layer);
        this.service.addExternalLayer(layer);
        $('#modal-addlayer').modal('hide');
        this.clearLayer();
      }
    },
    clearLayer: function() {
      this.layer.name = null;
      this.layer.title = null;
      this.layer.id = null;
      this.layer.type = null;
      this.layer.crs = this.service.getCrs();
      this.layer.color = {
        hex: '#194d33',
          rgba: {
          r: 25,
            g: 77,
            b: 51,
            a: 1
        },
        a: 1
      };
      this.layer.data = null;
    }
  }
};

// componente vue della mappa
var vueComponentOptions = {
  template: require('./map.html'),
  data: function() {
    return {
      target: 'map', // specidica l'id
      service: this.$options.mapService
    }
  },
  components: {
    'addlayer': AddLayerComponent
  },
  mounted: function() {
    var self = this;
    var mapService = this.$options.mapService;
    this.crs = mapService.getCrs();
    this.$nextTick(function() {
      mapService.setTarget(self.$el.id);
    });
    // questo serve per quando viene cambiato progetto/vista cartografica,
    // in cui viene ricreato il viewer (e quindi la mappa)
    mapService.onafter('setupViewer',function() {
      mapService.setTarget(self.$el.id);
    });
  }
};
// registro internamente
var InternalComponent = Vue.extend(vueComponentOptions);
// viene definito il componte map
Vue.component('g3w-map', vueComponentOptions);
//componente mappa
function MapComponent(options) {
  base(this, options);
  this.id = "map-component";
  this.title = "Catalogo dati";
  this.target = options.target || 'map';
  this.setService(new MapService(options));
  merge(this, options);
  this.internalComponent = new InternalComponent({
    mapService: this._service // definisco il mapservice
  });
  this.internalComponent.target = this.target;
}

inherit(MapComponent, Component);

var proto = MapComponent.prototype;
// funzione che ne definisce il layout della mappa
// ed è chamata dall viewport per risettare le size delle due view
proto.layout = function(width, height) {
  // setto alterzza e larghezza nuove
  $('#'+this.target).height(height);
  $('#'+this.target).width(width);
  this._service.layout(width,height);
};

module.exports =  MapComponent;


},{"../mapservice":149,"./addlayer.html":150,"./map.html":151,"core/utils/utils":80,"gui/vue/component":182}],153:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var resolvedValue = require('core/utils/utils').resolve;
var G3WObject = require('core/g3wobject');

var Panel = function(options) {
  this.internalPanel = null;
  var options = options || {};
  this.id = options.id || null;
  this.title = options.title || '';
};

inherit(Panel, G3WObject);

var proto = Panel.prototype;

proto.getId = function(){
  return this.id;
};

proto.getTitle = function(){
  return this.title;
};

proto.getInternalPanel = function() {
  return this.internalPanel;
};

proto.setInternalPanel = function(internalPanel) {
  this.internalPanel = internalPanel;
};

/* HOOKS */

/*
 * Il metodo permette al pannello di montarsi nel DOM
 * parent: elemento DOM padre, su cui inserirsi;
 * ritorna una promise, risolta nel momento in cui sarà terminato il montaggio
*/

// SONO DUE TIPOLOGIE DI MONTAGGIO CON IL QUALE IL PANNELLO
// CHE VERRA' MONTATO AL VOLO CON IL METODO MOUNT A SECONDA DEL TIPO DI PANNELLO RICHIESTO

// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso

proto.mount = function(parent) {
  var panel = this.internalPanel;
  var iCinstance = panel.$mount();
  $(parent).append(iCinstance.$el);
  iCinstance.$nextTick(function(){
    $(parent).localize();
    if (panel.onShow) {
      panel.onShow();
    }
  });
  return resolvedValue(true);
};

/*
 * Metodo richiamato quando si vuole rimuovere il panello.
 * Ritorna una promessa che sarà risolta nel momento in cui il pannello avrà completato la propria rimozione (ed eventuale rilascio di risorse dipendenti)
*/
proto.unmount = function() {
  var panel = this.internalPanel;
  var deferred = $.Deferred();
  panel.$destroy(true);
  $(panel.$el).remove();
  // lo setta di nuovo a null
  if (panel.onClose) {
    panel.onClose();
  }
  this.internalComponent = null;
  deferred.resolve();
  return deferred.promise();
};

/*
 * Metodo (opzionale) che offre l'opportunità di ricalcolare proprietà dipendenti dalle dimensioni del padre
 * parentHeight: nuova altezza del parent
 * parentWidth: nuova larghezza del parent
 * richiamato ogni volta che il parent subisce un ridimensionamento
*/
proto.onResize = function(parentWidth,parentHeight){};


module.exports = Panel;

},{"core/g3wobject":30,"core/utils/utils":80}],154:[function(require,module,exports){
var scale = [
  {
    value:500,
    label:'1:500'
  },
  {
    value:1000,
    label:'1:1.000'
  },
  {
    value:2000,
    label:'1:2.000'
  },
  {
    value:2500,
    label:'1:2.500'
  },
  {
    value:5000,
    label:'1:5.000'
  },
  {
    value:10000,
    label:'1:10.000'
  },
  {
    value:25000,
    label:'1:25.000'
  },
  {
    value:50000,
    label:'1:50.000'
  },
  {
    value:100000,
    label:'1:100.000'
  },
  {
    value:250000,
    label:'1:250.000'
  },
  {
    value:500000,
    label:'1:500.000'
  },
  {
    value:1000000,
    label:'1:1.000.000'
  },
  {
    value:5000000,
    label:'1:5.000.000'
  }
];
var dpis = [150, 300];

module.exports = {
  scale: scale,
  dpis: dpis
};

},{}],155:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var PrintService = require('core/print/printservice');
var resToScale = require('core/utils/geo').resToScale;
var scaleToRes = require('core/utils/geo').scaleToRes;
var printConfig = require('./printconfig');
var PrintPage = require('./vue/printpage');
var scale = printConfig.scale;
var dpis = printConfig.dpis;


function PrintComponentService() {
  base(this);
  // mi dice se è stato inizilizzato o meno
  this._initialized = false;
  // inizializzo lo state
  this.state = {};
  this._moveMapKeyEvent = null;
  // istanzio il componete page per la visualizzazione del pdf
  this._page = null;
  this._mapService = null;
  this._map = null;
  this._isOpen = false;
  // oggetto che va a mappare scale e risoluzione
  // si aggiornerà via via che verranno fatti zoom in e zoom out
  // tramite l'evento moveend
  this._scalesResolutions = {};
  // inizializzazione
  this.init = function() {
    // recupero il project
    this._project = ProjectsRegistry.getCurrentProject();
    // prendo le informazioni del print
    this.state.print = this._project.state.print;
    // setto lo state visible
    this.state.visible = (this.state.print && this.state.print.length) ? true : false;
    this.state.isShow = false;
    this.state.loading = false;
    this.state.url = null;
    if (this.state.visible) {
      // Imposto le configurazioni inziali da rivedere
      this.state.template = this.state.print[0].name;
      this.state.rotation = 0;
      this.state.inner = null;
      this.state.center = null;
      this.state.size = null;
      this.state.scale = scale;
      this.state.scala = null;
      this.state.dpis = dpis;
      this.state.dpi = dpis[0];
      this.state.map = null;//;this.state.print[0].maps[0].name;
      this.state.width = null;//this.state.print[0].maps[0].w;
      this.state.height = null;//this.state.print[0].maps[0].h;
    }
  };
  // metodo per il cambio di template
  this.changeTemplate = function() {
    var self = this;
    if (!this.state.template) return;
    var template = this.state.template;
    _.forEach(this.state.print, function(print) {
      if (print.name == template) {
        // al momento hardcoded mpa0
        self.state.width = print.maps[0].w;
        self.state.height = print.maps[0].h;
        self.state.map = print.maps[0].name;
      }
    });
    this._setPrintArea();
  };

  // metodo per il cambio di scala attraverso la select
  this.changeScale = function() {
    if (!this.state.scala) return;
    // vado a cambiare la print area
    this._setPrintArea();
  };

  // metodo per il cambio di rotazione
  this.changeRotation = function() {
    this._mapService.setInnerGreyCoverBBox({
      rotation: this.state.rotation
    });
    this._changePrintOutput();
  };

  // funzione che restituisce le options del print
  this._getOptionsPrint = function() {
    var options = {
      scale: this.state.scala, // scala scelta
      extent: this.state.inner.join(), // estensione
      rotation: this.state.rotation, // rotazione
      dpi: this.state.dpi,// dpi
      template: this.state.template, // nome template
      map: this.state.map // tipo mappa (sempre map0)
    };
    return options;
  };

  // funzione print
  this.print = function() {
    var self = this;
    this._page = new PrintPage({
      service: self
    });
    var options = this._getOptionsPrint();
    // apro il content
    GUI.setContent({
      content: self._page,
      title: 'Stampa',
      perc:100
    });
    PrintService.print(options)
    .then(function(data, status, xhr) {
      // setto l'url
      self.state.url = this.url;
    })
    .fail(function() {
      GUI.notify.error('Si è verificato un errore nella richiesta al server');
      GUI.closeContent();
    })
  };

  this._calculateInternalPrintExtent = function() {
    // vado a calcolare la risoluzione della mappa
    var resolution = this._map.getView().getResolution();
    // trasformo la scala in float
    var scala = parseFloat(this.state.scala);
    // vado a calcolarmi la larghezza in pixel da rappresentare sullo schermo
    // la formula uguale per quanto riguarda l'altezza è:
    // LARGHEZZA DELLA MAPPA SUL TEMPLATE (IN MM) LA DIVIDO PER 1000 OTTENEDO IL VALORE IN METRI
    // DELLA MAPPA SUL TEMPLATE. a QUESTO PUNTO VADO A MOLTIPLICARE PER LA SCALA OTTENEDO IL VALORE TOTALE
    // DELLA DISTANZA IN UNITÀ DI MAPPA (METRI) CHE COPRE LA LARGHEZZA DELLA MAPPA
    // UNA VOLTA SAPUTO QUANTO IN LARGHEZZA (IN METRI) LA MAPPA COPRE LA DIVIDO PER LA RISOLUZIONE DELLA MAPPA
    // OTTENEDO COSÌ IL NUMERO DEI PIXEL SULLA MAPPA CHE COPRONO TALE DISTANZA
    var w = this.state.width / 1000.0 * scala / resolution * ol.has.DEVICE_PIXEL_RATIO;
    var h = this.state.height  / 1000.0 * scala / resolution * ol.has.DEVICE_PIXEL_RATIO;
    var center = [this.state.size[0] * ol.has.DEVICE_PIXEL_RATIO / 2 , this.state.size[1] * ol.has.DEVICE_PIXEL_RATIO / 2];

    // in pixel
    var xmin = center[0] - (w / 2); // indica x min
    var ymin = center[1] - (h / 2);
    var xmax = center[0] + (w / 2);
    var ymax = center[1] + (h / 2);

    // vado a calcolare la x_min e x_max
    x_min = this._map.getCoordinateFromPixel([xmin, ymax]);
    x_max = this._map.getCoordinateFromPixel([xmax, ymax]);
    // vado a caloclare la y_min e y_max
    y_min = this._map.getCoordinateFromPixel([xmin, ymin]);
    y_max = this._map.getCoordinateFromPixel([xmax, ymin]);
    this.state.inner =  [x_min[0], x_min[1], y_max[0], y_max[1]];

  };

  // funzione che setta il BBOX della printArea
  this._setPrintArea = function() {
    // size della mappa
    this.state.size = this._map.getSize();
    this.state.currentScala = resToScale(this._map.getView().getResolution());
    // centro della mappa
    this.state.center = this._map.getView().getCenter();
    this._calculateInternalPrintExtent();
    this._mapService.setInnerGreyCoverBBox({
      inner: this.state.inner,
      rotation: this.state.rotation
    });
  };

  // metodo chiusura print panel
  this._clearPrint = function() {
    // rimovo l'evento movend della mappa
    ol.Observable.unByKey(this._moveMapKeyEvent);
    // lo setto a null
    this._moveMapKeyEvent = null;
    // dico al mapservice di fermare il disegno del print area
    this._mapService.stopDrawGreyCover();
  };

  // funzione che fa il change dell'ouput pdf quando
  // ci spostiamo nella mappa o cambiano i parametri del print
  // al momento non usata
  this._changePrintOutput = function() {
    var self = this;
    // verifico se l'otuput pdf è visibile
    if (this.state.isShow) {
      this.state.loading = true;
      var options = this._getOptionsPrint();
      PrintService.print(options)
        .then(function (url) {
          if (self.state.url == url) {
            self.state.loading = false;
          }
          self.state.url = url;
        })
    }
  };

  // la funzione mi serve per adattare le scale da visulzizzare in base alle
  // varie risoluzione della mappa basate su maResolution della view
  this._setAllScalesBasedOnMaxResolution = function(maxResolution) {
    var self = this;
    var resolution = maxResolution;
    var mapScala = resToScale(resolution);
    // ordino le scale dal più grande al più piccolo
    var orderScales = _.orderBy(this.state.scale, ['value'], ['desc']);
    var scale = [];
    _.forEach(orderScales, function(scala) {
      if (mapScala > scala.value) {
        scale.push(scala);
        resolution = scaleToRes(scala.value);
        self._scalesResolutions[scala.value] = resolution;
        resolution = resolution / 2;
      }
    });
    // riordino in modo crescente
    this.state.scale = _.orderBy(scale, ['value'], ['asc']);
  };

  // funzione che mi restituisce la scala da settare inizialmente
  this._setInitialScalaSelect = function() {
    var self = this;
    // prendo la risoluzione della mappa
    var initialResolution = this._map.getView().getResolution();
    // ci calcolo la scala associata alla resoluzione iniziale della mappa
    var initialScala = resToScale(initialResolution);
    var found = false;
    _.forEach(this.state.scale, function(scala, index) {
      // qui vado a settare la scala in base alla risoluzione inziale della mappa
      if (initialScala < scala.value && !self.state.scala) {
        var idx = index ? index -1 : index;
        self.state.scala = self.state.scale[idx].value;
        $('#scala').val(self.state.scala);
        found = true;
        return false
      }
    });
    if (!found) {
      this.state.scala = this.state.scale[this.state.scale.length-1].value;
    }
  };

  //setta la scala in base alla risoluzione
  this._setCurrentScala = function(resolution) {
    var self = this;
    _.forEach(this._scalesResolutions, function(res, scala) {
      if (res == resolution) {
        self.state.scala = scala;
        return false
      }
    });
  };

  // funzione che ha lo scopo di settare il moveend della mappa
  this._setMoveendMapEvent = function() {
    var self = this;
    // prendo la chiave dell'evento moveend
    this._moveMapKeyEvent = this._map.on('moveend', function() {
      /// setto nella select la scala corrispondente
      // vado a settare la print area
      self._setPrintArea();
    })
  };

  //funzione che setta l'area iniziale
  this._showPrintArea = function() {
    // vado ad impostare l'area di stampa
    this._setPrintArea();
    // dico al mapservice di disegnare l'area di stampa
    this._mapService.startDrawGreyCover();
  };


  // funzione che setta la massima e iniziale scala del progetto
  this._initPrintConfig = function() {
    var resolution;
    if (!this._initialized) {
      // prendo la massima risoluzione della mappa
      var maxResolution = this._map.getView().getMaxResolution();
      // ricavo le scale adatte alle mie risoluzioni
      this._setAllScalesBasedOnMaxResolution(maxResolution);
      //se non è stata ancora inizializzata allora vado a settare
      // setto la scala iniziale nella select in base alla risoluzione di partenza del progetto
      this._setInitialScalaSelect();
      //dico che è stata inzializzata
      this._initialized = true;
    } else {
      // prendo la risoluzione corrente
      resolution = this._map.getView().getResolution();
      // vado a cambiare la scala
      this._setCurrentScala(resolution);
    }
  };

  // funzione che ricava sempre map0
  this._setMapInfo = function() {
    var self = this;
    _.forEach(this.state.print[0].maps, function(map) {
      if (map.name == 'map0') {
        self.state.map = map.name;
        self.state.width = map.w;
        self.state.height = map.h;
        return false;
      }
    })
  };

  // metodo per la visualizzazione dell'area grigia o meno
  // chamata dal metodo _setOpen del componente
  this.showPrintArea = function(bool) {
    this._mapService = GUI.getComponent('map').getService();
    this._map = this._mapService.viewer.map;
    if (bool) {
      this._setMapInfo();
      // registo il moveend map event
      this._setMoveendMapEvent();
      // setto la scala iniziale derivato dalle proprietà della mappa
      // e limito la selezione delle scale
      this._initPrintConfig();
      // setto la area di print
      this._showPrintArea();
    } else {
      // vado a ripulire tutti le cose legate al print
      this._clearPrint();
    }
  };

  this.reload = function() {
    var self = this;
    this._project = ProjectsRegistry.getCurrentProject();
    this._mapService = GUI.getComponent('map').getService();
    this._map = this._mapService.viewer.map;
    // prendo le informazioni del print
    this.state.print = this._project.state.print;
    // setto lo state visible
    this.state.visible = (this.state.print && this.state.print.length) ? true : false;
    //verifico se è visibile nel senso se ci sono informazioni
    //sul print per quel progetto
    if (this.state.visible) {
      this.state.template = this.state.print[0].name;
      // setto la area di print
      if (!this._initialized) {
        this.init();
      }
      this._initPrintConfig();
      this._mapService.on('changeviewaftercurrentproject', function() {
        var maxResolution = self._map.getView().getMaxResolution();
        // ricavo le scale adatte alle mie risoluzioni
        self.state.scale = scale;
        self._setAllScalesBasedOnMaxResolution(maxResolution);
      });
    } else {
      // vado a ripulire tutti le cose legate al print
      this._clearPrint();
    }
  }
}

inherit(PrintComponentService, G3WObject);

module.exports = PrintComponentService;
},{"./printconfig":154,"./vue/printpage":159,"core/g3wobject":30,"core/print/printservice":70,"core/project/projectsregistry":74,"core/utils/geo":79,"core/utils/utils":80,"gui/gui":132}],156:[function(require,module,exports){
module.exports = "<ul id=\"print\" class=\"treeview-menu\">\n  <li>\n    <form id=\"g3w-search-form\" class=\"form-horizonal\">\n      <div class=\"box-body\">\n        <label for=\"templates\">Template</label>\n        <select class=\"form-control\" @change=\"onChangeTemplate\" v-model=\"state.template\" id=\"templates\" placeholder=\"Seleziona il template\">\n          <option v-for=\"print in state.print\">{{ print.name }}</option>\n        </select>\n        <label for=\"scala\">Scala</label>\n        <select class=\"form-control\" @change=\"onChangeScale\" v-model=\"state.scala\" id=\"scala\" placeholder=\"Seleziona la scala\">\n          <option v-for=\"scala in state.scale\" :value=\"scala.value\">{{ scala.label }}</option>\n        </select>\n        <label for=\"dpi\">dpi</label>\n        <select class=\"form-control\" @change=\"onChangeDpi\"  v-model=\"state.dpi\" id=\"dpi\" placeholder=\"Seleziona i dpi\">\n          <option v-for=\"dpi in state.dpis\" >{{ dpi }}</option>\n        </select>\n        <label for=\"rotation\">Rotazione</label>\n        <input min=\"-360\" max=\"360\"  @input=\"onChangeRotation\" v-model=\"state.rotation\" id=\"rotation\" class=\"form-control\" type=\"number\">\n      </div>\n      <div class=\"box-footer\" style=\"background-color: transparent\">\n        <span>\n          <button style=\"width:100%; background-color: #3c8dbc\" class=\"btn \" @click.stop.prevent=\"exec(button.cbk)\" v-disabled=\"btnEnabled(button)\">{{ button.title }}</button>\n        </span>\n      </div>\n    </form>\n    <div id=\"message\" style=\"text-align:center; padding:3px; color: yellow\" class=\"message\" v-show=\"btnEnabled(button)\">\n      <div>\n        <span>Muovendoti all'interno della mappa</span>\n      </div>\n      <div>\n        <span>o cambiando i parametri della stampa</span>\n      </div>\n      <div>\n        <span>il PDF si aggiornerà automaticamente</span>\n      </div>\n    </div>\n  </li>\n</ul>\n";

},{}],157:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var Component = require('gui/vue/component');
var PrintService = require('gui/print/printservice');
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;

var vueComponentOptions = {
  template: require('./print.html'),
  data: function() {
    var self = this;
    return {
      state: null,
      button: {
        title: "Crea PDF",
        class: "btn-success",
        type:"stampa",
        disabled: false,
        cbk: function() {
          self.print()
        }
      }
    }
  },
  methods: {
    exec: function(cbk) {
      cbk();
    },
    btnEnabled: function(button) {
      return button.disabled;
    },
    isAnnullaButton: function(type) {
      return type == 'annulla'
    },
    // metodo per il cambio di template
    onChangeTemplate: function() {
      this.$options.service.changeTemplate();
    },
    // metodo per il cambio di scala
    onChangeScale: function() {
      this.$options.service.changeScale()
    },
    // metodo per il cambio di DPI
    onChangeDpi: function() {

    },
    // metodo per il cambio di rotazione
    onChangeRotation: function(evt) {
      if (this.state.rotation >= 0 && !_.isNil(this.state.rotation) && this.state.rotation != '') {
        this.state.rotation = (this.state.rotation > 360) ? 360 : this.state.rotation;
        evt.target.value = this.state.rotation;
      } else if (this.state.rotation < 0) {
        this.state.rotation = (this.state.rotation < -360) ? -360 : this.state.rotation;
        evt.target.value = this.state.rotation;
      } else {
        this.state.rotation = 0;
      }

      this.$options.service.changeRotation();
    },
    // funzione dedicata alla visualizzazione dell'ouput del print
    print: function() {
      this.$options.service.print();
    }
  }
};


function PrintComponent(options) {
  // proprietà necessarie. In futuro le mettermo in una classe Panel
  // da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  base(this, options);
  this.title = "print";
  // qui vado a tenere traccia delle due cose che mi permettono di customizzare
  // vue component e service
  this.vueComponent = vueComponentOptions;
  //merge(this, options);
  // dichiaro l'internal Component
  this.internalComponent = null;
  // setto il service del component (istanzio il nuovo servizio)
  var service = options.service || new PrintService;
  this.setService(service);
  this._service.init();
  // setto il componente interno
  this.setInternalComponent = function () {
    var InternalComponent = Vue.extend(this.vueComponent);
    this.internalComponent = new InternalComponent({
      service: service
    });
    // setto la visibilità del print in base a quella del servizio calcolata sull'array
    // print restituita dal server
    this.state.visible = service.state.visible;
    // assegno all'internal componente lo state mergiato
    this.internalComponent.state = service.state;
    // ritorno l'internal component
    return this.internalComponent;
  };

  //sovrascrivo il metodo reload
  this._reload = function() {
    var service = this.getService();
    service.reload();
    this.state.visible = service.state.visible;
  };

  // funzione che viene chaimata quando viene visualizzato il contentuto del componente Stampa
  // nella sidebar
  this._setOpen = function() {
    this._service.showPrintArea(this.state.open);
  };
  merge(this, options);

}

inherit(PrintComponent, Component);

module.exports = PrintComponent;



},{"./print.html":156,"core/utils/utils":80,"gui/print/printservice":155,"gui/vue/component":182}],158:[function(require,module,exports){
module.exports = "<div id=\"pdf-output\" style=\"height:100%\">\n  <div v-show=\"state.loading\" class=\"bar-loader\"></div>\n  <iframe id=\"pdf\" style=\"border:0px;width:100%;height:100%\" :src=\"state.url\"></iframe>\n</div>";

},{}],159:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');

var InternalComponent = Vue.extend({
  template: require('./printpage.html'),
  data: function() {
    return {
      state: null
    }
  },
  mounted: function() {
    var self = this;
    this.state.loading = true;
    this.$nextTick(function(){
      $('#pdf').load(function(){
        self.state.loading = false;
      })
    });
  }
});

var PrintPage = function(options) {
  base(this);
  var options = options || {};
  var service = options.service;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent();
  this.setInternalComponent(internalComponent);
  this.internalComponent.state = service.state;
};

inherit(PrintPage, Component);


module.exports = PrintPage;



},{"./printpage.html":158,"core/utils/utils":80,"gui/vue/component":182}],160:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function PhotoService(options) {
  var options = options || {};
  this.state = {};
  base(this);
}

inherit(PhotoService, G3WObject);

module.exports = PhotoService;

},{"core/g3wobject":30,"core/utils/utils":80}],161:[function(require,module,exports){
module.exports = "<div id=\"photo\" style=\"margin: 10px;\">\n  <img :src=\"url\" style=\"width: 100%;\">\n</div>";

},{}],162:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var Service = require('../photoservice');

var InternalComponent = Vue.extend({
  template: require('./photo.html'),
  data: function() {
    return {
      state: null,
      url: this.$options.url
    }
  }
});

var PhotoComponent = function(options) {
  base(this);
  var options = options || {};
  var service = options.service || new Service({});
  var url = options.url || null;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service,
    url: url
  });
  this.setInternalComponent(internalComponent);
  this.internalComponent.state = service.state;
};

inherit(PhotoComponent, Component);


module.exports = PhotoComponent;



},{"../photoservice":160,"./photo.html":161,"core/utils/utils":80,"gui/vue/component":182}],163:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectsRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');


function RelationsService(options) {
  this.state = {};
  this._project = ProjectsRegistry.getCurrentProject();
  base(this);

  this.getRelations = function(options) {
    var projectId = this._project.state.id;
    options = options || {};
    var value = options.value || null;
    var id = options.id || null;
    return $.get('/qdjango/api/relations/'+projectId+'/'+id+'/'+value)
  };
  this.buildRelationTable = function(relations) {
    var columns = _.keys(relations[0]);
    var rows = [];
    _.forEach(relations, function(relation){
      rows.push(_.values(relation));
    });
    return {
      columns: columns,
      rows: rows
    }
  };
}

inherit(RelationsService, G3WObject);

module.exports = RelationsService;

},{"core/g3wobject":30,"core/project/projectsregistry":74,"core/utils/utils":80,"gui/gui":132}],164:[function(require,module,exports){
module.exports = "<div class=\"query-relation\">\n  <div class=\"back-btn\" @click=\"back\">\n    <span class=\"back-link\">\n      <span class=\"glyphicon glyphicon-chevron-left\"></span>\n      Ritorna alle Relazioni\n    </span>\n  </div>\n  <div class=\"header\">\n    <div>\n      Dati relativi alla relazione <b>{{ relation.name }}</b>\n    </div>\n  </div>\n  <div class=\"nano\" v-if=\"table.rows.length\">\n    <div class=\"nano-content\">\n      <table class=\"table table-striped\">\n        <thead>\n          <tr>\n            <th v-for=\"column in table.columns\">{{ column }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-for=\"row in table.rows\">\n            <td v-for=\"value in row\">{{ value }}</td>\n          </tr>\n        </tbody>\n        </table>\n    </div>\n  </div>\n  <div v-else> Non ci sono relazioni </div>\n\n</div>\n";

},{}],165:[function(require,module,exports){
module.exports = "<div class=\"query-relations\">\n  <div class=\"header\">\n    <div>Elenco Relazioni della feature <span v-for=\"info in featureInfo()\"><b>{{ info.key }}</b>: {{ info.value }} </span></div>\n  </div>\n  <div class=\"nano\">\n    <div class=\"nano-content\">\n      <table class=\"table table-bordered table-hover\">\n        <thead>\n        </thead>\n        <tbody>\n          <tr @click=\"showRelation(relation)\" v-for=\"relation in relations\" style=\"cursor:pointer\">\n            <td>\n              <span >{{ relation.name }}</span>\n              <span class=\"glyphicon glyphicon-chevron-right pull-right\" aria-hidden=\"true\"></span>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n";

},{}],166:[function(require,module,exports){
module.exports = "<div class=\"query-relations-page\">\n    <component\n        :is=\"currentview\"\n        :relations=\"relations\"\n        :relation=\"relation\"\n        :feature=\"feature\"\n        :table=\"table\">\n    </component>\n</div>";

},{}],167:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var Service = require('../relationsservice');



/* Lista delle relationi associate  */
var relationsComponent = {
  template: require('./relations.html'),
  props: ['relations', 'feature'],
  methods: {
    showRelation: function(relation) {
      this.$parent.showRelation(relation);
    },
    featureInfo: function() {
      var infoFeatures = [];
      var index = 0;
      _.forEach(this.feature.attributes, function(value, key) {
        if (index > 2) return false;
        if (value && _.isString(value) && value.indexOf('/') == -1 ) {
          infoFeatures.push({
            key: key,
            value: value
          });
          index+=1;
        }

      });
      return infoFeatures
    }
  }
};
/*-----------------------------------*/

/* Tabella relation */
var relationComponent = {
  template: require('./relation.html'),
  props: ['table', 'relation'],
  methods: {
    back: function() {
      this.$parent.setRelationsList();
    }
  }
};
/*-----------------------------------*/

var InternalComponent = Vue.extend({
  template: require('./relationspage.html'),
  data: function() {
    return {
      state: null,
      table: null,
      relation: null,
      relations: this.$options.relations,
      feature: this.$options.feature,
      currentview: 'relations' // proprietà che serve per switchare tra componenti
    }
  },
  components: {
    'relations': relationsComponent,
    'relation': relationComponent
  },
  methods: {
    showRelation: function(relation) {
      var self = this;
      this.relation = relation;
      var field = relation.fieldRef.referencedField;
      var value = this.feature.attributes[field];
      this.$options.service.getRelations({
        id: relation.id,
        value: value
      }).then(function(relations) {
        self.table = self.$options.service.buildRelationTable(relations);
        self.currentview = 'relation';
        Vue.nextTick(function() {
          $(".nano").nanoScroller();
        })
      })
    },
    setRelationsList: function() {
      this.currentview = 'relations';
    }
  }
});

var RelationsPage = function(options) {
  base(this);
  var options = options || {};
  var service = options.service || new Service({});
  var relations = options.relations || [];
  var feature = options.feature || null;
  // istanzio il componente interno
  this.setService(service);
  // istanzio il componente interno
  var internalComponent = new InternalComponent({
    service: service,
    relations: relations,
    feature: feature
  });
  this.setInternalComponent(internalComponent);
  internalComponent.state = service.state;
};
inherit(RelationsPage, Component);


module.exports = RelationsPage;



},{"../relationsservice":163,"./relation.html":164,"./relations.html":165,"./relationspage.html":166,"core/utils/utils":80,"gui/vue/component":182}],168:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectsRegistry = require('core/project/projectsregistry');
var Layer = require('core/layers/layer');
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var VectorLayer = require('core/map/layer/vectorlayer');
var ComponentsRegistry = require('gui/componentsregistry');
var QueryService = require('core/query/queryservice');
var PhotoComponent = require('./components/photo/vue/photo');
var RelationsPage = require('./components/relations/vue/relationspage');


function QueryResultsService() {
  var self = this;
  // prendo le relazioni dal progetto e se ci sono e le raggruppo per referencedLayer
  this._relations = ProjectsRegistry.getCurrentProject().state.relations ? _.groupBy(ProjectsRegistry.getCurrentProject().state.relations,'referencedLayer'): null;
  this._actions = {
    'zoomto': QueryResultsService.zoomToElement,
    'highlightgeometry': QueryResultsService.highlightGeometry,
    'clearHighlightGeometry': QueryResultsService.clearHighlightGeometry
  };
  this.state = {};
  this.init = function(options) {
    this.clearState();
  };

  // array dei layers vettoriali
  this._vectorLayers = [];

  this.setters = {
    setQueryResponse: function(queryResponse, coordinates, resolution ) {
      this.clearState();
      this.state.query = queryResponse.query;
      //recupero tutti i mlayers dalll'attributo data della risposta
      // costuendo il formato digeribile dal componente query
      var layers = this._digestFeaturesForLayers(queryResponse.data);
      //setto i layers data
      this.setLayersData(layers);
    },
    setLayersData: function(layers) {
      // un opportunità per aggiungere / modificare i risultati dell'interrogazione
      this.state.loading = false;
      this.state.layers =  layers;
      this.setActionsForLayers(layers);
    },
    addActionsForLayers: function(actions) {
      // un opportunità per i listener per aggiungere azioni a layer e feature
    },
    postRender: function(element) {
      // un opportunità per i listener di intervenire sul DOM
    }
  };
  // fa il clear dello state
  this.clearState = function() {
    this.state.layers = [];
    this.state.query = {};
    this.state.querytitle = "";
    this.state.loading = true;
    this.state.layersactions = {};
  };

  this.getState = function() {
    return this.state;
  };

  this.setState = function(state) {
    this.state = state;
  };

  this.setTitle = function(querytitle) {
    this.state.querytitle = querytitle || "";
  };
  
  this.reset = function() {
    this.clearState();
  };
  // funzione che serve a far digerire i risultati delle features
  this._digestFeaturesForLayers = function(featuresForLayers) {
    
    var self = this;
    var id = 0;
    // variabile che tiene traccia dei layer sotto query
    var layers = [];
    var layerAttributes,
      layerRelationsAttributes,
      layerTitle,
      layerId;
    _.forEach(featuresForLayers, function(featuresForLayer) {
      featuresForLayer = featuresForLayer;
      // prendo il layer
      var layer = featuresForLayer.layer;
      // verifico che tipo ti vector layer ci sono
      if (layer instanceof Layer) {
        layerAttributes = layer.getAttributes();
        layerRelationsAttributes = [];//layer.getRelationsAttributes();
        layerTitle = layer.getTitle();
        layerId = layer.getId();
      }
      else if (layer instanceof ol.layer.Vector){
        layerAttributes = layer.getProperties();
        layerRelationsAttributes =  [];
        layerTitle = layer.get('name');
        layerId = layer.get('id');
      }

      var layerObj = {
        title: layerTitle,
        id: layerId,
        attributes: [],
        features: [],
        hasgeometry: false,
        show: true,
        expandable: true,
        hasImageField: false, // regola che mi permette di vedere se esiste un campo image
        relationsattributes: layerRelationsAttributes,
        error: ''
      };

      // verifico che ci siano feature legate a quel layer che sono il risultato della query
      if (featuresForLayer.features && featuresForLayer.features.length) {
        // prendo solo gli attributi effettivamente ritornati dal WMS (usando la prima feature disponibile)
        layerObj.attributes = self._parseAttributes(layerAttributes, featuresForLayer.features[0].getProperties()),
        // faccio una ricerca sugli attributi del layer se esiste un campo image
        // se si lo setto a true
        _.forEach(layerObj.attributes, function(attribute) {
          if (attribute.type == 'image') {
            layerObj.hasImageField = true;
          }
        });
        // a questo punto scorro sulle features selezionate dal risultato della query
        _.forEach(featuresForLayer.features, function(feature){
          var fid = feature.getId() ? feature.getId() : id;
          var geometry = feature.getGeometry();
          // verifico se il layer ha la geometria
          if (geometry) {
            // setto che ha geometria mi servirà per le action
            layerObj.hasgeometry = true
          }
          // creo un feature object
          var featureObj = {
            id: fid,
            attributes: feature.getProperties(),
            geometry: feature.getGeometry(),
            show: true
            // aggiungo le relazioni
          };
          layerObj.features.push(featureObj);
          id += 1;
        });
        layers.push(layerObj);
      }
      else if (featuresForLayer.error){
        layerObj.error = featuresForLayer.error;
        console.log(featuresForLayer.error);
      }
    });
    return layers;
  };
  
  this._parseAttributes = function(layerAttributes, featureAttributes) {
    var featureAttributesNames = _.keys(featureAttributes);
    featureAttributesNames = _.filter(featureAttributesNames,function(featureAttributesName){
      return ['boundedBy','geom','the_geom','geometry','bbox', 'GEOMETRY'].indexOf(featureAttributesName) == -1;
    });
    if (layerAttributes && layerAttributes.length) {
      var featureAttributesNames = _.keys(featureAttributes);
      return _.filter(layerAttributes,function(attribute){
        return featureAttributesNames.indexOf(attribute.name) > -1;
      })
    }
    // se layer.attributes è vuoto
    // (es. quando l'interrogazione è verso un layer esterno di cui non so i campi)
    // costruisco la struttura "fittizia" usando l'attributo sia come name che come label
    else {
      return _.map(featureAttributesNames, function(featureAttributesName){
        return {
          name: featureAttributesName,
          label: featureAttributesName
        }
      })
    }
  };

  // metodo per settare le azioni che si possono fare sulle feature del layer
  this.setActionsForLayers = function(layers) {
    var self = this;
    // scorro su ogni layer che ho nella risposta
    _.forEach(layers, function(layer) {
      // se non esistono azioni su uno specifico layer creo
      // array di azioni con chiave id del layer (in quanto valore univoco)
      if (!self.state.layersactions[layer.id]) {
        self.state.layersactions[layer.id] = [];
      }
      // verifico se il layer ha gemetria
      if (layer.hasgeometry) {
        // se prsente aggiungo oggetto azione che mi server per fare
        // il goTo geometry
        self.state.layersactions[layer.id].push({
          id: 'gotogeometry',
          class: 'glyphicon glyphicon-map-marker',
          hint: 'Visualizza sulla mappa',
          cbk: QueryResultsService.goToGeometry
        })
      }
      // vado a costruire l'action delle query-relazioni
      if (self._relations) {
        // scorro sulle relazioni e vado a verificare se ci sono relazioni che riguardano quel determintato layer
        _.forEach(self._relations, function(relations, id) {
          // verifico se l'id del layer è uguale all'id della relazione
          if (layer.id == id) {
            self.state.layersactions[layer.id].push({
              id: 'show-query-relations',
              class: 'fa fa-sitemap',
              hint: 'Visualizza Relazioni',
              cbk: QueryResultsService.showQueryRelations,
              relations: relations
            })
          }
          return false;
        })
      }
    });
    this.addActionsForLayers(self.state.layersactions);
  };
  
  this.trigger = function(actionId, layer, feature) {
    var actionMethod = this._actions[actionId];
    if (actionMethod) {
      actionMethod(layer, feature);
    }
    if (layer) {
      var layerActions = self.state.layersactions[layer.id];
      if (layerActions) {
        var action;
        _.forEach(layerActions, function(layerAction){
          if (layerAction.id == actionId) {
            action = layerAction;
          }
        });
        if (action) {
          this.triggerLayerAction(action,layer,feature);
        }
      }
    }
  };

  this.triggerLayerAction = function(action,layer,feature) {
    if (action.cbk) {
      action.cbk(layer,feature, action)
    }
    if (action.route) {
      var url;
      var urlTemplate = action.route;
      url = urlTemplate.replace(/{(\w*)}/g,function(m,key){
        return feature.attributes.hasOwnProperty(key) ? feature.attributes[key] : "";
      });
      if (url && url != '') {
        GUI.goto(url);
      }
    }
  };

  //funzione che permette di vedere la foto a schermo intero
  this.showFullPhoto = function(url) {
    GUI.pushContent({
      content: new PhotoComponent({
        url: url
      }),
      backonclose: true,
      closable: false
    });
  };

  // funzione che mi serve per registrare il vector layer al fine di fare le query
  this.registerVectorLayer = function(vectorLayer) {
    if (this._vectorLayers.indexOf(vectorLayer) == -1) {
      //vado ad aggiungere informazioni utili alla visualizzazioni nel query
      vectorLayer.state = {};
      vectorLayer.state.title = vectorLayer.name;
      vectorLayer.state.id = vectorLayer.id;
      this._vectorLayers.push(vectorLayer);
    }
  };

  // funzione che mi serve per unregistrare il vector layer dalla query
  this.unregisterVectorLayer = function(vectorLayer) {
    var index = this._vectorLayers.indexOf(vectorLayer);
    if ( index != -1) {
      this._vectorLayers.splice(index, 1);
    }
  };

  // funzione che permette ai layer vettoriali di aggancirsi alla query info
  this._addVectorLayersDataToQueryResponse = function() {
    var self = this;
    this.onbefore('setQueryResponse', function (queryResponse, coordinates, resolution) {
      var mapService = ComponentsRegistry.getComponent('map').getService();
      var isVisible = false;
      _.forEach(self._vectorLayers, function(vectorLayer) {
        var features = [];
        var feature,
          intersectGeom;
        // la prima condizione mi server se viene fatto un setQueryResponse sul singolo layer vettoriale
        // ad esempio con un pickfeature per evitare che venga scatenato un'altra query
        // nel caso di attivazione di uno dei query control (la momento bbox, info e polygon)
        // la setQueryresponse ha priorità sugli altri di fatto cancellando la setResqponseqeusry dello specifico vectorLayer
        switch (vectorLayer.constructor) {
          case VectorLayer:
            isVisible = !vectorLayer.isVisible();
            break;
          case ol.layer.Vector:
            isVisible = !vectorLayer.getVisible();
            break;
        }
        if ((queryResponse.data && queryResponse.data.length && queryResponse.data[0].layer == vectorLayer) || !coordinates || isVisible ) { return true}
        // caso in cui è stato fatto una precedente richiesta identify e quindi devo attaccare il risultato
        // non mi piace perchè devo usare altro metodo
        // caso query info
        if (_.isArray(coordinates)) {
          if (coordinates.length == 2) {
            var pixel = mapService.viewer.map.getPixelFromCoordinate(coordinates);
            feature = mapService.viewer.map.forEachFeatureAtPixel(pixel, function (feature, layer) {
              return feature;
            },  {
              layerFilter: function(layer) {
                return layer === vectorLayer;
              }
            });
            if (feature) {
              QueryService.convertG3wRelations(feature);
              features.push(feature);
            }
          } else if (coordinates.length == 4) {
            intersectGeom = ol.geom.Polygon.fromExtent(coordinates);
            switch (vectorLayer.constructor) {
              case VectorLayer:
                features = vectorLayer.getIntersectedFeatures(intersectGeom);
                break;
              case ol.layer.Vector:
                _.forEach(vectorLayer.getSource().getFeatures(), function(feature) {
                  if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
                    features.push(feature);
                  }
                });
                break;
            }
          }
        } else if (coordinates instanceof ol.geom.Polygon || coordinates instanceof ol.geom.MultiPolygon) {
          intersectGeom = coordinates;
          switch (vectorLayer.constructor) {
            case VectorLayer:
              features = vectorLayer.getIntersectedFeatures(intersectGeom);
              break;
            case ol.layer.Vector:
              _.forEach(vectorLayer.getSource().getFeatures(), function(feature) {
                if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
                  features.push(feature);
                }
              });
              break;
          }
        }
        _.forEach(features, function(feature) {
          QueryService.convertG3wRelations(feature);
        });
        // vado a pushare le features verificando prima se c'è stato un risultato
        queryResponse.data = queryResponse.data ? queryResponse.data : [];
        queryResponse.data.push({
          features: features,
          layer: vectorLayer
        });
      })
    });
  };

  base(this);
  // lancio subito la registrazione
  this._addVectorLayersDataToQueryResponse();
}

QueryResultsService.zoomToElement = function(layer,feature) {
  //TODO
};

QueryResultsService.goToGeometry = function(layer,feature) {
  if (feature.geometry) {
    var mapService = ComponentsRegistry.getComponent('map').getService();
    mapService.highlightGeometry(feature.geometry, {duration: 4000});
  }
};

QueryResultsService.highlightGeometry = function(layer,feature) {
  if (feature.geometry) {
    var mapService = ComponentsRegistry.getComponent('map').getService();
    mapService.highlightGeometry(feature.geometry,{zoom: false});
  }
};

QueryResultsService.clearHighlightGeometry = function(layer, feature) {
  var mapService = ComponentsRegistry.getComponent('map').getService();
  mapService.clearHighlightGeometry();
};

QueryResultsService.showQueryRelations = function(layer, feature, action) {
  GUI.pushContent({
    content: new RelationsPage({
      relations: action.relations,
      feature: feature
    }),
    backonclose: true,
    closable: false
  });
};

// Make the public service en Event Emitter
inherit(QueryResultsService, G3WObject);

module.exports = QueryResultsService;

},{"./components/photo/vue/photo":162,"./components/relations/vue/relationspage":167,"core/g3wobject":30,"core/layers/layer":41,"core/map/layer/vectorlayer":60,"core/project/projectsregistry":74,"core/query/queryservice":75,"core/utils/utils":80,"gui/componentsregistry":122,"gui/gui":132}],169:[function(require,module,exports){
module.exports = "<div id=\"search-results\" class=\"queryresults-wrapper\">\n  <h3 v-if=\"state.querytitle\">Risultati {{state.querytitle.toLowerCase()}}</h3>\n  <div v-show=\"state.loading\" class=\"bar-loader\"></div>\n  <div class=\"queryresults-container\">\n    <ul v-if=\"hasResults()\" class=\"queryresults\" id=\"queryresults\">\n      <li v-if=\"layerHasFeatures(layer) && layer.show\" v-for=\"layer in state.layers\">\n        <div class=\"box box-primary\">\n          <div class=\"box-header with-border\" data-widget=\"collapse\">\n            <h3 class=\"box-title\">{{ layer.title }} ({{layer.features.length}})</h3>\n            <div class=\"box-tools pull-right\">\n              <button class=\"btn btn-box-tool\" data-widget=\"collapse\"><i class=\"btn-collapser fa fa-minus\"></i></button>\n            </div>\n          </div>\n          <div class=\"box-body\">\n            <table class=\"table table-striped\">\n              <thead>\n              <tr>\n                <th v-if=\"layer.hasgeometry\"></th>\n                <th v-for=\"(attribute, index) in attributesSubset(layer.attributes)\" :style=\"{ width:cellWidth(index,layer) + '%' }\">{{attribute.label}}</th>\n                <th :style=\"{ width:headerExpandActionCellWidth + '%' }\"></th>\n              </tr>\n              </thead>\n              <tbody>\n              <template v-if=\"feature.show\" v-for=\"feature in layer.features\">\n                <tr @click=\"toggleFeatureBoxAndZoom(layer,feature);\" @mouseover=\"trigger('highlightgeometry',layer,feature)\" @mouseout=\"trigger('clearHighlightGeometry')\" class=\"featurebox-header\">\n                  <td v-if=\"geometryAvailable(feature)\" class=\"action-cell\">\n                    <span @click.stop.prevent=\"trigger('gotogeometry',layer,feature)\" class=\"glyphicon glyphicon-map-marker action-button-icon\"></span>\n                  </td>\n                  <td v-for=\"attribute in attributesSubset(layer.attributes)\">\n                    <span>{{feature.attributes[attribute.name]}}</span>\n                  </td>\n                  <td class=\"action-cell\">\n                    <span class=\"fa link morelink\" :class=\"[collapsedFeatureBox(layer,feature) ? 'fa-plus' : 'fa-minus']\"></span>\n                  </td>\n                </tr>\n                <tr v-show=\"!collapsedFeatureBox(layer,feature)\" class=\"featurebox-body\">\n                  <td :colspan=\"attributesSubsetLength(layer.attributes)+2\">\n                    <div class=\"action-buttons-container\">\n                      <template v-for=\"action in state.layersactions[layer.id]\">\n                        <div @click=\"trigger(action.id,layer,feature)\"  class=\"action-button hint--top-right\" data-placement=\"auto bottom\" data-toggle=\"tooltip\" :title=\"action.hint\">\n                          <span :class=\"'action-button-icon ' + action.class\"></span>\n                        </div>\n                      </template>\n                    </div>\n                    <table>\n                      <tr v-for=\"attribute in layer.attributes\">\n                        <td class=\"attr-label\">{{attribute.label}}</td>\n                        <!--<td class=\"attr-value\">{{feature.attributes[attribute.name]}}</td>-->\n                        <td class=\"attr-value\">\n                          <span v-if=\"is('simple',layer,attribute.name,feature.attributes[attribute.name])\">{{feature.attributes[attribute.name]}}</span>\n                          <img v-if=\"is('photo',layer,attribute.name,feature.attributes[attribute.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(feature.attributes[attribute.name]))\" :src=\"isRelativePath(feature.attributes[attribute.name])\">\n                          <!--<span v-if=\"isRoute(layer,feature,attribute)\" class=\"link dashboardlink\" @click=\"goto(layer,feature.attributes[attribute.name])\">{{ feature.attributes[attribute.name] }}</span>-->\n                          <!--<img v-if=\"isPhoto(layer,feature,attribute)\" :data-url=\"getPhotoUrl(feature.attributes[attribute.name])\" style=\"max-width:50px\" :src=\"getPhotoUrl(feature.attributes[attribute.name],thumb)\" />-->\n                          <img v-else-if=\"checkField('image', attribute.label, layer.attributes)\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(attribute.value))\" :src=\"isRelativePath(attribute.value)\">\n                          <a v-if=\"is('link',layer,attribute.name,feature.attributes[attribute.name])\" :href=\"feature.attributes[attribute.name]\" target=\"_blank\" class=\"glyphicon glyphicon-link\"></a>\n                        </td>\n                      </tr>\n                    </table>\n                  </td>\n                </tr>\n                <tr v-show=\"collapsedFeatureBox(layer,feature) && feature.attributes.relations\">\n                  <td :colspan=\"attributesSubsetLength(layer.attributes)+2\">\n                    <!--Relazioni-->\n                    <div class=\"queryresults-container\">\n                      <ul class=\"queryresults\" id=\"relations\">\n                        <template v-for=\"relation in feature.attributes.relations\">\n                          <li>\n                            <div class=\"box box-solid box-default relationsbox collapsed-box\">\n                              <div class=\"box-header with-border\" data-widget=\"collapse\">\n                                <h3 class=\"box-title\">{{ relation.name }} ({{ relation.elements.length }})</h3>\n                                <div class=\"box-tools pull-right\">\n                                  <button class=\"btn btn-box-tool\" data-widget=\"collapse\"><i class=\"btn-collapser fa fa-plus\"></i></button>\n                                </div>\n                              </div>\n                              <div class=\"box-body\">\n                                <template v-for=\"(element, index) in relation.elements\">\n                                  <table class=\"table table-striped\">\n                                    <thead>\n                                    <tr>\n                                      <th v-for=\"attribute in relationsAttributesSubset(element)\">\n                                        {{attribute.label}}\n                                      </th>\n                                      <th></th>\n                                    </tr>\n                                    </thead>\n                                    <tbody>\n                                    <tr @click=\"toggleFeatureBox(layer, feature, relation.name+index)\"  class=\"featurebox-header\">\n                                      <td v-for=\"attribute in relationsAttributesSubset(element)\">\n                                        <span>{{attribute.value}}</span>\n                                      </td>\n                                      <td class=\"action-cell text-center\">\n                                        <span class=\"fa link morelink\" :class=\"[collapsedFeatureBox(layer, feature, relation.name+index) ? 'fa-minus' : 'fa-plus']\" style=\"text-align: right\"></span>\n                                      </td>\n                                    </tr>\n                                    <tr v-show=\"collapsedFeatureBox(layer, feature, relation.name+index)\" class=\"featurebox-body\">\n                                      <td :colspan=\"relationsAttributesSubsetLength(element)+1\">\n                                        <table>\n                                          <tr v-for=\"relattribute in relationsAttributes(element)\">\n                                            <td class=\"attr-label\">{{relattribute.label}}</td>\n                                            <!--<td class=\"attr-value\">{{attribute.value}}</td>-->\n                                            <td class=\"attr-value\">\n                                              <div v-if=\"isArray(relattribute.value)\" v-for=\"value in relattribute.value\">\n                                                <div v-for=\"value, label in value\">\n                                                  <span>{{ label }}</span><span class=\"pull-right\">{{ value }}</span>\n                                                </div>\n                                                <span class=\"divider\"></span>\n                                              </div>\n                                              <span v-if=\"isSimple(layer,relattribute.name, relattribute.value)\">{{relattribute.value}}</span>\n                                              <!--<img v-if=\"is('photo',layer,relattribute.name,feature.attributes[attribute.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(feature.attributes[attribute.name]))\" :src=\"isRelativePath(feature.attributes[attribute.name])\">-->\n                                              <!--<img v-if=\"relattribute.label == 'image'\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">-->\n                                              <img v-else-if=\"checkField('image', relattribute.label, layer.relationsattributes[relation.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">\n                                              <img v-else-if=\"is('photo',layer, relattribute.name, relattribute.value)\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">\n                                              <!--&lt;!&ndash;<span v-if=\"isRoute(layer,feature,attribute)\" class=\"link dashboardlink\" @click=\"goto(layer,feature.attributes[attribute.name])\">{{ feature.attributes[attribute.name] }}</span>&ndash;&gt;-->\n                                              <!--<img v-if=\"isPhoto(layer,feature,attribute)\" v-bind:data-url=\"getPhotoUrl(feature.attributes[attribute.name])\" style=\"max-width:50px\" :src=\"getPhotoUrl(feature.attributes[attribute.name],thumb)\" />-->\n                                              <a v-if=\"isLink(layer,relattribute.name, relattribute.value)\" :href=\"relattribute.value\" target=\"_blank\" class=\"glyphicon glyphicon-link\"></a>\n                                            </td>\n                                          </tr>\n                                        </table>\n                                      </td>\n                                    </tr>\n                                    </tbody>\n                                  </table>\n                                </template>\n                              </div>\n                            </div>\n                          </li>\n                        </template>\n                      </ul>\n                    </div>\n                    <!--Fine Relazioni-->\n                  </td>\n                </tr>\n              </template>\n              </tbody>\n            </table>\n          </div>\n        </div>\n      </li>\n    </ul>\n  </div>\n  <span v-if=\"!hasResults() && !state.loading\">Nessun risultato</span>\n</div>\n\n";

},{}],170:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var QueryResultsService = require('gui/queryresults/queryresultsservice');
var ProjectsRegistry = require('core/project/projectsregistry');

Fields = {};
Fields.SIMPLE = 'simple';
Fields.LINK = 'link';
Fields.PHOTO = 'photo';
Fields.IMAGE = 'image';
Fields.POINTLINK = 'pointlink';
Fields.ROUTE = 'route';

function getFieldType(layer, name, value) {

  var URLPattern = /^(https?:\/\/[^\s]+)/g;
  var PhotoPattern = /[^\s]+.(png|jpg|jpeg)$/g;
  if (_.isNil(value)) {
    return Fields.SIMPLE;
  }
  value = value.toString();

  var extension = value.split('.').pop();
  if (value.match(PhotoPattern)) {
    return Fields.PHOTO;
  }

  if (value.match(URLPattern)) {
    return Fields.LINK;
  }

  return Fields.SIMPLE;
}

function fieldIs(TYPE,layer,attributeName,attributeValue) {
  var fieldType = getFieldType(layer,attributeName,attributeValue);
  return fieldType === TYPE;
}

var maxSubsetLength = 3;
var headerExpandActionCellWidth = 10;
var headerActionsCellWidth = 10;

var vueComponentOptions = {
  template: require('./queryresults.html'),
  data: function() {
    return {
      state: this.$options.queryResultsService.state,
      layersFeaturesBoxes: {},
      headerExpandActionCellWidth: headerExpandActionCellWidth,
      headerActionsCellWidth: headerActionsCellWidth
    }
  },
  methods: {
    isArray: function (value) {
      return _.isArray(value);
    },
    isSimple: function(layer,attributeName,attributeValue) {
      return !this.isArray(attributeValue) && fieldIs(Fields.SIMPLE,layer,attributeName,attributeValue);
    },
    isLink: function(layer,attributeName,attributeValue) {
      return fieldIs(Fields.LINK,layer,attributeName,attributeValue);
    },
    is: function(type,layer,attributeName,attributeValue) {
      return fieldIs(type,layer,attributeName,attributeValue);
    },
    checkField: function(type, fieldname, attributes) {
      var isType = false;
      _.forEach(attributes, function(attribute) {
        if (attribute.name == fieldname) {
          isType = attribute.type == type;
        }
      });

      return isType;
    },
    isRelativePath: function(url) {
      if (!_.startsWith(url,'/')) {
        return ProjectsRegistry.getConfig().mediaurl + url
      }
      return url
    },
    layerHasFeatures: function(layer) {
      if (layer.features) {
        return layer.features.length > 0;
      }
      return false;
    },
    hasResults: function() {
      return this.state.layers.length;
    },
    layerHasActions: function(layer) {
      return this.state.layersactions[layer.id].length > 0;
    },
    featureHasActions: function(layer,feature) {
      return this.geometryAvailable(feature);
    },
    /*getLayerActions: function(layer) {
     return this.$options.queryResultsService.getLayerActions(layer);
     },*/
    geometryAvailable: function(feature) {
      return feature.geometry ? true : false;
    },
    attributesSubset: function(attributes) {
      // faccio un filtro sul campo immagine perchè non ha senso far vedere
      // la stringa con il path dell'immagine
      var attributes = _.filter(attributes, function(attribute) {
        return attribute.type != 'image';
      });
      var end = Math.min(maxSubsetLength, attributes.length);
      return attributes.slice(0, end);
    },
    relationsAttributesSubset: function(relationAttributes) {
      var attributes = [];

      _.forEach(relationAttributes, function (value, attribute) {
        if (_.isArray(value)) return;
        attributes.push({label: attribute, value: value})
      });
      var end = Math.min(maxSubsetLength, attributes.length);
      return attributes.slice(0, end);
    },
    relationsAttributes: function(relationAttributes) {
      var attributes = [];
      _.forEach(relationAttributes, function (value, attribute) {
        attributes.push({label: attribute, value: value})
      });
      return attributes;
    },
    attributesSubsetLength: function(attributes) {
      return this.attributesSubset(attributes).length;
    },
    cellWidth: function(index,layer) {
      var subsetLength = this.attributesSubsetLength(layer.attributes);
      var diff = maxSubsetLength - subsetLength;
      actionsCellWidth = layer.hasgeometry ? headerActionsCellWidth : 0;
      var headerAttributeCellTotalWidth = 100 - headerExpandActionCellWidth - actionsCellWidth;
      var baseCellWidth = headerAttributeCellTotalWidth / maxSubsetLength;
      if ((index == subsetLength-1) && diff>0) {
        return baseCellWidth * (diff+1);
      }
      else {
        return baseCellWidth;
      }
    },
    featureBoxColspan: function(layer) {
      var colspan = this.attributesSubsetLength(layer.attributes);
      if (layer.expandable) {
        colspan += 1;
      }
      if (layer.hasgeometry) {
        colspan += 1;
      }
      return colspan;
    },
    relationsAttributesSubsetLength: function(elements) {
      return this.relationsAttributesSubset(elements).length;
    },
    collapsedFeatureBox: function(layer, feature, relation_index) {
      var collapsed = true;
      var boxid;
      if (!_.isNil(relation_index)) {
        boxid = layer.id + '_' + feature.id+ '_' + relation_index;
      } else {
        boxid = layer.id + '_' + feature.id;
      }
      if (this.layersFeaturesBoxes[boxid]) {
        collapsed = this.layersFeaturesBoxes[boxid].collapsed;
      }
      return collapsed;
    },
    toggleFeatureBox: function(layer, feature, relation_index) {
      var boxid;
      if (!_.isNil(relation_index)) {
        boxid = layer.id + '_' + feature.id+ '_' + relation_index;
      } else {
        boxid = layer.id + '_' + feature.id;
      }
      this.layersFeaturesBoxes[boxid].collapsed = !this.layersFeaturesBoxes[boxid].collapsed;
    },
    toggleFeatureBoxAndZoom: function(layer, feature, relation_index) {;
      // Disattivo zoom to sul toggle della featurebox. Casomai lo ripristineremo quando sarà gestito tramite qualche setting
      /*if (this.collapsedFeatureBox(layer, feature, relation_index)) {
       this.trigger('gotogeometry',layer,feature)
       }*/
      this.toggleFeatureBox(layer, feature, relation_index);
    },
    trigger: function(action,layer,feature) {
      this.$options.queryResultsService.trigger(action,layer,feature);
    },
    showFullPhoto: function(url) {
      this.$options.queryResultsService.showFullPhoto(url);
    }
  },
  watch: {
    // i listeners del queryResultsService.postRender
    // potrebbero avere bisogno di modificare il DOM dopo che sono cambiati
    // (per qualsiasi motivo) i dati e quindi Vue rirenderizza il DOM
    'state.layers': function(layers) {
      var self = this;
      if (layers.length) {
        this.$nextTick(function() {
          self.$options.queryResultsService.postRender(self.$el);
        })
      }
    }
  },
  mounted: function() {
    Vue.nextTick(function() {
      // vado a settare i tooltip
      $('[data-toggle="tooltip"]').tooltip();
    })
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);

function QueryResultsComponent(options) {
  base(this, options);
  var self = this;
  this.id = "queryresults";
  this.title = "Query Results";
  this._service = new QueryResultsService();
  //usato quando è stato distrutto
  this.setInternalComponent = function() {
    this.internalComponent = new InternalComponent({
      queryResultsService: this._service
    });
    this.createLayersFeaturesBoxes();
    this.internalComponent.querytitle = this._service.state.querytitle;
  };

  this.getElement = function() {
    if (this.internalComponent) {
      return this.internalComponent.$el;
    }
  };

  this._service.onafter('setLayersData',function() {
    if (!self.internalComponent) {
      self.setInternalComponent();
    }
    self.createLayersFeaturesBoxes();
  });

  merge(this, options);

  this.createLayersFeaturesBoxes = function() {
    var layersFeaturesBoxes = {};
    var layers = this._service.state.layers;
    _.forEach(layers, function(layer) {
      //da rivedere meglio
      if (layer.attributes.length <= maxSubsetLength && !layer.hasImageField) {
        layer.expandable = false;
      }
      _.forEach(layer.features, function(feature, index) {
        // se è la prima feature e il layer ha più di maxSubsetLength attributi, allora la espando già in apertura
        //var collapsed = (index == 0 && layer.attributes.length > maxSubsetLength) ? false : true;
        var collapsed = true;
        var boxid = layer.id+'_'+feature.id;
        layersFeaturesBoxes[boxid] = {
          collapsed: collapsed
        };
        if (feature.attributes.relations) {
          boxid = '';
          _.forEach(feature.attributes.relations, function(relation) {
            boxid = layer.id + '_' + feature.id + '_' + relation.name;
            _.forEach(relation.elements, function(element, index){
              layersFeaturesBoxes[boxid+index] = {
                collapsed: true
              };
            });
          })
        }
      })
    });
    this.internalComponent.layersFeaturesBoxes = layersFeaturesBoxes;
  };
  // sovracrive il metodo pader mount del component
  /*this.mount = function(parent, append) {
    var self = this;
    // richiama il mont padre
    return base(this, 'mount', parent, append)
  };*/

  this.layout = function(width,height) {
    //TODO
  }
}
inherit(QueryResultsComponent, Component);

module.exports = QueryResultsComponent;
},{"./queryresults.html":169,"core/project/projectsregistry":74,"core/utils/utils":80,"gui/queryresults/queryresultsservice":168,"gui/vue/component":182}],171:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var ProjectsRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');
var SearchPanel = require('gui/search/vue/panel/searchpanel');

function SearchesService(){

  this.init = function(searchesObject) {
    var searches = searchesObject || ProjectsRegistry.getCurrentProject().state.search;
    this.state.searches = searches;
  };
  this.state = {
    searches: []
  };
  this.showSearchPanel = function(panelConfig) {
    var panel =  new SearchPanel();// creo panello search
    panel.init(panelConfig);//inizializzo pannello se
    GUI.showPanel(panel);
    return panel;
  };

  this.cleanSearchPanels = function() {
    this.state.panels = {};
  };

  this.stop = function(){
    var deferred = $.Deferred();
    deferred.resolve();
    return deferred.promise();
  };

  this.reload = function() {
    var searches = ProjectsRegistry.getCurrentProject().state.search;
    Vue.set(this.state, 'searches', searches);
  }
}

// Make the public service en Event Emitter
inherit(SearchesService, G3WObject);

module.exports = SearchesService;

},{"core/g3wobject":30,"core/project/projectsregistry":74,"core/utils/utils":80,"gui/gui":132,"gui/search/vue/panel/searchpanel":173}],172:[function(require,module,exports){
module.exports = "<div class=\"g3w-search-panel form-group\">\n  <h4><b>{{ title }}</b></h4>\n  <form id=\"g3w-search-form\">\n    <template v-for=\"(forminput, index) in forminputs\">\n      <div v-if=\"forminput.input.type == 'numberfield'\" class=\"form-group numeric\">\n        <label :for=\"forminput.id + ' '\">{{ forminput.label }}</label>\n        <input type=\"number\" v-model=\"formInputValues[index].value\" class=\"form-control\" :id=\"forminput.id\">\n      </div>\n      <div v-if=\"forminput.input.type == 'textfield' || forminput.input.type == 'textField'\" class=\"form-group text\">\n        <label :for=\"forminput.id\">{{ forminput.label }}</label>\n        <input type=\"text\" v-model=\"formInputValues[index].value\" class=\"form-control\" :id=\"forminput.id\">\n      </div>\n    </template>\n    <div class=\"form-group\">\n      <button style=\"background-color:#3c8dbc\" class=\"btn btn-block pull-right\" @click=\"doSearch($event)\" data-i18n=\"dosearch\">Search</button>\n    </div>\n  </form>\n</div>\n";

},{}],173:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var localize = require('core/i18n/i18n.service').t;
var resolve = require('core/utils/utils').resolve;
var GUI = require('gui/gui');
var QueryService = require('core/query/queryservice');
var ListPanel = require('gui/listpanel').ListPanel;
var Panel = require('gui/panel');
var ProjectsRegistry = require('core/project/projectsregistry');
var Filter = require('core/layers/filter/filter');
var Expression = require('core/layers/filter/expression');

//componente vue pannello search
var SearchPanelComponet = Vue.extend({
  template: require('./searchpanel.html'),
  data: function() {
    return {
      title: "",
      forminputs: [],
      filterObject: {},
      formInputValues : [],
      queryurl: null
    }
  },
  methods: {
    doSearch: function(event) {
      var self = this;
      event.preventDefault();
      //al momento molto farragginoso ma da rivedere
      //per associazione valore input
      this.filterObject = this.fillFilterInputsWithValues(this.filterObject, this.formInputValues);
      // forzo il cambiamento dell'url se esiste il query url
      if (this.queryurl) {
        this.filterObject.url = this.queryurl;
      }
      var showQueryResults = GUI.showContentFactory('query');
      var queryResultsPanel = showQueryResults(self.title);
      var filter = new Filter();
      var expression = new Expression();
      expression.createExpressionFromFilter(this.filterObject.filter, this.queryLayer.getName());
      filter.setExpression(expression.get());
      this.queryLayer.search({
        filter: filter
      })
      .then(function(results) {
         queryResultsPanel.setQueryResponse(results);
      })
      .fail(function() {
        GUI.notify.error('Si è verificato un errore nella richiesta al server');
        GUI.closeContent();
      })
    }
  }
});

//costruttore del pannello e del suo componente vue
function SearchPanel(options) {
  self = this;
  var options = options || {};
  this.config = {};
  this.filter = {};
  this.id = null;
  this.querylayerid = null;
  this.internalPanel = options.internalPanel || new SearchPanelComponet();
  //funzione inizializzazione
  this.init = function(config) {
    this.config = config || {};
    this.name = this.config.name || this.name;
    this.id = this.config.id || this.id;
    // rpendo il filtro restituito dal server
    this.filter = this.config.options.filter || this.filter;
    this.internalPanel.queryurl = this.config.options.queryurl || null;
    var queryLayerId = this.config.options.querylayerid || this.querylayerid;
    // recupero il query layer dall'id della configurazione
    this.queryLayer = ProjectsRegistry.getCurrentProject().getLayersStore().getLayerById(queryLayerId);
    //vado a riempire gli input del form del pannello con campo e valore
    this.fillInputsFormFromFilter();
    //creo e assegno l'oggetto filtro
    var filterObjFromConfig = this.createQueryFilterFromConfig(this.filter);

    //alla fine creo l'ggetto finale del filtro da passare poi al provider QGISWMS o WFS etc.. che contiene sia
    //il filtro che url, il nome del layer il tipo di server etc ..
    this.internalPanel.filterObject = this.createQueryFilterObject({
      queryLayer: this.queryLayer,
      filter: filterObjFromConfig
    });
    this.internalPanel.filterObject = this.internalPanel.filterObject;
    this.internalPanel.queryLayer = this.queryLayer;
    //soluzione momentanea assegno  la funzione del SearchPanle ma come pattern è sbagliato
    //vorrei delegarlo a SearchesService ma lo stesso stanzia questo (loop) come uscirne???
    //creare un searchpanelservice?
    this.internalPanel.fillFilterInputsWithValues = this.fillFilterInputsWithValues;
    this.internalPanel.title = this.name;
  };
  //funzione che popola gli inputs che ci saranno nel form del pannello ricerca
  //oltre costruire un oggetto che legherà i valori degli inputs del form con gli oggetti
  //'operazionali' del filtro
  this.fillInputsFormFromFilter = function() {
    var id = 0;
    var formValue;
    _.forEach(this.filter,function(v,k,obj) {
      _.forEach(v, function(input){
        //sempre nuovo oggetto
        formValue = {};
        //inserisco l'id all'input
        input.id = id;
        //aggiungo il tipo al valore per fare conversione da stringa a tipo input
        formValue.type = input.input.type;
        ////TEMPORANEO !!! DEVO PRENDERE IL VERO VALORE DI DEFAULT
        formValue.value = null;
        //popolo gli inputs:
        // valori
        self.internalPanel.formInputValues.push(formValue);
        //input
        self.internalPanel.forminputs.push(input);
        id+=1;
      });
    });
  };
  //funzione che associa i valori dell'inputs form al relativo oggetto "operazionde del filtro"
  this.fillFilterInputsWithValues = function(filterObject, formInputValues, globalIndex) {
    //funzione conversione da valore restituito dall'input (sempre stringa) al vero tipo di valore
    function convertInputValueToInputType(type, value) {
      switch(type) {
        case 'numberfield':
             value = parseInt(value);
             break;
        default:
             break;
      }
      return value;
    }
    //ciclo sull'oggetto filtro che ha come chiave root 'AND' o 'OR'
    _.forEach(filterObject.filter, function(v,k) {
      //scorro attraverso l'array di elementi operazionali da confrontare
      _.forEach(v, function(input, idx) {
        //elemento operazionale {'=':{}}
        _.forEach(input, function(v, k, obj) {
          //vado a leggere l'oggetto attributo
          if (_.isArray(v)) {
            //richiama la funzione ricorsivamente .. andrà bene ?
            fillFilterInputsWithValues(input, formInputValues, idx);
          } else {
            _.forEach(v, function(v, k, obj) {
              //considero l'index globale in modo che inputs di operazioni booleane interne
              //vengono considerate
              index = (globalIndex) ? globalIndex + idx : idx;
              obj[k] = convertInputValueToInputType(formInputValues[index].type, formInputValues[index].value);
            });
          }
        });
      });
    });
    return filterObject;
  };

  this.createQueryFilterFromConfig = function(filter) {
    var queryFilter = {};
    var operator;
    var field;
    var booleanObject = {};
    //funzione che costruisce l'oggetto operatore es. {'=':{'nomecampo':null}}
    function createOperatorObject(obj) {
      //rinizializzo a oggetto vuoto
      evalObject = {};
      //verifico che l'oggetto passato non sia a sua volta un oggetto 'BOOLEANO'
      _.forEach(obj, function(v,k) {
        if (_.isArray(v)) {
          return createBooleanObject(k,v);
        }
      });
      field = obj.attribute;
      operator = obj.op;
      evalObject[operator] = {};
      evalObject[operator][field] = null;
      return evalObject;
    }
    //functione che costruisce oggetti BOOLEANI caso AND OR contenente array di oggetti fornit dalla funzione createOperatorObject
    function createBooleanObject(booleanOperator, operations) {
      booleanObject = {};
      booleanObject[booleanOperator] = [];
      _.forEach(operations, function(operation){
        booleanObject[booleanOperator].push(createOperatorObject(operation));
      });
      return booleanObject;
    }
    /*
     // vado a creare l'oggetto filtro principale. Questo è un oggetto che contiene l'operatore booleano come root (chiave)
     // come valore un array di oggetti operatori che contengono il tipo di operatore come chiave e come valore un oggetto contenete
     // nome campo e valore passato
     */
    _.forEach(filter, function(v,k,obj) {
      queryFilter = createBooleanObject(k,v);
    });
    return queryFilter;
  };

// funzione che in base ai layer coinvolti nella chaita del filtro,
// creerà un'array di oggetti a seconda del tipo di layer
  this.createQueryFilterObject = function(options) {
    var options = options || {};
    var queryLayer = options.queryLayer || [];
    var ogcService = options.ogcService || 'wms';
    var filter =  options.filter || {};
    var queryFilter;
    var info = this.getInfoFromLayer(queryLayer, ogcService);
    // vado a creare un oggetto/array di oggetti con informazioni rigurdanti layers in comune
    queryFilter = _.merge(info, {
      // Servizio ogc: wfs, wms etc..
      ogcService: ogcService,
      filter : filter // oggetto che descrive come dovrà essere composto il filtro dal provider
    });
    return queryFilter
  };

// restituisce gli url per ogni layer o gruppo di layers
// che condividono lo stesso indirizzo di servizio
  this.getInfoFromLayer = function(layer, ogcService) {
    // wfs specifica se deve essere fatta chiamata wfs o no
    var urlForLayer = {};
    // scooro sui ogni layer e catturo il queryUrl
    // se wfs prendo l'api fornite dal server
    if (ogcService == 'wfs') {
      var queryUrl = layer.getProject().getWmsUrl();
    } else {
      var queryUrl = layer.getQueryUrl();
    }
    urlsForLayer = {
      url: queryUrl,
      layers: [],
      infoFormat: layer.getInfoFormat(ogcService),
      crs: layer.getCrs(), // dovrebbe essere comune a tutti
      serverType: layer.getServerType() // aggiungo anche il tipo di server
    };
    return urlForLayer;
  };
}

inherit(SearchPanel, Panel);

module.exports = SearchPanel;

},{"./searchpanel.html":172,"core/i18n/i18n.service":33,"core/layers/filter/expression":37,"core/layers/filter/filter":38,"core/project/projectsregistry":74,"core/query/queryservice":75,"core/utils/utils":80,"gui/gui":132,"gui/listpanel":146,"gui/panel":153}],174:[function(require,module,exports){
module.exports = "<ul id=\"g3w-search\" class=\"treeview-menu g3w-search g3w-tools menu-items\">\n  <li v-for=\"search in state.searches\" class=\"menu-item\" @click=\"showSearchPanel(search)\">\n    <i class=\"fa fa-circle-o\"></i>\n    <span>{{ search.name }}</span>\n  </li>\n</ul>\n";

},{}],175:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ProjectsRegistry = require('core/project/projectsregistry');
var SearchesService = require('gui/search/searchesservice');

var vueComponentOptions = {
   template: require('./search.html'),
   data: function() {
    	return {
    	  state: null
    	};
   },
   methods: {
    showSearchPanel: function(search) {
        this.$options.searchesService.showSearchPanel(search);
    }
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);
// se lo voglio usare come componente come elemento html

/* COMPONENTI FIGLI */
/* FINE COMPONENTI FIGLI */

/* INTERFACCIA PUBBLICA */
function SearchComponent(options){
  base(this,options);
  this.id = "search-component";
  this.title = "search";
  this._service = new SearchesService();
  this.internalComponent = new InternalComponent({
    searchesService: this._service
  });
  this.internalComponent.state = this._service.state;
  this.state.visible = ProjectsRegistry.getCurrentProject().state.search.length > 0;
  merge(this, options);
  this.initService = function() {
    //inizializzo il servizio
    this._service.init();
  };

  this._reload = function() {
    this.state.visible = ProjectsRegistry.getCurrentProject().state.search.length > 0;
    this._service.reload();
  }
}

inherit(SearchComponent, Component);
module.exports = SearchComponent;

},{"./search.html":174,"core/project/projectsregistry":74,"core/utils/utils":80,"gui/search/searchesservice":171,"gui/vue/component":182}],176:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var StreetViewComponent = require('gui/streetview/vue/streetview');

function StreetViewService() {
  this._position = null;
  this.setters = {
    postRender: function(position) {
      //hook postrender
    }
  };

  this.getPosition = function() {
    return this._position;
  };

  this.showStreetView = function(position) {
    this._position = position;
    GUI.setContent({
      content: new StreetViewComponent({
        service: this
      }),
      title: 'StreetView'
    });
  };
  base(this);
}

inherit(StreetViewService, G3WObject);

module.exports = StreetViewService;

},{"core/g3wobject":30,"core/utils/utils":80,"gui/gui":132,"gui/streetview/vue/streetview":178}],177:[function(require,module,exports){
module.exports = "<div id=\"streetview\"></div>";

},{}],178:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');

var InternalComponent = Vue.extend({
  template: require('./streetview.html'),
  data: function() {
    return {
      state: null
    }
  },
  mounted: function() {
    var self = this;
    this.$nextTick(function() {
      var position = self.$options.service.getPosition();
      self.$options.service.postRender(position);
    });
  }
});

var StreetViewComponent = function(options) {
  base(this);
  var options = options || {};
  var service = options.service;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service
  });
  this.setInternalComponent(internalComponent);
  this.unmount = function() {
    return base(this, 'unmount');
  }
};

inherit(StreetViewComponent, Component);


module.exports = StreetViewComponent;



},{"./streetview.html":177,"core/utils/utils":80,"gui/vue/component":182}],179:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function ToolsService(){
  var self = this;
  this.config = null;
  this._actions = {};
  this.state = {
    toolsGroups: []
  };
  this.setters = {
    addTools: function(order, groupName, tools) {
      self._addTools(order, groupName, tools);
    },
    addToolGroup: function(order, group) {
      self.state.toolsGroups.splice(order, 0, group);
    },
    removeTools:function() {
      self._removeTools();
    }
  };
  
  this._addTools = function(order, groupName, tools) {
    var self = this;
    var group = this._getToolsGroup(groupName);
    if (!group) {
      group = {
        name: groupName,
        tools: []
      };
      this.addToolGroup(order, group);
    }
    _.forEach(tools, function(tool){
      group.tools.push(tool);
      self._addAction(tool);
    });
  };

  this._removeTool = function(toolIdx) {
    this.state.toolsGroups = this.state.toolsGroups.splice(toolIdx, 1);
  };

  this._removeTools = function() {
    var self = this;
    _.forEach(this.state.toolsGroups, function(toolGroup, toolIdx) {
      self.state.toolsGroups.splice(0,1);
    })
  };

  this.updateToolsGroup = function(order, groupConfig) {
    Vue.set(this.state.toolsGroups, order, groupConfig);
  };

  this.getState = function() {
    return this.state;
  };

  this.fireAction = function(actionId){
    var action = this._actions[actionId];
    action();
  };

  this._getToolsGroup = function(groupName) {
    var group = null;
    _.forEach(this.state.toolsGroups,function(_group){
      if (_group.name == groupName) {
        group = _group;
      }
    });
    return group;
  };

  this._addAction = function(tool) {
    var actionId = Math.floor(Math.random() * 1000000)+1;
    tool.actionId = actionId;
    this._actions[actionId] = tool.action;
  };

  base(this);
}

inherit(ToolsService, G3WObject);

module.exports = ToolsService;

},{"core/g3wobject":30,"core/utils/utils":80}],180:[function(require,module,exports){
module.exports = "<ul class=\"g3w-tools treeview-menu\">\n  <li v-for=\"group in state.toolsGroups\">\n    <div class=\"tool-header\">\n      <i class=\"fa fa-gear\"></i>\n      <span style=\"\">{{ group.name }}</span>\n    </div>\n    <div :id=\"group.name + '-tools'\" class=\"tool-box\">\n      <template v-for=\"tool in group.tools\">\n        <div v-if=\"tool.type == 'checkbox' \" class=\"checkbox\">\n          <label>\n            <input style=\"cursor:pointer\" :id=\"tool.layerName\" v-model=\"tool.isCheck\" type=\"checkbox\" :value=\"tool.layerName\" @click=\"fireAction(tool.actionId)\">{{ tool.name }}\n          </label>\n        </div>\n        <div v-else class=\"tool\" @click=\"fireAction(tool.actionId)\">\n          <i class=\"fa fa-caret-right\"></i>\n          <span >{{ tool.name }}</span>\n        </div>\n      </template>\n    </div>\n  </li>\n</ul>\n\n";

},{}],181:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ToolsService = require('gui/tools/toolsservice');

var InternalComponent = Vue.extend({
  template: require('./tools.html'),
  data: function() {
    return {
      state: null
    }
  },
  methods: {
    fireAction: function(actionId) {
      this.$options.toolsService.fireAction(actionId);
    }
  }
});

function ToolsComponent(options) {

  base(this,options);
  var self = this;
  this._service = new ToolsService();
  this.id = "tools-component";
  this.title = "tools";
  this.state.visible = false;

  // vado a settare l'onafter nel caso di un add tools che di un remove tool
  this._service.onafter('addTools', function() {
    self.state.visible = self._service.state.toolsGroups.length > 0;
  });
  this._service.onafter('removeTools', function() {
    self.state.visible = self._service.state.toolsGroups.length > 0;
  });
  /* ----------------------*/
  merge(this, options);
  this.internalComponent = new InternalComponent({
    toolsService: this._service
  });
  //sostituisco lo state del servizio allo state del componente vue interno
  this.internalComponent.state = this._service.state;
}

inherit(ToolsComponent, Component);

var proto = ToolsComponent.prototype;

module.exports = ToolsComponent;

},{"./tools.html":180,"core/i18n/i18n.service":33,"core/utils/utils":80,"gui/tools/toolsservice":179,"gui/vue/component":182}],182:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var resolve = require('core/utils/utils').resolve;
var BaseComponent = require('gui/component');
// classe componente
var Component = function(options) {
  base(this, options);
};
// eredita le caratteristiche del componente base
inherit(Component, BaseComponent);

//prototype
var proto = Component.prototype;

// viene richiamato dalla toolbar o da qualsiasi parte per montare il componente vue su un particolare elemento dom padre
// quando il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
proto.mount = function(parent, append) {
  var self = this;
  var d = $.Deferred();
  // verifica che sia stato settato il componente interno
  if (!this.internalComponent) {
    this.setInternalComponent();
  }
  // verifica se è in append o no
  if (append) {
    var iCinstance = this.internalComponent.$mount();
    $(parent).append(iCinstance.$el);
  }
  else {
    this.internalComponent.$mount(parent);
  }
  //return resolve(true);
  Vue.nextTick(function(){
    $(parent).localize();
    // risolve la promessa
    d.resolve(true);
  });
  return d.promise();
};
// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso
proto.unmount = function() {
  // il problema che distruggere
  if (_.isNil(this.internalComponent)) {
    var a = 1;
    return resolve();
  }
  this.internalComponent.$destroy(true);
  $(this.internalComponent.$el).remove();
  // lo setta di nuovo a null
  this.internalComponent = null;
  return resolve();
};
// funzione che verifica se il componente interno è montato
proto.ismount = function() {
  return this.internalComponent && this.internalComponent.$el;
};

// funzione layout
proto.layout = function(width,height) {
  if (this.internalComponent) {}
};
module.exports = Component;

},{"core/utils/utils":80,"gui/component":121}],183:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;

Vue.directive("disabled",function(el, binding){
    if (binding.value){
      el.setAttribute('disabled','disabled');
    }
    else {
      el.removeAttribute('disabled');
    }
  }
);

Vue.directive("checked",function(el, binding){
    if (binding.value){
      el.setAttribute('checked','checked');
    }
    else {
      el.removeAttribute('checked');
    }
  }
);

Vue.directive("selected-first",function(el, binding){
    if (binding.value==0){
      el.setAttribute('selected','');
    }
    else {
      el.removeAttribute('selected');
    }
  }
);

Vue.directive("t",function(el, binding){
  return t(binding.value);
});

},{"core/i18n/i18n.service":33}],184:[function(require,module,exports){
var g3w = g3w || {};

g3w.core = {
  G3WObject: require('core/g3wobject'),
  utils: require('core/utils/utils'),
  ApplicationService: require('core/applicationservice'),
  ApiService: require('core/apiservice'),
  Router: require('core/router'),
  i18n: require('core/i18n/i18n.service'),
  editing: {
    Session: require('core/editing/session'),
    Editor: require('core/editing/editor'),
    ChangesManager: require('core/editing/changesmanager')
  },
  geometry: {
    Geom: require('core/geometry/geom'),
    Geometry: require('core/geometry/geometry')
  },
  project: {
    ProjectsRegistry: require('core/project/projectsregistry'),
    Project: require('core/project/project')
  },
  map: {
    MapLayersStoreRegistry: require('core/map/maplayersstoresregistry'),
    layer: {
      WmsLayer: require('core/map/layer/wmslayer'),
      VectorLayerLoader: require('core/map/layer/loader/vectorloaderlayer')
    }
  },
  catalog: {
    CatalogLayersStoresRegistry: require('core/catalog/cataloglayersstoresregistry')
  },
  layer: {
    LayersStoreRegistry: require('core/layers/layersstoresregistry'), //nel caso un plugin volesse instanziare un layersstoreregistry proprio
    LayersStore: require('core/layers/layersstore'),
    Layer: require('core/layers/layer'),
    LayerFactory: require('core/layers/layerfactory'),
    TableLayer: require('core/layers/tablelayer'),
    VectorLayer: require('core/layers/vectorlayer'),
    ImageLayer: require('core/layers/imagelayer'),
    geometry: {
      Geometry: require('core/geometry/geometry'),
      geom: require('core/geometry/geom')
    },
    features: {
      Feature: require('core/layers/features/feature'),
      FeaturesStore: require('core/layers/features/featuresstore'),
      OlFeaturesStore: require('core/layers/features/olfeaturesstore')
    },
    MapLayer: require('core/map/layer/maplayer')
  },
  query: {
    QueryService: require('core/query/queryservice')
  },
  interaction: {
    PickCoordinatesInteraction: require('g3w-ol3/src/interactions/pickcoordinatesinteraction'),
    PickFeatureInteraction: require('g3w-ol3/src/interactions/pickfeatureinteraction')
  },
  plugin: {
    Plugin: require('core/plugin/plugin'),
    PluginsRegistry: require('core/plugin/pluginsregistry'),
    PluginService: require('core/plugin/pluginservice')
  },
  workflow: {
    Task: require('core/workflow/task'),
    Step: require('core/workflow/step'),
    Flow: require('core/workflow/flow'),
    Workflow: require('core/workflow/workflow'),
    WorkflowsStack: require('core/workflow/workflowsstack')
  }
};

g3w.gui = {
  GUI: require('gui/gui'),
  Panel: require('gui/panel'),
  ControlFactory: require('gui/map/control/factory'),
  vue: {
    Component: require('gui/vue/component'),
    SearchComponent: require('gui/search/vue/search'),
    SearchPanel: require('gui/search/vue/panel/searchpanel'),
    PrintComponent: require('gui/print/vue/print'),
    CatalogComponent: require('gui/catalog/vue/catalog'),
    MapComponent: require('gui/map/vue/map'),
    ToolsComponent: require('gui/tools/vue/tools'),
    QueryResultsComponent : require('gui/queryresults/vue/queryresults'),
    // componente Form Principale
    FormComponent: require('gui/form/vue/form'),
    // componenti Form
    FormComponents: {
      Body: require('gui/form/components/body/vue/body'),
      Footer: require('gui/form/components/footer/vue/footer')
    },
    inputs: {
      InputsComponents: require('gui/inputs/inputs')
    }
  }
};

g3w.ol3 = {
  interactions : {
    PickFeatureInteraction : require('g3w-ol3/src/interactions/pickfeatureinteraction'),
    PickCoordsInteraction: require('g3w-ol3/src/interactions/pickcoordinatesinteraction'),
    DeleteFeatureInteraction: require('g3w-ol3/src/interactions/deletefeatureinteraction')
  },
  controls: {
  }
};

module.exports = {
  core: g3w.core,
  gui: g3w.gui,
  ol3: g3w.ol3
};

},{"core/apiservice":21,"core/applicationservice":22,"core/catalog/cataloglayersstoresregistry":23,"core/editing/changesmanager":25,"core/editing/editor":26,"core/editing/session":28,"core/g3wobject":30,"core/geometry/geom":31,"core/geometry/geometry":32,"core/i18n/i18n.service":33,"core/layers/features/feature":34,"core/layers/features/featuresstore":35,"core/layers/features/olfeaturesstore":36,"core/layers/imagelayer":40,"core/layers/layer":41,"core/layers/layerfactory":42,"core/layers/layersstore":43,"core/layers/layersstoresregistry":44,"core/layers/tablelayer":53,"core/layers/vectorlayer":54,"core/map/layer/loader/vectorloaderlayer":57,"core/map/layer/maplayer":58,"core/map/layer/wmslayer":61,"core/map/maplayersstoresregistry":63,"core/plugin/plugin":67,"core/plugin/pluginservice":68,"core/plugin/pluginsregistry":69,"core/project/project":73,"core/project/projectsregistry":74,"core/query/queryservice":75,"core/router":78,"core/utils/utils":80,"core/workflow/flow":81,"core/workflow/step":82,"core/workflow/task":83,"core/workflow/workflow":84,"core/workflow/workflowsstack":85,"g3w-ol3/src/interactions/deletefeatureinteraction":103,"g3w-ol3/src/interactions/pickcoordinatesinteraction":106,"g3w-ol3/src/interactions/pickfeatureinteraction":107,"gui/catalog/vue/catalog":117,"gui/form/components/body/vue/body":124,"gui/form/components/footer/vue/footer":126,"gui/form/vue/form":131,"gui/gui":132,"gui/inputs/inputs":136,"gui/map/control/factory":147,"gui/map/vue/map":152,"gui/panel":153,"gui/print/vue/print":157,"gui/queryresults/vue/queryresults":170,"gui/search/vue/panel/searchpanel":173,"gui/search/vue/search":175,"gui/tools/vue/tools":181,"gui/vue/component":182}]},{},[3]);
