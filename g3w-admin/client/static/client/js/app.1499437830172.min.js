(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var apptitle = "G3W Client";

var plugins = {
};

var tools = {
  tools:  []
};

var i18n = {
  resources: require('./locales/app.js')
};

var client =  {
  debug:  true,
  local:  false
};

var server =  {
  urls:  {
    baseurl: '/',
    ows:  'ows',
    api:  'api',
    initconfig:  'api/initconfig',
    config:  'api/config'
  }
};

module.exports = {
  apptitle: apptitle,
  client: client,
  server: server,
  plugins:  plugins,
  tools:  tools,
  i18n: i18n
};

},{"./locales/app.js":2}],2:[function(require,module,exports){
var translations = {
    "it": {
        "translation": {
            "component": "Componente Generico",
            "search": "Ricerche",
            "print": "Stampa",
            "dosearch": "Cerca",
            "catalog": "Mappa",
            "baselayers": "Basi",
            "tools": "Strumenti",
            "tree": "Strati",
            "legend": "Legenda",
            "street_search": "Cerca indirizzo",
            "show": "Mostra",
            "hide": "Nascondi",
            "street_search": "Cerca indirizzo",
            "copy_form_data": "Copia i dati del modulo",
            "paste_form_data": "Incolla",
            "copy_form_data_from_feature": "Copia i dati dalla mappa",
            "could_not_load_vector_layers": "Errore di connessione al server: non è stato possibile caricare i vettoriali richiesti"
        }
    }
};

module.exports = translations;

},{}],3:[function(require,module,exports){
var i18ninit = require('sdk').core.i18n.init;
// oggetto
var ApplicationService = require('sdk/sdk').core.ApplicationService;
// oggetto application template che si occupa di gestire il template dell'applicazione
var ApplicationTemplate = require('./template/js/template');
// configurazione dell'applicazione
var config = require('./config/config.js');
// SETTO LA VARIABILE GLOBALE g3wsdk, COME SE AVESSI USATO sdk.js
window.g3wsdk = require('sdk');
//imposto il timeout delle richieste ajax di jquery
// $.ajaxSetup({
//    timeout: 5000 // in milliseconds
// });
// inizilaizza l'internalizzazione
i18ninit(config.i18n);

// questa funzione che ala configurazione inizale dell'applicazione
// tutte le cose in comune
function createApplicationConfig() {
  return {
    apptitle: config.apptitle || '',
    logo_img: config.group.header_logo_img,
    logo_link: config.group.header_logo_link,
    terms_of_use_text: config.group.header_terms_of_use_text,
    terms_of_use_link: config.group.terms_of_use_link,
    debug: config.client.debug || false,
    group: config.group,
    urls: config.server.urls,
    mediaurl: config.server.urls.mediaurl,
    resourcesurl: config.server.urls.clienturl,
    projects: config.group.projects,
    initproject: config.group.initproject,
    overviewproject: (config.group.overviewproject && config.group.overviewproject.gid) ? config.group.overviewproject : null,
    baselayers: config.group.baselayers,
    mapcontrols: config.group.mapcontrols,
    background_color: config.group.background_color,
    crs: config.group.crs,
    proj4: config.group.proj4,
    minscale: config.group.minscale,
    maxscale: config.group.maxscale,
    // richiesto da ProjectService
    getWmsUrl: function(project){
      return config.server.urls.baseurl+config.server.urls.ows+'/'+config.group.id+'/'+project.type+'/'+project.id;
    },
    // richiesto da ProjectsRegistry per acquisire informazioni specifiche del progetto
    getProjectConfigUrl: function(project){
      return config.server.urls.baseurl+config.server.urls.config+'/'+config.group.id+'/'+project.type+'/'+project.id;
    },
    plugins: config.group.plugins,
    tools: config.tools,
    views: config.views || {},
    user: config.user || null
  };
}

// questa è la configurazione base del template che conterrà tutti gli
// elementi previsti dal template. Nella definizione sono tutti oggetti vuoti
// Sarà l'applicazione a scegliere di riempire gli elementi
function createTemplateConfig() {
  // recupero i componenti
  var CatalogComponent = require('sdk').gui.vue.CatalogComponent;
  var SearchComponent = require('sdk').gui.vue.SearchComponent;
  var PrintComponent = require('sdk').gui.vue.PrintComponent;
  var ToolsComponent = require('sdk').gui.vue.ToolsComponent;
  var MapComponent = require('sdk').gui.vue.MapComponent;
  var ContentsComponent = require('./template/js/contentsviewer');
  //al momento si utilizza quesllo quenerico ma si potrebbe costruire un componente
  //ad hoc per i risultati
  var QueryResultsComponent = require('sdk').gui.vue.QueryResultsComponent;
  return {
    title: config.apptitle,
    placeholders: {
      navbar: {
        components: []
      },
      sidebar: {
        components: [
          new PrintComponent({
            id: 'print',
            open: false,
            collapsible: true, //  i permette di capire se cliccandoci sopra posso lanciare il setOpen del componente
            icon: "fa fa-print"
          }),
          new SearchComponent({
            id: 'search',
            open: false,
            collapsible: true,
            icon: "fa fa-search"
          }),
          new CatalogComponent({
            id: 'catalog',
            open: false,
            collapsible: false,
            icon: "fa fa-map-o"
          }),
          // qui vanno i plugins sotto forma di tools
          new ToolsComponent({
            id: 'tools',
            open: false,
            collapsible: true,
            icon: "fa fa-gears"
          })
        ]
      },
      floatbar:{
        components: []
      }
    },
    othercomponents: [
      new QueryResultsComponent({
        id: 'queryresults'
      })
    ],
    viewport: {
      // placeholder del contenuto (view content) inizialmente Vista Secondaria (nascosta)
      components: {
        map: new MapComponent({
          id: 'map'
        }),
        content: new ContentsComponent({
          id: 'contents'
        })
      }
    }
  }
}

function sendErrorToApplicationTemplate(reloadFnc,error) {
  if (error && error.responseJSON && error.responseJSON.error.data) {
    error = error.responseJSON.error.data
  } else {
    error = 'Errore di connessione'
  }
  // stato un erore ne caricamento della configurazione del progetto
  // passo la stessa funzione di bootstrap
  ApplicationTemplate.fail(reloadFnc, error);
}

ApplicationService.on('ready', function() {
  //istanzio l'appication template passando la configurazione
  // del template e l'applicationService che fornisce API del progetto
  var templateConfig = createTemplateConfig();
  //istanzio l'application Template passando il templateconfig, l'applicationservice
  applicationTemplate = new ApplicationTemplate(templateConfig, this);
  //inizializzo e faccio partire con il metodo init
  applicationTemplate.init();
  // quando (dopo la chiamta e il setup del layout etc..) dell'application template
  // è ready lancio l'applicationTemplate service postBoostrat
  applicationTemplate.on('ready', function() {
    ApplicationService.postBootstrap();
  });
});

// funzione che viene lanciata al momento di caricare app.js
var bootstrap = function() {
  //ottengo al configurazione inizilae del gruppo di progetti
  // config.server.urls.initconfig: è l'api url a cui chiedere la configurazione iniziale
  ApplicationService.obtainInitConfig(config.server.urls.initconfig)
  .then(function(initConfig) {
    // una volta ottenuta la configurazione inziale
    // vado a scrivere gli url dei file statici e del media url
    config.server.urls.baseurl = initConfig.baseurl;
    config.server.urls.staticurl = initConfig.staticurl;
    config.server.urls.clienturl = initConfig.staticurl+initConfig.client;
    config.server.urls.mediaurl = initConfig.mediaurl;
    config.group = initConfig.group;
    config.user = initConfig.user;
    var applicationConfig = createApplicationConfig();
    // unavolta ottenuta la configurazione e settetat in modo digeribile all'applicazione
    // la vado a pssare al metodo init dell'application service
    ApplicationService.init(applicationConfig, true) // lancio manualmente il postBootstrp
      .then(function() {
        // andato tutto a buon fine
      })
      .fail(function(error) {
        sendErrorToApplicationTemplate(bootstrap, error);
      })
  })
  .fail(function(error) {
    sendErrorToApplicationTemplate(bootstrap, error);
  })
};

// lancio subito il bootstrap
bootstrap();


},{"./config/config.js":1,"./template/js/contentsviewer":13,"./template/js/template":19,"sdk":154,"sdk/sdk":154}],4:[function(require,module,exports){
module.exports = "<div class=\"wrapper\">\n  <header class=\"main-header\">\n    <!-- Logo -->\n    <!-- Header Navbar: style can be found in header.less -->\n    <nav class=\"navbar navbar-static-top\" role=\"navigation\">\n      <!-- Toggle button on navbar only for mobile -->\n      <a v-if=\"isMobile()\" href=\"#\" class=\"sidebar-toggle\" data-toggle=\"offcanvas\" role=\"button\">\n        <span class=\"sr-only\">Expand</span>\n      </a>\n      <div class=\"logo-wrapper\">\n        <a v-if=\"logo_url\" :href=\"logo_link\" :target=\"logo_link_target\" class=\"\"><img :src=\"logo_url\" style=\"height:40px\"></a>\n        <span class=\"\">{{project_title}}</span>\n      </div>\n      <div v-if=\"user\" class=\"navbar-custom-menu\">\n        <ul class=\"nav navbar-nav\">\n          <li class=\"dropdown user\" v-if=\"numberOfProjectsInGroup > 1\">\n            <a href=\"#\" @click=\"openProjectsMenu\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n              <i class=\"fa fa-th\" aria-hidden=\"true\"></i>\n              <span> Cambia Mappa</span>\n            </a>\n          </li>\n          <li class=\"dropdown user user-menu\">\n            <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n              <i class=\"fa fa-user\"></i>\n              <span class=\"hidden-xs\">{{ user.username }}</span>\n            </a>\n            <ul class=\"dropdown-menu\">\n              <li class=\"user-header\">\n                <p>\n                  {{ user.first_name }} {{ user.last_name }}\n                </p>\n              </li>\n              <li class=\"user-footer\">\n                <div class=\"pull-left\">\n                  <a :href=\"user.admin_url\" class=\"btn btn-default btn-flat\"><i class=\"fa fa-folder\"></i> Admin</a>\n                </div>\n                <div class=\"pull-right\">\n                  <a :href=\"user.logout_url\" class=\"btn btn-default btn-flat\"><i class=\"fa fa-sign-out\"></i>Sign out</a>\n                </div>\n              </li>\n            </ul>\n          </li>\n          <li class=\"dropdown user user-menu\">\n            <a href=\"#\" data-toggle=\"modal\" data-target=\"#credits\" class=\"dropdown-toggle\">\n              <span>Credits</span>\n            </a>\n          </li>\n        </ul>\n      </div>\n    </nav>\n  </header>\n  <!-- Left side column. contains the logo and sidebar -->\n  <sidebar></sidebar>\n  <!-- Content Wrapper. Contains page content -->\n  <div class=\"content-wrapper\" style=\"background-color:white\">\n    <viewport></viewport>\n  </div>\n  <!-- /.content-wrapper -->\n  <!-- Control Sidebar -->\n  <floatbar></floatbar>\n  <!-- /.control-sidebar -->\n  <!-- Add the sidebar's background. This div must be placed\n       immediately after the control sidebar -->\n  <div class=\"control-sidebar-bg\"></div>\n  <!--full screen modal element-->\n  <div class=\"modal fade modal-fullscreen force-fullscreen\" id=\"full-screen-modal\" tabindex=\"-1\" role=\"dialog\" data-backdrop=\"static\" data-keyboard=\"false\" aria-labelledby=\"full-screen-modal\" aria-hidden=\"true\"></div>\n  <!---->\n  <div id=\"credits\" class=\"modal fade\">\n    <div class=\"modal-dialog\" role=\"document\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n          </button>\n          <a style=\"text-align: center!important;\" href=\"http://www.gis3w.it\" target=\"_blank\">\n            <img src=\"http://gis3w.it/wp-content/uploads/sites/7/2017/01/logo_gis3w_156_85.png?x22227\" class=\"img-responsive center-block\" alt=\"\">\n            <div style=\"text-align: center!important; margin-bottom:50px; margin-top:20px; color:#000000\">\n              <h4>GIS3W s.n.c.</h4>\n            </div>\n          </a>\n          <address id=\"address-credits\" style=\"line-height: 2; text-align: center;\">\n            <i class=\"fa fa-map-marker\" aria-hidden=\"true\"></i>\n            <span> Viale Verdi, 24 - Montecatini Terme (PT)</span></br>\n            <i class=\"fa fa-mobile\" aria-hidden=\"true\"></i>\n            <span> +39 347 6597931</span></br>\n            <i class=\"fa fa-fax\" aria-hidden=\"true\"></i>\n            <span> +39 0572 901639</span></br>\n            <i class=\"fa fa-envelope\" aria-hidden=\"true\">\n            </i>\n            <span><a href=\"mailto:info@gis3w.it\" style=\"color:#000000\"> info@gis3w.it</a></span>\n          </address>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],5:[function(require,module,exports){
module.exports = "<div id=\"contents\" class=\"contents\"></div>\n";

},{}],6:[function(require,module,exports){
module.exports = "<aside class=\"control-sidebar control-sidebar-light\" >\n  <a v-show=\"panelsinstack\" href=\"#\" class=\"floatbar-aside-toggle\" data-toggle=\"control-sidebar\" role=\"button\">\n    <span class=\"sr-only\">Expand</span>\n  </a>\n  <div id=\"floatbar-spinner\" style=\"position:absolute\"></div>\n  <div v-show=\"panelsinstack\" class=\"g3w-sidebarpanel\">\n    <div v-if=\"closable\" class=\"row\">\n      <div class=\"col-xs-12 col-sm-12 col-md-12\">\n        <button class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closePanel\"></button>\n      </div>\n    </div>\n    <div v-if=\"panelname\">\n      <h4 class=\"g3w-floatbarpanel-name\">{{ panelname }}</h4>\n    </div>\n    <div id=\"g3w-floatbarpanel-placeholder\" class=\"g3w-floatbarpanel-placeholder\"></div>\n  </div>\n</aside>\n";

},{}],7:[function(require,module,exports){
module.exports = "<div id=\"menu-projects\" class=\"container nano\">\n  <div v-show=\"loading\" class=\"bar-loader\"></div>\n  <div class=\"nano-content\">\n    <div class=\"row row-equal\">\n      <!-- item -->\n      <div v-for=\"menuitem in state.menuitems\"  @click=\"trigger(menuitem)\" class=\"col-xs-12 col-sm-4 project-menu\">\n        <div class=\"project-menu-item-image\">\n          <img :src=\"logoSrc(menuitem.thumbnail)\" class=\"img-responsive\">\n        </div>\n        <div class=\"project-menu-item-content\">\n          <div class=\"project-menu-item-text\">\n            <h4 class=\"project-menu-item-title\">{{ menuitem.title }}</h4>\n            <div v-html=\"menuitem.description\"></div>\n          </div>\n        </div>\n      </div>\n      <div v-if=\"!state.menuitems.length\" style=\"margin-left:15px;\">\n        <h2>Non ci sono altri progetti in questo gruppo cartografico</h2>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],8:[function(require,module,exports){
module.exports = "<li  v-show=\"state.visible\" class=\"treeview sidebaritem\" :class=\"{'active': open}\">\n  <a @click=\"onClickItem\" href=\"#\">\n    <i :class=\"icon\"></i>\n    <span class=\"treeview-label\">{{title | t}}</span>\n    <i class=\"fa fa-angle-left pull-right\"></i>\n  </a>\n  <div id=\"g3w-sidebarcomponent-placeholder\"></div>\n</li>\n";

},{}],9:[function(require,module,exports){
module.exports = "<aside class=\"main-sidebar\">\n  <!-- sidebar: style can be found in sidebar.less -->\n  <!-- Sidebar toggle button-->\n  <!-- Toggle button on the left side of main sidebar only if not mobile -->\n  <a v-if=\"!isMobile()\" href=\"#\" class=\"sidebar-aside-toggle\" data-toggle=\"offcanvas\" role=\"button\">\n    <span class=\"sr-only\">Expand</span>\n  </a>\n  <!--<div class=\"quick-actions-menu\">-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-share-alt\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-modal-window\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-print\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-search\"></button>-->\n  <!--</div>-->\n\t<section class=\"sidebar\">\n    <div v-show=\"panelsinstack\" class=\"g3w-sidebarpanel\">\n      <div style=\"overflow: hidden;line-height: 14px;margin-top: 4px; font-size:1.5em\">\n          <button class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closePanel\"></button>\n      </div>\n      <div id=\"g3w-sidebarpanel-placeholder\" class=\"g3w-sidebarpanel-placeholder\"></div>\n    </div>\n\t  <ul id=\"g3w-sidebarcomponents\" v-show=\"showmainpanel\" class=\"sidebar-menu\"></ul>\n\t</section>\n\t<!-- /.sidebar -->\n</aside>\n";

},{}],10:[function(require,module,exports){
module.exports = "<div class=\"g3w-viewport\">\n  <div id=\"g3w-view-map\" class=\"g3w-view map\" :style=\"{width:state.map.sizes.width+'px',height:state.map.sizes.height+'px'}\">\n  </div>\n  <div id=\"g3w-view-content\" class=\"g3w-view content\" :style=\"{width:state.content.sizes.width+'px',height:state.content.sizes.height+'px'}\">\n    <div v-if=\"(showtitle && contentTitle) || previousTitle || (state.content.closable && state.content.aside)\" class=\"close-panel-block\">\n      <div v-if=\"previousTitle\" class=\"g3w_contents_back\">\n        <span  @click=\"gotoPreviousContent()\"><span class=\"glyphicon glyphicon-chevron-left\"></span> Torna {{ previousTitle }}</span>\n      </div>\n      <button v-if=\"state.content.closable && state.content.aside\" class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closeContent\"></button>\n      <div v-if=\"showtitle && contentTitle\">\n        <span>{{ contentTitle }}</span>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],11:[function(require,module,exports){
var ApplicationService = require('core/applicationservice');
var ProjectsRegistry = require('core/project/projectsregistry');
var ProjectsMenuComponent = require('./projectsmenu');
var GUI = require('sdk/gui/gui');
var layout = require('./layout');

var AppUI = Vue.extend({
  template: require('../html/app.html'),
  mounted: function(){
    this.$nextTick(function(){
      /* start to render LayoutManager layout */
      layout.loading(false);
      layout.setup();
      //Fix the problem with right sidebar and layout boxed
      layout.pushMenu.expandOnHover();
      layout.controlSidebar._fix($(".control-sidebar-bg"));
      layout.controlSidebar._fix($(".control-sidebar"));
      var controlsidebarEl = layout.options.controlSidebarOptions.selector;
      function setFloatBarMaxHeight(){
        $(controlsidebarEl).css('max-height',$(window).innerHeight());
        $('.g3w-sidebarpanel').css('height',$(window).height() - $(".main-header").height());
      }
      setFloatBarMaxHeight();
      function setModalHeight(){
        $('#g3w-modal-overlay').css('height',$(window).height());
      }
      $(window).resize(function() {
        setFloatBarMaxHeight();
        setModalHeight();
      });
    })
  },
  computed: {
    logo_url: function() {
      var config = ApplicationService.getConfig();
      var logo_url;
      if (config.logo_img && config.logo_img!='') {
        logo_url = config.mediaurl+config.logo_img;
      }
      return logo_url;
    },
    logo_link: function() {
      var logo_link = this.getLogoLink();
      return logo_link ? logo_link : "#";
    },
    logo_link_target: function() {
      var logo_link = this.getLogoLink();
      return logo_link ? "_blank" : "";
    },
    project_title: function() {
      var currentProject = ProjectsRegistry.getCurrentProject();
      return currentProject.state.name;
    },
    user: function() {
      var user = ApplicationService.getConfig().user;
      // verifico nel caso fosse un oggetto vuoto
      if (_.isEmpty(user)) {user = null}
      return user;
    },
    numberOfProjectsInGroup: function() {
      return ProjectsRegistry.getProjects().length;
    }
  },
  methods: {
    closePanel: function(){
      sidebarService.closePanel();
    },
    isMobile: function(){return isMobile.any},
    getLogoLink: function() {
      var logo_link = null;
      if (ApplicationService.getConfig().logo_link) {
        logo_link = ApplicationService.getConfig().logo_link;
      }
      return logo_link;
    },
    openProjectsMenu: function() {
      var contentsComponent = GUI.getComponent('contents');
      // verifico che il content è il projectsmenu
      if (contentsComponent.getComponentById('projectsmenu')) {
        GUI.closeContent();
      } else {
        GUI.setContent({
          content: new ProjectsMenuComponent(),
          title: '',
          perc:100
        });
      }
    }
  }
});

module.exports = AppUI;
},{"../html/app.html":4,"./layout":15,"./projectsmenu":17,"core/applicationservice":22,"core/project/projectsregistry":67,"sdk/gui/gui":114}],12:[function(require,module,exports){
var utils = require('sdk/core/utils/utils');
var inherit = require('sdk/core/utils/utils').inherit;
var G3WObject = require('sdk/core/g3wobject');
var Component = require('gui/vue/component');
var Panel = require('gui/panel');

//classe barstack
// Ha lo scopo di montare stack di pannelli
// sopra ogni parte del parent in questione
function BarStack() {
  this._parent = null;
  // state del barstak contenente array pannelli
  this.state = {
    contentsdata: []
  }
}

//eredita dall'oggetto G3WOBJECT
inherit(BarStack, G3WObject);

var proto = BarStack.prototype;

// funzione che immette il componente (di qualsiasi tipo) nel parent element
proto.push = function(content, options) {
  // parent è l'identificativo dell'elemento DOM sui cui montare (in append o meno) il component/panel
  this._parent = options.parent;
  // chiamo il metodo mount del barstack
  return this._mount(content, options);
};

// toglie l'ultimo componente dallo stack
proto.pop = function(){
  var self = this;
  var d = $.Deferred();
  // qui potremo chiedere al pannello se può essere chiuso...
  if (this.state.contentsdata.length) {
    var content = this.state.contentsdata.slice(-1)[0].content;
    return this._unmount(content)
    .then(function(){
      self.state.contentsdata.pop();
    })
  }
  else {
    d.resolve();
  }
  return d.promise();
};

// fa il clear di tutto lo stack in una volta sola
proto.clear = function() {
  var self = this;
  var d = $.Deferred();
  if (this.state.contentsdata.length) {
    var unmountRequests = [];
    _.forEach(this.state.contentsdata, function (data, idx) {
      unmountRequests.push(self._unmount(data.content));
    });
    $.when(unmountRequests).then(function () {
      //self.state.contentsdata = [];
      self.state.contentsdata.splice(0,self.state.contentsdata.length);
      d.resolve();
    });
  }
  else {
    d.resolve();
  }
  return d.promise();
};

proto.getContentData = function() {
  return this.state.contentsdata
};

proto.getCurrentContentData = function() {
  return this.state.contentsdata[this.state.contentsdata.length - 1];
};

proto.getPreviousContentData = function() {
  return this.state.contentsdata[this.state.contentsdata.length - 2];
};

// funzione che fa il mopnt del componente
proto._mount = function(content, options) {
  // verifico il tipo di content passato:
  //oggetto JQuery
  if (content instanceof jQuery) {
    return this._setJqueryContent(content);
  }
  //stringa
  else if (_.isString(content)) {
    var jqueryEl = $(content);
    // nel caso in cui content sia testo puro, devo wrapparlo in un tag HTML in modo che $() generi un elemento DOM
    if (!jqueryEl.length) {
      jqueryEl = $('<div>'+content+'</div>');
    }
    return this._setJqueryContent(jqueryEl);
  }
  // istanza componente (vue alla fine)
  else if (content.mount && typeof content.mount == 'function') {
    this._checkDuplicateVueContent(content); // nel caso esista già prima lo rimuovo
    return this._setVueContent(content,options)
  }
  // infine è elemento dom
  else {
    return this._setDOMContent(content);
  }
};

//funzione che permettere di appendere oggetto jquery
proto._setJqueryContent = function(content,options) {
  $(this._parent).append(content);
  this.state.contentsdata.push({
    content: content,
    options: options
  });
  return utils.resolve();
};

//funzione che appende dom element
proto._setDOMContent = function(content,options) {
  this._parent.appendChild(content);
  this.state.contentsdata.push({
    content: content,
    options: options
  });
  return utils.resolve();
};

// funzione che monta il componte su parent
proto._setVueContent = function(content, options) {
  var self = this;
  var d = $.Deferred();
  var append = options.append || false;
  content.mount(this._parent, append)
  .then(function(){
    $(parent).localize();
    // inserisco nell'array del content data un oggetto avente attributi:
    // content: oggetto component
    // options: oprizioni riguardanti title, perc etc ...
    self.state.contentsdata.push({
      content: content,
      options: options
    });
    d.resolve();
  });
  return d.promise();
};

// verifica nel caso di un componente vue
proto._checkDuplicateVueContent = function(content) {
  var self = this;
  var idxToRemove = null;
  var id = content.getId();
  _.forEach(this.state.contentsdata, function(data,idx) {
    if (data.content.getId && (data.content.getId() == id)) {
      idxToRemove = idx;
    }
  });
  if (!_.isNull(idxToRemove)) {
    var data = self.state.contentsdata[idxToRemove];
    data.content.unmount()
      .then(function() {
        self.state.contentsdata.splice(idxToRemove,1);
      });
  }
};

// smonta il componente
proto._unmount = function(content) {
  var self = this;
  var d = $.Deferred();
  if (content instanceof Component || content instanceof Panel) {
    content.unmount()
    .then(function(){
      d.resolve();
    });
  }
  else {
    $(this._parent).empty();
    d.resolve();
  }
  return d.promise();
};

proto.forEach = function(cbk) {
  _.forEach(this.state.contentsdata,function(data){
    cbk(data.content);
  })
};

// resituisce la lunghezza (numero elementi) dello stack
proto.getLength = function() {
  return this.state.contentsdata.length;
};

module.exports = BarStack;

},{"gui/panel":123,"gui/vue/component":152,"sdk/core/g3wobject":27,"sdk/core/utils/utils":71}],13:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Stack = require('./barstack.js');
// componente base
var Component = require('gui/vue/component');

// componente interno (VUE) del content della viewport
var InternalComponent = Vue.extend({
  template: require('../html/contentsviewer.html'), // altro non è che <div id="contents" class="contents"></div>
  data: function() {
    return {
      state: null
    }
  }
});

// componente content Viewer
function ContentsViewerComponent(options) {
  base(this, options);
  this.stack = new Stack();
  // setta come servizio se stesso
  this.setService(this);
  this.title = "contents";
  // lo state del component padre è
  /*
   this.state = {
    visible: options.visible || true,
    open: options.open || false
   }
   */
  this.contentsdata = this.stack.state.contentsdata;
  this.state.visible = true;
  // vado a settare il componente interno
  // sfruttando il metodo del componente base
  this.setInternalComponent(new InternalComponent({
    service: this
  }));
  // setto lo state del componente interno vue uguale allo state del service
  // che non è altro lo state component padre state={open, visible};
  this.internalComponent.state = this.state;
}

/// stooto classe di Component
inherit(ContentsViewerComponent, Component);

var proto = ContentsViewerComponent.prototype;

// setta il contenuto dell content
proto.setContent = function(options) {
  var self = this;
  var d = $.Deferred();
  var push = options.push || false;
  var content = options.content;
  // svuoto sempre lo stack, così ho sempre un solo elemento (la gestione dello stack è delegata alla viewport).
  // Uso comunque barstack perché implementa già la logica di montaggio dei contenuti nel DOM
  if (!push) {
    // elemino tutto lo stack content
    this.clearContents()
    .then(function() {
      self.addContent(content, options)
      .then(function(){
        d.resolve();
      })
    })
  }
  else {
    this.addContent(content,options)
    .then(function(){
      d.resolve();
    })
  }
  this.setOpen(true);
  return d.promise();
};

//aggiunge al componente base content componenti
proto.addContent = function(content, options) {
  var self = this;
  // l'emento parente è proprio il template content
  options.parent = this.internalComponent.$el;
  // definisce l'append a true
  options.append = true;
  // stack.push è una promise
  return this.stack.push(content, options)
  .then(function() {
    // prendo il contentuo dello stack
    self.contentsdata = self.stack.state.contentsdata;
    // aggiorna la visibilità dei vari componenti vue montati
    self.updateContentVisibility();
  })
};

// rimuove il contenuto dallo stack
proto.removeContent = function() {
  this.setOpen(false);
  return this.clearContents();
};

// usato da viewport.js
proto.popContent = function() {
  var self = this;
  return this.stack.pop()
  .then(function() {
    // solo dopo che lo stack è stato aggiornato aggiorna il contentsdata
    self.contentsdata = self.stack.state.contentsdata;
    // aggiorna la visibilità dei vari componenti vue montanti
    self.updateContentVisibility();
  });
};

// recupera il component attraverso la classe
proto.getComponentByClass = function(componentClass) {
  var component;
  var contentdata = this.stack.getContentData();
  _.forEach(contentdata, function(content) {
    if (content.content instanceof componentClass) {
      component = content.content;
      return false
    }
  });
  return component
};

// recupera il component attraverso l'id del componente
proto.getComponentById = function(id) {
  var component;
  var contentdata = this.stack.getContentData();
  _.forEach(contentdata, function(content) {
    if (content.content.id == id) {
      component = content.content;
      return false
    }
  });
  return component
};

proto.getContentData = function() {
  return this.stack.getContentData();
};

// restituisce il current contentdata
proto.getCurrentContentData = function(){
  return this.stack.getCurrentContentData();
};

// restituisce il previuos content data
proto.getPreviousContentData = function() {
  return this.stack.getPreviousContentData();
};

// funzione che aggiorna la visibilità dei componenti del content
proto.updateContentVisibility = function() {
  // hide tuttigli elementi all'infuri che l'ultimo
  var contentsEls = $(this.internalComponent.$el).children();
  contentsEls.hide();
  contentsEls.last().show();
};

// fa il clear dello stack in quanto si vuole che lo stack del contenteComponente
// deve essere sempre vuoto in partenza
proto.clearContents = function() {
  var self = this;
  return this.stack.clear()
  .then(function() {
    self.contentsdata = self.stack.state.contentsdata;
  })
};

// funzione che serve per definire di volta in volta il layout del content
// i parametri sono l'altezza e la larghezza dell'elemento parent contenitore
proto.layout = function(parentWidth, parentHeight) {
  var self = this;
  // elemento template del componente vue
  var el = $(this.internalComponent.$el);
  //lancia la callback solo dopo che è stato aggiornato lo stato di Vue
  Vue.nextTick(function() {
    // el.parent() è il div g3w-view-content
    var height = el.parent().height() - el.siblings('.close-panel-block').outerHeight(true) - el.siblings('.g3w_contents_back').outerHeight(true);
    el.height(height);
    el.children().first().height(height);
    var contentsdata = self.stack.state.contentsdata;
    contentsdata.forEach(function(data) {
      //vado a scorrere su tutti i cmponenti caricari nello stack
      if (typeof data.content.layout == 'function') {
        // vado a chiamare la funzione layout di tutti i componenti presenti nello stack
        data.content.layout(parentWidth, height);
      }
    })
  })
};

module.exports = ContentsViewerComponent;

},{"../html/contentsviewer.html":5,"./barstack.js":12,"core/utils/utils":71,"gui/vue/component":152}],14:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
var Stack = require('./barstack.js');
var GUI = require('sdk/gui/gui');

function FloatbarService(){
  this.stack = new Stack();
  this.init = function(layout){
    this.layout = layout;
    this.sidebarEl = $(this.layout.options.controlSidebarOptions.selector);
    this._zindex = this.sidebarEl.css("z-index");
    this._modalOverlay = null;
    this._modal = false;
    this._isopen = false;
  };

  this.isOpen = function() {
    return this._isopen;
  };

  this.open = function() {
    this.layout.floatBar.open(this.sidebarEl,true);
    this._isopen = true;
  };

  this.close = function() {
    this.layout.floatBar.close(this.sidebarEl,true);
    this._isopen = false;
  };

  this.showPanel = function(panel,options){
    var options = options || {};
    var append = options.append || false;
    var modal = options.modal || false;
    options.parent = "#g3w-floatbarpanel-placeholder";
    this.stack.push(panel, options);
    if (!this._isopen) {
      this.open();
    };
  };
  
  this.closePanel = function(panel){
    if (panel) {
      this.stack.remove(panel);
    }
    else {
      this.stack.pop();
    }
    if (!this.stack.getLength()) {
      if (this._modal){
        GUI.setModal(false);
        this.close();
        $('.control-sidebar-bg').toggleClass('control-sidebar-bg-shadow');
        this.sidebarEl.css("z-index","");
        this.sidebarEl.css("padding-top","50px");
        $('.control-sidebar-bg').css("z-index","");
        this._modal = false;
      }
      else {
        this.close();
      }
    }
  };
  
  this.hidePanel = function(){
    this.close();
  };
}

var floatbarService = new FloatbarService();

var FloatbarComponent = Vue.extend({
    template: require('../html/floatbar.html'),
    data: function() {
    	return {
        stack: floatbarService.stack.state,
      };
    },
    computed: {
      // quanti pannelli sono attivi nello stack
      panelsinstack: function(){
        return this.stack.contentsdata.length>0;
      },
      panelname: function(){
        var name;
        if (this.stack.contentsdata.length){
          name = this.stack.contentsdata.slice(-1)[0].content.getTitle();
        }
        return name;
      },
      closable: function() {
        return floatbarService.closable;
      }
    },
    watch: {
      // TODO: Brutto, ma è l'unico (per ora) modo flessibile che ho trovato per implementare il concetto di stack... 
      "stack.contentsdata": function(){
        var children = $("#g3w-floatbarpanel-placeholder").children();
        _.forEach(children,function(child,index){
          if (index == children.length-1){
            $(child).show();
          }
          else {
            $(child).hide();
          }
        })
      }
    },
    methods: {
      closePanel: function(){
        floatbarService.closePanel();
      }
    }
});

module.exports = {
  FloatbarService: floatbarService,
  FloatbarComponent: FloatbarComponent
};

},{"../html/floatbar.html":6,"./barstack.js":12,"sdk/core/i18n/i18n.service":30,"sdk/gui/gui":114}],15:[function(require,module,exports){
//Make sure jQuery has been loaded before app.js
if (typeof jQuery === "undefined") {
  throw new Error("LayoutManager requires jQuery");
}

$.LayoutManager = {};

/* --------------------
 * - LayoutManager Options -
 * --------------------
 * Modify these options to suit your implementation
 */
$.LayoutManager.options = {
  //Add slimscroll to navbar menus
  //This requires you to load the slimscroll plugin
  //in every page before app.js
  navbarMenuSlimscroll: true,
  navbarMenuSlimscrollWidth: "0px", //The width of the scroll bar
  navbarMenuHeight: "200px", //The height of the inner menu
  //General animation speed for JS animated elements such as box collapse/expand and
  //sidebar treeview slide up/down. This options accepts an integer as milliseconds,
  //'fast', 'normal', or 'slow'
  animationSpeed:'fast',
  //Sidebar push menu toggle button selector
  sidebarToggleSelector: "[data-toggle='offcanvas']",
  //Activate sidebar push menu
  sidebarPushMenu: true,
  //Activate sidebar slimscroll if the fixed layout is set (requires SlimScroll Plugin)
  sidebarSlimScroll: true,
  //Enable sidebar expand on hover effect for sidebar mini
  //This option is forced to true if both the fixed layout and sidebar mini
  //are used together
  sidebarExpandOnHover: false,
  //BoxRefresh Plugin
  enableBoxRefresh: true,
  //Bootstrap.js tooltip
  enableBSToppltip: true,
  BSTooltipSelector: "[data-toggle='tooltip']",
  //Enable Fast Click. Fastclick.js creates a more
  //native touch experience with touch devices. If you
  //choose to enable the plugin, make sure you load the script
  //before LayoutManager's app.js
  enableFastclick: true,
  //Control Sidebar Options
  enableControlSidebar: true,
  controlSidebarOptions: {
    //Which button should trigger the open/close event
    toggleBtnSelector: "[data-toggle='control-sidebar']",
    //The sidebar selector
    selector: ".control-sidebar",
    //Enable slide over content
    slide: true
  },
  //Box Widget Plugin. Enable this plugin
  //to allow boxes to be collapsed and/or removed
  enableBoxWidget: true,
  //Box Widget plugin options
  boxWidgetOptions: {
    boxWidgetIcons: {
      //Collapse icon
      collapse: 'fa-minus',
      //Open icon
      open: 'fa-plus',
      //Remove icon
      remove: 'fa-times'
    },
    boxWidgetSelectors: {
      //Remove button selector
      remove: '[data-widget="remove"]',
      //Collapse button selector
      collapse: '[data-widget="collapse"]'
    }
  },
  //Direct Chat plugin options
  directChat: {
    //Enable direct chat by default
    enable: true,
    //The button to open and close the chat contacts pane
    contactToggleSelector: '[data-widget="chat-pane-toggle"]'
  },
  //Define the set of colors to use globally around the website
  colors: {
    lightBlue: "#3c8dbc",
    red: "#f56954",
    green: "#00a65a",
    aqua: "#00c0ef",
    yellow: "#f39c12",
    blue: "#0073b7",
    navy: "#001F3F",
    teal: "#39CCCC",
    olive: "#3D9970",
    lime: "#01FF70",
    orange: "#FF851B",
    fuchsia: "#F012BE",
    purple: "#8E24AA",
    maroon: "#D81B60",
    black: "#222222",
    gray: "#d2d6de"
  },
  //The standard screen sizes that bootstrap uses.
  //If you change these in the variables.less file, change
  //them here too.
  screenSizes: {
    xs: 480,
    sm: 768,
    md: 992,
    lg: 1200
  }
};


/* ----------------------------------
 * - Initialize the LayoutManager Object -
 * ----------------------------------
 * All LayoutManager functions are implemented below.
 */
$.LayoutManager._init = function() {
  'use strict';
  /* Layout
   * ======
   * Fixes the layout height in case min-height fails.
   *
   * @type Object
   * @usage $.LayoutManager.layout.activate()
   *        $.LayoutManager.layout.fix()
   *        $.LayoutManager.layout.fixSidebar()
   */
  $.LayoutManager.layout = {
    activate: function () {
      var _this = this;
      _this.fix();
      _this.fixSidebar();
      $(window, ".wrapper").resize(function () {
        _this.fix();
        _this.fixSidebar();
      });
    },
    fix: function () {
      //Get window height and the wrapper height
      var neg = $('.main-header').outerHeight() + $('.main-footer').outerHeight();
      var window_height = $(window).height();
      var sidebar_height = $(".sidebar").height();
      //Set the min-height of the content and sidebar based on the
      //the height of the document.
      if ($("body").hasClass("fixed")) {
        $(".content-wrapper, .right-side").css('min-height', window_height - $('.main-footer').outerHeight());
        $(".content-wrapper, .right-side").css('height', window_height - $('.main-footer').outerHeight());
      } else {
        var postSetWidth;
        if (window_height >= sidebar_height) {
          $(".content-wrapper, .right-side").css('min-height', window_height - neg);
          postSetWidth = window_height - neg;
        } else {
          $(".content-wrapper, .right-side").css('min-height', sidebar_height);
          postSetWidth = sidebar_height;
        }
        //Fix for the control sidebar height
        var controlSidebar = $($.LayoutManager.options.controlSidebarOptions.selector);
        if (typeof controlSidebar !== "undefined") {
          if (controlSidebar.height() > postSetWidth)
            $(".content-wrapper, .right-side").css('min-height', controlSidebar.height());
        }

      }
    },
    fixSidebar: function () {
      //Make sure the body tag has the .fixed class
      if (!$("body").hasClass("fixed")) {
        if (typeof $.fn.slimScroll != 'undefined') {
          $(".sidebar").slimScroll({destroy: true}).height("auto");
        }
        return;
      } else if (typeof $.fn.slimScroll == 'undefined' && window.console) {
        window.console.error("Error: the fixed layout requires the slimscroll plugin!");
      }
      //Enable slimscroll for fixed layout
      if ($.LayoutManager.options.sidebarSlimScroll) {
        if (typeof $.fn.slimScroll != 'undefined') {
          //Destroy if it exists
          $(".sidebar").slimScroll({destroy: true}).height("auto");
          //Add slimscroll
          $(".sidebar").slimscroll({
            height: ($(window).height() - $(".main-header").height()) + "px",
            color: "rgba(255,255,255,0.7)",
            size: "3px"
          });
        }
      }
      else {
         $(".sidebar").css({'height': ($(window).height() - $(".main-header").height()) + "px"})
      }
      
      /*$(".sidebar li a").each(function(){
        var $this = $(this);
        var checkElement = $this.next();
        if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
          //Get the parent menu
          var parent = $this.parents('ul').first();
          var parent_li = $this.parent("li");
          var li_siblings = parent_li.siblings();
          var parent_find_active;
          var sidebar_content_height = parent.height() - parent.find('li.header').outerHeight();
          var treeviewHeight = parent_li.outerHeight();
          li_siblings.not('.header').each(function(index, el) {
                  treeviewHeight+=$(el).find('a').outerHeight();
          });
          var section_height = (sidebar_content_height - treeviewHeight);
          checkElement.css({
            'height': section_height + 'px',
            'max-height':section_height + 'px',
            'overflow-y': 'auto'
          });
        }
      });*/
      
    }
    
  };

  /* PushMenu()
   * ==========
   * Adds the push menu functionality to the sidebar.
   *
   * @type Function
   * @usage: $.LayoutManager.pushMenu("[data-toggle='offcanvas']")
   */
  $.LayoutManager.pushMenu = {
    activate: function (toggleBtn) {
      //Get the screen sizes
      var screenSizes = $.LayoutManager.options.screenSizes;

      //Enable sidebar toggle
      $(toggleBtn).on('click', function (e) {
        e.preventDefault();

        //Enable sidebar push menu
        if ($(window).width() > (screenSizes.sm - 1)) {
          if ($("body").hasClass('sidebar-collapse')) {
            $("body").removeClass('sidebar-collapse').trigger('expanded.pushMenu');
          } else {
            $("body").addClass('sidebar-collapse').trigger('collapsed.pushMenu');
          }
        }
        //Handle sidebar push menu for small screens
        else {
          if ($("body").hasClass('sidebar-open')) {
            $("body").removeClass('sidebar-open').removeClass('sidebar-collapse').trigger('collapsed.pushMenu');
          } else {
            $("body").addClass('sidebar-open').trigger('expanded.pushMenu');
          }
        }
      });

      /*$(".content-wrapper").click(function () {
        //Enable hide menu when clicking on the content-wrapper on small screens
        if ($(window).width() <= (screenSizes.sm - 1) && $("body").hasClass("sidebar-open")) {
          $("body").removeClass('sidebar-open');
        }
      });*/

      //Enable expand on hover for sidebar mini
      if ($.LayoutManager.options.sidebarExpandOnHover || ($('body').hasClass('fixed') && $('body').hasClass('sidebar-mini'))) {
        this.expandOnHover();
      }
    },
    expandOnHover: function () {
      var _this = this;
      var screenWidth = $.LayoutManager.options.screenSizes.sm - 1;
      //Expand sidebar on hover
      $('.main-sidebar').hover(function () {
        if ($('body').hasClass('sidebar-mini') && $("body").hasClass('sidebar-collapse') && $(window).width() > screenWidth) {
          _this.expand();
        }
      }, function () {
        if ($('body').hasClass('sidebar-mini') && $('body').hasClass('sidebar-expanded-on-hover') && $(window).width() > screenWidth) {
          _this.collapse();
        }
      });
    },
    expand: function () {
      $("body").removeClass('sidebar-collapse').addClass('sidebar-expanded-on-hover');
    },
    collapse: function () {
      if ($('body').hasClass('sidebar-expanded-on-hover')) {
        $('body').removeClass('sidebar-expanded-on-hover').addClass('sidebar-collapse');
      }
    }
  };

  /* Tree()
   * ======
   * Converts the sidebar into a multilevel
   * tree view menu.
   *
   * @type Function
   * @Usage: $.LayoutManager.tree('.sidebar')
   */
  $.LayoutManager.tree = function (menu) {
    var _this = this;
    var animationSpeed = $.LayoutManager.options.animationSpeed;
    //click event //
    $(document).on('click', menu + ' li a', function (e) {

      //Get the clicked link and the next element
      var $this = $(this);
      //is the content of the "accordion" ul //
      var checkElement = $this.next();

      //Check if the next element is a menu and is visible
      if ((checkElement.is('.treeview-menu')) && (checkElement.is(':visible'))) {
        //Close the menu
        checkElement.slideUp(animationSpeed, function () {
          checkElement.parent("li.treeview").removeClass("active");
          checkElement.removeClass('menu-open');
          //Fix the layout in case the sidebar stretches over the height of the window
          //_this.layout.fix();
        });

      }
      //If the menu is not visible
      else if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
        //Get the parent menu
        var parent = $this.parents('ul').first();
        var parent_li = $this.parent("li");
        var li_siblings = parent_li.siblings();
        var parent_find_active;
        var sidebar_content_height = parent.height() - parent.find('li.header').outerHeight();
        var treeviewHeight = parent_li.outerHeight();
        li_siblings.not('.header').each(function(index, el) {
                treeviewHeight+=$(el).find('a').outerHeight();
        });
        var section_height = (sidebar_content_height - treeviewHeight);
        /*checkElement.css({
          'height': section_height + 'px',
          'max-height':section_height + 'px',
          //'overflow-y': 'auto'
        });*/
        //Close all open menus within the parent
        var ul = parent.find('ul.treeview-menu:visible').slideUp(animationSpeed);
        //Remove the menu-open class from the parent
        ul.removeClass('menu-open');
        //Get the parent li
        //Open the target menu and add the menu-open class
        checkElement.slideDown(animationSpeed, function () {
          //Add the class active to the parent li
          checkElement.addClass('menu-open');
          parent_find_active = parent.find('li.treeview.active');
          parent_find_active.removeClass('active');
          parent_li.addClass('active');
          //Fix the layout in case the sidebar stretches over the height of the window
          _this.layout.fix();
        });
      }
      //if this isn't a link, prevent the page from being redirected
      if (checkElement.is('.treeview-menu')) {
        e.preventDefault();
      }
      
      //$.LayoutManager.layout.fix();
      //$.LayoutManager.layout.fixSidebar();
    });
  };

  /* ControlSidebar
   * ==============
   * Adds functionality to the right sidebar
   *
   * @type Object
   * @usage $.LayoutManager.controlSidebar.activate(options)
   */
  $.LayoutManager.floatBar = $.LayoutManager.controlSidebar = {
    //instantiate the object
    activate: function () {
      //Get the object
      var _this = this;
      //Update options
      var o = $.LayoutManager.options.controlSidebarOptions;
      //Get the sidebar
      var sidebar = $(o.selector);
      //The toggle button
      var btn = $(o.toggleBtnSelector);

      //Listen to the click event
      btn.on('click', function (e) {
        e.preventDefault();
        //If the sidebar is not open
        if (!sidebar.hasClass('control-sidebar-open') && !$('body').hasClass('control-sidebar-open')) {
          //Open the sidebar
          _this.open(sidebar, o.slide);
        } else {
          _this.close(sidebar, o.slide);
        }
      });

      //If the body has a boxed layout, fix the sidebar bg position
      var bg = $(".control-sidebar-bg");
      _this._fix(bg);

      //If the body has a fixed layout, make the control sidebar fixed
      if ($('body').hasClass('fixed')) {
        _this._fixForFixed(sidebar);
      } else {
        //If the content height is less than the sidebar's height, force max height
        if ($('.content-wrapper, .right-side').height() < sidebar.height()) {
          _this._fixForContent(sidebar);
        }
      }
    },
    //Open the control sidebar
    open: function (sidebar, slide) {
      //Slide over content
      if (slide) {
        sidebar.addClass('control-sidebar-open');
      } else {
        //Push the content by adding the open class to the body instead
        //of the sidebar itself
        $('body').addClass('control-sidebar-open');
      }
    },
    //Close the control sidebar
    close: function (sidebar, slide) {
      if (slide) {
        sidebar.removeClass('control-sidebar-open');
      } else {
        $('body').removeClass('control-sidebar-open');
      }
    },
    _fix: function (sidebar) {
      var _this = this;
      if ($("body").hasClass('layout-boxed')) {
        sidebar.css('position', 'absolute');
        sidebar.height($(".wrapper").height());
        $(window).resize(function () {
          _this._fix(sidebar);
        });
      } else {
        sidebar.css({
          'position': 'fixed',
          'height': 'auto'
        });
      }
    },
    _fixForFixed: function (sidebar) {
      sidebar.css({
        'position': 'fixed',
        'max-height': '100%',
        //'overflow': 'auto',  // non dovrebbe fare danni questo commento, serve per non nascondere il pulsanti "Chiudi pannello"
        'padding-bottom': '50px'
      });
    },
    _fixForContent: function (sidebar) {
      $(".content-wrapper, .right-side").css('min-height', sidebar.height());
    }
  };

  /* BoxWidget
   * =========
   * BoxWidget is a plugin to handle collapsing and
   * removing boxes from the screen.
   *
   * @type Object
   * @usage $.LayoutManager.boxWidget.activate()
   *        Set all your options in the main $.LayoutManager.options object
   */
  $.LayoutManager.boxWidget = {
    selectors: $.LayoutManager.options.boxWidgetOptions.boxWidgetSelectors,
    icons: $.LayoutManager.options.boxWidgetOptions.boxWidgetIcons,
    animationSpeed: $.LayoutManager.options.animationSpeed,
    activate: function (_box) {
      var _this = this;
      if (!_box) {
        _box = document; // activate all boxes per default
      }
      //Listen for collapse event triggers
      $(_box).on('click', _this.selectors.collapse, function (e) {
        e.preventDefault();
        _this.collapse($(this));
      });

      //Listen for remove event triggers
      $(_box).on('click', _this.selectors.remove, function (e) {
        e.preventDefault();
        _this.remove($(this));
      });
    },
    collapse: function (element) {
      var _this = this;
      //Find the box parent
      var box = element.parents(".box").first();
      //Find the body and the footer
      var box_content = box.find("> .box-body, > .box-footer, > form  >.box-body, > form > .box-footer");
      if (!box.hasClass("collapsed-box")) {
        //Convert minus into plus
        element.find(".btn-collapser")
                .removeClass(_this.icons.collapse)
                .addClass(_this.icons.open);
        //Hide the content
        box_content.slideUp(_this.animationSpeed, function () {
          box.addClass("collapsed-box");
        });
      } else {
        //Convert plus into minus
        element.find(".btn-collapser")
                .removeClass(_this.icons.open)
                .addClass(_this.icons.collapse);
        //Show the content
        box_content.slideDown(_this.animationSpeed, function () {
          box.removeClass("collapsed-box");
        });
      }
    },
    remove: function (element) {
      //Find the box parent
      var box = element.parents(".box").first();
      box.slideUp(this.animationSpeed);
    }
  };
  
  return $.LayoutManager;
};

/* ------------------
 * - Custom Plugins -
 * ------------------
 * All custom plugins are defined below.
 */

/*
 * BOX REFRESH BUTTON
 * ------------------
 * This is a custom plugin to use with the component BOX. It allows you to add
 * a refresh button to the box. It converts the box's state to a loading state.
 *
 * @type plugin
 * @usage $("#box-widget").boxRefresh( options );
 */
$.LayoutManager.addRefreshButton = function () {
  "use strict";

  $.fn.boxRefresh = function (options) {

    // Render options
    var settings = $.extend({
      //Refresh button selector
      trigger: ".refresh-btn",
      //File source to be loaded (e.g: ajax/src.php)
      source: "",
      //Callbacks
      onLoadStart: function (box) {
        return box;
      }, //Right after the button has been clicked
      onLoadDone: function (box) {
        return box;
      } //When the source has been loaded

    }, options);

    //The overlay
    var overlay = $('<div class="overlay"><div class="fa fa-refresh fa-spin"></div></div>');

    return this.each(function () {
      //if a source is specified
      if (settings.source === "") {
        if (window.console) {
          window.console.log("Please specify a source first - boxRefresh()");
        }
        return;
      }
      //the box
      var box = $(this);
      //the button
      var rBtn = box.find(settings.trigger).first();

      //On trigger click
      rBtn.on('click', function (e) {
        e.preventDefault();
        //Add loading overlay
        start(box);

        //Perform ajax call
        box.find(".box-body").load(settings.source, function () {
          done(box);
        });
      });
    });

    function start(box) {
      //Add overlay and loading img
      box.append(overlay);

      settings.onLoadStart.call(box);
    }

    function done(box) {
      //Remove overlay and loading img
      box.find(overlay).remove();

      settings.onLoadDone.call(box);
    }

  };
  return $.LayoutManager;
};

/*
 * EXPLICIT BOX ACTIVATION
 * -----------------------
 * This is a custom plugin to use with the component BOX. It allows you to activate
 * a box inserted in the DOM after the app.js was loaded.
 *
 * @type plugin
 * @usage $("#box-widget").activateBox();
 */
$.LayoutManager.activateBox = function () {
  'use strict';

  $.fn.activateBox = function () {
    $.LayoutManager.boxWidget.activate(this);
  };
  
  return $.LayoutManager;
};

/*
 * TODO LIST CUSTOM PLUGIN
 * -----------------------
 * This plugin depends on iCheck plugin for checkbox and radio inputs
 *
 * @type plugin
 * @usage $("#todo-widget").todolist( options );
 */

$.LayoutManager.listCustomPlugin = function () {

	  'use strict';

	  $.fn.todolist = function (options) {
	    // Render options
	    var settings = $.extend({
	      //When the user checks the input
	      onCheck: function (ele) {
	        return ele;
	      },
	      //When the user unchecks the input
	      onUncheck: function (ele) {
	        return ele;
	      }
	    }, options);

	    return this.each(function () {

	      if (typeof $.fn.iCheck != 'undefined') {
	        $('input', this).on('ifChecked', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          settings.onCheck.call(ele);
	        });

	        $('input', this).on('ifUnchecked', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          settings.onUncheck.call(ele);
	        });
	      } else {
	        $('input', this).on('change', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          if ($('input', ele).is(":checked")) {
	            settings.onCheck.call(ele);
	          } else {
	            settings.onUncheck.call(ele);
	          }
	        });
	      }
	    });
	  };
	  return $.LayoutManager;
	};
	
	/* ------------------
	 * - Implementation -
	 * ------------------
	 * The next block of code implements LayoutManager's
	 * functions and plugins as specified by the
	 * options above.
	 */
	$.LayoutManager.setup = function ()
	{
	  "use strict";

	  //Fix for IE page transitions
	  $("body").removeClass("hold-transition");

	  //Extend options if external options exist
	  if (typeof LayoutManagerOptions !== "undefined") {
	    $.extend(true,
	            $.LayoutManager.options,
	            LayoutManagerOptions);
	  }

	  //Easy access to options
	  var o = $.LayoutManager.options;

	  //Set up the object
	  $.LayoutManager._init();

	  //Activate the layout maker
	  $.LayoutManager.layout.activate();

	  //Enable sidebar tree view controls
	  $.LayoutManager.tree('.sidebar');

	  //Enable control sidebar
	  if (o.enableControlSidebar) {
	    $.LayoutManager.controlSidebar.activate();
	  }

	  //Add slimscroll to navbar dropdown
	  if (o.navbarMenuSlimscroll && typeof $.fn.slimscroll != 'undefined') {
	    $(".navbar .menu").slimscroll({
	      height: o.navbarMenuHeight,
	      alwaysVisible: false,
	      size: o.navbarMenuSlimscrollWidth
	    }).css("width", "100%");
	  }

	  //Activate sidebar push menu
	  if (o.sidebarPushMenu) {
	    $.LayoutManager.pushMenu.activate(o.sidebarToggleSelector);
	  }

	  //Activate Bootstrap tooltip
	  if (o.enableBSToppltip) {
	    $('body').tooltip({
	      selector: o.BSTooltipSelector
	    });
	  }

	  //Activate box widget
	  if (o.enableBoxWidget) {
	    $.LayoutManager.boxWidget.activate();
	  }

	  //Activate fast click
	  if (o.enableFastclick && typeof FastClick != 'undefined') {
	    FastClick.attach(document.body);
	  }

	  //Activate direct chat widget
	  if (o.directChat.enable) {
	    $(document).on('click', o.directChat.contactToggleSelector, function () {
	      var box = $(this).parents('.direct-chat').first();
	      box.toggleClass('direct-chat-contacts-open');
	    });
	  }

	  /*
	   * INITIALIZE BUTTON TOGGLE
	   * ------------------------
	   */
	  $('.btn-group[data-toggle="btn-toggle"]').each(function () {
	    var group = $(this);
	    $(this).find(".btn").on('click', function (e) {
	      group.find(".btn.active").removeClass("active");
	      $(this).addClass("active");
	      e.preventDefault();
	    });

	  });
	  
	  return $.LayoutManager
	  	.addRefreshButton()
	  	.activateBox()
	  	.listCustomPlugin();
	};

$.LayoutManager.loading = function(start) {
  $('#initerror').remove();
  var start = _.isBoolean(start) ? start : true;
  if (start) {
    $('body').append('<div id="loadspinner" class="loading"></div>');
  }
  else {
    $('#loadspinner').remove();
  }
};

$.LayoutManager.reload = function(errorMsg) {
  $('body').append('<div id="initerror"><h2>Oops!!! Si è verificato un errore</h2>' +
    '<h4>Causa:  '+ errorMsg+'</h4>' +
    '<h5>Al momento non è possibile caricare la mappa</h5>' +
    '<button id="reload" type="button" class="btn btn-primary center-block" onclick="$.LayoutManager.loading();$.LayoutManager.bootstrap()">' +
    '<span class="glyphicon glyphicon-refresh"></span> <strong>Riprova</strong></button>' +
    '</div>'
  );
};

module.exports = $.LayoutManager;

},{}],16:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var GUI = require('gui/gui');
var ProjectsRegistry = require('core/project/projectsregistry');

var InternalComponent = Vue.extend({
  template: require('../html/menu.html'),
  data: function() {
    return {
      state: null,
      loading: false
    }

  },
  methods: {
    trigger: function(item) {
      var self = this;
      if (item.cbk) {
        //setto il modale a schermo intero
        $('#full-screen-modal').modal('show');
        this.loading = true;
        item.cbk.apply(item)
          .then(function(){
            self.loading = false;
            // tyolgo il modale a schermo intero
            $('#full-screen-modal').modal('hide');
          })
          .fail(function() {
            GUI.notify.error("<h4>Errore di caricamento della nuova mappa.</h4>" +
              "<h5>Controllare la connessione internet o contattare l'amministratore</h5>");
            $('#full-screen-modal').modal('hide');
            self.loading = false;
          })
      }
      else if (item.href) {
        window.open(item.href, '_blank');
      }
      else if (item.route) {
        GUI.goto(item.route);
      }
      else {
        console.log("Nessuna azione per "+item.title);
      }
    },
    logoSrc: function(src) {
      if (src.indexOf('./') > -1) {
        return ProjectsRegistry.config.mediaurl + src;
      } else {
        return src;
      }
    }
  },
  mounted: function() {
    Vue.nextTick(function () {
      $("#menu-projects.nano").nanoScroller();
    })
  }
});

function MenuComponent(options){
  options = options || {};
  base(this,options);
  //this.id = "menu_"+Date.now();
  this.title = options.title || "menu";
  this.state.visible = true;
  this.state.menuitems = options.menuitems;
  merge(this, options);
  this.internalComponent = new InternalComponent({
    service: this
  });
  this.internalComponent.state = this.state;
}
inherit(MenuComponent, Component);

var proto = MenuComponent.prototype;

proto.trigger = function(item) {

};

module.exports = MenuComponent;


},{"../html/menu.html":7,"core/i18n/i18n.service":30,"core/project/projectsregistry":67,"core/utils/utils":71,"gui/gui":114,"gui/vue/component":152}],17:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('core/plugin/pluginsregistry');
var MenuComponent = require('./menu');
var SidebarService = require('./sidebar').SidebarService;
var GUI = require('sdk').gui.GUI;

function ProjectsMenuComponent(options) {
  options = options || {};
  options.id = 'projectsmenu';
  base(this, options);
  var menuitems = [];
  var projects = ProjectRegistry.getListableProjects();
  _.forEach(projects, function(project){
    menuitems.push({
      title: project.title,
      description: project.description,
      thumbnail: project.thumbnail,
      cbk: function() {
        var d = $.Deferred();
        var currentProject;
        ProjectRegistry.getProject(project.gid)
        .then(function(project) {
          GUI.closeContent()
            .then(function() {
              currentProject = project;
              var currentUrl = window.location.href;
              var paths = currentUrl.split('/');
              if (!paths[ paths.length-1 ]) {
                paths[ paths.length-2 ] = project.getId();
                paths[ paths.length-3 ] = project.getType();
              } else {
                paths[ paths.length-1 ] = project.getId();
                paths[ paths.length-2 ] = project.getType();
              }
              //window.location = paths.join('/');
              // cambio la url
              history.pushState(null, null, paths.join('/'));
              // vado a afre il reload dei plugins
              PluginsRegistry.reloadPlugins(project);
              ProjectRegistry.setCurrentProject(currentProject);
              // vado a fare il reloads dei component
              SidebarService.reloadComponents();
              d.resolve();
            })
        })
        .fail(function() {
          d.reject();
        });
        return d.promise();
      }
    })
  });
  this.state.menuitems = menuitems;
}

inherit(ProjectsMenuComponent, MenuComponent);

module.exports = ProjectsMenuComponent;



},{"./menu":16,"./sidebar":18,"core/i18n/i18n.service":30,"core/plugin/pluginsregistry":62,"core/project/projectsregistry":67,"core/utils/utils":71,"sdk":154}],18:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
var inherit = require('sdk/core/utils/utils').inherit;
var Stack = require('./barstack.js');
var G3WObject = require('sdk/core/g3wobject');
var base = require('sdk/core/utils/utils').base;

//sidebar item che non è altro che un li della sidebar dove sarà possibile impostare
//titolo tipo di icona etc .. customizzata per ogni componente
var SidebarItem = Vue.extend({
  template: require('../html/sidebar-item.html'),
  data: function() {
    return {
        main: true,
        component: null,
        active: false,
        title: 'component',
        open: false,
        icon: null,
        state: null
      };
  },
  methods: {
    onClickItem: function() {
      var self = this;
      var sidebarService = this.$options.service;
      this.component.setOpen(!this.component.state.open);
      // setto lo stato del componente open
      _.forEach(sidebarService.state.components, function (component) {
        if (component != self.component && self.component.collapsible) {
          component.setOpen(false);
        }
      })
    }
  }
});

// service sidebar
function SidebarService() {
  //stack della sidebar
  this.stack = new Stack();
  // metto i setter close sidebarpanel per catturare l'evento
  // della chiusura del pannello sulla sidebar
  this.setters = {
    closeSidebarPanel: function()  {
      //hook function
    },
    openCloseItem: function(bool) {
    }
  };
  //stato del servizio
  this.state = {
    components: []
  };
  //inizializzazione del servizio (non sembra chaimato mai)
  this.init = function(layout) {
    this.layout = layout;
  };
  // funzione che serve ad aggiungere componeti alla sidebar
  this.addComponents = function(components){
    var self = this;
    // per ogni componente (istanza) appartenete alla sidebar viene chiamato il metodo
    // addComponent
    _.forEach(components,function(component){
      self.addComponent(component);
    });
    // rtorno true alla fine dell'aggiunta dei componenti perchè mi serve
    // al template durante il buoldtemplate di dire se è stato regitstrato (true) o meno
    return true;
  };
  // funzione che aggiunge il singolo componente sulla sidebar
  // aggiungo anche possibilità di insicare la positione nella sidebar
  this.addComponent = function(component, position) {
    //faccio montare il sidebar-item che contiene al suo interno il placeholder del componente vero e proprio
    //in questo modo il componente non si dovrà occupare di costruire anche l'elemento li della sidebar
    //ma conterrà solo il contenuto
    var sidebarItem = new SidebarItem({
      service: this
    });
    //setto le parti della sidebar-item che cambiano da componente a componente (da rivedere)
    sidebarItem.title = component.title || sidebarItem.title;
    sidebarItem.open = component.state.open;//(component.open === undefined) ? sidebarItem.open : component.open;
    sidebarItem.icon = component.icon || sidebarItem.icon;
    sidebarItem.state = component.state || true;
    sidebarItem.collapsible = component.collapsible || true;
    sidebarItem.component = component;
    //lo appendo al g3w-sidebarcomponents (template sidebar.html)
    var itemcomponent = sidebarItem.$mount();
    if (_.isNil(position)) {
      this.state.components.push(component);
      $('#g3w-sidebarcomponents').append(itemcomponent.$el);
    } else {
      this.state.components = this.state.components.splice(0,0,component);
      $('#g3w-sidebarcomponents').children().each(function(index, element) {
        if (position == index) {
          $(itemcomponent.$el).insertBefore(element);
        }
      });
    }
    //monto il componete nella g3w-sidebarcomponent-placeholder (template sidebar-item.html);
    component.mount("#g3w-sidebarcomponent-placeholder");
    // verifico che il componete abbia l'iniService come metodo
    if (_.has(component, 'initService')) {
      //se si lo chiamo inizializzazione del servizo
      component.initService();
    }
    return true;
  };

  // restituisce il component in base all'id
  this.getComponent = function(id) {
    var Component;
    _.forEach(this.state.components, function(component) {
      if (component.getId() == id) {
        Component = component;
        return false;
      }
    });
    return Component;
  };

  // restiuisce tutti i componenti
  this.getComponents = function() {
    return this.state.components;
  };

  this.reloadComponent = function(id) {
    var component = this.getComponent(id);
    component.reload();
  };

  this.reloadComponents = function() {
    // vado a forzare la chisura del panel
    this.closePanel();
    _.forEach(this.state.components, function(component) {
      if (component.collapsible && component.state.open) {
        $(component.getInternalComponent().$el).siblings().click();
        component.setOpen(false);
      }
      component.reload();
    })
  };
  //rimuove il component
  this.removeComponent = function(component) {
    var self = this;
    _.forEach(this.state.components, function(sidebarComponent, index) {
      if (component == sidebarComponent) {
        component.unmount();
        self.state.components.splice(index, 1);
        return false;
      }
    })
  };
  // visualizzazione pannello sullo stack
  this.showPanel = function(panel) {
    var parent = "#g3w-sidebarpanel-placeholder";
    // utilizzo il metodo push dello stack per montare il panel sul sidebar
    this.stack.push(panel, {
      parent: parent
    });
  };
  // chiusura pannello
  this.closePanel = function() {
    this.closeSidebarPanel();
    var panel = this.stack.pop();
  };

  base(this);
}

// eredito da G3Wobject così posso agire su onafter etc ..
inherit(SidebarService, G3WObject);

var sidebarService = new SidebarService;

var SidebarComponent = Vue.extend({
    template: require('../html/sidebar.html'),
    data: function() {
    	return {
        components: sidebarService.state.components,
        panels: sidebarService.stack.state.contentsdata,
        bOpen: true,
    		bPageMode: false,
    		header: t('main navigation')
        };
    },
    computed: {
      // quanti pannelli sono attivi nello stack
      panelsinstack: function(){
        return this.panels.length > 0;
      },
      showmainpanel: function(){
        return this.components.length>0 && !this.panelsinstack;
      },
      componentname: function(){
        var name = "";
        if (this.components.length){
          name = this.components.slice(-1)[0].getTitle();
        }
        return name;
      },
      panelname: function(){
        var name = "";
        if (this.panels.length){
          name = this.panels.slice(-1)[0].content.getTitle();
        }
        return name;
      }
    },
    methods: {
      closePanel: function(){
        sidebarService.closePanel();
      },
      isMobile: function(){
        return isMobile.any
      }
    }
});

module.exports = {
  SidebarService: sidebarService,
  SidebarComponent: SidebarComponent
};

},{"../html/sidebar-item.html":8,"../html/sidebar.html":9,"./barstack.js":12,"sdk/core/g3wobject":27,"sdk/core/i18n/i18n.service":30,"sdk/core/utils/utils":71}],19:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
require('sdk/gui/vue/vue.directives');
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ComponentsRegistry = require('sdk/gui/componentsregistry');
var GUI = require('sdk/gui/gui');
// temporaneo per far funzionare le cose
var config = {
  client:{}
};
// vado a recuperare le parti che compongono l'applicazione
var sidebar = require('./sidebar');
var floatbar = require('./floatbar');
var viewport = require('./viewport');
var AppUI = require('./applicationui');
var layout = require('./layout');

// forse da trovare un posto migliore per attivare lo spinner iniziale...
layout.loading(true);
// classe che serve per instaziare e settare il template dell'applicazione
var ApplicationTemplate = function(templateConfig, ApplicationService) {
  self = this;
  this.templateConfig = templateConfig;
  this.init = function() {
    var config = ApplicationService.getConfig();
    // fa il setup dell'interfaccia
    // dichiarando i metodi generali dell'applicazione GUI.showForm etc ..
    this._setupInterface();
    // fa il setup del layout
    this._setupLayout();
    //vado a registrare tutti i servizi dell'appilazione
    this._setUpServices();
  };

  // setup layout
  // funzione che registra i componenti vue dell'applicazione
  this._setupLayout = function(){
    Vue.filter('t', function (value) {
      return t(value);
    });

    // veramente brutto ma ora non saprei fare diversamente: quando non siamo su mobile definiamo un left per dare spazio al sidebar-aside-toggle
    if (!isMobile.any) {
      $("<style type='text/css'> .ol-control-tl {" +
        "top: 7px;" +
        "left:43px;" +
      "}</style>").appendTo("head");
    }
    // Inizializzo i componenti vue dell'applicazione
    // prima che venga istanziato l'oggetto vue padre
    Vue.component('sidebar', sidebar.SidebarComponent);
    Vue.component('viewport', viewport.ViewportComponent);
    Vue.component('floatbar', floatbar.FloatbarComponent);
    Vue.component('app', AppUI);
    //inizializza l'applicazione Vue oggetto vue padre dell'applicazione
    var app = new Vue({
      el: '#app',
      mounted: function() {
        //una volta che l'istanza vue è pronta
        // inzio a costruire il template aggiungendo i vari componenti
        self._buildTemplate();
        // faccio il localize
        $(document).localize();
        this.$nextTick(function(){
          // setto la viewport passadogli la configurazione del viewport dell'applicazione
          self._setViewport(self.templateConfig.viewport);
          // emetto l'evento ready
          self.emit('ready');
          GUI.ready();
        });
      }
    });
  };
  //funzione che server per registrare tutti i servizi legati
  // alle vaie pari dell'appliazione
  this._setUpServices = function() {
    // registro i servizi dei componenti principali applicazione
    // sidebar, viewport etc..
    _.forEach(ApplicationTemplate.Services, function(service, element) {
      ApplicationService.registerService(element, service);
    });
    // registro tutti i servizi del componenti figli
    _.forEach(GUI.getComponents(), function(component) {
      ApplicationService.registerService(component.id, component.getService());
    })
  };
  // funzione che costruice il template
  this._buildTemplate = function() {
    var self = this;
    floatbar.FloatbarService.init(layout);
    // recupero i plceholders dalla configurazione del template
    var placeholdersConfig = this.templateConfig.placeholders;
    // ciclo su ogni placeholder
    _.forEach(placeholdersConfig, function(options, placeholder) {
      // per ogni placeholder ci possono essere più componenti ciclo e aggiungo
      //che vuol dire montare i varic componenti vue nei rispettivi placeholder
      self._addComponents(options.components, placeholder);
    });
    //registro altri componenti che non hanno una collocazione spaziale precisa
    // come da esempio QueryResultsComponent, form  che possono essere montati sulla floatbar o altre parti del template
    this._addOtherComponents();
  };

  //aggiungere compineti non legati ad un placeholder
  this._addOtherComponents = function() {
    var self = this;
    // verifico che ci siano altrimcomponenti rispetto a quelli in posizione standard
    if (this.templateConfig.othercomponents) {
      self._addComponents(this.templateConfig.othercomponents);
    }
  };
  // metodo per il setting della vieport
  this._setViewport = function(viewportOptions) {
    // sono passati i componenti della viewport
    // es.: map e content
    /*

    components: {
      map: new MapComponent({
        id: 'map'
      }),
      content: new ContentsComponent({
        id: 'content',
      })
     }

     */
    if (viewportOptions) {
      // inizializzo il service della viewport
      ApplicationTemplate.Services.viewport.init(viewportOptions);
      // passo i componenti della viewport per essere aggiunti alla viewport
      this._addComponents(viewportOptions.components);
    }
  };
  // aggiunge componente al template
  this._addComponent = function(component, placeholder) {
    this._addComponents([component], placeholder);
  };
  // aggiunge componenti al template e registra con componentregistry
  this._addComponents = function(components, placeholder) {
    var register = true;
    // qui entro solo e soltanto se è stato passato un placeholder e che questo
    // sia tra i componeti dei placeholders previsti
    // ad esempio nel caso della vieport (setViewport) non viene passato nessun placeholder
    // e quindi non viene chiamato addComponet del servizio viewport in quanto è
    // chaitao quando viene inizializzazto (chiamato init) del servizio
    if (placeholder && ApplicationTemplate.PLACEHOLDERS.indexOf(placeholder) > -1) {
      // recupero il service del placeholder associato (sidebar, navbar etc..)
      var placeholderService = ApplicationTemplate.Services[placeholder];
      // se non è nullo o vuoto
      if (placeholderService) {
        // delego il servizio del placheholder di aggiungere il componente
        register = placeholderService.addComponents(components);
      }
    }
    // ciclo sui componenti
    _.forEach(components, function(component) {
      // verifico se è stato registrato
      // nel cosa in cui non è stato registrato (esempio caso otherscomponents)
      if (register) {
        // registro il componente
        ComponentsRegistry.registerComponent(component);
      }
    })
  };
  // rimuovo il componente andando a toglierlo al component registry
  this._removeComponent = function(componentId) {
    ComponentsRegistry.unregisterComponent(componentId);
  };
  // funzione che visualizza la modelae overlay
  this._showModalOverlay = function(bool) {
    var mapService = GUI.getComponent('map').getService();
    if (bool) {
      mapService.startDrawGreyCover();
    } else {
      mapService.stopDrawGreyCover();
    }
  };
  this._showSidebar = function() {
    //codice qui
  };
  this._hideSidebar = function() {
    //codice qui
  };
  // setup dell'interfaccia dell'applicazione
  // qui definisco i metodi generali dell'applicazione
  // per poter interagire con essa attraverso maggiormente con l'oggetto GUI
  this._setupInterface = function() {
    /* DEFINIZIONE INTERFACCIA PUBBLICA */
    /* Metodi comuni a tutti i template */
    GUI.layout = layout;
    GUI.addComponent = _.bind(this._addComponent, this);
    GUI.removeComponent = _.bind(this._removeComponent, this);
    /* Metodi da definire (tramite binding) */
    GUI.getResourcesUrl = _.bind(function() {
      return ApplicationService.getConfig().resourcesurl;
    },this);
    //LIST
    GUI.showList = _.bind(floatbar.FloatbarService.showPanel, floatbar.FloatbarService);
    GUI.closeList = _.bind(floatbar.FloatbarService.closePanel, floatbar.FloatbarService);
    GUI.hideList = _.bind(floatbar.FloatbarService.hidePanel, floatbar.FloatbarService);
    // TABLE
    GUI.showTable = function() {};
    GUI.closeTable = function() {};
    //esempio di metodo generico Aside Results e Form etc...
    // metodo che restituisce il metodo GUI
    // a cui passare oggetto per la visualizzazione del Panello sul content component
    GUI.showContentFactory = function(type) {
      var showPanelContent;
      switch (type) {
        case 'query':
          showPanelContent = GUI.showQueryResults;
          break;
        case 'form':
          showPanelContent = GUI.showForm;
          break;
      }
      return showPanelContent;
    };
    // funzione per la visualizzazione del form
    // viene utilizzata ad esempio dall'editor per visualizzare il form nel content component
    GUI.showForm = function(options) {
      // recupero il compomponete Form base
      var FormComponent = require('sdk').gui.vue.FormComponent;
      // verifico che sia stato definito un formcomponent dall'editor custom del plugin
      // Istanzio sempre un componente nuovo
      var formComponent = options.formComponent ? new options.formComponent :  new FormComponent({
        id: 'form'
      });
      //recupero il servizio (che darà sempre una nuova istanza)
      var formService = formComponent.getService();
      // inizializzo il form con le opzioni ad esempio passate dall'editor (fields, relations etc..)
      formService.setInitForm(options);
      // agggiunto un ulteriore parametro closable che di default è true
      // e quindi sarà possibile chidere il pannello con la x
      // parametri : [content, title, push, perc, split, closable]
      GUI.setContent({
        content: formComponent,
        push: false, //significa che ci deve essere solo lui( cancellando eventuali precedenti form)
        closable: false
      });
      //ritorno il formService
      return formService;
    };
    // chiudo il form che chiama il metodo removeContent del service viewport
    GUI.closeForm = function() {
      viewport.ViewportService.removeContent();
      // forzo a far si che il modale venga tolto
      GUI.setModal(false);
    };

    // chide la colonna di dentra del content
    // ritorna una promise
    GUI.closeContent = function() {
      return viewport.ViewportService.closeContent();
    };

    // funzione per la visuzlizzazione dei risultati
    GUI.showQueryResults = function(title, results) {
      // prendo il componente
      var queryResultsComponent = GUI.getComponent('queryresults');
      // prendo il servizio del componente
      var queryResultService = queryResultsComponent.getService();
      queryResultService.reset();
      if (results) {
        queryResultService.setQueryResponse(results);
      }
      var contentsComponent = GUI.getComponent('contents');
      //vado a verificare se non c'è contentuto oppure se è stato fatta una sola query
      if (!contentsComponent.getContentData().length || (contentsComponent.getContentData().length == 1 && contentsComponent.getCurrentContentData().content.getId() == 'queryresults')) {
        GUI.showContextualContent(
          {
            content: queryResultsComponent,
            title: "Risultati " + title
          }
        );
      } else {
        if (contentsComponent.getCurrentContentData().content.getId() == 'queryresults') {
          contentsComponent.popContent();
        }
        GUI.pushContent({
          content: queryResultsComponent,
          backonclose: true,
          closable:false,
          perc: 50,
          title: "Risultati " + title
        });
      }
      return queryResultService;
    };
    //temporaneo show panel
    GUI.showPanel = _.bind(sidebar.SidebarService.showPanel, sidebar.SidebarService);
    GUI.closePanel = _.bind(sidebar.SidebarService.closePanel, sidebar.SidebarService);

    /* ------------------ */

    toastr.options.positionClass = 'toast-top-center';
    toastr.options.preventDuplicates = true;
    toastr.options.timeOut = 2000;

    /* --------------------- */
    // proxy della libreria toastr
    GUI.notify = toastr;
    // proxy della libreria bootbox
    GUI.dialog = bootbox;
    /* spinner */
    GUI.showSpinner = function(options){
      var container = options.container || 'body';
      var id = options.id || 'loadspinner';
      var where = options.where || 'prepend'; // append | prepend
      var style = options.style || '';
      var transparent = options.transparent ? 'background-color: transparent' : '';
      var center = options.center ? 'margin: auto' : '';
      if (!$("#"+id).length) {
        $(container)[where].call($(container),'<div id="'+id+'" class="spinner-wrapper '+style+'" style="'+transparent+'"><div class="spinner '+style+'" style="'+ center+'"></div></div>');
      }
    };
    //fa sparire lo spinner di caricamento
    GUI.hideSpinner = function(id){
      $("#"+id).remove();
    };
    /* end spinner*/
    /* fine metodi comuni */

    /* Metodi specifici del template */
    // FLOATBAR //
    GUI.showFloatbar = function() {
      floatbar.FloatbarService.open();
    };
    GUI.hideFloatbar = function() {
      floatbar.FloatbarService.close();
    };
    // SIDEBAR //
    GUI.showSidebar = _.bind(this._showSidebar, this);
    GUI.hideSidebar = _.bind(this._hideSidebar, this);
    // MODAL
    GUI.setModal = _.bind(this._showModalOverlay, this);

    // VIEWPORT //
    GUI.setPrimaryView = function(viewName) {
      viewport.ViewportService.setPrimaryView(viewName);
    };
    // Mostra la mappa nascondendo la vista dei contenuti
    GUI.showMap = function() {
      viewport.ViewportService.showMap();
    };
    // Mostra la mappa come vista aside (nel caso sia attiva la vista contenuti). Percentuale di default 30%
    GUI.showContextualMap = function(perc,split) {
      perc = perc || 30;
      viewport.ViewportService.showContextualMap({
        perc: perc,
        split: split
      })
    };
    GUI.setContextualMapComponent = function(mapComponent) {
      viewport.ViewportService.setContextualMapComponent(mapComponent);
    };
    GUI.resetContextualMapComponent = function() {
      viewport.ViewportService.resetContextualMapComponent();
    };
    // Mostra il contenuto (100%)
    GUI.showContent = function(options) {
      options =  options || {};
      options.perc = 100;
      GUI.setContent(options);
    };
    // Mostra il contenuto. Il contenuto può essere una string HTML,
    // un elemento DOM o un componente Vue. Percentuale di default 50%
    GUI.showContextualContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 50;
      GUI.setContent(options)
    };
    // funzione che server ad aggiungere il componente
    // allo stack del content (in append)
    // Le differenze rispetto a setContent sono :
    //  - nel fatto che push è sempre a true e quindi il component viene impilato su altro componente
    //  - ha un parametro in più che è il backonclose che specifica se nel cosa venga clicckato sulla x
    //    il contentComponet viene chiuso totalmente e lo stack resettato o rimosso solo quel componete
    GUI.pushContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 100;
      options.push = true;
      GUI.setContent(options);
    };
    // Aggiunge contenuto allo stack
    GUI.pushContextualContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 50;
      options.push = true;
      GUI.setContent(options);
    };
    // funzione che setta i parametri del contenuto del content
    // come il componete etc..
    GUI.setContent = function(options) {
      options = options || {};
      // vado a verificare le opzioni passate e setto valori di default
      // in caso di mancata assegnazione
      options.content = options.content || null;
      options.title = options.title || "";
      options.push = _.isBoolean(options.push) ? options.push : false;
      options.perc = options.perc || 0;
      options.split = options.split || 'h';
      options.backonclose = _.isBoolean(options.backonclose) ? options.backonclose : false;
      options.showtitle = _.isBoolean(options.showtitle) ? options.showtitle : true;
      // chiamo il metodo showContent del servizio
      // viewport per poter visualizzare il content
      viewport.ViewportService.showContent(options);
    };

    /* FINE VIEWPORT */
    /* fine metodi specifici */
    /* FINE DEFINIZIONE INTERFACCIA PUBBLICA */
  };
  base(this);
};

inherit(ApplicationTemplate,G3WObject);

// funzione di classe
ApplicationTemplate.fail = function(bootstrap, errorMsg) {
  layout.loading(false);
  if (!layout.bootstrap) layout.bootstrap = bootstrap;
  layout.reload(errorMsg);
};

// questi sono i plceholder previsti ne standard dell'applicazione
ApplicationTemplate.PLACEHOLDERS = [
  'navbar',
  'sidebar',
  'viewport',
  'floatbar'
];

// questi sono i servizi dei contenitori di componenti
ApplicationTemplate.Services = {
  navbar: null,
  sidebar: sidebar.SidebarService,
  viewport: viewport.ViewportService,
  floatbar: sidebar.FloatbarService
};

module.exports =  ApplicationTemplate;


},{"./applicationui":11,"./floatbar":14,"./layout":15,"./sidebar":18,"./viewport":20,"core/g3wobject":27,"core/utils/utils":71,"sdk":154,"sdk/core/i18n/i18n.service":30,"sdk/gui/componentsregistry":110,"sdk/gui/gui":114,"sdk/gui/vue/vue.directives":153}],20:[function(require,module,exports){
var inherit = require('sdk').core.utils.inherit;
var base = require('sdk').core.utils.base;
var G3WObject = require('sdk').core.G3WObject;
var GUI = require('sdk').gui.GUI;

// calsse servizio della viewport
var ViewportService = function() {
  // contiene lo stato della viewport
  this.state = {
    primaryView: 'map', // di default la vista primaria è la prima
    // percentuale della secondary view
    secondaryPerc: 0,
    // come viene splittatta la vista (h = orizzontale, v = verticale)
    split: 'h',
    //mappa
    map: {
      sizes: {
        width: 0,
        height: 0
      },
      aside: false
    },
    //content
    content:{
      sizes: {
        width: 0,
        height: 0
      },
      aside: true,
      stack: [], // array contentente gli elementi nello stack del contents
      closable: true, // specifica se chiudibile o meno (presenza della x)
      backonclose: false, // se al click della x deve essere chiso il contenuto tutto o toglierer l'ultomo contenuto dalla stack
      contentsdata:[] // array contenete i dati del content
    }
  };
  // sono i contentuti della viewport (mappa e content)
  this._components = {
    map: null,
    content: null
  };
  // contenuti di default
  this._defaultMapComponent;
  this._contextualMapComponent;

  // altezza e largezza minima della secondary view
  // imposte per evitare che la secondaryView (principalmente il content) possa diventare
  // molto piccola (esempio impostando un perc = 1) e quindi rendere illeggibile
  // il contenuto
  this._secondaryViewMinWidth = 300;
  this._secondaryViewMinHeight = 200;
  // attributo che serve per
  this._immediateComponentsLayout = true;
  /* INTERFACCIA PUBBLICA */
  // funzione che va ad aggiungere i comnponenti alla viewport
  // funzione di inizialilizzazione
  this.init = function(options) {
    var options = options || {};
    // verifica se è stata settata/specificata la primary view altrimenti mette la mappa di default
    this.state.primaryView = options.primaryview ? options.primaryview : 'map';
    // verifica se è stato settato la modalità di splitting altrimenti mette quello orizzontale
    this.state.split = options.split ? options.split : 'h';
    // aggiunge i componenti ( che sono map e content)
    this._addComponents(options.components);
  };

  // aggiunge i componenti alla viewport
  this._addComponents = function(components) {
    var self = this;
    // components è un oggetto contente chiave nome componente e valure istanza componente
    // nel caso attuale (vedi index.js)
    /*
     {
      map: new MapComponent({
        id: 'map'
      }),
      content: new ContentsComponent({
        id: 'contents'
      })
     }
     */
    _.forEach(components, function(component, viewName) {
      // verifica che i componenti siano map o content
      if (['map', 'content'].indexOf(viewName) > -1) {
        // monto (chiamo il metodo mount che tuttti i componeti hanno) componente sull'id specifico del componenti della mappa
        // map e content
        // monto con append a true
        component.mount('#g3w-view-'+viewName, true)
          .then(function() {
            // una volta che è stato montato aggiungo
            // all'array components
            self._components[viewName] = component;
            // verifico se il nome della view è la mappa
            if (viewName == 'map') {
              // setto il il componete come componente mappa di default
              self._defaultMapComponent = component;
            }
          });
      }
    })
  };


  // funzione showMap per la visulizzazione della mappa
  this.showMap = function() {
    this._toggleMapComponentVisibility(this._defaultMapComponent,true);
    this._components['map'] = this._defaultMapComponent;
    this._showView('map');
  };

  this.showContextualMap = function(options) {
    var self = this;
    if (!this._contextualMapComponent) {
      this._contextualMapComponent = this._defaultMapComponent;
    }
    if (this._contextualMapComponent != this._defaultMapComponent) {
      this._toggleMapComponentVisibility(this._defaultMapComponent,false);
    }
    if (!this._contextualMapComponent.ismount()) {
      var contextualMapComponent = this._contextualMapComponent;
      contextualMapComponent.mount('#g3w-view-map', true)
        .then(function(){
          self._components['map'] = contextualMapComponent;
        });
    }
    else {
      self._components['map'] = this._contextualMapComponent;
      this._toggleMapComponentVisibility(this._contextualMapComponent,true);
    }
    this._showView('map',options);
  };

  // funzione che recupera il componente mappa di default
  this.recoverDefaultMap = function() {
    // se il componente mappa è diversa dal componente mappa di default
    if (this._components['map'] != this._defaultMapComponent) {
      this._components['map'] = this._defaultMapComponent;
      this._toggleMapComponentVisibility(this._contextualMapComponent,false);
      this._toggleMapComponentVisibility(this._defaultMapComponent,true);
    }
  };

  this.setContextualMapComponent = function(mapComponent) {
    var self = this;
    if (mapComponent == this._defaultMapComponent) {
      return;
    }
    if (this._contextualMapComponent) {
      this._contextualMapComponent.unmount();
    }
    this._contextualMapComponent = mapComponent;
  };

  this.resetContextualMapComponent = function() {
    if (this._contextualMapComponent) {
      this._contextualMapComponent.unmount();
    }
    this._contextualMapComponent = this._defaultMapComponent;
  };

  this._toggleMapComponentVisibility = function(mapComponent,toggle) {
    mapComponent.internalComponent.$el.style.display = toggle ? 'block' : 'none';
  };

  // chiude la mappa
  this.closeMap = function() {
    this.state.secondaryPerc = (this.state.primaryView == 'map') ? 100 : 0;
    this.recoverDefaultMap();
    this._layout();
  };

  // visualizza il contentuto della content della viewport
  /*
   options: {
     content: può essere una stringa di testo, un elemento jQuery o un componente Vue
     title: il title da mostrare nella finestra dei contenuti
     push (opzionale, default false): se il contenuto deve essere impilato sul precedente (con possibilità di tornare indietro nello stack dei contenuti (contentStack)
     split (opzionale, default 'h'): 'h' || 'v' splittare le finestre orizzontalmente o verticalmente. per ora testato solo orizzontalmente
     perc (opzionale, default 50): valore numerico, indica la percentuale delle finestra dei contenuti (es. 33 -> 2/3 saranno di mappa e 1/3 di contenuti)
   }
   */
  // funzione che è chiamata da GUI.setContent per visualizzare conentuto all'interno del content component
  this.showContent = function(options) {
    var self = this;
    // verifica se è stato settato l'opzione push
    options.push = options.push || false;
    // vado a settare tutti i parametri per il content come la parcentuale, titolo, etc ..
    this._prepareContentView(options);
    // setto immediateComponentsLayout a false
    this._immediateComponentsLayout = false;
    this._showView('content', options, true);
    self._components.content.setContent(options)
      .then(function(){
        //var data = self._components.content.getCurrentContentData();
        //self._prepareView(data.options);
        self._layoutComponents();
        self._immediateComponentsLayout = true;
      });
  };

  // funzione che toglie l'ultimo content al contentStack
  this.popContent = function() {
    var self = this;
    // verifica che ci sia il conentuto nel compontentStack
    if (this.state.content.contentsdata.length) {
      this.recoverDefaultMap();
      // recupero il precedente content dallo stack
      var data = this._components.content.getPreviousContentData();
      self._prepareContentView(data.options);
      this._immediateComponentsLayout = false;
      this._showView('content');
      this._components.content.popContent()
        .then(function(){
          self._layoutComponents();
          self._immediateComponentsLayout = true;
        })
    }
  };

  // chiude il content
  this.closeContent = function() {
    this._components.content.removeContent();
    //fa il recover della mappa di default
    this.recoverDefaultMap();
    // chiudo la View secondaria ritornando una promise
    return this.closeSecondaryView();
  };

  // funzione che rimuove il cont dalla viewport o solo una parte
  this.removeContent = function() {
    // verifico che l'attributo backonclose sia true o false
    // per fare in modo che lo stack del contentStack si completamente rimosso
    // o tolto solamente il componente
    if (this.state.content.backonclose && this.state.content.contentsdata.length > 1) {
      this.popContent();
    } else {
      this._components.content.removeContent();
      //fa il recover della mappa di default
      this.recoverDefaultMap();
      // chido la View secondaria
      return this.closeSecondaryView();
    }
  };

  // risposte se è view primaria
  this.isPrimaryView = function(viewName) {
    return this.state.primaryView == viewName;
  };

  // metodo per definire qual'è la vista primaria
  this.setPrimaryView = function(viewTag) {
    if (this.state.primaryView != viewTag) {
      this.state.primaryView = viewTag;
    }
    this._layout();
  };

  // visualizza la primary view a seconda della percentuale passata come argomento
  this.showPrimaryView = function(perc) {
    if (perc && this.state.secondaryVisible && this.state.secondaryPerc == 100) {
      this.state.secondaryPerc = 100 - perc;
      this._layout();
    }
  };

  // metodo per la visualizzazione della vista secondaria
  // nella maggior parte dei casi è il content
  this.showSecondaryView = function(split, perc) {
    // setto la visibilità dello stato della seconda view
    this.state.secondaryVisible = true;
    this.state.split = split ? split : this.state.split;
    this.state.secondaryPerc = perc ? perc : this.state.perc;
    // richiamo la funzione layout
    this._layout();
  };

  // chiudo la view secondaria
  this.closeSecondaryView = function(componentId) {
    var d = $.Deferred();
    var self = this;
    var secondaryViewComponent = this._components[this._otherView(this.state.primaryView)];
    if (secondaryViewComponent.clearContents) {
      secondaryViewComponent.clearContents()
        .then(function(){
          self.state.secondaryVisible = false;
          self._layout();
          Vue.nextTick(function() {
            d.resolve();
          })
        });
    }
    else {
      this.state.secondaryVisible = false;
      // questo è il metodo che esegue il layout delle viste,
      // e dà ad ogni componente l'opportunità di ricalcolare il proprio layout
      this._layout();
      Vue.nextTick(function() {
        d.resolve();
      })
    }
    return d.promise();
  };

  //ritorna il valore di default della percentuale della view a sconda del tipo
  // di content
  this.getDefaultViewPerc = function(viewName) {
    return this.isPrimaryView(viewName) ? 100 : 50;
  };

  // ritorna la vista opposta rispoetto a quella passata
  this._otherView = function(viewName) {
    return (viewName == 'map') ? 'content' : 'map';
  };

  this._isSecondary = function(view) {
    return this.state.primaryView != view;
  };

  // meccanismo per il ricalcolo delle dimensioni della viewport e dei suoi componenti figli
  this._setPrimaryView = function(viewTag) {
    if (this.state.primaryView != viewTag) {
      this.state.primaryView = viewTag;
    }
  };

  // setto gli attributi del content della viewport
  this._prepareContentView = function(options) {
    this.state.content.preferredPerc = options.perc || this.getDefaultViewPerc('content');
    this.state.content.title = options.title;
    this.state.content.closable =  _.isNil(options.closable) ? true : options.closable;
    this.state.content.backonclose = _.isNil(options.backonclose) ? true : options.backonclose;
    this.state.content.contentsdata = this._components.content.contentsdata;
  };

  // metodo che si occupa delle gestione di tutta la logica di visualizzazione delle due viste (mappa e contenuti)
  // viewName può essere: map o content
  // le opzione specificano percentuali , splitting tittolo etc ..
  this._showView = function(viewName, options) {
    options = options || {};
    // prende il parametro percentuale
    var perc = options.perc || this.getDefaultViewPerc(viewName);
    // prende la tipologia di split della viewport
    var split = options.split || 'h';
    var aside;
    // verifica se la view in question è la primaria o meno
    if (this.isPrimaryView(viewName)) {
      aside = (typeof(options.aside) == 'undefined') ? false : options.aside;
    }
    else {
      aside = true;
    }
    // setto il valore di aside della view
    this.state[viewName].aside = aside;
    // calcolo la percentuale della view secondaria
    var secondaryPerc = this.isPrimaryView(viewName) ? 100 - perc : perc;
    if (secondaryPerc > 0) {
      // vado a visualizzare la secondaru view
      this.showSecondaryView(split, secondaryPerc);
    } else {
      // vado a chidere la view secondaria
      return this.closeSecondaryView();
    }
  };

  // funzione che restituisce le misure in alterzza e larghezza per cui
  // il contentuo deve essere spostato per evitare che venga messo sotto
  //sidebar-aside-toggle nel caso di un content al 100% a tutta viewport
  this._getReducedSizes = function(){
    var contentEl = $('.content');
    var reducedWidth = 0;
    var reducedHeight = 0;
    if (contentEl && this.state.secondaryVisible && this.state.secondaryPerc == 100) {
      var sideBarToggleEl = $('.sidebar-aside-toggle');
      if (sideBarToggleEl && sideBarToggleEl.is(':visible')) {
        var toggleWidth = sideBarToggleEl.outerWidth();
        contentEl.css('padding-left',toggleWidth + 5);
        reducedWidth = (toggleWidth - 5);
      }
    }
    else {
      contentEl.css('padding-left', 15);
    }
    return {
      reducedWidth: reducedWidth,
      reducedHeight: reducedHeight
    }
  };

  // funzione principale che si occupa dell'intero layout della vieport
  this._layout = function() {
    var self = this;
    // prende il tipo di split
    var splitClassToAdd = (this.state.split == 'h') ? 'split-h' : 'split-v';
    var splitClassToRemove =  (this.state.split == 'h') ? 'split-v' : 'split-c';
    // vengono aggiunte e rimosse le classi
    $(".g3w-viewport .g3w-view").addClass(splitClassToAdd);
    $(".g3w-viewport .g3w-view").removeClass(splitClassToRemove);
    var reducesdSizes = this._getReducedSizes();
    // setta il size delle vista
    this._setViewSizes(reducesdSizes.reducedWidth,reducesdSizes.reducedHeight);
    // cloaseMap button
    var closeMapBtn = $('#closemap-btn');
    if (!closeMapBtn.length) {
      var closeMapBtn = $('<div id="closemap-btn" @click="closeMap" style="\
        position: absolute;\
        right: 10px;\
        top: 7px;\
        line-height: 1;\
        padding: 7px 2px;\
        font-size: 1.5em;\
        background-color: #3c8dbc;\
        color: white;\
        z-index:1000;\
        height: 39px;\
        width: 39px">\
          <button class="glyphicon glyphicon-remove pull-right close-panel-button" style="background-color: transparent;border: 0px;"></button>\
        </div>');
      closeMapBtn.on('click',function(){
        self.closeMap();
      });
      var mapView = $(".g3w-viewport .map");
      mapView.append(closeMapBtn);
    }

    if (this.state.secondaryVisible) {
      if (this._isSecondary('content') && (this.state.secondaryPerc < this.state.content.preferredPerc)) {
        closeMapBtn.show()
      }
      else {
        closeMapBtn.hide();
      }
    }
    else {
      closeMapBtn.hide();
    }

    if (this._immediateComponentsLayout) {
      this._layoutComponents();
    }
  };

  // funzione che setta i size delle view (primaria e secondari)
  this._setViewSizes = function() {
    // view primaria e secondaria
    var primaryView = this.state.primaryView;
    // recupera la seconda View che è non è la primary (verosimilmente 'content')
    var secondaryView = this._otherView(primaryView);
    // altezza e larghezza della viewport
    var viewportWidth = this._viewportWidth();
    var viewportHeight = this._viewportHeight();
    // asegna alla primary view l'altezza e la larghezza della viewport
    var primaryWidth = viewportWidth;
    var primaryHeight = viewportHeight;
    var scale = this.state.secondaryPerc / 100;
    // verifica il tipo di plistting
    // caso orizzontale
    if (this.state.split == 'h') {
      secondaryWidth = this.state.secondaryVisible ? Math.max((viewportWidth * scale),this._secondaryViewMinWidth) : 0;
      secondaryHeight = viewportHeight;
      primaryWidth = viewportWidth - secondaryWidth;
      primaryHeight = viewportHeight;
    }
    else {
      secondaryWidth = viewportWidth;
      secondaryHeight = this.state.secondaryVisible ? Math.max((viewportHeight * scale),this._secondaryViewMinHeight) : 0;
      primaryWidth = viewportWidth;
      primaryHeight = viewportHeight - secondaryHeight;
    }
    // riassegno le giuste proporzione in sia height e width alla primary e secondary view
    // primary ViewSizes
    this.state[primaryView].sizes.width = primaryWidth;
    this.state[primaryView].sizes.height = primaryHeight;
    // secondaryViewSizes
    this.state[secondaryView].sizes.width = secondaryWidth;
    this.state[secondaryView].sizes.height = secondaryHeight;
  };

  // funzione che restituisce l'altezza che deve avere la viewPort
  this._viewportHeight = function() {
    var topHeight = $(".navbar").innerHeight();
    return $(window).innerHeight() - topHeight;
  };

  // funzione che restituisce la larghezza della view
  this._viewportWidth = function() {
    // prendo la posizione della posizione a sinistra
    // della sidebar
    var offset = $(".main-sidebar").offset().left;
    var width = $(".main-sidebar").innerWidth();
    var sideBarSpace = width + offset;
    // resituisco la larghezza riservata alla viewport
    return $(window).innerWidth() - sideBarSpace;
  };

  // funzione che va a caricare i componenti (della viewport)
  // solo dopo che le size delle view sono state corrette
  this._layoutComponents = function() {
    var self = this;
    Vue.nextTick(function(){
      var reducesdSizes = self._getReducedSizes();
      reducedWidth = reducesdSizes.reducedWidth || 0;
      reducedHeight = reducesdSizes.reducedHeight || 0;
      _.forEach(self._components, function(component, name) {
        // viene chiamato il metodo per il ricacolo delle dimensioni nei componenti figli
        var width = self.state[name].sizes.width - reducedWidth ;
        var height = self.state[name].sizes.height - reducedHeight;
        // ogni componente (mappa e contenuto) qui
        // ha l'opportunità di ricalcolare il proprio il layout.
        // Usato per esempio dalla mappa per reagire al resize della viewport
        component.layout(width, height);
      })
    });
  };

  // funzione che viene chiamata la prima volta che
  // si instanzia la viewport
  this._firstLayout = function() {
    var self = this;
    var drawing = false;
    var resizeFired = false;

    // funzione che fa il trigger del resize
    function triggerResize() {
      resizeFired = true;
      drawResize();
    }

    function drawResize() {
      if (resizeFired === true) {
        resizeFired = false;
        drawing = true;
        // chiama la funzione che si occupa ti settare
        // il layout della viewport
        self._layout(true);
        //funzione javascript nativa del browser (html5) che serve
        // per il Controllo temporizzazione per animazioni basate su script
        requestAnimationFrame(drawResize);
      } else {
        drawing = false;
      }
    }
    // registra la funzione che deve essere lanciata una volta che
    // la GUI e pronta (si ha quando è stato chiamato il metodo _buildTemplate di template.js)
    // che non fa altro che aggiungere alle varie parti dell'applicazione
    GUI.on('ready',function(){
      // prendo al primary view (verosimilmente 'map')
      var primaryView = self.state.primaryView;
      // secondary view 'content' di solito
      var secondaryView = self._otherView(primaryView);
      // seleziono l'elemento secondario con JQuery
      var secondaryEl = $(".g3w-viewport ."+secondaryView);
      // prendo (se esiste il valore css della seconday view min-width)
      var secondaryViewMinWidth = secondaryEl.css('min-width');
      if ((secondaryViewMinWidth != "") && !_.isNaN(parseFloat(secondaryViewMinWidth))) {
        self._secondaryViewMinWidth =  parseFloat(secondaryViewMinWidth);
      }
      var secondaryViewMinHeight = secondaryEl.css('min-height');
      if ((secondaryViewMinHeight != "") && !_.isNaN(parseFloat(secondaryViewMinHeight))) {
        self._secondaryViewMinHeight =  parseFloat(secondaryViewMinHeight);
      }
      self._layout(true);
      // resize scatenato da GUI
      GUI.on('guiresized',function() {
        triggerResize();
      });
      // resize della window
      $(window).resize(function() {
        // set resizedFired to true and execute drawResize if it's not already running
        if (drawing === false) {
          triggerResize();
        }
      });
      // resize sul ridimensionamento della sidebar
      $('.main-sidebar').on('webkitTransitionEnd transitionend msTransitionEnd oTransitionEnd', function () {
        $(this).trigger('trans-end');
        triggerResize();
      });
    });
  };
  this._firstLayout();
  base(this);
};
// eredita da G3WOBJECT
inherit(ViewportService, G3WObject);

//singleton
var viewportService = new ViewportService;

// COMPONENTE VUE VIEWPORT
var ViewportComponent = Vue.extend({
  template: require('../html/viewport.html'),
  data: function() {
    return {
      state: viewportService.state // lo stato del compoente è quello del servizio
    }
  },
  computed: {
    // proprietà derivata (booleana) che è legata al contentsdata dell'oggetto content
    showtitle: function() {
      var showtitle = true;
      // prende l'array di componenti dello stack del content
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length) {
        var options = contentsData[contentsData.length - 1].options;
        if (_.isBoolean(options.showtitle)) showtitle = options.showtitle;
      }
      return showtitle;
    },
    contentTitle: function() {
      // cambia il titolo prendendo l'ultimo elemento aggiunto alla stack
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length) {
        return contentsData[contentsData.length - 1].options.title;
      }
    },
    previousTitle: function() {
      // prende il titolo del precendete elemento
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length > 1) {
        if (!contentsData[contentsData.length - 2].options.title) {
          return 'indietro'
        }
        return 'a ' + contentsData[contentsData.length - 2].options.title;
      }
      return false;
    },
    contentSmallerThenPreferred: function() {
      return this.state.secondaryPerc < this.state.content.preferredPerc;
    }
  },
  methods: {
    closeContent: function() {
      viewportService.removeContent();
    },
    closeMap: function() {
      viewportService.closeMap();
    },
    gotoPreviousContent: function() {
      viewportService.popContent();
    }
  }
});

module.exports = {
  ViewportService: viewportService,
  ViewportComponent: ViewportComponent
};

},{"../html/viewport.html":10,"sdk":154}],21:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var reject = require('core/utils/utils').reject;

function ApiService(){
  this._config = null;
  this._baseUrl = null;
  this.init = function(config) {
    var deferred = $.Deferred();
    this._config = config;
    // prende l'url base delle api dal config dell'applicazione
    this._baseUrl = config.urls.api;
    this._apiEndpoints = config.urls.apiEndpoints;
    deferred.resolve();
    return deferred.promise();
  };
  //incrementi
  var howManyAreLoading = 0;
  this._incrementLoaders = function(){
    if (howManyAreLoading == 0){
      this.emit('apiquerystart');
    }
    howManyAreLoading += 1;
  };
  
  this._decrementLoaders = function(){
    howManyAreLoading -= 1;
    if (howManyAreLoading == 0){
      this.emit('apiqueryend');
    }
  };
  this.get = function(api, options) {
    var self = this;
    var apiEndPoint = this._apiEndpoints[api];
    if (apiEndPoint) {
      var completeUrl = this._baseUrl + '/' + apiEndPoint;
      if (options.request) {
         completeUrl = completeUrl + '/' + options.request;
      }
      var params = options.params || {};
      
      self.emit(api+'querystart');
      this._incrementLoaders();
      return $.get(completeUrl,params)
      .done(function(response){
        self.emit(api+'queryend',response);
        return response;
      })
      .fail(function(e){
        self.emit(api+'queryfail',e);
        return e;
      })
      .always(function(){
        self._decrementLoaders();
      });
    }
    else {
      return reject();
    }
  };
  base(this);
}

inherit(ApiService,G3WObject);

module.exports = new ApiService;

},{"core/g3wobject":27,"core/utils/utils":71}],22:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ApiService = require('core/apiservice');
var RouterService = require('core/router');
var ProjectsRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('core/plugin/pluginsregistry');
var ClipboardService = require('core/clipboardservice');

var G3W_VERSION = "1499437830172";

//oggetto servizio per la gestione dell'applicazione
var ApplicationService = function() {
  var self = this;
  this.version = G3W_VERSION.indexOf("G3W_VERSION") == -1 ? G3W_VERSION  : "";
  this.secret = "### G3W Client Application Service ###";
  this.ready = false;
  this.complete = false;
  this._modalOverlay = null;
  this._acquirePostBoostrap = false;
  // oggetto che tiene tutti i servizi dei vari sidebar etc..
  // utili per il plugin
  this._applicationServices = {};
  this.config = {};
  this._initConfigUrl = null;
  this._initConfig = {};
  // chiama il costruttore di G3WObject (che in questo momento non fa niente)
  base(this);
  // funzione inizializzazione che prende la configurazione dal server
  this.init = function(config, acquirePostBoostrap){
    this._config = config;
    if (acquirePostBoostrap) {
      this._acquirePostBoostrap = true;
    }
    // lancio il bootstrap dell'applicazione
    return this._bootstrap();
  };
  // restituisce la configurazione
  this.getConfig = function() {
    return this._config;
  };
  // restituisce il router service
  this.getRouterService = function() {
    return RouterService;
  };
  // clipboard service
  this.getClipboardService = function() {
    return ClipboardService;
  };

  // funzione che ottiene la configurazione dal server
  this.obtainInitConfig = function(initConfigUrl) {
    var self = this;
    if (!this._initConfigUrl) {
      this._initConfigUrl = initConfigUrl;
    }
    var d = $.Deferred();
    //se esiste un oggetto globale initiConfig
    //risolvo con quell'oggetto
    if (window.initConfig) {
      this._initConfig = window.initConfig;
      return d.resolve(window.initConfig);
    }
    // altrimenti devo prenderlo dal server usando il percorso indicato in ?project=<percorso>
    else {
      var projectPath;
      var queryTuples;
      if (location.search) {
        queryTuples = location.search.substring(1).split('&');
        _.forEach(queryTuples, function (queryTuple) {
          //se esiste la parola project nel url
          if(queryTuple.indexOf("project") > -1) {
            //prendo il valore del path progetto (nomeprogetto/tipoprogetto/idprogetto)
            //esempio comune-di-capannori/qdjango/22/
            projectPath = queryTuple.split("=")[1];
          }
        });
      } else {
        // prevista per il reload in fase di admin
        projectPath = location.pathname.split('/').splice(-4,3).join('/');
      }
      if (projectPath) {
        var initUrl = this._initConfigUrl;
        if (projectPath) {
          initUrl = initUrl + '/' + projectPath;
        }
        //recupro dal server la configurazione di quel progetto
        $.get(initUrl)
          .then(function(initConfig) {
            //initConfig è l'oggetto contenete:
            //group, mediaurl, staticurl, user
            initConfig.staticurl = "../dist/"; // in locale forziamo il path degli asset
            initConfig.clienturl = "../dist/"; // in locale forziamo il path degli asset
            self._initConfig = initConfig;
            // setto la variabile initConfig
            window.initConfig = initConfig;
            d.resolve(initConfig);
          })
          .fail(function(error) {
            d.reject(error);
          })
      }
    }
    return d.promise();
  };

  this.getInitConfig = function() {
    return this._initConfig;
  };

  this.getInitConfigUrl = function() {
    return this._initConfigUrl;
  };

  this.setInitConfigUrl = function(initConfigUrl) {
    this._initConfigUrl = initConfigUrl;
  };

  // funzione post boostratp
  this.postBootstrap = function() {
    if (!this.complete) {
      RouterService.init();
      // una volta inizializzati i progetti e l'api service
      // registra i plugins passando gli static urls e l'oggetto plugins
      PluginsRegistry.init({
        pluginsBaseUrl: self._config.urls.staticurl,
        pluginsConfigs: self._config.plugins,
        otherPluginsConfig: ProjectsRegistry.getCurrentProject().getState()
      });
      this.complete = true;
    }
  };

  // funzione bootstrap (quando viene chiamato l'init)
  this._bootstrap = function() {
    var self = this;
    var d = $.Deferred();
    //nel caso in cui (prima volta) l'application service non è pronta
    //faccio una serie di cose
    if (!this.ready) {
      // Inizializza la configurazione dei servizi.
      // Ognungo cercherà dal config quello di cui avrà bisogno
      // una volta finita la configurazione emetto l'evento ready.
      // A questo punto potrò avviare l'istanza Vue globale
      $.when(
        // registra i progetti
        ProjectsRegistry.init(this._config),
        // inizializza api service
        ApiService.init(this._config)
      ).then(function() {
        // emetto l'evento ready
        self.emit('ready');
        if (!self._acquirePostBoostrap) {
          self.postBootstrap();
        }
        this.initialized = true;
        d.resolve();
      }).fail(function(error) {
        d.reject(error);
      })
    }
    return d.promise();
  };

  this.registerService = function(element, service) {
    this._applicationServices[element] = service;
  };

  this.unregisterService = function(element) {
    delete this._applicationServices[element];
  };

  this.getService = function(element) {
    return this._applicationServices[element];
  };

  this.errorHandler = function(error) {
    console.log(error);
  }

};

inherit(ApplicationService,G3WObject);


module.exports = new ApplicationService;

},{"core/apiservice":21,"core/clipboardservice":24,"core/g3wobject":27,"core/plugin/pluginsregistry":62,"core/project/projectsregistry":67,"core/router":69,"core/utils/utils":71}],23:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var LayersStoresRegistry = require('core/layers/layersstoresregistry');

function CatalogLayersStoresRegistry() {
  base(this);
}

inherit(CatalogLayersStoresRegistry, LayersStoresRegistry);

module.exports = new CatalogLayersStoresRegistry();
},{"core/layers/layersstoresregistry":40,"core/utils//utils":71,"core/utils/utils":71}],24:[function(require,module,exports){
function ClipboardService() {
  this._data = {};
  this.set = function(formId, data) {
    // clipBoardId : id del form, data sono fileds e relations passate al form
    // il clipBoardForm mi serve per capire se attivare o meno la clipboard
    // se e solo se si riferisce allo stesso id
    var formLayer = formId.split('form')[0];
    this._data[formLayer] = data;
  };

  this.get = function(formLayer) {
    var data = this._data[formLayer] || {};
    this._data[formLayer] = {};
    return data;
  };

}
module.exports = new ClipboardService;

},{}],25:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Editor(layer){
  base(this);

  this._layer = layer;
}
inherit(Editor, G3WObject);

var proto = Editor.prototype;

proto.getLayer = function() {
  return this._layer;
};

module.exports = Editor;
},{"core/g3wobject":27,"core/utils//utils":71,"core/utils/utils":71}],26:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var resolve = require('core/utils/utils').resolve;
var reject = require('core/utils/utils').reject;

function Session(){
  base(this);

  this._started = false;
  this._layers = [];
}
inherit(Session, G3WObject);

var proto = Session.prototype;

proto.start = function(){
  this._started = true;
};

proto.isStarted = function() {
  return this._started;
};

proto.addLayer = function(layer){
  this._layers.push(layer);
};

proto.commit = function() {
  console.log("Committing...");
  return resolve();
};

module.exports = Session;
},{"core/g3wobject":27,"core/utils//utils":71,"core/utils/utils":71}],27:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var noop = require('core/utils/utils').noop;

/**
 * Un oggetto base in grado di gestire eventuali setter e relativa catena di listeners.
 * @constructor
 */
var G3WObject = function() {
  //quando istanzio l'oggetto verifico che nella sua proprietà
  // ci sia l'attributo setters. Se si vado a registare la catena di eventi
  // per poter registare azioni prima e dopo la chiamata del metodo
  if (this.setters) {
    this._setupListenersChain(this.setters);
  }
};

inherit(G3WObject, EventEmitter);

var proto = G3WObject.prototype;

/**
 * Inserisce un listener dopo che è stato eseguito il setter
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener (solo sincrona)
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onafter = function(setter, listener, priority){
  return this._onsetter('after', setter, listener, false, priority);
};

// un listener può registrarsi in modo da essere eseguito PRIMA dell'esecuzione del metodo setter. Può ritornare true/false per
// votare a favore o meno dell'esecuzione del setter. Se non ritorna nulla o undefined, non viene considerato votante
/**
 * Inserisce un listener prima che venga eseguito il setter. Se ritorna false il setter non viene eseguito
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener, a cui viene passato una funzione "next" come ultimo parametro, da usare nel caso di listener asincroni
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onbefore = function(setter, listener, priority) {
  return this._onsetter('before', setter, listener, false, priority);
};

/**
 * Inserisce un listener prima che venga eseguito il setter. Al listener viene passato una funzione "next" come ultimo parametro, da chiamare con parametro true/false per far proseguire o meno il setter
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener, a cui
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onbeforeasync = function(setter, listener, priority) {
  return this._onsetter('before', setter, listener, true, priority);
};

proto.un = function(setter, key){
  _.forEach(this.settersListeners,function(settersListeners) {
    _.forEach(settersListeners[setter],function(setterListener, idx) {
      if(setterListener.key == key) {
        settersListeners[setter].slice(idx, 1);
      }
    })
  })
};

// funzione che si occupa di settare le funzioni legate al setter in base alla tipologia
// di evento se prima o dopo
/*
  when=before|after,
  type=sync|async
*/
proto._onsetter = function(when, setter, listener, async, priority) {
  // vado a recuperarer l'oggetto che ceh si riferifsce al when
  var settersListeners = this.settersListeners[when];
  // creo una listenerKey unica
  var listenerKey = ""+Math.floor(Math.random()*1000000)+""+Date.now();
  // verifico la priorità
  priority = priority || 0;
  // prendo tutto ciò che riguarda il setter (la funzione che dovrà essere chiamata)
  var settersListeneres = settersListeners[setter];
  // vado ad inserire l'oggetto che mi servirà a chiamare la funzione legata
  // al tipo di evento del setter
  settersListeneres.push({
    key: listenerKey,
    fnc: listener,
    async: async,
    priority: priority
  });
  // vado a riordinare l'array dei listeners del setter per quell'evento in base alla priorità
  settersListeners[setter] = _.sortBy(settersListeneres, function(setterListener) {
    return setterListener.priority;
  });
  // ritorno la chiave
  return listenerKey;
};

// trasformo un listener sincrono in modo da poter essere usato nella catena di listeners (richiamando next col valore di ritorno del listener)
/*proto._makeChainable = function(listener){
  var self = this
  return function(){
    var args = Array.prototype.slice.call(arguments);
    // rimuovo next dai parametri prima di chiamare il listener
    var next = args.pop();
    var canSet = listener.apply(self,arguments);
    var _canSet = true;
    if (_.isBoolean(canSet)){
      _canSet = canSet;
    }
    next(canSet);
  }
};*/

// funzione che viene lanciata se la sottoclasse ha come parametro setters
proto._setupListenersChain = function(setters) {
  // inizializza tutti i metodi definiti nell'oggetto "setters" della classe figlia.
  var self = this;
  this.settersListeners = {
    after: {},
    before: {}
  };
  // per ogni setter viene definito l'array dei listeners e fiene sostituito
  // il metodo originale con la funzioni che gestisce la coda di listeners
  // setterOption è la funzione
  // stters è la chiave/nome del metodo che viene assegnato all'istanza
  _.forEach(setters, function(setterOption, setter) {
    var setterFnc = noop;
    var setterFallback = noop;
    // verifico che il valore della chiave setter sia una funzione
    if (_.isFunction(setterOption)){
      setterFnc = setterOption
    } // altrimenti vado a vedere il valore dell'attributo fnc
    else {
      setterFnc = setterOption.fnc;
      setterFallback = setterOption.fallback || noop; // funzione in caso di errore nell'esecuzione della fnc
    }
    //vado a creare l'arry dei metodi/azioni/funzioni che devo essere eseguiti prima/dopo
    //la chiamata del metodo sette dell'oggetto
    self.settersListeners.after[setter] = [];
    self.settersListeners.before[setter] = [];
    // setter aggiunto come proprietà dell'istanza
    self[setter] = function() {
      // prendo gli argomenti passati alla funzione
      var args = arguments;
      var deferred = $.Deferred();
      var returnVal = null;
      var counter = 0;
      // funzione complete che serve per lanciare la funzione setter dell'istanza
      function complete() {
        // eseguo la funzione
        returnVal = setterFnc.apply(self,args);
        // e risolvo la promessa (eventualmente utilizzata da chi ha invocato il setter)
        deferred.resolve(returnVal);
        //vado a eseguire tutti i listener che sono stati settati dopo l'esecuzione del setter
        var afterListeners = self.settersListeners.after[setter];
        _.forEach(afterListeners, function(listener) {
          listener.fnc.apply(self, args);
        })
      }

      // funzione abort che mi server ad uscire dal ciclo dei listener
      // nel caso si verificasse un problema
      function abort() {
        // se non posso proseguire ...
        // chiamo l'eventuale funzione di fallback
        setterFallback.apply(self,args);
        // e rigetto la promessa
        deferred.reject();
      }

      // vado a prendere l'array delle funzioni che devo lanciare prima di lanciare il setter
      var beforeListeners = self.settersListeners['before'][setter];
      // contatore dei listener che verrà decrementato ad ogni chiamata a next()
      counter = 0;
      // funzione passata come ultimo parametro ai listeners,
      // che ***SE SONO STATI AGGIUNTI COME ASINCRONI la DEVONO*** richiamare per poter proseguire la catena
      function next(bool) {
        // inizializzo la variabile cont a true (continue) non possibile usare
        // continue perchè parola riservata di javascript
        var cont = true;
        // verifica se è stato passato un parametro boolenao alla funzione
        // e la setto alla variabile cont (continue)
        if (_.isBoolean(bool)) {
          cont = bool;
        }
        // ricavo l'array di argomenti passati alla funzione setter
        var _args = Array.prototype.slice.call(args);
        // se la catena è stata bloccata (cont==false)
        // o se siamo arrivati alla fine dei beforelisteners
        // o non non sono stati settati nessun beforelisteners
        if (cont === false || (counter == beforeListeners.length)) {
          if (cont === false) {
            // significa che si è verificato un errore oppure si è forzato a concludere
            abort.apply(self, args);
          } else {
            //vado a chiamare la funzione setter
            completed = complete.apply(self, args);
            //verifico che cosa ritorna
            if (_.isUndefined(completed) || completed === true) {
              self.emitEvent('set:'+setter,args);
            }
          }
        } else {
          // se cont è true (continua)
          if (cont) {
            // vado a prendere la funzione dall'array dei before listener
            var listenerFnc = beforeListeners[counter].fnc;
            // verifico se questa è asyncrona
            if (beforeListeners[counter].async) {
              // aggiungo next come ulyimo nel caso di onbeforeasync
              _args.push(next);
              // vado ad aggiornare il counter dei listener onbefore
              counter += 1;
              // chiamo la funzione passandogli l'argomento (modificato con next)
              // su se stesso
              listenerFnc.apply(self, _args)
            } // nel caso di onbefore(quindi non asincrona)
            else {
              // chiamo la funzione listener che mi deve ritornare un boolenano o undefined
              var _cont = listenerFnc.apply(self,_args);
              //vado ad aggiornare il counter
              counter += 1;
              next(_cont);
            }
          }
        }
      }
      // quando viene chiamato la funzione
      // viene lanciato la funzione next
      next();
      return deferred.promise();
    }
  })
};

// funzione che unregistra la chiave del listener
proto.un = function(listenerKey) {
  _.forEach(this.settersListeners, function(setterListeners) {
      _.forEach(setterListeners,function(listener,idx){
        if (listener.key == listenerKey) {
          setterListeners.splice(idx,1);
        }
      })
  })
};

module.exports = G3WObject;

},{"core/utils/utils":71}],28:[function(require,module,exports){
var geom = {
  distance: function(c1,c2){
    return Math.sqrt(geom.squaredDistance(c1,c2));
  },
  squaredDistance: function(c1,c2){
    var x1 = c1[0];
    var y1 = c1[1];
    var x2 = c2[0];
    var y2 = c2[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    return dx * dx + dy * dy;
  },
  closestOnSegment: function(coordinate, segment) {
    var x0 = coordinate[0];
    var y0 = coordinate[1];
    var start = segment[0];
    var end = segment[1];
    var x1 = start[0];
    var y1 = start[1];
    var x2 = end[0];
    var y2 = end[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = (dx === 0 && dy === 0) ? 0 :
        ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);
    var x, y;
    if (along <= 0) {
      x = x1;
      y = y1;
    } else if (along >= 1) {
      x = x2;
      y = y2;
    } else {
      x = x1 + along * dx;
      y = y1 + along * dy;
    }
    return [x, y];
  }
}

module.exports = geom;

},{}],29:[function(require,module,exports){
var Geometry = {};

Geometry.GeometryTypes = {
  POINT: "Point",
  MULTIPOINT: "MultiPoint",
  LINESTRING: "Line", // per seguire la definizione di QGis.GeometryType, che definisce Line invece di Linestring.
  MULTILINESTRING: "MultiLine",
  POLYGON: "Polygon",
  MULTIPOLYGON: "MultiPolygon",
  GEOMETRYCOLLECTION: "GeometryCollection"
};

Geometry.SupportedGeometryTypes = [
  Geometry.GeometryTypes.POINT,
  Geometry.GeometryTypes.MULTIPOINT,
  Geometry.GeometryTypes.LINESTRING,
  Geometry.GeometryTypes.MULTILINESTRING,
  Geometry.GeometryTypes.POLYGON,
  Geometry.GeometryTypes.MULTIPOLYGON
]

module.exports = Geometry;

},{}],30:[function(require,module,exports){
function init(config) {
  i18next
  .use(i18nextXHRBackend)
  .init({ 
      lng: 'it',
      ns: 'app',
      fallbackLng: 'it',
      resources: config.resources
  });
  
  jqueryI18next.init(i18next, $, {
    tName: 't', // --> appends $.t = i18next.t
    i18nName: 'i18n', // --> appends $.i18n = i18next
    handleName: 'localize', // --> appends $(selector).localize(opts);
    selectorAttr: 'data-i18n', // selector for translating elements
    targetAttr: 'data-i18n-target', // element attribute to grab target element to translate (if diffrent then itself)
    optionsAttr: 'data-i18n-options', // element attribute that contains options, will load/set if useOptionsAttr = true
    useOptionsAttr: false, // see optionsAttr
    parseDefaultValueFromContent: true // parses default values from content ele.val or ele.text
  });
}
    
var t = function(text){
    var trad = i18next.t(text);
    return trad;
};
    
module.exports = {
  init: init,
  t: t
};

},{}],31:[function(require,module,exports){
// Classe Feature che eridita da ol.Feature sfruttando tutti i metodi
// necessari anche alla costruzione di un layer vettoriale
// Allo stesso modo può essere un oggetto non vettoriale non settando la geometria
// ma solo le proprièta
var Feature = function(options) {

  ol.Feature.call(this);
  options = options || {};
  var feature = options.feature;
  //verificare come utilizzare clone
  if (feature) {
    this.setId(feature.getId());
    this.setProperties(feature.getProperties());
    this.setGeometryName(feature.getGeometryName());
    var geometry = feature.getGeometry();
    if (geometry) {
      this.setGeometry(geometry);
    }
    var style = this.getStyle();
    if (style) {
      this.setStyle(style);
    }
  }
  // necessario per poter interagire reattivamente con l'esterno
  this.state = {};
};

ol.inherits(Feature, ol.Feature);

proto = Feature.prototype;

proto.setState = function(state) {
  this.state = state;
};

proto.getState = function() {
  return this.state;
};


module.exports = Feature;
},{}],32:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interfaccia per registare i layers
function FeaturesStore(options) {
  var self = this;
  options = options || {};
  this._features = [];
  this._provider = options.provider || null;
  this.setters = {
    addFeatures: function(features) {
      _.forEach(features, function(feature) {
        self._addFeature(feature);
      })
    },
    addFeature: function(feature) {
      self._addFeature(feature);
    },
    removeFeature: function(feature) {
      self._removeFeature(feature);
    },
    clearFeatures: function() {
      self._clearFeatures()
    }
  };

  base(this);
}

inherit(FeaturesStore, G3WObject);

proto = FeaturesStore.prototype;

proto.getFeatures = function(options) {
  var self = this;
  var d = $.Deferred();
  this._provider.getFeatures(options)
    .then(function(features) {
      console.log(features);
      // il provider ritornerà 
      self.addFeatures(features);
      d.resolve(self._features);
    });
  return d.promise();
};

proto._addFeature = function(feature) {
  this._features.push(feature);
};

proto._removeFeature = function(feature) {
  this._features.push(feature);
};

proto._clearFeatures = function() {
  // vado a rimuovere le feature in modo reattivo (per vue) utlizzando metodi che vue
  // possa reagire allacancellazione di elementi di un array
  this._features.splice(0, this._features.length);
};

proto.getDataProvider = function() {
  return this._dataprovider;
};

module.exports = FeaturesStore;
},{"core/g3wobject":27,"core/utils//utils":71,"core/utils/utils":71}],33:[function(require,module,exports){
var Filters = {
  eq: '=',
  gt: '>',
  gte: '>=',
  lt: '<',
  lte: '=<',
  LIKE: 'LIKE',
  ILIKE: 'ILIKE',
  AND: 'AND',
  OR: 'OR',
  NOT: '!='
};

function Expression(options) {
  options = options || {};
}

var proto = Expression.prototype;

proto._createFilter = function(filterObject, layername) {
  /////inserisco il nome del layer (typename) ///
  var filter = [];
  function createSingleFilter(booleanObject) {
    var filterElements = [];
    var filterElement = '';
    var valueExtra = "";
    var valueQuotes = "'";
    var rootFilter;
    _.forEach(booleanObject, function(v, k, obj) {
      //creo il filtro root che sarà AND OR
      rootFilter = Filters[k];
      //qui c'è array degli elementi di un booleano
      _.forEach(v, function(input){
        //scorro su oggetto
        valueExtra = "";
        _.forEach(input, function(v, k, obj) {
          //verifico se il valore dell'oggetto è array e quindi è altro oggetto padre booleano
          if (_.isArray(v)) {
            filterElement = createSingleFilter(obj);
          } else { // è un oggetto operatore
            if (k == 'LIKE' || k == 'ILIKE') {
              valueExtra = "%";
            }
            filterOp = Filters[k];
            var value;
            _.forEach(input, function(v, k, obj) {
              _.forEach(v, function(v, k, obj) {
                //verifico se il valore non è un numero e quindi aggiungo singolo apice
                if (!(_.isNull(v) || (_.isNaN(v) || _.trim(v) == ''))) {
                  filterElement = "\"" + k + "\" "+ filterOp +" " + valueQuotes + valueExtra + v + valueExtra + valueQuotes;
                  filterElements.push(filterElement);
                }
              });
            });
          }
        });
      });
      rootFilter = (filterElements.length > 0) ? filterElements.join(" "+ rootFilter + " ") : false;
    });
    return rootFilter;
  }
  //assegno il filtro creato
  if (createSingleFilter(filterObject)) {
    return  layername + ":" + createSingleFilter(filterObject);
  } else {
    return false
  }
};


module.exports = Expression;
},{}],34:[function(require,module,exports){
var Expression = require('./expression');

// classe Filtro per poter creare filtri
// chiesti principalmente dai providers per poter
// effettuare richieste di dati
function Filter() {
  this._bbox = null;
  this._geometry = null;
  this._fids = null;
  this._expression = null;
}

var proto = Filter.prototype;

// server per creare un filtro complesso
proto.setExpression = function(expression) {
  this._expression = expression;
};

proto.getExpression = function() {
  return this._expression;
};

proto.setGeometry = function(geometry) {
  this._geometry = geometry;
  return this;
};

proto.getGeometry = function() {
  return this._geometry;
};

proto.setBBOX = function(bbox) {
  this._bbox = [bbox];
  return this;
};

proto.getBBOX = function() {
  return this._bbox;
};

proto.setFids = function(ids) {
  this._fids = ids;
  return this;
};

proto.getFids = function() {
  return this._fids;
};

proto.serialize = function() {
  return JSON.stringify(this);
};




module.exports = Filter;

},{"./expression":33}],35:[function(require,module,exports){
var Layer = require('core/layers/layer');
var Projections = require('g3w-ol3/src/projection/projections');


function GeoLayerMixin(config) {
}

var proto = GeoLayerMixin.prototype;

proto.setup = function(config){
  if (!this.config) {
    console.log("GeoLayerMixin must be used from a valid (geo) Layer instance");
    return;
  }

  this.config.multilayerid = config.multilayer;

  _.extend(this.state, {
    geolayer: true,
    bbox: config.bbox || null
  });

  if (config.projection) {
    this.config.projection = config.projection;
  }
  else if (config.crs) {
    if (config.project) {
      if (config.project.getProjection().getCode() != config.crs) {
        Projections.get(config.crs,config.proj4);
      }
      else {
        this.config.projection = config.project.getProjection();
      }
    }
  }
};

proto.getConfig = function() {
  return this.config;
};

proto.getState = function() {
  return this.state;
};

proto.getMultiLayerId = function() {
  return this.config.multilayerid;
};

proto.getGeometryType = function() {
  return this.config.geometrytype;
};

proto.getMultiLayerId = function() {
  return this.config.multilayerid;
};

proto.setProjection = function(crs,proj4) {
  this.config.projection = Projections.get(crs,proj4);
};

proto.getProjection = function() {
  return this.config.projection;
};

proto.getCrs = function() {
  if (this.config.projection) {
    return this.config.projection.getCode();
  }
};

proto.isCached = function() {
  return this.config.cache_url && this.config.cache_url != '';
};

proto.getCacheUrl = function(){
  if (this.isCached()) {
    return this.config.cache_url;
  }
};

module.exports = GeoLayerMixin;

},{"core/layers/layer":37,"g3w-ol3/src/projection/projections":100}],36:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var mixin = require('core/utils/utils').mixin;
var Layer = require('core/layers/layer');
var VectorLayer = require('./vectorlayer');
var GeoLayerMixin = require('./geolayermixin');

function ImageLayer(config) {
  config = config || {};
  /*{
    id,
    title,
    name,
    origname,
    multilayerid,
    servertype,
    source,
    crs,
    projection,
    bbox,
    capabilities,
    cache_url,
    baselayer,
    geometrytype,
    editops,
    expanded,
    fields,
    wmsUrl,
    infoformat,
    infourl,
    maxscale,
    minscale,
    visible,
    scalebasedvisibility,
    wfscapabilities
  }*/
  base(this, config);

  this.config.baselayer = config.baselayer || false;

  this.type = Layer.LayerTypes.IMAGE;

  // vado a modificare lo state aggiungendo il bbox e l'informazione geolayer
  this.setup(config);
}

inherit(ImageLayer, Layer);
mixin(ImageLayer, GeoLayerMixin);

var proto = ImageLayer.prototype;


proto.getEditingLayer = function() {
  if (this.isEditable()) {
    var config = _.cloneDeep(this.config);
    return new VectorLayer(config);
  }
};

proto.isBaseLayer = function() {
  return this.config.baselayer;
};

proto.isWMS = function() {
  return ImageLayer.WMSServerTypes.indexOf(this.config.servertype) > -1;
};

proto.isExternalWMS = function() {
  return (this.config.source && this.config.source.url);
};

proto.getWMSLayerName = function() {
  // prendo come inizio 'attributo name come nome del layer wms
  var layerName = this.config.name;
  if (this.config.source && this.config.source.layers) {
    layerName = this.config.source.layers;
  }
  return layerName;
};

proto.getWmsUrl = function() {
  var url;
  if (this.config.source && this.config.source.type == 'wms' && this.config.source.url){
    url = this.config.source.url
  }
  else {
    url = this.config.wmsUrl;
  }
  return url;
};

proto.getQueryUrl = function() {
  var url = base(this,'getQueryUrl');
  if (this.getServerType() == 'QGIS' && this.config.source && this.config.source.type == 'wms' && this.config.source.external) {
    url+='SOURCE=wms';
  }
  return url;
};

proto.getLegendUrl = function() {
  var url = this.getWmsUrl();
  sep = (url.indexOf('?') > -1) ? '&' : '?';
  return url+sep+'SERVICE=WMS&VERSION=1.3.0&REQUEST=GetLegendGraphic&SLD_VERSION=1.1.0&FORMAT=image/png&TRANSPARENT=true&ITEMFONTCOLOR=white&LAYERTITLE=True&ITEMFONTSIZE=10&WIDTH=300&LAYER='+this.getWMSLayerName();
};

proto.getWFSLayerName = function() {
  // prendo come inizio 'attributo name come nome del layer wms
  var layerName = this.config.origname;
  if (this.config.source && this.config.source.layers) {
    layerName = this.config.source.layers;
  }
  return layerName;
};

proto.getWfsCapabilities = function() {
  return this.config.wfscapabilities || this.config.capabilities == 1 ;
};

ImageLayer.WMSServerTypes = [
  Layer.ServerTypes.QGIS,
  Layer.ServerTypes.Mapserver,
  Layer.ServerTypes.Geoserver,
  Layer.ServerTypes.OGC
];


module.exports = ImageLayer;

},{"./geolayermixin":35,"./vectorlayer":50,"core/layers/layer":37,"core/utils//utils":71,"core/utils/utils":71}],37:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var ProviderFactory = require('core/layers/providers/providersfactory');

function Layer(config) {
  var self = this;
  config = config || {};
  // contiene la configurazione statica del layer
  this.config = _.extend({
    id: config.id || 'Layer' ,
    title: config.title  || null,
    name: config.name || null,
    origname: config.origname || null,
    capabilities: config.capabilities || null,
    editops: config.editops || null,
    infoformat: config.infoformat || null,
    infourl: config.infourl || null,
    servertype: config.servertype || null,
    source: config.source || null,
    geolayer: false
  },config);

  // contiene la parte dinamica del layer
  //this.state = config; // questo fa in modo che il catalog reagisca al mutamento
  // delle proprietà dinamiche (select, disable, visible)
  this.state = {
    id: config.id,
    title: config.name,
    visible: config.visible,
    selected: config.selected | false,
    disabled: config.disabled | false,
    editing: false,
    modified: false,
    hidden: config.hidden || false
  };

  this.type = null;

  this.fields = config.fields;
  // relations
  this.relations = config.relations || null; // da vedere com gestirle
  // setters
  this.setters = {
    //funzione che segnala lo start editing
    startEditing: function() {
      self._startEditing();
    },
    // segnalazione stop editing
    stopEditing: function() {
      self._stopEditing();
    },
    // cancellazione di tutte le features del layer
    clearFeatures: function() {
      self._clearFeatures();
    }
  };

  var serverType = this.config.servertype;
  var sourceType = this.config.source.type;

  this.providers = {
    query: ProviderFactory.build('query',serverType,sourceType,{
      layer: this
    }),
    filter: ProviderFactory.build('filter',serverType,sourceType,{
      layer: this
    }),
    data: ProviderFactory.build('data',serverType,sourceType,{
      layer: this
    })
  };

  base(this);
}

inherit(Layer, G3WObject);

var proto = Layer.prototype;

proto.getProject = function() {
  return this.config.project;
};

proto.getConfig = function() {
  return this.config;
};

proto.getState = function() {
  return this.state;
};

proto.getEditingLayer = function() {
  return self;
};

proto.isHidden = function() {
  return this.state.hidden;
};

proto.setHidden = function(bool) {
  this.state.hidden = _.isBoolean(bool) ? bool: true;
};

proto.isModified = function() {
  //medodo che stbilisce se modificato o no
  return this.state.modified;
};

proto.getId = function() {
  return this.config.id;
};

proto.getTitle = function() {
  return this.config.title;
};

proto.getName = function() {
  return this.config.name;
};

proto.getOrigName = function() {
  return this.config.origname;
};

proto.getServerType = function() {
  if (this.config.servertype && this.config.servertype != '') {
    return this.config.servertype;
  }
  else {
    return ServerTypes.QGIS;
  }
};

proto.getType = function() {
  return this.type;
};

proto.isSelected = function() {
  return this.state.selected;
};

proto.isDisabled = function() {
  return this.state.disabled;
};

proto.isVisible = function() {
  return this.state.visible;
};

proto.isQueryable = function() {
  var queryEnabled = false;
  var queryableForCababilities = this.config.capabilities && (this.config.capabilities & Layer.CAPABILITIES.QUERYABLE);
  if (queryableForCababilities) {
    // è interrogabile se visibile e non disabilitato (per scala) oppure se interrogabile comunque (forzato dalla proprietà infowhennotvisible)
    queryEnabled = (this.state.visible && !this.state.disabled);
    if (!_.isUndefined(this.config.infowhennotvisible) && (this.config.infowhennotvisible === true)) {
      queryEnabled = true;
    }
  }
  return queryEnabled;
};

proto.isFilterable = function() {
  // useremo Layer.CAPABILITIES.FILTERABLE
  // return this.config.capabilities && (this.config.capabilities & Layer.CAPABILITIES.FILTERABLE);

  // per ora facciamo così
  return this.providers.filter != undefined;
};

proto.isEditable = function() {
  // useremo Layer.CAPABILITIES.EDITABLE appena il server l'avrà implementato
  //return this.config.capabilities && (this.config.capabilities & Layer.CAPABILITIES.EDITABLE);

  // per ora facciamo così
  return this.config.servertype == 'QGIS' && [Layer.SourceTypes.POSTGIS,Layer.SourceTypes.SPATIALITE].indexOf(this.config.source.type) > -1;
};

proto.query = function(options) {
  options = options || {};
  var self = this;
  var d = $.Deferred();
  var type = options.type;
  var provider = this.providers.query;
  if (options.filter) {
    provider = this.providers.filter;
  }
  if (provider) {
    provider.query(options)
      .done(function(features) {
        d.resolve(features);
      })
      .fail(function(err) {
        d.reject(err);
      });
  }
  else {
    d.reject('Il layer non è interrogabile tramite filtri');
  }
  return d.promise();
};

proto.getQueryUrl = function() {
  var infoUrl;
  if (this.config.infourl && this.config.infourl != '') {
    infoUrl = this.config.infourl;
  }
  else {
    infoUrl = this.config.wmsUrl;
  }
  return infoUrl;
};

proto.setQueryUrl = function(queryUrl) {
  this.config.inforurl = queryUrl;
};

proto.getQueryLayerName = function() {
  var queryLayerName;
  if (this.config.infolayer && this.config.infolayer != '') {
    queryLayerName = this.config.infolayer;
  }
  else {
    queryLayerName = this.config.name;
  }
  return queryLayerName;
};

proto.getQueryLayerOrigName = function() {
  var queryLayerName;
  if (this.state.infolayer && this.config.infolayer != '') {
    queryLayerName = this.config.infolayer;
  }
  else {
    queryLayerName = this.config.origname;
  }
  return queryLayerName;
};

proto.getInfoFormat = function(ogcService) {
  if (this.config.infoformat && this.config.infoformat != '' && ogcService !='wfs') {
    return this.config.infoformat;
  }
  else {
    return 'application/vnd.ogc.gml';
  }
};

proto.setInfoFormat = function(infoFormat) {
  this.state.infoformat = infoFormat;
};

proto.getAttributes = function() {
  return this.fields;
};

proto.changeAttribute = function(attribute, type, options) {
  _.forEach(this.fields, function(field) {
    if (field.name == attribute) {
      field.type = type;
      field.options = options;
    }
  })
};

proto.getAttributeLabel = function(name) {
  var label;
  _.forEach(this.getAttributes(),function(field){
    if (field.name == name){
      label = field.label;
    }
  });
  return label;
};

// restituisce tutte le relazioni legati a quel layer
proto.getRelations = function() {
  return this.state.relations
};

//restituisce gli attributi fields di una deterninata relazione
proto.getRelationAttributes = function(relationName) {
  var fields = [];
  _.forEach(this.state.relations, function(relation) {
    if (relation.name == relationName) {
      fields = relation.fields;
      return false
    }
  });
  return fields;
};

// retituisce un oggetto contenente nome relazione e fileds(attributi) associati
proto.getRelationsAttributes = function() {
  var fields = {};
  _.forEach(this.state.relations, function(relation) {
    fields[relation.name] = relation.fields;
  });
  return fields;
};

proto.getProvider = function(type) {
  return this.providers[type];
};

Layer.LayerTypes = {
  TABLE: "table",
  IMAGE: "image",
  VECTOR: "vector"
};

Layer.ServerTypes = {
  OGC: "OGC",
  QGIS: "QGIS",
  Mapserver: "Mapserver",
  Geoserver: "Geoserver",
  ArcGIS: "ArcGIS",
  OSM: "OSM",
  Bing: "Bing",
  Local: "Local"
};

Layer.SourceTypes = {
  POSTGIS: 'postgres',
  SPATIALITE: 'spatialite',
  CSV: 'delimitedtext',
  WMS: 'wms'
};

Layer.CAPABILITIES = {
  QUERYABLE: 1,
  FILTERABLE: 3,
  EDITABLE: 5
};

Layer.EDITOPS = {
  INSERT: 1,
  UPDATE: 2,
  DELETE: 4
};


module.exports = Layer;

},{"core/g3wobject":27,"core/layers/providers/providersfactory":44,"core/utils//utils":71,"core/utils/utils":71}],38:[function(require,module,exports){
var Layer = require('./layer');
var TableLayer = require('./tablelayer');
var VectorLayer = require('./vectorlayer');
var ImageLayer = require('./imagelayer');


function LayerFactory() {
  this.build = function(config) {
    // ritorna l'sitanza del provider selezionato
    var layerClass = this.get(config);
    if (layerClass) {
      return new layerClass(config);
    }
    return null;
  };

  this.get = function(config) {
    var LayerClass;
    var serverType = config.servertype;
    if (serverType == 'QGIS') {
      LayerClass = ImageLayer;
      if (config.source && config.geometrytype) {
        if ([Layer.SourceTypes.POSTGIS,Layer.SourceTypes.SPATIALITE,Layer.SourceTypes.CSV].indexOf(config.source.type) > -1) {
          if (config.geometrytype && config.geometrytype == undefined) {
            LayerClass = TableLayer;
          }
        }
      }
    }
    else if (serverType == 'OGC') {
      if (config.source) {
        var type = config.source.type;
        switch (type) {
          case 'WMS':
            LayerClass = ImageLayer;
            break;
          case 'WFS':
            LayerClass = VectorLayer;
        }
      }
    }
    else if (serverType == 'Local') {
      LayerClass = VectorLayer;
    }

    return LayerClass;
  };
}

module.exports = new LayerFactory();
},{"./imagelayer":36,"./layer":37,"./tablelayer":49,"./vectorlayer":50}],39:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interfaccia per registare i layers
function LayersStore(config) {
  var self = this;
  config = config || {};
  this.config = {
    id: config.id || Date.now(),
    projection: config.projection,
    extent: config.extent,
    initextent: config.initextent,
    wmsUrl: config.wmsUrl,
    //metto caratteristica catalogabile
    catalog: _.isBoolean(config.catalog) ? config.catalog : true
  };

  this.state = {
    layerstree: []
  };

  this._layers = this.config.layers || {};

  this.setters = {
    setLayersVisible: function (layersIds, visible) {
      var self = this;
      _.forEach(layersIds, function (layerId) {
        self.getLayerById(layerId).state.visible = visible;
      })
    },
    setLayerSelected: function(layerId, selected) {
      var layers = this.getLayers();
      _.forEach(layers, function(layer) {
        layer.state.selected = ((layerId == layer.getId()) && selected) || false;
      })
    },
    addLayer: function(layer) {
      this._addLayer(layer);
    },
    removeLayer: function(layerId) {
      this._removeLayer(layerId);
    }
  };

  base(this);
}

inherit(LayersStore, G3WObject);

proto = LayersStore.prototype;

proto.showOnCatalog = function() {
  return this.config.catalog;
};

proto.setOptions = function(config) {
  this.config = config;
};

proto.getId = function() {
  return this.config.id;
};

proto._addLayer = function(layer) {
  this._layers[layer.getId()] = layer;
};

proto.addLayers = function(layers) {
  var self = this;
  _.forEach(layers, function(layer) {
    self.addLayer(layer);
  });
};

proto._removeLayer = function(layerId) {
  delete this._layers[layerId];
};

proto.removeLayers = function(layersId) {
  _.forEach(layersId, function(layerId) {
    self.removeLayer(layer)
  })
};

proto.getLayersDict = function(options) {
  if (!options) {
    return this._layers;
  }
  var options = options || {};
  var filterActive = options.ACTIVE;
  var filterQueryable = options.QUERYABLE;
  var filterFilterable = options.FILTERABLE;
  var filterEditable = options.EDITABLE;
  var filterVisible = options.VISIBLE;
  var filterSelected = options.SELECTED;
  var filterCached = options.CACHED;
  var filterSelectedOrAll = options.SELECTEDORALL;
  var filterAllNotSelected = options.ALLNOTSELECTED;
  var filterServerType = options.SERVERTYPE;
  var filterBaseLayer = options.BASELAYER || false;
  var filterGeoLayer = options.GEOLAYER;
  var filterHidden = options.HIDDEN;
  var filterWfs = options.WFS;
  if (filterSelectedOrAll) {
    filterSelected = null;
  }
  if (_.isUndefined(filterQueryable)
    && _.isUndefined(filterFilterable)
    && _.isUndefined(filterEditable)
    && _.isUndefined(filterVisible)
    && _.isUndefined(filterActive)
    && _.isUndefined(filterSelected)
    && _.isUndefined(filterCached)
    && _.isUndefined(filterSelectedOrAll)
    && _.isUndefined(filterServerType)
    && _.isUndefined(filterGeoLayer)
    && _.isUndefined(filterHidden)
    && _.isUndefined(filterBaseLayer)) {
    return this._layers;
  }
  var layers = [];
  _.forEach(this._layers, function(layer, key) {
    layers.push(layer);
  });


  if (typeof filterActive == 'boolean') {
    layers = _.filter(layers, function(layer) {
      return filterActive == !layer.isDisabled();
    });
  }

  if (typeof filterQueryable == 'boolean') {
    layers = _.filter(layers, function(layer) {
      return filterQueryable == layer.isQueryable();
    });
  }

  if (typeof filterFilterable == 'boolean') {
    layers = _.filter(layers,function(layer) {
      return filterFilterable == layer.isFilterable();
    });
  }

  if (typeof filterEditable == 'boolean') {
    layers = _.filter(layers,function(layer) {
      return filterEditable == layer.isEditable();
    });
  }

  if (typeof filterVisible == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterVisible == layer.isVisible();
    });
  }

  if (typeof filterCached == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterCached == layer.isCached();
    });
  }

  if (typeof filterSelected == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterSelected == layer.isSelected();
    });
  }

  if (typeof filterBaseLayer == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterBaseLayer == layer.isBaseLayer();
    });
  }

  if (typeof filterGeoLayer == 'boolean') {
    layers = _.filter(layers,function(layer) {
      return filterGeoLayer == layer.state.geolayer;
    });
  }

  if (typeof filterHidden == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterHidden == layer.isHidden();
    });
  }

  if (typeof filterServerType == 'string' && filterServerType!='') {
    layers = _.filter(layers,function(layer){
      return filterServerType = layer.getServerType();
    });
  }
  // filtra solo i selezionati
  if (filterSelectedOrAll) {
    var _layers = layers;
    layers = _.filter(layers,function(layer){
      return layer.isSelected();
    });
    layers = layers.length ? layers : _layers;
  }

  // filtra solo i quelli non selezionati
  if (filterAllNotSelected) {
    var _layers = layers;
    layers = _.filter(layers,function(layer){
      return !layer.isSelected();
    });
    layers = layers.length ? layers : _layers;
  }

  return layers;
};

// ritorna l'array dei layers (con opzioni di ricerca)
proto.getLayers = function(options) {
  var layers = this.getLayersDict(options);
  return _.values(layers);
};

proto.getBaseLayers = function() {
  return this.getLayersDict({
    BASELAYER: true
  });
};

proto.getLayerById = function(layerId) {
  return this.getLayersDict()[layerId];
};

proto.getLayerByName = function(name) {
  var layer = null;
  _.forEach(this.getLayersDict(),function(layer){
    if (layer.getName() == name){
      layer = _layer;
    }
  });
  return layer;
};

proto.getLayerAttributes = function(layerId){
  return this.getLayerById(layerId).getAttributes();
};

proto.getLayerAttributeLabel = function(layerId,name){
  return this.getLayerById(layerId).getAttributeLabel(name);
};

proto.getGeoLayers = function() {
  return this.getLayers({
    GEOLAYER: true
  })
};

proto.toggleLayer = function(layerId,visible){
  var layer = this.getLayerById(layerId);
  var visible = visible || !layer.state.visible;
  this.setLayersVisible([layerId],visible);
};

proto.toggleLayers = function(layersIds,visible){
  this.setLayersVisible(layersIds,visible);
};

proto.selectLayer = function(layerId){
  this.setLayerSelected(layerId, true);
};

proto.unselectLayer = function(layerId) {
  this.setLayerSelected(layerId, false);
};

proto.getProjection = function() {
  return this.config.projection;
};

proto.getExtent = function() {
  return this.config.extent;
};

proto.getInitExtent = function() {
  return this.config.initextent;
};

proto.getWmsUrl = function() {
  return this.config.wmsUrl;
};

// funzione che setta il layersstree deli layers del layersstore
proto.setLayersTree = function(layerstree,name) {
  var self = this;
  function traverse(obj) {
    _.forIn(obj, function (layer, key) {
      //verifica che il nodo sia un layer e non un folder
      if (!_.isNil(layer.id)) {
        obj[key] = self.getLayerById(layer.id).getState();
      }
      if (!_.isNil(layer.nodes)){
        traverse(layer.nodes);
      }
    });
  }
  traverse(layerstree);

  // questo server per raggruppare ogni albero dei layer
  // al proprio gruppo che sia un progetto, un plugin o altro
  // quando viene creato il layersstore
  this.state.layerstree.splice(0,0,{
    title: name || this.config.id,
    expanded: true,
    nodes: layerstree
  });
};

// funzione che posso sfruttare dai plugin per costruire un
// layerstree senza tanto stare acreare  e ricordarmi come creare un layerstrree
// naturalmente è ad una dimanesione altrimenti c'è da studiare
// come creare un layers tree cosa innestata forse paasando un layertree nella configurazione
proto.createLayersTree = function(groupName, options) {
  var options = options || {};
  var full = options.full || false;
  var _layerstree = options.layerstree || null;
  var layerstree = [];
  if (_layerstree) {
    if (full === true) {
      return this.state.layerstree;
    }
    else {
      function traverse(obj,newobj) {
        _.forIn(obj, function (layer) {
          var lightlayer = {};
          if (!_.isNil(layer.id)) {
            lightlayer.id = layer.id;
          }
          if (!_.isNil(layer.nodes)){
            lightlayer.title = layer.name;
            lightlayer.expanded = layer.expanded;
            lightlayer.nodes = [];
            traverse(layer.nodes,lightlayer.nodes)
          }
          newobj.push(lightlayer);
        });
      }
      traverse(_layerstree,layerstree);
    }
  } else {
    _.forEach(this.getGeoLayers(), function (layer) {
      layerstree.push({
        id: layer.getId(),
        name: layer.getName(),
        title: layer.getTitle(),
        visible: layer.isVisible() || false
      })
    });
  }  
  this.setLayersTree(layerstree, groupName);
};

proto.removeLayersTree = function(id) {
  this.state.layerstree.splice(0,this.state.layerstree.length);
};

proto.getLayersTree = function(id) {
  return this.state.layerstree;
};

module.exports = LayersStore;

},{"core/g3wobject":27,"core/utils//utils":71,"core/utils/utils":71}],40:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interfaccia per registare i layers
function LayersStoresRegistry() {
  var self = this;
  this.stores = {};
  this.storesArray = [];
  // questi setters mi servono per far reagire  le varie parti dell'applicazione
  // che dipendono o sono legate ai layersStores
  this.setters = {
    addLayersStore: function(layersStore, idx) {
      this._addLayersStore(layersStore, idx);
    },
    removeLayersStore: function(layerStore) {
      this._removeLayersStore(layerStore);
    }
  };

  base(this);
}

inherit(LayersStoresRegistry, G3WObject);

proto = LayersStoresRegistry.prototype;

proto.getLayers = function(filter) {
  var layers = [];
  _.forEach(this.stores, function(layerStore) {
    layers.concat(layerStore.getLayers(filter))
  });
  return layers;
};

proto.getLayersStore = function(id) {
  return this.stores[id];
};

proto.getLayersStores = function() {
  var self = this;
  var stores = [];

  _.forEach(this.storesArray,function(storeId){
    stores.push(self.stores[storeId]);
  });

  return stores;
};

// funzione che aggiunge un layersstore al registro della
proto._addLayersStore = function(layerStore, idx) {
  // usiamo un array per garantire ordine di inserimento, poi potremo gestire richieste di inserimento in una specifica posizione
  var storeId = layerStore.getId();
  this.stores[storeId] = layerStore;
  if (!_.isNil(idx)) {
    this.storesArray.splice(idx,0, storeId);
  } else {
    this.storesArray.push(storeId);
  }
};

proto._removeLayersStore = function(layerStore) {

  if (layerStore) {
    var storeId = layerStore.getId();
    var idx = this.storesArray.indexOf(storeId);
    delete this.stores[storeId];
    this.storesArray.splice(idx, 1);
  }
};

module.exports = LayersStoresRegistry;
},{"core/g3wobject":27,"core/utils//utils":71,"core/utils/utils":71}],41:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function GEOJSONDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'geojson';
}

inherit(GEOJSONDataProvider, DataProvider);

var proto = GEOJSONDataProvider.prototype;

proto.getFearures = function() {
  var d = $.Deferred();
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
  var d = $.Deferred();
  // attravercso il layer name e il base url
  // chiedo la server di inviarmi la configurazione editing del laye
  $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
  var d = $.Deferred();
  var lock = this.getMode() == 'w' ? true : false;
  var apiUrl;
  if (lock) {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
  } else {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
  }
  $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

module.exports = GEOJSONDataProvider;


},{"core/layers/providers/provider":43,"core/utils/utils":71}],42:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function KMLDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'kml';
}

inherit(KMLDataProvider, DataProvider);

var proto = KMLDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};


module.exports = KMLDataProvider;
},{"core/layers/providers/provider":43,"core/utils/utils":71}],43:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var Feature = require('core/layers/features/feature');

function Provider(options) {
  options = options || {};
  this._isReady = false;
  this._name = 'provider';
  this._layer = options.layer;
  base(this);
}

inherit(Provider, G3WObject);

var proto = Provider.prototype;

proto.getFeatures = function() {
  console.log('da sovrascrivere')
};

proto.query = function(options) {
  console.log('metodo da sovrascrivere')
};

proto.setReady = function(bool) {
  this._isReady = bool;
};

proto.isReady = function() {
  return this._isReady;
};

proto.error = function() {
  //TODO
};

proto.isValid = function() {
  console.log('deve essere implementatato dai singoli provider');
};

proto.getName = function() {
  return this._name;
};

// Messo qui generale la funzione che si prende cura della trasformazione dell'xml di risposta
// dal server così da avere una risposta coerente in termini di formato risultati da presentare
// nel componente QueryResults
proto.handleQueryResponseFromServer = function(response, ogcservice) {
  var self = this;
  var jsonresponse;
  var parser, data, features, error;
  switch (this._layer.getInfoFormat()) {
    case 'json':
      parser = this._parseLayerGeoJSON;
      data = response.vector.data;
      break;
    default:
      // caso gml
      var x2js = new X2JS();
      try {
        if (_.isString(response)) {
          jsonresponse = x2js.xml_str2json(response);
        } else {
          jsonresponse = x2js.xml2json(response);
        }
      }
      catch (e) {
        return;
      }
      var rootNode = _.keys(jsonresponse)[0];
      switch (rootNode) {
        case 'FeatureCollection':
          parser = this._parseLayerFeatureCollection;
          data = jsonresponse;
          break;
        case "msGMLOutput":
          parser = this._parseLayermsGMLOutput;
          data = response;
          break;
        case "ServiceExceptionReport":
          error = 'an error occured while querying the layer';
          if (jsonresponse.ServiceExceptionReport.ServiceException)  {
            error = jsonresponse.ServiceExceptionReport.ServiceException.toString();
          }
        
      }
  }
  if (parser) {
    features = parser.call(self, data, ogcservice);
  }

  return [{
    layer: this._layer,
    features: features,
    error: error
  }];
};

// Brutto ma per ora unica soluzione trovata per dividere per layer i risultati di un doc xml wfs.FeatureCollection.
// OL3 li parserizza tutti insieme non distinguendo le features dei diversi layers
proto._parseLayerFeatureCollection = function(data, ogcService) {
  var layerName = (ogcService == 'wfs') ? this._layer.getWMSLayerName().replace(/ /g,'_'): this._layer.getWMSLayerName().replace(/ /g,''); // QGIS SERVER rimuove gli spazi dal nome del layer per creare l'elemento FeatureMember
  var layerData = _.cloneDeep(data);
  layerData.FeatureCollection.featureMember = [];
  var featureMembers = data.FeatureCollection.featureMember;
  featureMembers = _.isArray(featureMembers) ? featureMembers : [featureMembers];
  _.forEach(featureMembers,function(featureMember){
    var isLayerMember = _.get(featureMember,layerName);
    if (isLayerMember) {
      layerData.FeatureCollection.featureMember.push(featureMember);
    }
  });
  var x2js = new X2JS();
  var layerFeatureCollectionXML = x2js.json2xml_str(layerData);
  var parser = new ol.format.WMSGetFeatureInfo();
  return parser.readFeatures(layerFeatureCollectionXML);
};

// mentre con i risultati in msGLMOutput (da Mapserver) il parser può essere istruito per parserizzare in base ad un layer di filtro
proto._parseLayermsGMLOutput = function(data) {
  var layers = this._layer.getQueryLayerOrigName();
  var parser = new ol.format.WMSGetFeatureInfo({
    layers: layers
  });
  return parser.readFeatures(data);
};


proto._parseLayerGeoJSON = function(data) {

  var geojson = new ol.format.GeoJSON({
    defaultDataProjection: this.crs,
    geometryName: "geometry"
  });
  return geojson.readFeatures(data);
};


module.exports = Provider;
},{"core/g3wobject":27,"core/layers/features/feature":31,"core/utils/utils":71}],44:[function(require,module,exports){
var Providers = {
  geojson: require('./geojsonprovider'),
  kml: require('./kmlprovider'),
  xml: require('./xmlprovider'),
  qgis: require('./qgisprovider'),
  wms: require('./wmsprovider'),
  wfs: require('./wfsprovider')
};

var ProvidersForServerTypes = {
  'QGIS': {
    'postgres': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.qgis
    },
    'spatialite': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.qgis
    },
    'ogr': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: null
    },
    'delimitedtext': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: null
    },
    'wms': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: null
    },
    'wfs': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.wfs
    },
    'gdal': {
      query: Providers.wms,
      filter: null,
      data: null
    }
  },
  'OGC': {
    'wms': {
      query: Providers.wms,
      filter: null,
      data: null
    }
  }
};

function ProviderFactory() {
  this.build = function(providerType,serverType,sourceType,options) {
    // ritorna l'sitanza del provider selezionato
    var providerClass = this.get(providerType,serverType,sourceType);
    if (providerClass) {
      return new providerClass(options);
    }
    return null;
  };

  this.get = function(providerType,serverType,sourceType) {
    return ProvidersForServerTypes[serverType][sourceType][providerType];
  }
}

module.exports = new ProviderFactory();

},{"./geojsonprovider":41,"./kmlprovider":42,"./qgisprovider":45,"./wfsprovider":46,"./wmsprovider":47,"./xmlprovider":48}],45:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');
var Feature = require('core/layers/features/feature');

function  QGISProvider(options) {
  options = options || {};
  base(this);
  this._name = 'qgis';
  this._layer = options.layer || null;
  this._layerName = options.layerName || null;
  this._infoFormat = options.infoFormat || 'application/vnd.ogc.gml';
}

inherit(QGISProvider, DataProvider);


var proto = QGISProvider.prototype;

proto.query = function(options) {
  var self = this;
  var d = $.Deferred();
  options = options || {};
  var filter = options.filter || null;
  if (filter) {
    if (filter.bbox) {

    }
    // temporaneo per evitare che possa scoppiare
    d.resolve({
      query: '',
      data: [{
        features: [],
        layer: this._layer
      }]
    });
  }
  return d.promise()
};

// METODI LOADING EDITING FEATURES //

proto.getFeatures = function(options) {
  var d = $.Deferred();
  options = options || {};
  var features = [];
  var featuresGeoJson = ENTIGeoJSON;
  _.forEach(this._parseLayerGeoJSON(featuresGeoJson), function(feature) {
    features.push(new Feature({
      feature: feature
    }))
  });
  d.resolve(features);
  return d.promise();
};

// funzione principale, starting point, chiamata dal plugin per
// il recupero dei vettoriali (chiamata verso il server)
proto._loadLayerData = function(mode, customUrlParameters) {
  // il parametro mode mi di è in scrittura, lettura etc ..
  var self = this;
  var deferred = $.Deferred();

  //verifica se sono stati caricati i vettoriali dei layer
  // attraverso la proprietà vector del layer passato dal plugin
  _.forEach(this._layers, function(layer, layerCode) {
    // verifico se l'attributo vector è nullo
    if (_.isNull(layer.vector)) {
      noVectorlayerCodes.push(layerCode);
    }
  });
  // eseguo le richieste delle configurazioni e mi tengo le promesse
  var vectorLayersSetup = _.map(noVectorlayerCodes, function(layerCode) {
    return self._setupVectorLayer(layerCode);
  });
  // emetto l'evento loadingvectorlayersstart (il pluginservice è in ascolto)
  self.emit('loadingvectorlayersstart');
  // aspetto tutte le promesse del setup vector
  $.when.apply(this, vectorLayersSetup)
  // una volta che tutte le configurazioni dei layer vecor
  // sono state prese dal server e dopo aver assegnato all'attributo vector
  // del layer plugin il layer vettoriale costruito con le configurazioni
  // di sopra
    .then(function() {
      // le promesse ritornano il layerCode del layer vettoriale appena costuito
      var vectorLayersCodes = Array.prototype.slice.call(arguments);
      // emtto evento che inzia il recupero dei dati dei layer vettoriali (geojson)
      self.emit('loadingvectolayersdatastart');
      // inizio a caricare tutti i vettoriali dopo aver caricato le configurazioni
      self.loadAllVectorsData(vectorLayersCodes)
        .then(function() {
          self._vectorLayersCodes = vectorLayersCodes;
          deferred.resolve(vectorLayersCodes);
          // emtto evento che ho ricevuto i layers
          self.emit('loadingvectorlayersend');
          // ora il loader è pronto
          self.setReady(true);

        })
        .fail(function() {
          // risetto tutti i layer veetotiali a null
          _.forEach(self._layers, function(layer) {
            layer.vector = null;
          });
          deferred.reject();
          // emttto che c'è stato un errore nel loading dei dati che vengono dal server
          self.emit('errorloadingvectorlayersend');
          self.setReady(false);
        })
    })
    .fail(function() {
      self.setReady(false);
      self.emit('errorloadingvectorlayersend');
      deferred.reject();
    });
  return deferred.promise();
};

proto.setVectorLayersCodes = function(vectorLayersCodes) {
  this._vectorLayersCodes = vectorLayersCodes;
};

proto.getVectorLayersCodes = function() {
  return this._vectorLayersCodes;
};

proto.getLayers = function() {
  return this._layers;
};

// funzione che fa il reload che rihiede di nuovo il dati del vetor layer
// caso in cui si lavora con un layer vettoriale e non si usa un wms per fare la query
proto.reloadVectorData = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  var bbox = this._mapService.state.bbox;
  self._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
          self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
          vectorLayer.setData(vectorDataResponse.vector.data);
          deferred.resolve(vectorLayer);
        });
    });
  return deferred.promise();
};

//funzione che permette di ottenere tutti i dati relativi ai layer vettoriali caricati
//prima si è ottenuta la coinfigurazione, ora si ottengono i dati veri e propri
proto.loadAllVectorsData = function(layerCodes) {
  var self = this;
  var deferred = $.Deferred();
  var layers = this._layers;
  // verifico che il BBOX attuale non sia stato già  caricato
  // prondo il bbox
  var bbox = this._mapService.state.bbox;
  var loadedExtent = this._loadedExtent;
  if (loadedExtent && ol.extent.containsExtent(loadedExtent, bbox)) {
    return resolvedValue();
  }
  if (!loadedExtent) {
    this._loadedExtent = bbox;
  } else {
    this._loadedExtent = ol.extent.extend(loadedExtent, bbox);
  }
  if (layerCodes) {
    layers = [];
    _.forEach(layerCodes, function(layerCode) {
      layers.push(self._layers[layerCode]);
    });
  }
  //per ogni layer del plugin che non ha il layer vado a caricare i dati del layer vettoriale
  var vectorDataRequests = _.map(layers, function(Layer) {
    return self._loadVectorData(Layer.vector, bbox);
  });

  $.when.apply(this, vectorDataRequests)
    .then(function() {
      deferred.resolve(layerCodes);
    })
    .fail(function(){
      deferred.reject();
    });

  return deferred.promise();
};

proto._setCustomUrlParameters = function(customUrlParameters) {
  this._customUrlParameters = customUrlParameters;
};

proto._checkVectorGeometryTypeFromConfig = function(vectorConfig) {
  switch (vectorConfig.geometrytype) {
    case 'Line':
      vectorConfig.geometrytype = 'LineString';
      break;
    case 'MultiLine':
      vectorConfig.geometrytype = 'MultiLineString';
      break;
  }
  return vectorConfig;
};


proto._createVectorLayerFromConfig = function(layerCode) {
  var self = this;
  // recupero la configurazione del layer settata da plugin service
  var layerConfig = this._layers[layerCode];
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._getVectorLayerConfig(layerConfig[this._editingApiField])
    .then(function(vectorConfigResponse) {
      var vectorConfig = vectorConfigResponse.vector;
      // vado a verificare la correttezza del geometryType (caso di editing generico)
      vectorConfig = self._checkVectorGeometryTypeFromConfig(vectorConfig);
      // una volta ottenuta dal server la configurazione vettoriale,
      // provvedo alla creazione del layer vettoriale
      var crsLayer = layerConfig.crs || self._mapService.getProjection().getCode();
      var vectorLayer = self._createVectorLayer({
        geometrytype: vectorConfig.geometrytype,
        format: vectorConfig.format,
        crs: self._mapService.getProjection().getCode(),
        crsLayer : crsLayer,
        id: layerConfig.id,
        name: layerConfig.name,
        pk: vectorConfig.pk,
        editing: self._editingMode
      });
      // setto i campi del layer
      vectorLayer.setFields(vectorConfig.fields);
      vectorLayer.setCrs(crsLayer);
      // questo è la proprietà della configurazione del config layer
      // che specifica se esistono relazioni con altri layer
      // sono array di oggetti che specificano una serie di
      // informazioni su come i layer sono relazionati (nome della relazione == nome layer)
      // foreign key etc ..
      var relations = vectorConfig.relations;
      // nel caso il layer abbia relazioni (array non vuoto)
      if (relations) {
        // per dire a vectorLayer che i dati
        // delle relazioni verranno caricati solo quando
        // richiesti (es. aperture form di editing)
        vectorLayer.lazyRelations = true;
        //vado a settare le relazioni del vector layer
        vectorLayer.setRelations(relations);
      }
      // setto lo stile del layer OL
      if (layerConfig.style) {
        vectorLayer.setStyle(layerConfig.style);
      }
      // risolve con il nome del vectorLayer
      deferred.resolve(vectorLayer);
    })
    .fail(function(){
      deferred.reject();
    });
  return deferred.promise();
};

// funzione che dato la configurazione del layer fornito dal plugin (style, editor, vctor etc..)
// esegue richieste al server al fine di ottenere configurazione vettoriale del layer
proto._setupVectorLayer = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      var layerConfig = self._layers[layerCode];
      // assegno il vetorLayer appena creato all'attributo vector del layer
      layerConfig.vector = vectorLayer;
      // risolve con il nome del layerCode
      deferred.resolve(layerCode);
    })
    .fail(function() {
      deferred.reject();
    });
  return deferred.promise();
};

//in base all bbox e la layer chiedo al server di restituirmi il vettoriale (geojson) del layer
proto._loadVectorData = function(vectorLayer, bbox) {
  var self = this;
  // eseguo le richieste dei dati al server al fine di ottenere il geojson,
  // vettoriale, del layer richiesto
  return self._getVectorLayerData(vectorLayer, bbox)
    .then(function(vectorDataResponse) {
      self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
      // setto i dati vettoriali del layer vettoriale
      // e verifico se siamo in editingMode write e se ci sono featurelocks
      if (self._editingMode && vectorDataResponse.featurelocks) {
        // nel cso in cui sia in editing (mode w) e che si siano featureLocks
        // setto tale features al layervettoriale
        self.setVectorFeaturesLock(vectorLayer, vectorDataResponse.featurelocks);
      }
      //setto i dati del layer vettoriale (geojson)
      vectorLayer.setData(vectorDataResponse.vector.data);
      if (self._)
        return vectorDataResponse;
    })
    .fail(function() {
      return false;
    })
};

proto.getVectorLayerData = function(layerCode) {
  return this._vectorLayersData[layerCode];
};

proto.getVectorLayersData = function() {
  return this._vectorLayersData;
};

proto.setVectorLayerData = function(layerCode, vectorLayerData) {
  this._vectorLayersData[layerCode] = vectorLayerData;
};

//funzione che setta le features lock del layer vettoriale
proto.setVectorFeaturesLock = function(vectorLayer, featureslock) {
  //vado a pescare le fifferenze tra le featureidlock già caricati id
  var newFeaturesLockIds = _.differenceBy(featureslock, vectorLayer.getFeatureLocks(), 'featureid');
  _.forEach(newFeaturesLockIds, function(newLockId) {
    vectorLayer.addLockId(newLockId)
  });
};

proto.cleanVectorFeaturesLock = function(vectorLayer) {
  vectorLayer.cleanFeatureLocks();
};

proto.lockFeatures = function(layerName) {
  var self = this;
  var d = $.Deferred();
  var bbox = this._mapService.state.bbox;
  var vectorLayer = this._layers[layerName].vector;
  $.get(this._baseUrl+layerName+"/?lock" + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      self.setVectorFeaturesLock(vectorLayer, data.featurelocks);
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
  var d = $.Deferred();
  // attravercso il layer name e il base url
  // chiedo la server di inviarmi la configurazione editing del laye
  $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
  var d = $.Deferred();
  var lock = this.getMode() == 'w' ? true : false;
  var apiUrl;
  if (lock) {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
  } else {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
  }
  $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};
// funzione per creare il layer vettoriale
proto._createVectorLayer = function(options) {
  var vector = new VectorLayer(options);
  return vector;
};
//funzione chiamata dal plugin quando si vuole fare un cleanUp dei layers
// !!! -- DA RIVEDERE -- !!!
proto.cleanUpLayers = function() {
  this._loadedExtent = null;
};


module.exports = QGISProvider;

var ENTIGeoJSON = {
  "type": "FeatureCollection",
  "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:EPSG::3003" } },
  "features": [
    { "type": "Feature", "properties": { "gid": 1, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "1", "am_cam_id": "1", "nome": "CASENTINO", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1723520.243297379929572, 4845229.65344777982682 ] ] } },
    { "type": "Feature", "properties": { "gid": 2, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "2", "am_cam_id": "2", "nome": "PRATOMAGNO", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1712658.505333, 4829966.873250789940357 ] ] } },
    { "type": "Feature", "properties": { "gid": 3, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "3", "am_cam_id": "3", "nome": "VALTIBERINA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1753621.60567691992037, 4828969.308742919936776 ] ] } },
    { "type": "Feature", "properties": { "gid": 4, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "4", "am_cam_id": "4", "nome": "CASTELLINA IN CHIANTI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1684911.21800134005025, 4815562.959644709713757 ] ] } },
    { "type": "Feature", "properties": { "gid": 5, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "5", "am_cam_id": "5", "nome": "SAN QUIRICO D'ORCIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1712169.134751349920407, 4770662.078955880366266 ] ] } },
    { "type": "Feature", "properties": { "gid": 6, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "6", "am_cam_id": "6", "nome": "MURLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1694406.39198483992368, 4782312.866568639874458 ] ] } },
    { "type": "Feature", "properties": { "gid": 7, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "7", "am_cam_id": "7", "nome": "MONTICIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1677328.338403180008754, 4778658.688623270019889 ] ] } },
    { "type": "Feature", "properties": { "gid": 8, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "8", "am_cam_id": "8", "nome": "BUONCONVENTO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1701895.50073137995787, 4779181.66243883036077 ] ] } },
    { "type": "Feature", "properties": { "gid": 9, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "9", "am_cam_id": "9", "nome": "ASCIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1707861.907723299926147, 4790092.74594611953944 ] ] } },
    { "type": "Feature", "properties": { "gid": 10, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "10", "am_cam_id": "10", "nome": "CHIUSI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1740247.048921700101346, 4766895.924898349680007 ] ] } },
    { "type": "Feature", "properties": { "gid": 11, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "11", "am_cam_id": "11", "nome": "CHIANCIANO TERME", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1730593.422915870090947, 4771235.033481759950519 ] ] } },
    { "type": "Feature", "properties": { "gid": 12, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "12", "am_cam_id": "12", "nome": "TREQUANDA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1716798.971671259962022, 4785272.235241410322487 ] ] } },
    { "type": "Feature", "properties": { "gid": 13, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "13", "am_cam_id": "13", "nome": "CHIUSDINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1669823.737861400004476, 4780151.421721699647605 ] ] } },
    { "type": "Feature", "properties": { "gid": 14, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "14", "am_cam_id": "14", "nome": "SOVICILLE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1680783.464639419922605, 4794404.789667289704084 ] ] } },
    { "type": "Feature", "properties": { "gid": 15, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "15", "am_cam_id": "15", "nome": "RADDA IN CHIANTI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1692016.776902179932222, 4817593.908220710232854 ] ] } },
    { "type": "Feature", "properties": { "gid": 16, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "16", "am_cam_id": "16", "nome": "RADICONDOLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1665768.493470950052142, 4791853.671191230416298 ] ] } },
    { "type": "Feature", "properties": { "gid": 17, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "17", "am_cam_id": "17", "nome": "ABBADIA SAN SALVATORE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1718680.796665739966556, 4751088.906772729940712 ] ] } },
    { "type": "Feature", "properties": { "gid": 18, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "18", "am_cam_id": "18", "nome": "MONTEPULCIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1726333.058189739938825, 4774888.675014800392091 ] ] } },
    { "type": "Feature", "properties": { "gid": 19, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "19", "am_cam_id": "19", "nome": "MONTALCINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1702774.09806304005906, 4770643.300836020149291 ] ] } },
    { "type": "Feature", "properties": { "gid": 20, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "20", "am_cam_id": "20", "nome": "CASTELNUOVO BERARDENGA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1702825.240103430114686, 4802242.926064640283585 ] ] } },
    { "type": "Feature", "properties": { "gid": 21, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "21", "am_cam_id": "21", "nome": "CASOLE D'ELSA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1665624.442152040079236, 4800624.810719270259142 ] ] } },
    { "type": "Feature", "properties": { "gid": 22, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "22", "am_cam_id": "22", "nome": "CETONA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1736615.40750929992646, 4760786.467516589909792 ] ] } },
    { "type": "Feature", "properties": { "gid": 23, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "23", "am_cam_id": "23", "nome": "MONTERIGGIONI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1679735.511786780087277, 4806871.756403059698641 ] ] } },
    { "type": "Feature", "properties": { "gid": 24, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "24", "am_cam_id": "24", "nome": "CASTIGLIONE D'ORCIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1713248.179830549983308, 4764785.87559004034847 ] ] } },
    { "type": "Feature", "properties": { "gid": 25, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "25", "am_cam_id": "25", "nome": "GAIOLE IN CHIANTI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1696917.75518576009199, 4815675.541613539680839 ] ] } },
    { "type": "Feature", "properties": { "gid": 26, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "26", "am_cam_id": "26", "nome": "MONTERONI D'ARBIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1696705.396854490041733, 4789357.043639239855111 ] ] } },
    { "type": "Feature", "properties": { "gid": 27, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "27", "am_cam_id": "27", "nome": "SAN GIOVANNI D'ASSO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1710606.390525389928371, 4781048.145711150020361 ] ] } },
    { "type": "Feature", "properties": { "gid": 28, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "28", "am_cam_id": "28", "nome": "RAPOLANO TERME", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1711303.36976227001287, 4795939.203271050006151 ] ] } },
    { "type": "Feature", "properties": { "gid": 29, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "29", "am_cam_id": "29", "nome": "RADICOFANI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1725916.79096699994989, 4753085.81937914993614 ] ] } },
    { "type": "Feature", "properties": { "gid": 30, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "30", "am_cam_id": "30", "nome": "PIANCASTAGNAIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1719985.633822479983792, 4747618.863608459942043 ] ] } },
    { "type": "Feature", "properties": { "gid": 31, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "31", "am_cam_id": "31", "nome": "PIENZA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1718139.37307652994059, 4772827.297681040130556 ] ] } },
    { "type": "Feature", "properties": { "gid": 32, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "32", "am_cam_id": "32", "nome": "SAN CASCIANO DEI BAGNI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1734892.569469979964197, 4750548.453212739899755 ] ] } },
    { "type": "Feature", "properties": { "gid": 33, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "33", "am_cam_id": "33", "nome": "TORRITA DI SIENA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1725357.685880959965289, 4783075.490489169955254 ] ] } },
    { "type": "Feature", "properties": { "gid": 34, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "34", "am_cam_id": "34", "nome": "SINALUNGA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1722346.649264289997518, 4788025.959795939736068 ] ] } },
    { "type": "Feature", "properties": { "gid": 35, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "35", "am_cam_id": "35", "nome": "SARTEANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1733863.587052129907534, 4763644.630601299926639 ] ] } },
    { "type": "Feature", "properties": { "gid": 36, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "36", "am_cam_id": "36", "nome": "POGGIBONSI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1673670.920566889923066, 4814959.417979089543223 ] ] } },
    { "type": "Feature", "properties": { "gid": 37, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "37", "am_cam_id": "37", "nome": "COLLE DI VAL D'ELSA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1671458.860459110001102, 4809808.506717859767377 ] ] } },
    { "type": "Feature", "properties": { "gid": 38, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "38", "am_cam_id": "38", "nome": "SAN GIMIGNANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1665301.624138159910217, 4814786.523145129904151 ] ] } },
    { "type": "Feature", "properties": { "gid": 39, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "39", "am_cam_id": "39", "nome": "SIENA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1689137.736664549913257, 4798806.567762039601803 ] ] } },
    { "type": "Feature", "properties": { "gid": 40, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "40", "am_cam_id": "40", "nome": "AMIATA SENESE", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1719437.395121149951592, 4747805.344233449548483 ] ] } },
    { "type": "Feature", "properties": { "gid": 41, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "41", "am_cam_id": "41", "nome": "VAL DI MERSE", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1665768.493470950052142, 4791853.671191230416298 ] ] } },
    { "type": "Feature", "properties": { "gid": 42, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "42", "am_cam_id": "42", "nome": "CETONA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1733870.036528970114887, 4763626.949370980262756 ] ] } },
    { "type": "Feature", "properties": { "gid": 43, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "43", "am_cam_id": "43", "nome": "SIENA", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1688915.463630859972909, 4798666.076873579993844 ] ] } },
    { "type": "Feature", "properties": { "gid": 44, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "44", "am_cam_id": "44", "nome": "PESCIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1635647.504888510098681, 4862652.653938240371644 ] ] } },
    { "type": "Feature", "properties": { "gid": 45, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "45", "am_cam_id": "45", "nome": "UZZANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1637288.415242739953101, 4860167.369695919565856 ] ] } },
    { "type": "Feature", "properties": { "gid": 46, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "46", "am_cam_id": "46", "nome": "BUGGIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1638812.488352529937401, 4860008.630827720277011 ] ] } },
    { "type": "Feature", "properties": { "gid": 47, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "47", "am_cam_id": "47", "nome": "MASSA E COZZILE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1641117.760224899975583, 4860925.483528289943933 ] ] } },
    { "type": "Feature", "properties": { "gid": 48, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "48", "am_cam_id": "48", "nome": "MONTECATINI TERME", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1642446.45953842997551, 4860538.391247980296612 ] ] } },
    { "type": "Feature", "properties": { "gid": 49, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "49", "am_cam_id": "49", "nome": "PIEVE A NIEVOLE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1644160.679539320059121, 4859992.656011030077934 ] ] } },
    { "type": "Feature", "properties": { "gid": 50, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "50", "am_cam_id": "50", "nome": "MONSUMMANO TERME", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1645837.5241372899618, 4859322.742167750373483 ] ] } },
    { "type": "Feature", "properties": { "gid": 51, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "51", "am_cam_id": "51", "nome": "LAMPORECCHIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1652571.873469729907811, 4853309.402236900292337 ] ] } },
    { "type": "Feature", "properties": { "gid": 52, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "52", "am_cam_id": "52", "nome": "CHIESINA UZZANESE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1638272.838373380014673, 4855478.374700150452554 ] ] } },
    { "type": "Feature", "properties": { "gid": 53, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "53", "am_cam_id": "53", "nome": "PONTE BUGGIANESE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1640506.928431909997016, 4855689.433391209691763 ] ] } },
    { "type": "Feature", "properties": { "gid": 54, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "54", "am_cam_id": "54", "nome": "PISTOIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1653981.518201479921117, 4866326.567725770175457 ] ] } },
    { "type": "Feature", "properties": { "gid": 55, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "55", "am_cam_id": "55", "nome": "SAN MARCELLO PISTOIESE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1643547.88954244996421, 4879627.211829070001841 ] ] } },
    { "type": "Feature", "properties": { "gid": 56, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "56", "am_cam_id": "56", "nome": "PITEGLIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1641636.966335789998993, 4876562.947512470185757 ] ] } },
    { "type": "Feature", "properties": { "gid": 57, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "57", "am_cam_id": "57", "nome": "MONTALE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1662288.349717430071905, 4866638.335440269671381 ] ] } },
    { "type": "Feature", "properties": { "gid": 58, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "58", "am_cam_id": "58", "nome": "CUTIGLIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1640457.424283409956843, 4884591.824804210104048 ] ] } },
    { "type": "Feature", "properties": { "gid": 59, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "59", "am_cam_id": "59", "nome": "ABETONE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1633155.132592449896038, 4889161.192516259849072 ] ] } },
    { "type": "Feature", "properties": { "gid": 60, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "60", "am_cam_id": "60", "nome": "SAMBUCA PISTOIESE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1660026.395029509905726, 4885391.944145820103586 ] ] } },
    { "type": "Feature", "properties": { "gid": 62, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "62", "am_cam_id": "62", "nome": "LARCIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1651026.161529369885102, 4854087.362791280262172 ] ] } },
    { "type": "Feature", "properties": { "gid": 63, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "63", "am_cam_id": "63", "nome": "APPENNINO PISTOIESE", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1643475.755184330046177, 4879837.942286520265043 ] ] } },
    { "type": "Feature", "properties": { "gid": 64, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "64", "am_cam_id": "64", "nome": "QUARRATA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1659071.702029139967635, 4856823.234588120132685 ] ] } },
    { "type": "Feature", "properties": { "gid": 65, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "65", "am_cam_id": "65", "nome": "PISTOIA", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1654015.934995430056006, 4866171.011545210145414 ] ] } },
    { "type": "Feature", "properties": { "gid": 66, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "66", "am_cam_id": "66", "nome": "SERRAVALLE PISTOIESE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1647203.907956159906462, 4863058.828440080396831 ] ] } },
    { "type": "Feature", "properties": { "gid": 67, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "67", "am_cam_id": "67", "nome": "AGLIANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1660922.210950490087271, 4863122.500618499703705 ] ] } },
    { "type": "Feature", "properties": { "gid": 68, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "68", "am_cam_id": "68", "nome": "VERNIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1672731.9375, 4880098.5 ] ] } },
    { "type": "Feature", "properties": { "gid": 69, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "69", "am_cam_id": "69", "nome": "CANTAGALLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1668891.9375, 4877183.5 ] ] } },
    { "type": "Feature", "properties": { "gid": 70, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "70", "am_cam_id": "70", "nome": "VAIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1670347.3125, 4870594.25 ] ] } },
    { "type": "Feature", "properties": { "gid": 71, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "71", "am_cam_id": "71", "nome": "MONTEMURLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1663541.4375, 4865829.0 ] ] } },
    { "type": "Feature", "properties": { "gid": 72, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "72", "am_cam_id": "72", "nome": "PRATO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1668484.8124899999239, 4860788.75 ] ] } },
    { "type": "Feature", "properties": { "gid": 73, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "73", "am_cam_id": "73", "nome": "PRATO", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1668561.25001, 4860734.0 ] ] } },
    { "type": "Feature", "properties": { "gid": 74, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "74", "am_cam_id": "74", "nome": "POGGIO A CAIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1665395.875, 4853541.5 ] ] } },
    { "type": "Feature", "properties": { "gid": 75, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "75", "am_cam_id": "75", "nome": "CARMIGNANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1662347.25, 4853225.25 ] ] } },
    { "type": "Feature", "properties": { "gid": 76, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "76", "am_cam_id": "76", "nome": "VAL DI BISENZIO", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1672351.104877009987831, 4879258.360874329693615 ] ] } },
    { "type": "Feature", "properties": { "gid": 77, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "77", "am_cam_id": "77", "nome": "PISA", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1612673.184794429922476, 4840667.996782300062478 ] ] } },
    { "type": "Feature", "properties": { "gid": 78, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "78", "am_cam_id": "78", "nome": "PISA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1612913.955068879993632, 4841242.789777600206435 ] ] } },
    { "type": "Feature", "properties": { "gid": 79, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "79", "am_cam_id": "79", "nome": "VECCHIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1611604.995407359907404, 4848564.07520775962621 ] ] } },
    { "type": "Feature", "properties": { "gid": 80, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "80", "am_cam_id": "80", "nome": "SAN GIULIANO TERME", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1616195.321568720042706, 4846639.976671350188553 ] ] } },
    { "type": "Feature", "properties": { "gid": 81, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "81", "am_cam_id": "81", "nome": "BUTI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1627873.504058910068125, 4842850.59750956017524 ] ] } },
    { "type": "Feature", "properties": { "gid": 82, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "82", "am_cam_id": "82", "nome": "BIENTINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1630520.392816880019382, 4840954.605 ] ] } },
    { "type": "Feature", "properties": { "gid": 83, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "83", "am_cam_id": "83", "nome": "CASTELFRANCO DI SOTTO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1640660.635253299959004, 4840008.964779789559543 ] ] } },
    { "type": "Feature", "properties": { "gid": 84, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "84", "am_cam_id": "84", "nome": "SANTA MARIA A MONTE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1636419.729919360019267, 4839681.534965540282428 ] ] } },
    { "type": "Feature", "properties": { "gid": 85, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "85", "am_cam_id": "85", "nome": "SAN MINIATO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1649322.975043809972703, 4837961.537492330186069 ] ] } },
    { "type": "Feature", "properties": { "gid": 86, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "86", "am_cam_id": "86", "nome": "VICOPISANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1627737.256037150043994, 4839752.058335459791124 ] ] } },
    { "type": "Feature", "properties": { "gid": 87, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "87", "am_cam_id": "87", "nome": "CALCINAIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1630259.078130580019206, 4837924.489161349833012 ] ] } },
    { "type": "Feature", "properties": { "gid": 88, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "88", "am_cam_id": "88", "nome": "PONTEDERA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1631892.670204879948869, 4835860.14084502030164 ] ] } },
    { "type": "Feature", "properties": { "gid": 89, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "89", "am_cam_id": "89", "nome": "MONTOPOLI IN VAL D'ARNO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1641959.504128250060603, 4836609.0267467899248 ] ] } },
    { "type": "Feature", "properties": { "gid": 90, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "90", "am_cam_id": "90", "nome": "PALAIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1643127.203540340065956, 4829528.789571110159159 ] ] } },
    { "type": "Feature", "properties": { "gid": 91, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "91", "am_cam_id": "91", "nome": "PONSACCO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1631814.552291929954663, 4831024.165422510355711 ] ] } },
    { "type": "Feature", "properties": { "gid": 92, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "92", "am_cam_id": "92", "nome": "CAPANNOLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1634643.480640139896423, 4828105.273341829888523 ] ] } },
    { "type": "Feature", "properties": { "gid": 93, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "93", "am_cam_id": "93", "nome": "LARI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1628621.961453289957717, 4824963.825006379745901 ] ] } },
    { "type": "Feature", "properties": { "gid": 94, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "94", "am_cam_id": "94", "nome": "FAUGLIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1622439.951030780095607, 4824920.824167730286717 ] ] } },
    { "type": "Feature", "properties": { "gid": 95, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "95", "am_cam_id": "95", "nome": "CASCIANA TERME", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1630724.782714440021664, 4820452.915422510355711 ] ] } },
    { "type": "Feature", "properties": { "gid": 96, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "96", "am_cam_id": "96", "nome": "TERRICCIOLA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1635494.80603715009056, 4820471.374577489681542 ] ] } },
    { "type": "Feature", "properties": { "gid": 97, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "97", "am_cam_id": "97", "nome": "PECCIOLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1639051.387298309942707, 4823124.200832270085812 ] ] } },
    { "type": "Feature", "properties": { "gid": 98, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "98", "am_cam_id": "98", "nome": "ORCIANO PISANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1622189.978527599945664, 4816710.403439120389521 ] ] } },
    { "type": "Feature", "properties": { "gid": 99, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "99", "am_cam_id": "99", "nome": "SANTA LUCE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1626689.983130580047145, 4814500.683335459791124 ] ] } },
    { "type": "Feature", "properties": { "gid": 100, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "100", "am_cam_id": "100", "nome": "CHIANNI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1632860.038962850114331, 4816103.462503190152347 ] ] } },
    { "type": "Feature", "properties": { "gid": 101, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "101", "am_cam_id": "101", "nome": "LAJATICO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1639825.754801499890164, 4815035.68 ] ] } },
    { "type": "Feature", "properties": { "gid": 102, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "102", "am_cam_id": "102", "nome": "VOLTERRA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1650601.634052539942786, 4807135.666248410008848 ] ] } },
    { "type": "Feature", "properties": { "gid": 103, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "103", "am_cam_id": "103", "nome": "CASTELLINA MARITTIMA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1627590.995627389987931, 4807779.833329079672694 ] ] } },
    { "type": "Feature", "properties": { "gid": 104, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "104", "am_cam_id": "104", "nome": "RIPARBELLA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1629647.158130580093712, 4802566.255416139960289 ] ] } },
    { "type": "Feature", "properties": { "gid": 105, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "105", "am_cam_id": "105", "nome": "MONTESCUDAIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1631958.426459660055116, 4798384.388757970184088 ] ] } },
    { "type": "Feature", "properties": { "gid": 106, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "106", "am_cam_id": "106", "nome": "GUARDISTALLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1632442.955627389950678, 4796862.746248410083354 ] ] } },
    { "type": "Feature", "properties": { "gid": 107, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "107", "am_cam_id": "107", "nome": "CASALE MARITTIMO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1631073.328956469893456, 4795114.404590239748359 ] ] } },
    { "type": "Feature", "properties": { "gid": 108, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "108", "am_cam_id": "108", "nome": "MONTECATINI VAL DI CECINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1641733.246043530059978, 4805895.324218730442226 ] ] } },
    { "type": "Feature", "properties": { "gid": 109, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "109", "am_cam_id": "109", "nome": "MONTEVERDI MARITTIMO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1639413.454877529991791, 4781906.755607870407403 ] ] } },
    { "type": "Feature", "properties": { "gid": 110, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "110", "am_cam_id": "110", "nome": "POMARANCE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1652013.625633769901469, 4795862.256670920178294 ] ] } },
    { "type": "Feature", "properties": { "gid": 111, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "111", "am_cam_id": "111", "nome": "CASTELNUOVO DI VAL DI CECINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1654775.296875800006092, 4785881.275838649831712 ] ] } },
    { "type": "Feature", "properties": { "gid": 112, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "112", "am_cam_id": "112", "nome": "CASCINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1625032.001875800080597, 4837110.251670920290053 ] ] } },
    { "type": "Feature", "properties": { "gid": 113, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "113", "am_cam_id": "113", "nome": "CALCI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1622111.393202109960839, 4842551.019000539556146 ] ] } },
    { "type": "Feature", "properties": { "gid": 114, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "114", "am_cam_id": "114", "nome": "CRESPINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1626323.275768150109798, 4825758.100454020313919 ] ] } },
    { "type": "Feature", "properties": { "gid": 115, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "115", "am_cam_id": "115", "nome": "VAL DI CECINA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1652127.726037150016055, 4795628.51665817014873 ] ] } },
    { "type": "Feature", "properties": { "gid": 116, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "116", "am_cam_id": "116", "nome": "SANTA CROCE SULL'ARNO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1643345.760409760056064, 4841371.471037150360644 ] ] } },
    { "type": "Feature", "properties": { "gid": 117, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "117", "am_cam_id": "117", "nome": "LORENZANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1624008.1491741000209, 4821507.284378980286419 ] ] } },
    { "type": "Feature", "properties": { "gid": 118, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "118", "am_cam_id": "118", "nome": "MASSA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1591447.030883529921994, 4876584.533042400144041 ] ] } },
    { "type": "Feature", "properties": { "gid": 119, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "119", "am_cam_id": "119", "nome": "MONTIGNOSO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1594280.143014169996604, 4874530.748720490373671 ] ] } },
    { "type": "Feature", "properties": { "gid": 120, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "120", "am_cam_id": "120", "nome": "CARRARA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1587838.284448170103133, 4881082.909430590458214 ] ] } },
    { "type": "Feature", "properties": { "gid": 121, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "121", "am_cam_id": "121", "nome": "MASSA-CARRARA", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1591564.904099639970809, 4876575.838130390271544 ] ] } },
    { "type": "Feature", "properties": { "gid": 122, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "122", "am_cam_id": "122", "nome": "AULLA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1577377.870550429914147, 4895571.136900080367923 ] ] } },
    { "type": "Feature", "properties": { "gid": 123, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "123", "am_cam_id": "123", "nome": "VILLAFRANCA IN LUNIGIANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1575926.89218108006753, 4904816.786252699792385 ] ] } },
    { "type": "Feature", "properties": { "gid": 124, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "124", "am_cam_id": "124", "nome": "FIVIZZANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1589700.997921909904107, 4898876.27360715996474 ] ] } },
    { "type": "Feature", "properties": { "gid": 125, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "125", "am_cam_id": "125", "nome": "LUNIGIANA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1590049.982498229946941, 4899090.04442336037755 ] ] } },
    { "type": "Feature", "properties": { "gid": 126, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "126", "am_cam_id": "126", "nome": "PONTREMOLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1570384.883343920111656, 4914177.049749409779906 ] ] } },
    { "type": "Feature", "properties": { "gid": 127, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "127", "am_cam_id": "127", "nome": "BAGNONE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1579350.975704269949347, 4907410.522767109796405 ] ] } },
    { "type": "Feature", "properties": { "gid": 128, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "128", "am_cam_id": "128", "nome": "TRESANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1575976.002197129884735, 4898736.718471029773355 ] ] } },
    { "type": "Feature", "properties": { "gid": 129, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "129", "am_cam_id": "129", "nome": "PODENZANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1575195.072980399942026, 4895241.473859779536724 ] ] } },
    { "type": "Feature", "properties": { "gid": 130, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "130", "am_cam_id": "130", "nome": "MULAZZO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1572370.328145769890398, 4907978.518991639837623 ] ] } },
    { "type": "Feature", "properties": { "gid": 131, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "131", "am_cam_id": "131", "nome": "ZERI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1560879.732295070076361, 4911380.281682809814811 ] ] } },
    { "type": "Feature", "properties": { "gid": 132, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "132", "am_cam_id": "132", "nome": "FILATTIERA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1574729.741139970021322, 4909133.45448071975261 ] ] } },
    { "type": "Feature", "properties": { "gid": 133, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "133", "am_cam_id": "133", "nome": "FOSDINOVO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1581541.136602309998125, 4887341.294140419922769 ] ] } },
    { "type": "Feature", "properties": { "gid": 134, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "134", "am_cam_id": "134", "nome": "LICCIANA NARDI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1582910.942747589899227, 4901864.908233949914575 ] ] } },
    { "type": "Feature", "properties": { "gid": 135, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "135", "am_cam_id": "135", "nome": "COMANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1590108.65494628995657, 4904850.381708730012178 ] ] } },
    { "type": "Feature", "properties": { "gid": 136, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "136", "am_cam_id": "136", "nome": "CASOLA IN LUNIGIANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1593972.214437890099362, 4894907.469059470109642 ] ] } },
    { "type": "Feature", "properties": { "gid": 137, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "137", "am_cam_id": "137", "nome": "CAPANNORI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1626652.837900750106201, 4856365.041538080200553 ] ] } },
    { "type": "Feature", "properties": { "gid": 138, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "138", "am_cam_id": "138", "nome": "LUCCA", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1620712.145308850100264, 4855384.28273004014045 ] ] } },
    { "type": "Feature", "properties": { "gid": 139, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "139", "am_cam_id": "139", "nome": "LUCCA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1620729.968236459884793, 4855680.484546359628439 ] ] } },
    { "type": "Feature", "properties": { "gid": 140, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "140", "am_cam_id": "140", "nome": "AREA LUCCHESE", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1621086.004297150066122, 4855994.618789250031114 ] ] } },
    { "type": "Feature", "properties": { "gid": 141, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "141", "am_cam_id": "141", "nome": "PORCARI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1629966.001038539921865, 4855381.62943120021373 ] ] } },
    { "type": "Feature", "properties": { "gid": 142, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "142", "am_cam_id": "142", "nome": "MONTECARLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1634144.655250560026616, 4856634.58966008014977 ] ] } },
    { "type": "Feature", "properties": { "gid": 143, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "143", "am_cam_id": "143", "nome": "ALTOPASCIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1634721.003574440022931, 4852705.252815529704094 ] ] } },
    { "type": "Feature", "properties": { "gid": 144, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "144", "am_cam_id": "144", "nome": "VILLA BASILICA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1632071.38467384991236, 4865181.724812430329621 ] ] } },
    { "type": "Feature", "properties": { "gid": 145, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "145", "am_cam_id": "145", "nome": "PESCAGLIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1613195.337789919925854, 4869086.115485649555922 ] ] } },
    { "type": "Feature", "properties": { "gid": 146, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "146", "am_cam_id": "146", "nome": "MEDIA VALLE DEL SERCHIO", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1623995.032778539927676, 4870734.099854090251029 ] ] } },
    { "type": "Feature", "properties": { "gid": 147, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "147", "am_cam_id": "147", "nome": "BORGO A MOZZANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1623821.931297139963135, 4870645.916080550290644 ] ] } },
    { "type": "Feature", "properties": { "gid": 148, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "148", "am_cam_id": "148", "nome": "CAMPORGIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1606630.79047452006489, 4890390.082841220311821 ] ] } },
    { "type": "Feature", "properties": { "gid": 149, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "149", "am_cam_id": "149", "nome": "PIEVE FOSCIANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1612946.657533959951252, 4887620.818324229680002 ] ] } },
    { "type": "Feature", "properties": { "gid": 150, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "150", "am_cam_id": "150", "nome": "GARFAGNANA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1613122.422588810091838, 4884995.458524250425398 ] ] } },
    { "type": "Feature", "properties": { "gid": 151, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "151", "am_cam_id": "151", "nome": "CASTELNUOVO DI GARFAGNANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1612988.749749549897388, 4885060.421025569550693 ] ] } },
    { "type": "Feature", "properties": { "gid": 152, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "152", "am_cam_id": "152", "nome": "VIAREGGIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1600459.93873854004778, 4857870.554010599851608 ] ] } },
    { "type": "Feature", "properties": { "gid": 153, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "153", "am_cam_id": "153", "nome": "MASSAROSA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1607883.617153049912304, 4858163.804530969820917 ] ] } },
    { "type": "Feature", "properties": { "gid": 154, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "154", "am_cam_id": "154", "nome": "CAMAIORE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1604702.340030069928616, 4865888.561508730053902 ] ] } },
    { "type": "Feature", "properties": { "gid": 155, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "155", "am_cam_id": "155", "nome": "PIETRASANTA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1598478.504044049885124, 4868087.833579059690237 ] ] } },
    { "type": "Feature", "properties": { "gid": 156, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "156", "am_cam_id": "156", "nome": "FORTE DEI MARMI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1593894.608082480030134, 4867925.121220109984279 ] ] } },
    { "type": "Feature", "properties": { "gid": 157, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "157", "am_cam_id": "157", "nome": "SERVEZZA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1598517.362958240089938, 4872101.306860310025513 ] ] } },
    { "type": "Feature", "properties": { "gid": 158, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "158", "am_cam_id": "158", "nome": "STAZZEMA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1603926.765148170059547, 4872397.031294190324843 ] ] } },
    { "type": "Feature", "properties": { "gid": 159, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "159", "am_cam_id": "159", "nome": "S.ROMANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1607742.781343990005553, 4891466.545752909965813 ] ] } },
    { "type": "Feature", "properties": { "gid": 160, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "160", "am_cam_id": "160", "nome": "FOSCIANDORA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1616479.885468340013176, 4885731.218964110128582 ] ] } },
    { "type": "Feature", "properties": { "gid": 161, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "161", "am_cam_id": "161", "nome": "VAGLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1602505.231720519950613, 4885268.299742929637432 ] ] } },
    { "type": "Feature", "properties": { "gid": 162, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "162", "am_cam_id": "162", "nome": "PIAZZA AL SERCHIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1603904.699368770001456, 4893032.656330459751189 ] ] } },
    { "type": "Feature", "properties": { "gid": 163, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "163", "am_cam_id": "163", "nome": "MINUCCIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1596581.145712340017781, 4891560.040106760337949 ] ] } },
    { "type": "Feature", "properties": { "gid": 164, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "164", "am_cam_id": "164", "nome": "GIUNCUGNANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1600437.373227460077032, 4896790.45936574973166 ] ] } },
    { "type": "Feature", "properties": { "gid": 165, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "165", "am_cam_id": "165", "nome": "SILLANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1603866.269884899957106, 4897496.706164170056581 ] ] } },
    { "type": "Feature", "properties": { "gid": 166, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "166", "am_cam_id": "166", "nome": "CASTIGLIONE DI GARFAGNANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1612766.635213309898973, 4889355.41214369982481 ] ] } },
    { "type": "Feature", "properties": { "gid": 167, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "167", "am_cam_id": "167", "nome": "VILLA COLLEMANDINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1611714.753441520035267, 4890565.346340480260551 ] ] } },
    { "type": "Feature", "properties": { "gid": 168, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "168", "am_cam_id": "168", "nome": "CAREGGINE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1606044.452945289900526, 4886148.536839270032942 ] ] } },
    { "type": "Feature", "properties": { "gid": 169, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "169", "am_cam_id": "169", "nome": "FABBRICHE DI VALLICO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1614859.196549270069227, 4872817.190502800047398 ] ] } },
    { "type": "Feature", "properties": { "gid": 170, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "170", "am_cam_id": "170", "nome": "ALTA VERSILIA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1598252.951999079901725, 4871955.088216570205986 ] ] } },
    { "type": "Feature", "properties": { "gid": 171, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "171", "am_cam_id": "171", "nome": "COREGLIA ANT", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1622188.242029649903998, 4880177.521055379882455 ] ] } },
    { "type": "Feature", "properties": { "gid": 172, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "172", "am_cam_id": "172", "nome": "BARGA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1618921.039107309887186, 4881160.912331730127335 ] ] } },
    { "type": "Feature", "properties": { "gid": 173, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "173", "am_cam_id": "173", "nome": "GALLICANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1614986.869562489911914, 4879644.312829789705575 ] ] } },
    { "type": "Feature", "properties": { "gid": 174, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "174", "am_cam_id": "174", "nome": "BAGNI DI LUCCA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1627585.403668090002611, 4874281.343755509704351 ] ] } },
    { "type": "Feature", "properties": { "gid": 175, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "175", "am_cam_id": "175", "nome": "VERGEMOLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1610724.452520549995825, 4878638.073787829838693 ] ] } },
    { "type": "Feature", "properties": { "gid": 176, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "176", "am_cam_id": "176", "nome": "MOLAZZANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1613664.72299464000389, 4880937.599321910180151 ] ] } },
    { "type": "Feature", "properties": { "gid": 177, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "177", "am_cam_id": "177", "nome": "COLLESALVETTI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1619181.305995079921558, 4827319.171689379960299 ] ] } },
    { "type": "Feature", "properties": { "gid": 178, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "178", "am_cam_id": "178", "nome": "ROSIGNANO MARITTIMO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1619218.073575149988756, 4806895.27011530008167 ] ] } },
    { "type": "Feature", "properties": { "gid": 179, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "179", "am_cam_id": "179", "nome": "LIVORNO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1605687.972832530038431, 4822999.112384510226548 ] ] } },
    { "type": "Feature", "properties": { "gid": 180, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "180", "am_cam_id": "180", "nome": "PIOMBINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1624641.575070390012115, 4753291.727950819768012 ] ] } },
    { "type": "Feature", "properties": { "gid": 181, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "181", "am_cam_id": "181", "nome": "SAN VINCENZO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1625192.13798926002346, 4773168.423954560421407 ] ] } },
    { "type": "Feature", "properties": { "gid": 182, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "182", "am_cam_id": "182", "nome": "CAMPIGLIA MARITTIMA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1631702.78898425004445, 4768651.382446429692209 ] ] } },
    { "type": "Feature", "properties": { "gid": 183, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "183", "am_cam_id": "183", "nome": "SUVERETO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1636693.583563060034066, 4770995.201518589630723 ] ] } },
    { "type": "Feature", "properties": { "gid": 184, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "184", "am_cam_id": "184", "nome": "CECINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1623246.766856689937413, 4796622.742006519809365 ] ] } },
    { "type": "Feature", "properties": { "gid": 185, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "185", "am_cam_id": "185", "nome": "CASTAGNETO CARDUCCI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1630926.188893300015479, 4779929.979725579731166 ] ] } },
    { "type": "Feature", "properties": { "gid": 186, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "186", "am_cam_id": "186", "nome": "CAMPO NELL'ELBA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1600975.53945926995948, 4733212.927278639748693 ] ] } },
    { "type": "Feature", "properties": { "gid": 187, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "187", "am_cam_id": "187", "nome": "PORTOFERRAIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1608845.548154330113903, 4741159.127315550111234 ] ] } },
    { "type": "Feature", "properties": { "gid": 188, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "188", "am_cam_id": "188", "nome": "CAPOLIVERI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1613014.951715969946235, 4733222.918708729557693 ] ] } },
    { "type": "Feature", "properties": { "gid": 189, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "189", "am_cam_id": "189", "nome": "CAPRAIA ISOLA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1568639.506084660068154, 4766718.499997099861503 ] ] } },
    { "type": "Feature", "properties": { "gid": 190, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "190", "am_cam_id": "190", "nome": "SASSETTA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1633752.173193630063906, 4776375.433471409603953 ] ] } },
    { "type": "Feature", "properties": { "gid": 191, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "191", "am_cam_id": "191", "nome": "BIBBONA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1629761.559779789997265, 4791986.445971589535475 ] ] } },
    { "type": "Feature", "properties": { "gid": 192, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "192", "am_cam_id": "192", "nome": "MARCIANA MARINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1597868.312966350000352, 4739885.726826850324869 ] ] } },
    { "type": "Feature", "properties": { "gid": 193, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "193", "am_cam_id": "193", "nome": "RIO NELL'ELBA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1614460.979358840035275, 4741072.532927160151303 ] ] } },
    { "type": "Feature", "properties": { "gid": 194, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "194", "am_cam_id": "194", "nome": "RIO MARINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1616698.489059170009568, 4741339.416717190295458 ] ] } },
    { "type": "Feature", "properties": { "gid": 195, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "195", "am_cam_id": "195", "nome": "PORTO AZZURRO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1614471.446531800087541, 4735640.10125641990453 ] ] } },
    { "type": "Feature", "properties": { "gid": 196, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "196", "am_cam_id": "196", "nome": "MARCIANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1595597.868969979928806, 4738104.241800109855831 ] ] } },
    { "type": "Feature", "properties": { "gid": 197, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "197", "am_cam_id": "197", "nome": "VAL DI CORNIA", "tipo_ente": "CIRCONDARIO" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1624694.723105439916253, 4754030.663868390023708 ] ] } },
    { "type": "Feature", "properties": { "gid": 198, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "198", "am_cam_id": "198", "nome": "ELBA - CAPRAIA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1608318.251107319956645, 4741214.467738370411098 ] ] } },
    { "type": "Feature", "properties": { "gid": 199, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "199", "am_cam_id": "199", "nome": "LIVORNO", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1605797.668891760054976, 4822986.554294340312481 ] ] } },
    { "type": "Feature", "properties": { "gid": 200, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "200", "am_cam_id": "200", "nome": "MONTEROTONDO MARITTIMO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1650937.05586871993728, 4778650.622141379863024 ] ] } },
    { "type": "Feature", "properties": { "gid": 201, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "201", "am_cam_id": "201", "nome": "MONTIERI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1664022.978010789956897, 4777311.870229190215468 ] ] } },
    { "type": "Feature", "properties": { "gid": 202, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "202", "am_cam_id": "202", "nome": "MASSA MARITTIMA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1653770.311500099953264, 4768140.390866270288825 ] ] } },
    { "type": "Feature", "properties": { "gid": 203, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "203", "am_cam_id": "203", "nome": "ROCCASTRADA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1676662.053875009994954, 4764363.699602739885449 ] ] } },
    { "type": "Feature", "properties": { "gid": 204, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "204", "am_cam_id": "204", "nome": "CIVITELLA PAGANICO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1686024.599388859933242, 4762682.710057130083442 ] ] } },
    { "type": "Feature", "properties": { "gid": 205, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "205", "am_cam_id": "205", "nome": "SEGGIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1708840.138855240074918, 4756075.875827319920063 ] ] } },
    { "type": "Feature", "properties": { "gid": 206, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "206", "am_cam_id": "206", "nome": "FOLLONICA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1643656.831952370004728, 4753685.051388800144196 ] ] } },
    { "type": "Feature", "properties": { "gid": 207, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "207", "am_cam_id": "207", "nome": "GAVORRANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1655564.147260729921982, 4754306.203466650098562 ] ] } },
    { "type": "Feature", "properties": { "gid": 208, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "208", "am_cam_id": "208", "nome": "SCARLINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1651185.829946839949116, 4752233.548912120051682 ] ] } },
    { "type": "Feature", "properties": { "gid": 209, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "209", "am_cam_id": "209", "nome": "CASTEL DEL PIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1707126.446441340027377, 4752097.220968600362539 ] ] } },
    { "type": "Feature", "properties": { "gid": 210, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "210", "am_cam_id": "210", "nome": "CINIGIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1695556.502389830071479, 4751528.542057810351253 ] ] } },
    { "type": "Feature", "properties": { "gid": 211, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "211", "am_cam_id": "211", "nome": "CAMPAGNATICO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1685804.28904937999323, 4750328.015298630110919 ] ] } },
    { "type": "Feature", "properties": { "gid": 212, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "212", "am_cam_id": "212", "nome": "ARCIDOSSO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1707401.803358729928732, 4749685.113224909640849 ] ] } },
    { "type": "Feature", "properties": { "gid": 213, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "213", "am_cam_id": "213", "nome": "SANTA FIORA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1711383.143080879934132, 4745367.592033630236983 ] ] } },
    { "type": "Feature", "properties": { "gid": 214, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "214", "am_cam_id": "214", "nome": "ROCCALBEGNA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1705130.302828839980066, 4740102.893784849904478 ] ] } },
    { "type": "Feature", "properties": { "gid": 215, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "215", "am_cam_id": "215", "nome": "GROSSETO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1672979.069017220055684, 4736365.009388989768922 ] ] } },
    { "type": "Feature", "properties": { "gid": 216, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "216", "am_cam_id": "216", "nome": "CASTELL'AZZARA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1720880.663808980025351, 4739002.497226770035923 ] ] } },
    { "type": "Feature", "properties": { "gid": 217, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "217", "am_cam_id": "217", "nome": "CASTIGLIONE DELLA PESCAIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1653756.871718500042334, 4736121.424051419831812 ] ] } },
    { "type": "Feature", "properties": { "gid": 218, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "218", "am_cam_id": "218", "nome": "SEMPRONIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1708133.77848976990208, 4734021.360460519790649 ] ] } },
    { "type": "Feature", "properties": { "gid": 219, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "219", "am_cam_id": "219", "nome": "SORANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1722385.515123290009797, 4729067.911268490366638 ] ] } },
    { "type": "Feature", "properties": { "gid": 220, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "220", "am_cam_id": "220", "nome": "SCANSANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1691185.211590609978884, 4728823.187184340320528 ] ] } },
    { "type": "Feature", "properties": { "gid": 221, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "221", "am_cam_id": "221", "nome": "PITIGLIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1718885.932760220021009, 4723765.307200520299375 ] ] } },
    { "type": "Feature", "properties": { "gid": 222, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "222", "am_cam_id": "222", "nome": "MANCIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1706460.215699800057337, 4718066.731193990446627 ] ] } },
    { "type": "Feature", "properties": { "gid": 223, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "223", "am_cam_id": "223", "nome": "MAGLIANO IN TOSCANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1688274.366381299914792, 4718725.396258629858494 ] ] } },
    { "type": "Feature", "properties": { "gid": 224, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "224", "am_cam_id": "224", "nome": "CAPALBIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1699284.578124929917976, 4702967.242187489755452 ] ] } },
    { "type": "Feature", "properties": { "gid": 225, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "225", "am_cam_id": "225", "nome": "ORBETELLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1681914.453421560116112, 4700873.708453189581633 ] ] } },
    { "type": "Feature", "properties": { "gid": 226, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "226", "am_cam_id": "226", "nome": "MONTE ARGENTARIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1674021.975126710021868, 4700737.753805629909039 ] ] } },
    { "type": "Feature", "properties": { "gid": 227, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "227", "am_cam_id": "227", "nome": "ISOLA DEL GIGLIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1656564.897025259910151, 4692171.702545559965074 ] ] } },
    { "type": "Feature", "properties": { "gid": 228, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "228", "am_cam_id": "228", "nome": "GROSSETO", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1673030.159942159894854, 4736303.672909390181303 ] ] } },
    { "type": "Feature", "properties": { "gid": 229, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "229", "am_cam_id": "229", "nome": "COLLINE METALLIFERE", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1654002.332679870072752, 4768142.371190940029919 ] ] } },
    { "type": "Feature", "properties": { "gid": 230, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "230", "am_cam_id": "230", "nome": "COLLINE DEL FIORA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1719215.693118900060654, 4723627.452061929740012 ] ] } },
    { "type": "Feature", "properties": { "gid": 231, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "231", "am_cam_id": "231", "nome": "AMIATA GROSSETANO", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1707299.66945417993702, 4750317.131651679985225 ] ] } },
    { "type": "Feature", "properties": { "gid": 232, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "232", "am_cam_id": "232", "nome": "FIRENZE", "tipo_ente": "REGIONE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1681603.569170860107988, 4849371.798308770172298 ] ] } },
    { "type": "Feature", "properties": { "gid": 233, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "233", "am_cam_id": "233", "nome": "FIRENZE", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1681578.387221910059452, 4849364.21689322963357 ] ] } },
    { "type": "Feature", "properties": { "gid": 234, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "234", "am_cam_id": "234", "nome": "BAGNO A RIPOLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1686778.06, 4846884.46 ] ] } },
    { "type": "Feature", "properties": { "gid": 235, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "235", "am_cam_id": "235", "nome": "BARBERINO DI MUGELLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1679508.88, 4874365.47 ] ] } },
    { "type": "Feature", "properties": { "gid": 236, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "236", "am_cam_id": "236", "nome": "BARBERINO VAL D'ELSA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1675448.42, 4823274.61 ] ] } },
    { "type": "Feature", "properties": { "gid": 237, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "237", "am_cam_id": "237", "nome": "BORGO SAN LORENZO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1691608.12, 4869643.48 ] ] } },
    { "type": "Feature", "properties": { "gid": 238, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "238", "am_cam_id": "238", "nome": "CALENZANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1674177.13, 4859257.23 ] ] } },
    { "type": "Feature", "properties": { "gid": 239, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "239", "am_cam_id": "239", "nome": "CAMPI BISENZIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1671939.7, 4854195.7 ] ] } },
    { "type": "Feature", "properties": { "gid": 240, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "240", "am_cam_id": "240", "nome": "DICOMANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1702794.09, 4862920.57 ] ] } },
    { "type": "Feature", "properties": { "gid": 241, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "241", "am_cam_id": "241", "nome": "FIESOLE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1684455.01, 4852942.35 ] ] } },
    { "type": "Feature", "properties": { "gid": 242, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "242", "am_cam_id": "242", "nome": "FIGLINE VALDARNO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1699606.14, 4832512.66 ] ] } },
    { "type": "Feature", "properties": { "gid": 244, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "244", "am_cam_id": "244", "nome": "FIRENZUOLA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1690455.08, 4887822.56 ] ] } },
    { "type": "Feature", "properties": { "gid": 245, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "245", "am_cam_id": "245", "nome": "GREVE IN CHIANTI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1687072.02, 4828167.0 ] ] } },
    { "type": "Feature", "properties": { "gid": 246, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "246", "am_cam_id": "246", "nome": "IMPRUNETA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1681760.78, 4839460.13 ] ] } },
    { "type": "Feature", "properties": { "gid": 247, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "247", "am_cam_id": "247", "nome": "INCISA IN VAL D'ARNO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1697535.85, 4837432.93 ] ] } },
    { "type": "Feature", "properties": { "gid": 248, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "248", "am_cam_id": "248", "nome": "LASTRA A SIGNA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1669522.73, 4848503.62 ] ] } },
    { "type": "Feature", "properties": { "gid": 249, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "249", "am_cam_id": "249", "nome": "LONDA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1706316.89, 4859607.04 ] ] } },
    { "type": "Feature", "properties": { "gid": 250, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "250", "am_cam_id": "250", "nome": "MARRADI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1709233.89, 4883594.87 ] ] } },
    { "type": "Feature", "properties": { "gid": 251, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "251", "am_cam_id": "251", "nome": "PALAZZUOLO SUL SENIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1703942.33, 4887513.88 ] ] } },
    { "type": "Feature", "properties": { "gid": 252, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "252", "am_cam_id": "252", "nome": "PELAGO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1701352.43, 4849676.23 ] ] } },
    { "type": "Feature", "properties": { "gid": 253, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "253", "am_cam_id": "253", "nome": "PONTASSIEVE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1696391.09, 4849878.93 ] ] } },
    { "type": "Feature", "properties": { "gid": 254, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "254", "am_cam_id": "254", "nome": "REGGELLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1704459.09, 4839751.71 ] ] } },
    { "type": "Feature", "properties": { "gid": 255, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "255", "am_cam_id": "255", "nome": "RIGNANO SULL'ARNO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1697658.24, 4843922.95 ] ] } },
    { "type": "Feature", "properties": { "gid": 256, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "256", "am_cam_id": "256", "nome": "RUFINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1700256.95, 4855720.81 ] ] } },
    { "type": "Feature", "properties": { "gid": 257, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "257", "am_cam_id": "257", "nome": "SAN CASCIANO IN VAL DI PESA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1676203.14, 4836218.84 ] ] } },
    { "type": "Feature", "properties": { "gid": 258, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "258", "am_cam_id": "258", "nome": "SAN GODENZO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1710306.06, 4866866.94 ] ] } },
    { "type": "Feature", "properties": { "gid": 259, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "259", "am_cam_id": "259", "nome": "SAN PIERO A SIEVE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1686446.69, 4870233.26 ] ] } },
    { "type": "Feature", "properties": { "gid": 261, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "261", "am_cam_id": "261", "nome": "SCARPERIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1688866.51, 4874255.28 ] ] } },
    { "type": "Feature", "properties": { "gid": 262, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "262", "am_cam_id": "262", "nome": "SESTO FIORENTINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1676784.73, 4855597.57 ] ] } },
    { "type": "Feature", "properties": { "gid": 263, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "263", "am_cam_id": "263", "nome": "SIGNA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1668827.9, 4849871.92 ] ] } },
    { "type": "Feature", "properties": { "gid": 264, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "264", "am_cam_id": "264", "nome": "TAVARNELLE VAL DI PESA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1675502.37, 4825435.85 ] ] } },
    { "type": "Feature", "properties": { "gid": 266, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "266", "am_cam_id": "266", "nome": "VICCHIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1697906.91, 4867482.06 ] ] } },
    { "type": "Feature", "properties": { "gid": 267, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "267", "am_cam_id": "267", "nome": "MONTAGNA FIORENTINA", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1699684.475363059900701, 4855085.508449680171907 ] ] } },
    { "type": "Feature", "properties": { "gid": 268, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "268", "am_cam_id": "268", "nome": "MUGELLO", "tipo_ente": "COMUNIT MONTANA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1692139.544983749976382, 4869455.144234320148826 ] ] } },
    { "type": "Feature", "properties": { "gid": 269, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "269", "am_cam_id": "269", "nome": "FUCECCHIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1645807.685261740116403, 4843338.59123822953552 ] ] } },
    { "type": "Feature", "properties": { "gid": 270, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "270", "am_cam_id": "270", "nome": "CERRETO GUIDI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1651173.934396029915661, 4846910.570519150234759 ] ] } },
    { "type": "Feature", "properties": { "gid": 271, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "271", "am_cam_id": "271", "nome": "VINCI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1655044.823288569925353, 4850026.827965560369194 ] ] } },
    { "type": "Feature", "properties": { "gid": 272, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "272", "am_cam_id": "272", "nome": "CAPRAIA E LIMITE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1659438.181255540112033, 4845416.186024039983749 ] ] } },
    { "type": "Feature", "properties": { "gid": 273, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "273", "am_cam_id": "273", "nome": "MONTELUPO FIORENTINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1662712.802608029916883, 4843844.552130489610136 ] ] } },
    { "type": "Feature", "properties": { "gid": 274, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "274", "am_cam_id": "274", "nome": "MONTESPERTOLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1667430.092589299893007, 4834423.45433853007853 ] ] } },
    { "type": "Feature", "properties": { "gid": 275, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "275", "am_cam_id": "275", "nome": "EMPOLI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1656888.50070449989289, 4842533.717008709907532 ] ] } },
    { "type": "Feature", "properties": { "gid": 276, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "276", "am_cam_id": "276", "nome": "CASTELFIORENTINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1659114.924526409944519, 4829993.864261760376394 ] ] } },
    { "type": "Feature", "properties": { "gid": 277, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "277", "am_cam_id": "277", "nome": "MONTAIONE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1654437.6095812600106, 4823952.816014179959893 ] ] } },
    { "type": "Feature", "properties": { "gid": 278, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "278", "am_cam_id": "278", "nome": "GAMBASSI TERME", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1657861.236546709900722, 4822512.301189789548516 ] ] } },
    { "type": "Feature", "properties": { "gid": 279, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "279", "am_cam_id": "279", "nome": "CERTALDO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1664890.919624810107052, 4823644.764354189857841 ] ] } },
    { "type": "Feature", "properties": { "gid": 280, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "280", "am_cam_id": "280", "nome": "CIRCONDARIO EMPOLESE-VALDELSA", "tipo_ente": "CIRCONDARIO" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1657061.878716330043972, 4842571.823530400171876 ] ] } },
    { "type": "Feature", "properties": { "gid": 281, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "281", "am_cam_id": "281", "nome": "CORTONA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1742259.86, 4795706.54 ] ] } },
    { "type": "Feature", "properties": { "gid": 282, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "282", "am_cam_id": "282", "nome": "FOIANO DELLA CHIANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1728821.105, 4792708.565 ] ] } },
    { "type": "Feature", "properties": { "gid": 283, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "283", "am_cam_id": "283", "nome": "CASTIGLION FIORENTINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1737033.605, 4802913.25499999989 ] ] } },
    { "type": "Feature", "properties": { "gid": 284, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "284", "am_cam_id": "284", "nome": "MARCIANO DELLA CHIANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1725998.22, 4798471.41 ] ] } },
    { "type": "Feature", "properties": { "gid": 285, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "285", "am_cam_id": "285", "nome": "MONTE SAN SAVINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1720954.065, 4801240.69 ] ] } },
    { "type": "Feature", "properties": { "gid": 286, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "286", "am_cam_id": "286", "nome": "MONTERCHI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1751676.28, 4819458.985 ] ] } },
    { "type": "Feature", "properties": { "gid": 287, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "287", "am_cam_id": "287", "nome": "ANGHIARI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1747021.935, 4825395.32 ] ] } },
    { "type": "Feature", "properties": { "gid": 288, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "288", "am_cam_id": "288", "nome": "SANSEPOLCRO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1753729.79, 4829035.15 ] ] } },
    { "type": "Feature", "properties": { "gid": 289, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "289", "am_cam_id": "289", "nome": "CIVITELLA IN VAL DI CHIANA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1724404.03, 4809340.575 ] ] } },
    { "type": "Feature", "properties": { "gid": 290, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "290", "am_cam_id": "290", "nome": "AREZZO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1733152.38, 4816687.27 ] ] } },
    { "type": "Feature", "properties": { "gid": 291, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "291", "am_cam_id": "291", "nome": "PERGINE VALDARNO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1717264.72, 4816587.165 ] ] } },
    { "type": "Feature", "properties": { "gid": 292, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "292", "am_cam_id": "292", "nome": "CASTIGLION FIBOCCHI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1723369.835, 4823192.535 ] ] } },
    { "type": "Feature", "properties": { "gid": 293, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "293", "am_cam_id": "293", "nome": "LATERINA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1719040.01, 4820785.41 ] ] } },
    { "type": "Feature", "properties": { "gid": 294, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "294", "am_cam_id": "294", "nome": "CAPOLONA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1730957.395, 4827388.69 ] ] } },
    { "type": "Feature", "properties": { "gid": 295, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "295", "am_cam_id": "295", "nome": "SUBBIANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1731800.26, 4828748.99 ] ] } },
    { "type": "Feature", "properties": { "gid": 296, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "296", "am_cam_id": "296", "nome": "BUCINE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1711685.365, 4817399.63 ] ] } },
    { "type": "Feature", "properties": { "gid": 297, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "297", "am_cam_id": "297", "nome": "MONTEVARCHI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1707517.68, 4822186.495 ] ] } },
    { "type": "Feature", "properties": { "gid": 298, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "298", "am_cam_id": "298", "nome": "CAVRIGLIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1701139.685, 4821835.39499999955 ] ] } },
    { "type": "Feature", "properties": { "gid": 299, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "299", "am_cam_id": "299", "nome": "TERRANUOVA BRACCIOLINI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1708912.915, 4825261.71499999985 ] ] } },
    { "type": "Feature", "properties": { "gid": 300, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "300", "am_cam_id": "300", "nome": "LORO CIUFFENNA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1712454.495, 4830085.585 ] ] } },
    { "type": "Feature", "properties": { "gid": 301, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "301", "am_cam_id": "301", "nome": "SAN GIOVANNI VALDARNO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1704364.555, 4826656.905 ] ] } },
    { "type": "Feature", "properties": { "gid": 302, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "302", "am_cam_id": "302", "nome": "PIEVE SANTO STEFANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1745244.85, 4839605.5 ] ] } },
    { "type": "Feature", "properties": { "gid": 303, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "303", "am_cam_id": "303", "nome": "SESTINO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1765684.89, 4844782.79 ] ] } },
    { "type": "Feature", "properties": { "gid": 304, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "304", "am_cam_id": "304", "nome": "BADIA TEDALDA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1756646.65, 4844481.46 ] ] } },
    { "type": "Feature", "properties": { "gid": 305, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "305", "am_cam_id": "305", "nome": "CAPRESE MICHELANGELO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1740833.8, 4836709.95 ] ] } },
    { "type": "Feature", "properties": { "gid": 306, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "306", "am_cam_id": "306", "nome": "TALLA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1724946.55, 4831459.75 ] ] } },
    { "type": "Feature", "properties": { "gid": 307, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "307", "am_cam_id": "307", "nome": "CASTEL FOCOGNANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1728705.52, 4837089.35 ] ] } },
    { "type": "Feature", "properties": { "gid": 260, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "260", "am_cam_id": "260", "nome": "SCANDICCI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1673835.091376014519483, 4846658.266475414857268 ] ] } },
    { "type": "Feature", "properties": { "gid": 308, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "308", "am_cam_id": "308", "nome": "CHITIGNANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1732292.75, 4838309.8 ] ] } },
    { "type": "Feature", "properties": { "gid": 309, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "309", "am_cam_id": "309", "nome": "BIBBIENA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1727137.625, 4841808.0 ] ] } },
    { "type": "Feature", "properties": { "gid": 310, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "310", "am_cam_id": "310", "nome": "ORTIGNANO RAGGIOLO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1721892.3, 4840200.15 ] ] } },
    { "type": "Feature", "properties": { "gid": 311, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "311", "am_cam_id": "311", "nome": "CHIUSI DELLA VERNA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1736484.52, 4842753.43 ] ] } },
    { "type": "Feature", "properties": { "gid": 312, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "312", "am_cam_id": "312", "nome": "POPPI", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1722787.665, 4844874.375 ] ] } },
    { "type": "Feature", "properties": { "gid": 313, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "313", "am_cam_id": "313", "nome": "CASTEL SAN NICCOL", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1717872.475, 4846782.84499999974 ] ] } },
    { "type": "Feature", "properties": { "gid": 314, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "314", "am_cam_id": "314", "nome": "STIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1717925.385, 4853100.09 ] ] } },
    { "type": "Feature", "properties": { "gid": 315, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "315", "am_cam_id": "315", "nome": "PRATOVECCHIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1718984.7, 4852103.48 ] ] } },
    { "type": "Feature", "properties": { "gid": 316, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "316", "am_cam_id": "316", "nome": "CASTELFRANCO DI SOPRA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1706127.95, 4832965.8 ] ] } },
    { "type": "Feature", "properties": { "gid": 317, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "317", "am_cam_id": "317", "nome": "MONTEMIGNAIO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1710986.467297950061038, 4846341.57 ] ] } },
    { "type": "Feature", "properties": { "gid": 318, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "318", "am_cam_id": "318", "nome": "PIAN DI SC", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1705488.65, 4835211.65 ] ] } },
    { "type": "Feature", "properties": { "gid": 319, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "319", "am_cam_id": "319", "nome": "LUCIGNANO", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1722875.335, 4795008.775 ] ] } },
    { "type": "Feature", "properties": { "gid": 320, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "320", "am_cam_id": "320", "nome": "AREZZO", "tipo_ente": "PROVINCIA" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1733221.826634859899059, 4816678.425567770376801 ] ] } },
    { "type": "Feature", "properties": { "gid": 265, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "265", "am_cam_id": "265", "nome": "VAGLIA", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1686501.752689821412787, 4862889.187600770033896 ] ] } },
    { "type": "Feature", "properties": { "gid": 243, "area": 0.000000, "perimeter": 0.000000, "am_cam_": "243", "am_cam_id": "243", "nome": "FIRENZE", "tipo_ente": "COMUNE" }, "geometry": { "type": "MultiPoint", "coordinates": [ [ 1681145.353114033350721, 4848869.348600102588534 ] ] } }
  ]
};
},{"core/layers/features/feature":31,"core/layers/providers/provider":43,"core/utils/utils":71}],46:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');
var Filter = require('core/layers/filter/filter');

function WFSDataProvider(options) {
  options = options || {};
  base(this, options);
  this._name = 'wfs';
}

inherit(WFSDataProvider, DataProvider);

var proto = WFSDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};

proto.query = function(options) {
  var self = this;
  var filter = options.filter;
  var d = $.Deferred();
  this._doRequest(filter)
    .done(function(response) {
      var featuresForLayers = self.handleQueryResponseFromServer(response,'wfs');
      d.resolve({
        data: featuresForLayers
      });
    })
    .fail(function(e){
      d.reject(e);
    });
  return d.promise();
};

proto._post = function(url, params) {
  url = url + '/';
  return  $.post(url, params)

};

// get request
proto._get = function(url, params) {
  // trasformo i parametri
  var urlParams = $.param(params);
  url = url + '?' + urlParams;
  return $.get(url)
};

proto._doRequest = function(filter) {
  if (!(filter instanceof Filter)) {
    return;
  }
  var layer = this._layer;
  var url = layer.getQueryUrl();
  var crs = layer.getProjection().getCode();
  var infoFormat = layer.getInfoFormat();

  var params = {
    SERVICE: 'WFS',
    VERSION: '1.3.0',
    REQUEST: 'GetFeature',
    TYPENAME: layer.getQueryLayerName().replace(/ /g,'_'),
    OUTPUTFORMAT: infoFormat,
    SRSNAME:  crs
  };

  var bbox = filter.getBBOX();
  if (bbox) {
    params.BBOX = bbox.join();
    request = this._get(url, params)

  } else {
    var geometry = filter.getGeometry();
    if (geometry) {
      var f = ol.format.filter;
      var featureRequest = new ol.format.WFS().writeGetFeature({
        featureTypes: [layer],
        filter: f.intersects('the_geom', geometry)
      });
      filter = featureRequest.children[0].innerHTML;
      params.FILTER = filter;
      request = this._post(url, params)
    }
  }
  return request
};


module.exports = WFSDataProvider;
},{"core/layers/filter/filter":34,"core/layers/providers/provider":43,"core/utils/utils":71}],47:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var utils = require('core/utils/utils');
var geoutils = require('g3w-ol3/src/utils/utils');
var DataProvider = require('core/layers/providers/provider');
//vado a sovrascrivere il metodo per leggere le feature
// da un geojson
var PIXEL_TOLERANCE = 10;
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];

function WMSDataProvider(options) {
  options = options || {};
  base(this, options);
  this._name = 'wms';
  this._url = this._layer.getQueryUrl();
  this._layerName = this._layer.getName() || null; // prendo sempre il name del layer di QGIS, perché le query sono proxate e gestite da g3w-server
  this._infoFormat = this._layer.getInfoFormat() || 'application/vnd.ogc.gml';
}

inherit(WMSDataProvider, DataProvider);

var proto = WMSDataProvider.prototype;


proto._getRequestUrl = function(url, extent, size, pixelRatio, projection, params) {

  params['CRS'] = projection.getCode();

  if (!('STYLES' in params)) {
    params['STYLES'] = '';
  }

  params['DPI'] = 90 * pixelRatio;
  params['WIDTH'] = size[0];
  params['HEIGHT'] = size[1];

  var axisOrientation = projection.getAxisOrientation();

  var bbox;
  if (axisOrientation.substr(0, 2) == 'ne') {
    bbox = [extent[1], extent[0], extent[3], extent[2]];
  } else {
    bbox = extent;
  }
  params['BBOX'] = bbox.join(',');

  return utils.appendParams(url, params);
};

// funzione che deve esserere "estratta dal mapservice"
proto._getGetFeatureInfoUrlForLayer = function(url, coordinates,resolution,params) {
  var extent = geoutils.getExtentForViewAndSize(
    coordinates, resolution, 0,
    GETFEATUREINFO_IMAGE_SIZE);

  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': '1.3.0',
    'REQUEST': 'GetFeatureInfo',
    'FORMAT': 'image/png',
    'TRANSPARENT': true,
    'QUERY_LAYERS': this._layer.getName()
  };

  _.merge(baseParams, params);

  var x = Math.floor((coordinates[0] - extent[0]) / resolution);
  var y = Math.floor((extent[3] - coordinates[1]) / resolution);
  baseParams[ 'I' ] = x;
  baseParams['J'] = y;

  return this._getRequestUrl(
    url, extent, GETFEATUREINFO_IMAGE_SIZE,
    1, this._layer.getProjection(), baseParams);
};

proto.query = function(options) {
  var d = $.Deferred();
  var coordinates = options.coordinates || [];
  var resolution = options.resolution || null;
  var url = this._url;
  var sourceParam = url.split('SOURCE');
  if (sourceParam.length) {
    url = sourceParam[0];
    
    if (sourceParam.length > 1) {
      sourceParam = '&SOURCE' + sourceParam[1];
    } else {
      sourceParam = '';
    }
  }
  
  var params = {
    LAYERS: this._layerName,
    QUERY_LAYERS: this._layerName,
    INFO_FORMAT: this._infoFormat,
    FEATURE_COUNT: 10,
    // PARAMETRI DI TOLLERANZA PER QGIS SERVER
    FI_POINT_TOLERANCE: PIXEL_TOLERANCE,
    FI_LINE_TOLERANCE: PIXEL_TOLERANCE,
    FI_POLYGON_TOLERANCE: PIXEL_TOLERANCE,
    G3W_TOLERANCE: PIXEL_TOLERANCE * resolution
  };
  var getFeatureInfoUrl = this._getGetFeatureInfoUrlForLayer(url, coordinates, resolution, params);
  var queryString = getFeatureInfoUrl.split('?')[1];
  url += '?'+queryString + sourceParam;

  this.makeQueryForLayer(url, coordinates, resolution)
    .then(function(response) {
      d.resolve(response)
    })
    .fail(function(e){
      d.reject(e);
    });
  return d.promise();
};

proto.makeQueryForLayer = function(url, coordinates, resolution) {
  var d = $.Deferred();
  var queryInfo = {
    coordinates: coordinates,
    resolution: resolution
  };
  this.doRequestAndParse(url)
    .then(function(response){
      d.resolve({
        data: response,
        query: queryInfo
      });
    })
    .fail(function(e){
      d.reject(e);
    });
  return d.promise()
};

proto.doRequestAndParse = function(url) {
  var self = this;
  var d = $.Deferred();
  $.get(url)
    .done(function(response) {
      var featuresForLayers = self.handleQueryResponseFromServer(response, this._infoFormat, this._layerName);
      d.resolve(featuresForLayers);
    })
    .fail(function(){
      d.reject();
    });
  return d;
};



module.exports = WMSDataProvider;

},{"core/layers/providers/provider":43,"core/utils/utils":71,"g3w-ol3/src/utils/utils":102}],48:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function XMLDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'xml';
}

inherit(XMLDataProvider, DataProvider);

var proto = XMLDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};

module.exports = XMLDataProvider;
},{"core/layers/providers/provider":43,"core/utils/utils":71}],49:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var Layer = require('./layer');
var Editor = require('core/editing/editor');
var FeaturesStore = require('./features/featuresstore');

function TableLayer(config) {
  base(this, config);

  this.type = Layer.LayerTypes.TABLE;

  this._editor = new Editor(this);
  this._featuresStore = new FeaturesStore({
    provider: this.providers.data
  });
}
inherit(TableLayer, Layer);

var proto = TableLayer.prototype;

proto.getEditor = function() {
  return this._editor;
};

proto.setEditor = function(editor) {
  this._editor = editor;
};

proto._startEditing = function() {
  console.log('start editing');
};

proto._stopEditing = function() {
  console.log('stop editing');
  // this.editor.stop()
};

proto.getFeaturesStore = function() {
  return this._featuresStore;
};

// funzione per la lettura dei dati precedentemente acquisiti dal provider
proto.readFeatures = function() {
  return this._featuresStore.readFeatures();
};

proto._clearFeatures = function() {
  this._featuresStore.clearFeatures();
};

// funzione che recupera i dati da qualsisasi fonte (server, wms, etc..)
proto.getFeatures = function(options) {
  var self = this;
  var d = $.Deferred();
  this._featuresStore.getFeatures(options)
    .then(function(features) {
      return d.resolve(features);
    });
  return d.promise();
};


module.exports = TableLayer;
},{"./features/featuresstore":32,"./layer":37,"core/editing/editor":25,"core/utils//utils":71,"core/utils/utils":71}],50:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var mixin = require('core/utils/utils').mixin;
var TableLayer = require('./tablelayer');
var GeoLayerMixin = require('./geolayermixin');

function VectorLayer(config) {
  config = config || {};
  /*{
   id,
   title,
   name,
   origname,
   multilayerid,
   servertype,
   source,
   crs,
   projection,
   bbox,
   capabilities,
   cache_url,
   baselayer,
   geometrytype,
   editops,
   expanded,
   fields,
   wmsUrl,
   infoformat,
   infourl,
   maxscale,
   minscale,
   visible,
   scalebasedvisibility,
   wfscapabilities
   }*/

  base(this,config);

  this.type = Layer.LayerTypes.VECTOR;

  // vado a modificare lo state aggiungendo il bbox e l'informazione geolayer
  _.extend(this.state, {
    geolayer: true,
    bbox: config.bbox || null
  });
}
inherit(VectorLayer, TableLayer);
mixin(VectorLayer, GeoLayerMixin);

var proto = VectorLayer.prototype;

module.exports = VectorLayer;
},{"./geolayermixin":35,"./tablelayer":49,"core/utils//utils":71,"core/utils/utils":71}],51:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function BingLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(BingLayer,MapLayer);

var proto = BingLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;

  var olLayer;
  var subtype = this.layer.state.source ? this.layer.state.source.subtype : null
  switch(subtype) {
    case 'streets':
      olLayer = BaseLayers.BING.Road;
      break;
    case 'aerial':
      olLayer = BaseLayers.BING.Aerial;
      break;
    case 'aerialwithlabels':
      olLayer = BaseLayers.BING.AerialWithLabels;
      break;
    default:
      olLayer = BaseLayers.BING.Aerial;
      break;
  }
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto._updateLayer = function(mapState,extraParams){
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = BingLayer;

},{"core/map/layer/maplayer":54,"core/utils/geo":70,"core/utils/utils":71,"g3w-ol3/src/layers/bases":96}],52:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function LoaderLayerService() {
  this._layers = {};
  this._type = 'tipo di layers';
  this._isReady = false;
  base(this);
}
inherit(LoaderLayerService, G3WObject);

var proto = LoaderLayerService.prototype;

proto.getLoaderType = function() {
    return this._type;
};

proto.getLayers = function() {
  return this._layers;
};

proto.getLayer = function(layerName) {
  return this._layers[layerName];
};

proto.loadLayer = function(url, options) {
  //TODO
};
proto.loadLayers = function() {
  //TODO
};

proto.cleanUpLayers = function() {
  //TODO
};

proto.setReady = function(bool) {
  this._isReady = bool;
};

proto.isReady = function() {
  return this._isReady;
};

// setto il modo di caricare il layer
proto.setMode = function(mode) {
  switch(mode){
    case 'w':
      this._editingMode = true;
      break;
    case 'r':
      this._editingMode = false;
      break;
    default:
      mode = 'w';
      this._editingMode = true;
  }
  this._mode = mode;
  this.emit('setmode', mode);
};

proto.getMode = function() {
  return this._mode;
};



module.exports = LoaderLayerService;
},{"core/g3wobject":27,"core/utils/utils":71}],53:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var resolvedValue = require('core/utils/utils').resolve;
var VectorLayer = require('core/map/layer/vectorlayer');
var LoaderLayer = require('./loaderlayer');

function VectorLoaderLayer() {
  this._layer = {};
  this._type = 'vector';
  this._layerCodes = [];
  this._baseUrl = '';
  this._mapService = null;
  this._loadedExtent = null;
  this._editingMode = false;
  this._customUrlParameters = '';
  //mi tengo i vectorLayersCodes dei layer caricati
  this._vectorLayersCodes = [];
  this._vectorLayersData = {};
  base(this);
  //setto le proprià che mi interessano
  this.init = function(options) {
    //i layers provenienti dal plugin
    this._layers = options.layers || {};
    // il base url per poter fare richieste al server
    this._baseUrl = options.baseurl || '';
    // il map service per ineragire con la mappa
    // recuperando il bbox del layer vettoriale
    this._mapService = options.mapService || null;
    // i codice dei layers per poter recuperare le informazioni
    // dei layers passati dal plugin
    this._layerCodes = _.keys(this._layers);
    // questo mi permette di gestire e generalizzare il valore del campo del layer
    // a cui passare all'apiEditing
    this._editingApiField = options.editingApiField || 'name';
  };
}

inherit(VectorLoaderLayer, LoaderLayer);

var proto = VectorLoaderLayer.prototype;
// funzione principale, starting point, chiamata dal plugin per
// il recupero dei vettoriali (chiamata verso il server)
proto.loadLayers = function(mode, customUrlParameters) {
    // il parametro mode mi di è in scrittura, lettura etc ..
  var self = this;
  var deferred = $.Deferred();
  // tiene conto dei codici dei layer che non sono stati
  // i dati vettoriali
  var noVectorlayerCodes = [];
  // setto il mode (r/w)
  this.setMode(mode);
  //verifico che ci siano parametri custom (caso di alcuni plugin) da aggiungere alla base url
  // per fare le chiamate al server
  if (customUrlParameters) {
    this._setCustomUrlParameters(customUrlParameters)
  }
  //verifica se sono stati caricati i vettoriali dei layer
  // attraverso la proprietà vector del layer passato dal plugin
  _.forEach(this._layers, function(layer, layerCode) {
    // verifico se l'attributo vector è nullo
    if (_.isNull(layer.vector)) {
      noVectorlayerCodes.push(layerCode);
    }
  });
  // eseguo le richieste delle configurazioni e mi tengo le promesse
  var vectorLayersSetup = _.map(noVectorlayerCodes, function(layerCode) {
    return self._setupVectorLayer(layerCode);
  });
    // emetto l'evento loadingvectorlayersstart (il pluginservice è in ascolto)
  self.emit('loadingvectorlayersstart');
  // aspetto tutte le promesse del setup vector
  $.when.apply(this, vectorLayersSetup)
    // una volta che tutte le configurazioni dei layer vecor
    // sono state prese dal server e dopo aver assegnato all'attributo vector
    // del layer plugin il layer vettoriale costruito con le configurazioni
    // di sopra
    .then(function() {
      // le promesse ritornano il layerCode del layer vettoriale appena costuito
      var vectorLayersCodes = Array.prototype.slice.call(arguments);
      // emtto evento che inzia il recupero dei dati dei layer vettoriali (geojson)
      self.emit('loadingvectolayersdatastart');
      // inizio a caricare tutti i vettoriali dopo aver caricato le configurazioni
      self.loadAllVectorsData(vectorLayersCodes)
      .then(function() {
        self._vectorLayersCodes = vectorLayersCodes;
        deferred.resolve(vectorLayersCodes);
        // emtto evento che ho ricevuto i layers
        self.emit('loadingvectorlayersend');
        // ora il loader è pronto
        self.setReady(true);

      })
      .fail(function() {
        // risetto tutti i layer veetotiali a null
        _.forEach(self._layers, function(layer) {
          layer.vector = null;
        });
        deferred.reject();
        // emttto che c'è stato un errore nel loading dei dati che vengono dal server
        self.emit('errorloadingvectorlayersend');
        self.setReady(false);
      })
  })
  .fail(function() {
    self.setReady(false);
    self.emit('errorloadingvectorlayersend');
    deferred.reject();
  });
  return deferred.promise();
};

proto.setVectorLayersCodes = function(vectorLayersCodes) {
  this._vectorLayersCodes = vectorLayersCodes;
};

proto.getVectorLayersCodes = function() {
  return this._vectorLayersCodes;
};

proto.getLayers = function() {
  return this._layers;
};

// funzione che fa il reload che rihiede di nuovo il dati del vetor layer
// caso in cui si lavora con un layer vettoriale e non si usa un wms per fare la query
proto.reloadVectorData = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  var bbox = this._mapService.state.bbox;
  self._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
          self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
          vectorLayer.setData(vectorDataResponse.vector.data);
          deferred.resolve(vectorLayer);
        });
    });
  return deferred.promise();
};

//funzione che permette di ottenere tutti i dati relativi ai layer vettoriali caricati
//prima si è ottenuta la coinfigurazione, ora si ottengono i dati veri e propri
proto.loadAllVectorsData = function(layerCodes) {
    var self = this;
    var deferred = $.Deferred();
    var layers = this._layers;
    // verifico che il BBOX attuale non sia stato già  caricato
  // prondo il bbox
    var bbox = this._mapService.state.bbox;
    var loadedExtent = this._loadedExtent;
    if (loadedExtent && ol.extent.containsExtent(loadedExtent, bbox)) {
      return resolvedValue();
    }
    if (!loadedExtent) {
      this._loadedExtent = bbox;
    } else {
      this._loadedExtent = ol.extent.extend(loadedExtent, bbox);
    }
    if (layerCodes) {
      layers = [];
      _.forEach(layerCodes, function(layerCode) {
        layers.push(self._layers[layerCode]);
      });
    }
    //per ogni layer del plugin che non ha il layer vado a caricare i dati del layer vettoriale
    var vectorDataRequests = _.map(layers, function(Layer) {
        return self._loadVectorData(Layer.vector, bbox);
    });

    $.when.apply(this, vectorDataRequests)
        .then(function() {
            deferred.resolve(layerCodes);
        })
        .fail(function(){
            deferred.reject();
        });

    return deferred.promise();
};

proto._setCustomUrlParameters = function(customUrlParameters) {
  this._customUrlParameters = customUrlParameters;
};

proto._checkVectorGeometryTypeFromConfig = function(vectorConfig) {
  switch (vectorConfig.geometrytype) {
    case 'Line':
      vectorConfig.geometrytype = 'LineString';
      break;
    case 'MultiLine':
      vectorConfig.geometrytype = 'MultiLineString';
      break;
  }
  return vectorConfig;
};


proto._createVectorLayerFromConfig = function(layerCode) {
  var self = this;
  // recupero la configurazione del layer settata da plugin service
  var layerConfig = this._layers[layerCode];
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._getVectorLayerConfig(layerConfig[this._editingApiField])
    .then(function(vectorConfigResponse) {
      var vectorConfig = vectorConfigResponse.vector;
      // vado a verificare la correttezza del geometryType (caso di editing generico)
      vectorConfig = self._checkVectorGeometryTypeFromConfig(vectorConfig);
      // una volta ottenuta dal server la configurazione vettoriale,
      // provvedo alla creazione del layer vettoriale
      var crsLayer = layerConfig.crs || self._mapService.getProjection().getCode();
      var vectorLayer = self._createVectorLayer({
        geometrytype: vectorConfig.geometrytype,
        format: vectorConfig.format,
        crs: self._mapService.getProjection().getCode(),
        crsLayer : crsLayer,
        id: layerConfig.id,
        name: layerConfig.name,
        pk: vectorConfig.pk,
        editing: self._editingMode
      });
      // setto i campi del layer
      vectorLayer.setFields(vectorConfig.fields);
      vectorLayer.setCrs(crsLayer);
      // questo è la proprietà della configurazione del config layer
      // che specifica se esistono relazioni con altri layer
      // sono array di oggetti che specificano una serie di
      // informazioni su come i layer sono relazionati (nome della relazione == nome layer)
      // foreign key etc ..
      var relations = vectorConfig.relations;
      // nel caso il layer abbia relazioni (array non vuoto)
      if (relations) {
        // per dire a vectorLayer che i dati
        // delle relazioni verranno caricati solo quando
        // richiesti (es. aperture form di editing)
        vectorLayer.lazyRelations = true;
        //vado a settare le relazioni del vector layer
        vectorLayer.setRelations(relations);
      }
      // setto lo stile del layer OL
      if (layerConfig.style) {
        vectorLayer.setStyle(layerConfig.style);
      }
      // risolve con il nome del vectorLayer
      deferred.resolve(vectorLayer);
    })
    .fail(function(){
      deferred.reject();
    });
  return deferred.promise();
};

// funzione che dato la configurazione del layer fornito dal plugin (style, editor, vctor etc..)
// esegue richieste al server al fine di ottenere configurazione vettoriale del layer
proto._setupVectorLayer = function(layerCode) {
    var self = this;
    var deferred = $.Deferred();
    // eseguo le richieste delle configurazioni
    this._createVectorLayerFromConfig(layerCode)
        .then(function(vectorLayer) {
            var layerConfig = self._layers[layerCode];
            // assegno il vetorLayer appena creato all'attributo vector del layer
            layerConfig.vector = vectorLayer;
            // risolve con il nome del layerCode
            deferred.resolve(layerCode);
        })
        .fail(function() {
            deferred.reject();
        });
    return deferred.promise();
};

//in base all bbox e la layer chiedo al server di restituirmi il vettoriale (geojson) del layer
proto._loadVectorData = function(vectorLayer, bbox) {
    var self = this;
    // eseguo le richieste dei dati al server al fine di ottenere il geojson,
    // vettoriale, del layer richiesto
    return self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
            self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
            // setto i dati vettoriali del layer vettoriale
            // e verifico se siamo in editingMode write e se ci sono featurelocks
            if (self._editingMode && vectorDataResponse.featurelocks) {
              // nel cso in cui sia in editing (mode w) e che si siano featureLocks
              // setto tale features al layervettoriale
              self.setVectorFeaturesLock(vectorLayer, vectorDataResponse.featurelocks);
            }
            //setto i dati del layer vettoriale (geojson)
            vectorLayer.setData(vectorDataResponse.vector.data);
          if (self._)
            return vectorDataResponse;
        })
      .fail(function() {
        return false;
      })
};

proto.getVectorLayerData = function(layerCode) {
  return this._vectorLayersData[layerCode];
};

proto.getVectorLayersData = function() {
  return this._vectorLayersData;
};

proto.setVectorLayerData = function(layerCode, vectorLayerData) {
  this._vectorLayersData[layerCode] = vectorLayerData;
};

//funzione che setta le features lock del layer vettoriale
proto.setVectorFeaturesLock = function(vectorLayer, featureslock) {
  //vado a pescare le fifferenze tra le featureidlock già caricati id
  var newFeaturesLockIds = _.differenceBy(featureslock, vectorLayer.getFeatureLocks(), 'featureid');
  _.forEach(newFeaturesLockIds, function(newLockId) {
    vectorLayer.addLockId(newLockId)
  });
};

proto.cleanVectorFeaturesLock = function(vectorLayer) {
  vectorLayer.cleanFeatureLocks();
};

proto.lockFeatures = function(layerName) {
  var self = this;
  var d = $.Deferred();
  var bbox = this._mapService.state.bbox;
  var vectorLayer = this._layers[layerName].vector;
  $.get(this._baseUrl+layerName+"/?lock" + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      self.setVectorFeaturesLock(vectorLayer, data.featurelocks);
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
    var d = $.Deferred();
    // attravercso il layer name e il base url
    // chiedo la server di inviarmi la configurazione editing del laye
    $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
        .done(function(data) {
            d.resolve(data);
        })
        .fail(function(){
            d.reject();
        });
    return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
    var d = $.Deferred();
    var lock = this.getMode() == 'w' ? true : false;
    var apiUrl;
    if (lock) {
      apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
    } else {
      apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
    }
    $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
        .done(function(data) {
            d.resolve(data);
        })
        .fail(function(){
            d.reject();
        });
    return d.promise();
};
// funzione per creare il layer vettoriale
proto._createVectorLayer = function(options) {
  var vector = new VectorLayer(options);
  return vector;
};
//funzione chiamata dal plugin quando si vuole fare un cleanUp dei layers
// !!! -- DA RIVEDERE -- !!!
proto.cleanUpLayers = function() {
    this._loadedExtent = null;
};

module.exports = VectorLoaderLayer;
},{"./loaderlayer":52,"core/map/layer/vectorlayer":56,"core/utils/utils":71}],54:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function MapLayer(config){
  this.config = config || {};
  this.id = config.id;
  this.projection = config.projection;
  this._olLayer = null;
  base(this);
}

inherit(MapLayer, G3WObject);

var proto = MapLayer.prototype;

proto.getId = function(){
  return this.id;
};

module.exports = MapLayer;

},{"core/g3wobject":27,"core/utils/utils":71}],55:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function OSMLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(OSMLayer,MapLayer);

var proto = OSMLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;

  
  var olLayer = BasesLayers.OSM;
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto._updateLayer = function(mapState,extraParams){
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = OSMLayer;

},{"core/map/layer/maplayer":54,"core/utils/geo":70,"core/utils/utils":71,"g3w-ol3/src/layers/bases":96}],56:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var truefnc = require('core/utils/utils').truefnc;
var resolve = require('core/utils/utils').resolve;
var reject = require('core/utils/utils').reject;
var G3WObject = require('core/g3wobject');

function VectorLayer(config) {
  var config = config || {};
  this.geometrytype = config.geometrytype || null;
  this.format = config.format || null;
  this.crs = config.crs  || null;
  this.crsLayer = config.crsLayer || this.crs;
  this.id = config.id || null;
  this.name = config.name || "";
  this.pk = config.pk || "id"; // TODO: il GeoJSON setta l'id della feature da sé, e nasconde il campo PK dalle properties. In altri formati va verificato, e casomai usare feature.setId()
  this._newPrefix = '_new_';
  this._olSource = new ol.source.Vector({
    features: new ol.Collection()
  });
  this._olLayer = new ol.layer.Vector({
    name: this.name,
    source: this._olSource
  });
  this._isReady = false;
  /*
   * Array di oggetti:
   * {
   *  name: Nome dell'attributo,
   *  type: integer | float | string | boolean | date | time | datetime,
   *  input: {
   *    label: Nome del campo di input,
   *    type: select | check | radio | coordspicker | boxpicker | layerpicker | fielddepend,
   *    options: {
   *      Le opzioni per lo spcifico tipo di input (es. "values" per la lista di valori di select, check e radio)
   *    }
   *  }
   * }
  */
  this._PKinAttributes = false;
  this._featuresFilter = null;
  this._fields = null;
  this._relationsDataLoaded = {};
  this.lazyRelations = true;
  this._relations = null;
  this._editingMode = config.editing || false;
  this._loadedIds = [];
  this._featureLocks = [];
  this._crs = null;
}

inherit(VectorLayer,G3WObject);

module.exports = VectorLayer;

var proto = VectorLayer.prototype;

proto.getPk = function() {
  return this.pk;
};

proto.setData = function(featuresData) {
  var self = this;
  var Ids = [];
  var features;
  if (this.format) {
    switch (this.format){
      case "GeoJSON":
        var geojson = new ol.format.GeoJSON({
          geometryName: "geometry"
        });
        features = geojson.readFeatures(featuresData, {
          dataProjection: self.crsLayer,
          featureProjection: self.crs
        });
        break;
    }
    if (this._editingMode && this._featureLocks) {
      features = _.filter(features, function(feature) {
        var hasFeatureLock = false;
        _.forEach(self._featureLocks,function(featureLock){
          if (featureLock.featureid == feature.getId()) {
            hasFeatureLock = true;
            Ids.push(feature.getId());
          }
        });
        return hasFeatureLock;
      })
    }
    
    if (features && features.length) {
      if (!_.isNull(this._featuresFilter)){
        features = _.map(features,function(feature){
          return self._featuresFilter(feature);
        });
      }
      var featuresToLoad = _.filter(features,function(feature) {
        return !_.includes(self._loadedIds,feature.getId());
      });

      this._olSource.addFeatures(featuresToLoad);
      // verifico, prendendo la prima feature, se la PK è presente o meno tra gli attributi
      var attributes = this.getSource().getFeatures()[0].getProperties();
      this._PKinAttributes = _.get(attributes,this.pk) ? true : false;
      this._loadedIds = _.union(this._loadedIds, Ids);
    }
  }
  else {
    console.log("VectorLayer format not defined");
  }
};
proto.cleanFeatureLocks = function() {
  this._featureLocks = [];
};

proto.setFeatureLocks = function(featurelocks) {
  this._featureLocks = featurelocks;
};

proto.getFeatureLocks = function() {
  return this._featureLocks;
};

proto.addLockId = function(lockId) {
  this._featureLocks.push(lockId);
};

// funzione che serve ad aggiornare o settare gli attibuti ad una feature
// viene sfruttatat al momento del salvataggio in editing di una feature
proto.setFeatureData = function(oldfid,fid,geometry,attributes) {
  var self = this;
  // vado a prende il vecchio fid (id temporaneo _new_...) oppure prendo una feature già esistente
  var feature = this.getFeatureById(oldfid) || this.getFeatureById(fid);
  // se la feature esiste vuol dire che simao nel caso di una nuoav feature
  if (feature) {
    if (oldfid && oldfid != fid) {
      feature.setId(fid);
    }
    if(geometry) {
      feature.setGeometry(geometry);
    }
    if (attributes) {
      var oldAttributes = feature.getProperties();
      var newAttributes = _.assign(oldAttributes, attributes);
      feature.setProperties(newAttributes);
    }
  }
  // vado a cambiare modificarele relazioni esistenti
  // in base alle relationi nuove Cambio id etc..)
  // NON È DETTO CHE SIA LEGATO AD UN CAMBIO DI FEATURE
  if (attributes && attributes.relations) {
    this.addRelationElements(attributes.relations);
  }

  return feature;
};

// funzione che va ada modificare la relaione/relazioni aggiunte della feature esistetnte
// si ha nel caso di un inserimento di una nuova relazione)
proto.addRelationElements = function(relations) {
  var self = this;
  var fid = relations.featureid;
  var feature = this.getFeatureById(fid);
  // scorro sulle relazioni ritornate dal server dopo un commit (new)
  // sono oggetto con chiave nome della relazione e valore gli elementi aggiunti
  _.forEach(relations, function(elements, relationName) {
    // scorro sulle relazioni di quella feature che sono state aggiunte
    _.forEach(self._relationsDataLoaded[fid], function(relationLoaded) {
      if (relationLoaded.name == relationName) {
        _.forEach(elements, function(element) {
          _.forEach(relationLoaded.elements, function(ele) {
            if (ele.id == element.clientid ) {
              ele.id = element.id;
            }
          })
        })
      }
    })
  })
};

proto.addFeature = function(feature) {
  this.getSource().addFeature(feature);
};

proto.addFeatures = function(features) {
  this.getSource().addFeatures(features);
};

proto.modifyFeatureGeometry = function(featureId, geometry) {
  var features = this.getFeatures();
  var feature = null;
  _.forEach(features, function(feature, index) {
    if (feature.getId() == featureId) {
      features[index].setGeometry(geometry);
      feature = feature[index];
      return feature
    }
  });
  return feature;
};

proto.setFeaturesFilter = function(featuresFilter){
  this._featuresFilter = featuresFilter;
};

proto.setFields = function(fields) {
  this._fields = fields;
};

proto.setCrs = function(crs) {
  this._crs = crs;
};

proto.getCrs = function() {
  return this._crs;
};

proto.setPkField = function(){
  var self = this;
  var pkfieldSet = false;
  _.forEach(this._fields,function(field){
    if (field.name == self.pk ){
      pkfieldSet = true;
    }
  });
  
  if (!pkfieldSet) {
    this._fields;
  }
};

proto.getFeatures = function() {
  return this.getSource().getFeatures();
};

proto.getFeatureIds = function(){
  var featureIds = _.map(this.getSource().getFeatures(), function(feature){
    return feature.getId();
  });
  return featureIds
};

// funzione che recurepa le feature del vector layer in base alla geometria passata
proto.getIntersectedFeatures = function(geometry) {
  var features = [];
  _.forEach(this.getFeatures(), function(feature) {
    if (geometry.intersectsExtent(feature.getGeometry().getExtent())) {
      features.push(feature);
    }
  });
  return features
};


proto.getFields = function(){
  return _.cloneDeep(this._fields);
};

// funzione che mi server per la query result nel caso di vector layer
proto.getAttributes = function() {
  return this._fields;
};

proto.getFieldsNames = function(){
  return _.map(this._fields,function(field){
    return field.name;
  });
};
// funzione che serve ad esempio all'openEditorFor per popolare
// il form con i campi della feature e i relativi valori (nel caso di editing di una feature esistente)
proto.getFieldsWithValues = function(obj) {
  var self = this;
  // clono i fields in quanto non voglio modificare i valori originali
  var fields = _.cloneDeep(this._fields);
  var feature, attributes;
  // il metodo accetta sia feature che fid
  if (obj instanceof ol.Feature){
    feature = obj;
  }
  else if (obj){
    feature = this.getFeatureById(obj);
  }
  // se c'è una feature ne prendo le proprietà
  if (feature) {
    attributes = feature.getProperties();
  }
  _.forEach(fields, function(field){
    if (feature){
      if (!this._PKinAttributes && field.name == self.pk) {
        if (self.isNewFeature(feature.getId())) {
          field.value = null;
        } else {
          field.value = feature.getId();
        }
      } else {
        
        field.value = attributes[field.name];
      }
    }
    else{
      field.value = null;
    }
  });

  return fields;
};

// funzione che setta e relazione del layer vettoriale
proto.setRelations = function(relations) {
  // assegno al valore _relations l'array relazioni
  this._relations = relations;
  // è un array contenete le relazioni con altri layers
  _.forEach(relations, function(relation) {
    // per ogni relazione scorro sull'attributo fields (array) di oggetti
    // che descrivono  i campi del layer relazione
    _.forEach(relation.fields, function(field, idx) {
      if (field.name == relation.pk) {
        // aggiung ll'atributo pkFieldIndex
        // che mi servirà per recuperare il campo
        // primary del layer relazione
        // setto indice del campo chiave primaria
        relation.pkFieldIndex = idx
      }
    })
  })
};
// resituisce le relazioni
proto.getRelations = function() {
  return this._relations;
};

// retituisce un oggetto contenente nome relazione e fileds(attributi) associati
proto.getRelationsAttributes = function() {
  var fields = {};
  _.forEach(this._relations, function(relation) {
    fields[relation.name] = relation.fields;
  });
  return fields;
};
proto.getRelation = function(relationName) {
  var relation;
  _.forEach(this._relations,function(_relation){
    if (_relation.name == relationName) {
      relation = _relation;
    }
  });
  return relation;
};

proto.hasRelations = function() {
  return !_.isNull(this._relations);
};

proto.getRelationPkFieldIndex = function(relation) {
  var pkFieldIndex;
  _.forEach(relation.fields,function(field,idx){
    if (field.name == relation.pk) {
      pkFieldIndex = idx;
    }
  });
  return pkFieldIndex;
};

proto.getRelationElementPkValue = function(relation,element) {
  var pkFieldIndex = this.getRelationPkFieldIndex(relation);
  return element.fields[pkFieldIndex].value;
};

proto.getRelationsFksKeys = function(){
  var fks = [];
  _.forEach(this._relations,function(relation){
    fks.push(relation.fk);
  });
  return fks;
};

proto.getRelationFields = function(relation) {
  return relation.fields;
};

proto.getRelationFieldsNames = function(relation){
  return _.map(relationFields,function(field){
    return field.name;
  });
};

// ottengo le relazioni a partire dal fid di una feature esistente
proto.getRelationsWithValues = function(fid) {
  var self = this;
  if (!this._relations) {
    // se non ha nessuna relazione
    // rirotno array vuoto
    resolve([]);
  }
  // altrimenti creo un clone dell'attributo relations
  var relations = _.cloneDeep(this._relations);
  // se non è stato settao l'id della feature e quindi la feature non esiste
  // vado a creare la strutture lelations element (array)
  if (!fid && !this.getFeatureById(fid)) {
    _.forEach(relations, function(relation) {
      relation.elements = [];
    });
    return resolve(relations);
  }
  else {
    if (this.lazyRelations) {
      //verifico se sono già state caricate le relazioni di quella feature
      if (!self._relationsDataLoaded[fid]) {
        var deferred = $.Deferred();
        var attributes = this.getFeatureById(fid).getProperties();
        var fks = {};
        _.forEach(relations, function(relation) {
          var keyVals = [];
          _.forEach(relation.fk, function(fkKey) {
            // verifico che la foreingkey sia la primary key del layer e a questo punto
            // prendo il fid altrimenti prendo il valore dell'attributo della feature
            if (fkKey == self.pk)  {
              fks[fkKey] = fid;
            } else {
              fks[fkKey] = attributes[fkKey];
            }
          });
        });
        this.getRelationsWithValuesFromFks(fks)
          .then(function(relationsResponse){
            self._relationsDataLoaded[fid] = relationsResponse;
            deferred.resolve(relationsResponse);
          })
          .fail(function(){
            deferred.reject();
          });
        return deferred.promise();
      }
      else {
        return resolve(this._relationsDataLoaded[fid]);
      }
    }
    else {
      return resolve(this._relations); // vuol dire che gli elementi delle relazioni sono stati già inseriti in fase di creazione del vettoriale
    }
  }
};

// ottengo le relazioni valorizzate a partire da un oggetto con le chiavi FK come keys e i loro valori come values
proto.getRelationsWithValuesFromFks = function(fks, newRelation) {
  var self = this;
  var relations = _.cloneDeep(this._relations);
  var relationsRequests = [];

  _.forEach(relations,function(relation){
    relation.elements = []; // creo la proprietà che accoglierà gli elementi della relazione ( e che quindi li cacherà)
    var url = relation.url;
    var keyVals = [];
    _.forEach(relation.fk,function(fkKey){
      var fkValue = fks[fkKey];
      keyVals.push(fkKey+"="+fkValue);
    });
    var fkParams = _.join(keyVals,"&");
    url += "?"+fkParams;
    relationsRequests.push($.get(url)
      .then(function(relationsElements){
        if (relationsElements.length) {
          _.forEach(relationsElements,function(relationElement){
            var element = {};
            element.fields = _.cloneDeep(relation.fields); // i campi li metto anche in ogni elemento, in modo da poterne assegnarne i valori
            _.forEach(element.fields,function(field){ // assegno i valori ai campi
              field.value = relationElement[field.name];
              if (field.name == relation.pk) {
                element.id = field.value; // aggiungo element.id dandogli il valore della chiave primaria della relazione
                var state = newRelation ? 'NEW' : 'OLD';
                element.state = state; // flag usato per identificare elemento: 'NEW', 'OLD', 'DELETED'
              }
            });
            relation.elements.push(element);
          })
        }
      })
    )
  });
  
  return $.when.apply(this,relationsRequests)
  .then(function(){
    return relations; // le relazioni e i loro elementi sono immutabili; le modifiche vanno nei RelationEditBuffer
  });
};

proto.getNewRelationsWithValuesFromFks = function(fks){
  return this.getRelationsWithValuesFromFks(fks, true)
};

// data una feature verifico se ha tra gli attributi i valori delle FK delle (eventuali) relazioni
proto.featureHasRelationsFksWithValues = function(feature){
  var attributes = feature.getProperties();
  var fksKeys = this.getRelationsFksKeys();
  return _.every(fksKeys,function(fkKey){
    var value = attributes[fkKey];
    return (!_.isNil(value) && value != '');
  })
};

// data una feature popolo un oggetto con chiavi/valori delle FK delle (eventuali) relazione
proto.getRelationsFksWithValuesForFeature = function(feature){
  var attributes = feature.getProperties();
  var fks = {};
  var fksKeys = this.getRelationsFksKeys();
  _.forEach(fksKeys,function(fkKey){
    fks[fkKey] = attributes[fkKey];
  });
  return fks;
};

//vado a settare le nuove relaioni dopo che ho fatto save del form
proto.setRelationsData = function (fid, relationsData) {
  this._relationsDataLoaded[fid] = relationsData;
};

proto.setStyle = function(style){
  this._olLayer.setStyle(style);
};

proto.getMapLayer = function(){
  return this._olLayer;
};

proto.getSource = function(){
  return this._olLayer.getSource();
};

proto.getFeatureById = function(fid){
  if (fid) {
    return this._olLayer.getSource().getFeatureById(fid);
  }
};

proto.isVisible = function() {
  return this._olLayer.getVisible();
};

proto.setVisible = function(bool) {
  this._olLayer.setVisible(bool);
};

proto.clear = function(){
  this.getSource().clear();
};

proto.addToMap = function(map){
  map.addLayer(this._olLayer);
};

proto.isNewFeature = function(fid){
  if (fid) {
    return fid.toString().indexOf(this._newPrefix) == 0;
  }
  return true;
};


},{"core/g3wobject":27,"core/utils/utils":71}],57:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

function WMSLayer(options,extraParams){
  var self = this;
  this.LAYERTYPE = {
    LAYER: 'layer',
    MULTILAYER: 'multilayer'
  };

  this.extraParams = extraParams;
  this.layers = [];
  
  base(this,options);
}

inherit(WMSLayer,MapLayer);

var proto = WMSLayer.prototype;

proto.getOLLayer = function(withLayers){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer(withLayers);
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getInfoFormat = function() {
  return 'application/vnd.ogc.gml';
};

proto.getGetFeatureInfoUrl = function(coordinate,resolution,epsg,params){
  return this.getOLLayer().getSource().getGetFeatureInfoUrl(coordinate,resolution,epsg,params);
};

proto.getLayerConfigs = function(){
  return this.layers;
};

proto.addLayer = function(layer){
  this.layers.push(layer);
};

proto.toggleLayer = function(layer){
  _.forEach(this.layers,function(_layer){
    if (_layer.id == layer.id){
      _layer.visible = layer.visible;
    }
  });
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayers(mapState, extraParams);
};

proto.isVisible = function(){
  return this._getVisibleLayers().length > 0;
};

proto.getQueryUrl = function(){
  var layer = this.layers[0];
  if (layer.infourl && layer.infourl != '') {
    return layer.infourl;
  }
  return this.config.url;
};

proto.getQueryableLayers = function(){ 
  return _.filter(this.layers,function(layer){
    return layer.isQueryable();
  });
};

proto._getVisibleLayers = function(mapState){
  var self = this;
  var visibleLayers = [];
  _.forEach(this.layers,function(layer){
    var resolutionBasedVisibility = layer.state.maxresolution ? (layer.state.maxresolution && layer.state.maxresolution > mapState.resolution) : true;
    if (layer.state.visible && resolutionBasedVisibility) {
      visibleLayers.push(layer);
    }    
  });
  return visibleLayers;
};

proto._makeOlLayer = function(withLayers){
  var self = this;
  var wmsConfig = {
    url: this.config.url,
    id: this.config.id
  };
  
  if (withLayers) {
    wmsConfig.layers = _.map(this.layers,function(layer){
      return layer.getWMSLayerName();
    });
  }
  
  var representativeLayer = this.layers[0]; //BRUTTO, DEVO PRENDERE UN LAYER A CASO (IL PRIMO) PER VEDERE SE PUNTA AD UN SOURCE DIVERSO (dovrebbe accadere solo per i layer singoli, WMS esterni)
  
  if (representativeLayer.state.source && representativeLayer.state.source.type == 'wms' && representativeLayer.state.source.url){
    wmsConfig.url = representativeLayer.state.source.url;
  }
  
  var olLayer = new RasterLayers.WMSLayer(wmsConfig,this.extraParams);
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto.checkLayerDisabled = function(layer,resolution) {
  var scale = geo.resToScale(resolution);
  var enabled = true;
  if (layer.config.maxresolution){
    enabled = enabled && (layer.config.maxresolution > resolution);
  }
  if (layer.config.minresolution){
    enabled = enabled && (layer.config.minresolution < resolution);
  }
  if (layer.config.minscale) {
    enabled = enabled && (layer.config.minscale > scale);
  }
  if (layer.config.maxscale) {
    enabled = enabled && (layer.config.maxscale < scale);
  }
  layer.state.disabled = !enabled;
};

proto.checkLayersDisabled = function(resolution){
  var self = this;
  _.forEach(this.layers,function(layer){
    self.checkLayerDisabled(layer,resolution);
  });
};

proto._updateLayers = function(mapState,extraParams){
  this.checkLayersDisabled(mapState.resolution);
  var visibleLayers = this._getVisibleLayers(mapState);
  if (visibleLayers.length > 0) {
    var params = {
      LAYERS: _.join(_.map(visibleLayers, function(layer) {
        return layer.getWMSLayerName();
      }),',')
    };
    if (extraParams) {
      params = _.assign(params,extraParams);
    }
    this._olLayer.setVisible(true);
    this._olLayer.getSource().updateParams(params);
  }
  else {
    this._olLayer.setVisible(false);
  }
};

module.exports = WMSLayer;

},{"core/map/layer/maplayer":54,"core/utils/geo":70,"core/utils/utils":71,"g3w-ol3/src/layers/rasters":97}],58:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

var GENERCI_GRID_EXTENT = [0,0,8388608,8388608];
var STANDARD_PROJECTIONS = [3857,900913,4326];

function XYZLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(XYZLayer,MapLayer);

var proto = XYZLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};

proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;
  
  var projection = this.projection ? this.projection : this.layer.getProjection();

  var layerOptions = {
    url: this.layer.getCacheUrl()+"/{z}/{x}/{y}.png",
    maxZoom: 20
  };

  /*if (STANDARD_PROJECTIONS.indexOf(crs) < 0) {
    layerOptions.projection = new ol.proj.Projection({
      code: "EPSG:"+crs,
      extent: GENERIC_GRID_EXTENT
    })
  }*/

  layerOptions.projection = projection;

  var olLayer = RasterLayers.XYZLayer(layerOptions);

  olLayer.getSource().on('imageloadstart', function() {
    self.emit("loadstart");
  });
  olLayer.getSource().on('imageloadend', function() {
    self.emit("loadend");
  });

  return olLayer
};

proto._updateLayer = function(mapState, extraParams) {
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = XYZLayer;

},{"core/map/layer/maplayer":54,"core/utils/geo":70,"core/utils/utils":71,"g3w-ol3/src/layers/rasters":97}],59:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var LayersStoresRegistry = require('core/layers/layersstoresregistry');

function MapLayersStoresRegistry() {
  base(this);
}

inherit(MapLayersStoresRegistry, LayersStoresRegistry);

module.exports = new MapLayersStoresRegistry();
},{"core/layers/layersstoresregistry":40,"core/utils//utils":71,"core/utils/utils":71}],60:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('./pluginsregistry');

var Plugin = function() {

  base(this);
  this.name = '(no name)';
  this.config = null;
  this.service = null;

};

inherit(Plugin,G3WObject);

var proto = Plugin.prototype;

//recuperare il servizio associato al plugin
proto.getService = function() {
  return this.service
};

//settare un servizio
proto.setService = function(service) {
  this.service = service;
};

//recupero il nome
proto.getName = function() {
  return this.name;
};

//setto il nome
proto.setName = function(name) {
  this.name = name;
};

//recupero la configurazione del plugin dal registro dei plugins
proto.getConfig = function(name) {
  name = name || this.name;
  return PluginsRegistry.getPluginConfig(name);
};

proto.setConfig = function(config) {
  this.config = config;
};

//verifica la compatibilià con il progetto corrente
proto.isCurrentProjectCompatible = function(projectId) {
  var project = ProjectsRegistry.getCurrentProject();
  return projectId == project.getGid();
};

//registrazione plugin se compatibile con il progetto corrente
proto.registerPlugin = function(projectId) {
  if (this.isCurrentProjectCompatible(projectId)) {
    PluginsRegistry.registerPlugin(this);
    return true;
  }
  return false;
};

// setup dell'interfaccia
proto.setupGui = function() {
  //al momento niente non so se verrà usata
};

// caso di sgancaimento del plugin (caso cambio progetto)
proto.unload  = function() {
  //console.log('UNLOAD deve essere sovrascritto eventalmente dal plugin');
};

// funzione che viene lanciata quando si fa il load del plugin
proto.load = function() {
  //console.log('LOAD deve essere sovrascritto eventalmente dal plugin');
};

module.exports = Plugin;

},{"./pluginsregistry":62,"core/g3wobject":27,"core/project/projectsregistry":67,"core/utils/utils":71}],61:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

// classe utilizzata dai plugin per il servizo
// al momento inizilaizza il config
function PluginService(options) {
  var options = options || {};
  base(this, options);
  this.init = function(config) {
    this.config = config;
    //TODO
  }
}

inherit(PluginService, G3WObject);

var proto = PluginService.prototype;

proto.getConfig = function() {
  return this.config;
};

proto.setConfig = function(config) {
  this.config = config;
};



module.exports = PluginService;
},{"core/g3wobject":27,"core/utils/utils":71}],62:[function(require,module,exports){
var base = require('core/utils/utils').base;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function PluginsRegistry() {
  var self = this;
  this.config = null;
  // un domani questo sarà dinamico
  this._plugins = {};
  this._loadedPluginUrls = [];
  this.setters = {
    //setters che server per registrare il plugin
    registerPlugin: function(plugin) {
      if (!self._plugins[plugin.name]) {
        self._plugins[plugin.name] = plugin;
      }
    }
  };

  base(this);

  // funzione di inizializzazione dei plugin
  this.init = function(options) {
    var self = this;
    this.pluginsBaseUrl = options.pluginsBaseUrl;
    // oggetto contenente la configuarzione dei vvari plugins (che sono le chiavi dell'oggetto)
    this.pluginsConfigs = options.pluginsConfigs;
    // configurazione altri plugin
    this.otherPluginsConfig = options.otherPluginsConfig;
    this.setOtherPlugins();
        //ciclo sull'oggetto plugins per fare il setup dei vari plugin legati al progetto
    _.forEach(this.pluginsConfigs, function(pluginConfig, name) {
      self._setup(name, pluginConfig);
    })
  };

  this.setOtherPlugins = function() {
    //da vedere poi come cutomizzare il law plugin
    if (this.otherPluginsConfig && this.otherPluginsConfig.law && this.otherPluginsConfig.law.length) {
      this.pluginsConfigs['law'] =  this.otherPluginsConfig.law;
    }
  };

  // funzione che serve per fare il reload dei plugins
  this.reloadPlugins = function(project) {
    var self = this;
    var ApplicationService = require('core/applicationservice');
    //forzo la varibile globale initConfig a null affinche venga ricaricato
    // la configurazione iniziale
    window.initConfig = null;
    //vado a riottenere l'initConfig
    ApplicationService.obtainInitConfig()
      .then(function(initConfig) {
        // prendo vado a rimuovere i tools
        GUI.getComponent('tools').getService().removeTools();
        // setto il pluginsConfig
        self.setPluginsConfig(initConfig.group.plugins);
        // devo ricaricare quelli con custom
        self.setOtherPlugins();
        // prendo dal documento tutti gli scripts
        var scripts = $('script');
        // va do a scorrere sui plugin registrati e verifico se il plugin esisteva oppure  no
        // se non esiste devo chiamare il metodo unload per sganciare tutte le sue cose (se previsto)
        // e implementato dal plugin
        _.forEach(self.getPlugins(), function(plugin, pluginName) {
          // verifico che il plugin non sia presente nella nuoav configurazione dei plugin
          //e quindi chieamo l'unload (se implementato) del plugin prima di
          // rimuovere lo script
          if (_.keys(self.pluginsConfigs).indexOf(pluginName) == -1) {
            // chaimo il metodo unload del plugin
            plugin.unload();
            // rimuovo il plugin anche dai pugin registrati
            delete self._plugins[pluginName];
            // cliclo sugli script vado a togliere gli script che contengono plugin
            _.forEach(scripts, function(scr) {
              _.forEach(self._loadedPluginUrls, function(pluginUrl, idx) {
                if (scr.getAttribute('src') == pluginUrl && pluginUrl.indexOf(pluginName) != -1) {
                  scr.parentNode.removeChild( scr );
                  //vado a cancellare lo script associato a quel plugin
                  self._loadedPluginUrls.splice(idx, 1);
                  return false;
                }
              })
            });
          } else {
            plugin.load();
            // lo devo togliere dalla configurazione
            delete self.pluginsConfigs[pluginName];
          }
        });
        _.forEach(self.pluginsConfigs, function(pluginConfig, pluginName) {
          self._setup(pluginName, pluginConfig);
        })
      });
  };

  this.setPluginsConfig = function(config) {
    this.pluginsConfigs = config;
  };

  //funzione che permette il caricamento dello script del plugin
  this._setup = function(name, pluginConfig) {
    if (pluginConfig) {
      var url = this.pluginsBaseUrl+name+'/js/plugin.js?'+Date.now();
      $script(url);
      // vado ad aggiunguere il plugin all'array dei plugin caricati
      this._loadedPluginUrls.push(url);
    }
  };
  
  this.getPluginConfig = function(pluginName) {
    return this.pluginsConfigs[pluginName];
  };

  this.getPlugins = function() {
    return this._plugins;
  };
  
  this.getPlugin = function(pluginName) {
    return this._plugins[pluginName];
  }

}

inherit(PluginsRegistry,G3WObject);

module.exports = new PluginsRegistry;

},{"core/applicationservice":22,"core/g3wobject":27,"core/utils/utils":71,"gui/gui":114}],63:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var PrinterProvider = require('./providers/printerprovider');

function PrintService() {
  base(this);
  // funzione generica nel caso volessi lanciare il print
  // senza ottenere il printer
  this.print = function(options) {
    /* options è un oggetto che contiene:
     type: tipo di printer server
     url: url a cui effettuare la richiesta
     params : oggetto contenete i parametri necessari alla creazione della richiesta
              come ad esempio filter etc ..
    */
    var options = options || {};
    var type = options.type || 'QGIS';
    var provider = new PrinterProvider(type);
    var url = provider.print(options);
    return $.get(url)
  };
}

inherit(PrintService, G3WObject);

module.exports = new PrintService;

},{"./providers/printerprovider":64,"core/g3wobject":27,"core/utils/utils":71}],64:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
// providers

var PrinterQGISProvider = require('./qgis/printerQGISProvider');

var Providers = {
  'QGIS': PrinterQGISProvider
};

// classe costruttore che permette a seconda delle caratteristiche dei layers
// ogcservice etc... di chiamare il proprio providers per effettuare le chiamte al server
function PrinterProvider(options) {
  var options = options || {};
  var serverType = options.serverType || 'QGIS';
  this._provider = Providers[serverType];
  this.print = function(options) {
    return this._provider.print(options);
  };
  base(this);
}

inherit(PrinterProvider, G3WObject);

module.exports =  PrinterProvider;


},{"./qgis/printerQGISProvider":65,"core/g3wobject":27,"core/utils/utils":71}],65:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var resolve = require('core/utils/utils').resolve;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');


function PrinterQGISProvider() {
  base(this);

  this._getPrintUrl = function(options) {
    var options = options || {};
    var layersStore =   ProjectsRegistry.getCurrentProject().getLayersStore();
    var templateMap = options.map || 'map0';
    var url = layersStore.getWmsUrl();
    // devo fare il reverse perchè l'odine conta sulla visualizzazione del print
    var layers = _.reverse(layersStore.getLayers({
      ACTIVE: true,
      VISIBLE: true,
      SERVERTYPE: 'QGIS'
    }));
    layers = _.map(layers,function(layer){
      return layer.getQueryLayerName()
    });
    var params = {
      SERVICE: 'WMS',
      VERSION: '1.3.0',
      REQUEST: 'GetPrint',
      TEMPLATE: options.template,
      DPI: options.dpi,
      FORMAT: 'pdf',
      CRS:layersStore.getProjection().getCode(),
      LAYERS: layers.join()
    };
    // AL comento commento
    params[templateMap+':SCALE'] = options.scale;
    params[templateMap+':EXTENT'] = options.extent;
    params[templateMap+':ROTATION'] = options.rotation;
    url = url + '?' + $.param(params);
    return url;
  };

  this.print = function(options) {
    /* options è un oggetto che contiene:
     type: tipo di printer server
     url: url a cui effettuare la richiesta
     params : oggetto contenete i parametri necessari alla creazione della richiesta
     come ad esempio filter etc ..
     */
    var options = options || {};
    return this._getPrintUrl(options);
  };
}

inherit(PrinterQGISProvider, G3WObject);

module.exports = new PrinterQGISProvider;


/*
 http://localhost/fcgi-bin/qgis_mapserver/qgis_mapserv.fcgi?MAP=/home/marco/geodaten/projekte/composertest.qgs&SERVICE=WMS&VERSION=1.3.0
 &REQUEST=GetPrint&TEMPLATE=Composer 1&
 map0:extent=693457.466131,227122.338236,700476.845177,230609.807051&
 BBOX=693457.466131,227122.338236,700476.845177,230609.807051&
 CRS=EPSG:21781&WIDTH=1467&HEIGHT=729&LAYERS=layer0,layer1&
 STYLES=,&FORMAT=pdf&DPI=300&TRANSPARENT=true

 In detail, the following parameters can be used to set properties for composer maps:

 <mapname>:EXTENT=<xmin,ymin,xmax, ymax> //mandatory
 <mapname>:ROTATION=<double> //optional, defaults to 0
 <mapname>:SCALE=<double> //optional. Forces scale denominator as server and client may have different scale calculations
 <mapname>:LAYERS=<comma separated list with layer names> //optional. Defaults to all layer in the WMS request
 <mapname>:STYLES=<comma separated list with style names> //optional
 <mapname>:GRID_INTERVAL_X=<double> //set the grid interval in x-direction for composer grids
 <mapname>:GRID_INTERVAL_Y=<double> //set the grid interval in x-direction for composer grids
 */
},{"core/g3wobject":27,"core/project/projectsregistry":67,"core/utils/utils":71}],66:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var LayerFactory = require('core/layers/layerfactory');
var ImageLayer = require('core/layers/imagelayer');
var LayersStore = require('core/layers/layersstore');
var Projections = require('g3w-ol3/src/projection/projections');

function Project(projectConfig) {
  var self = this;
  /* struttura oggetto 'project'
  {
    id,
    type,
    gid,
    name,
    crs,
    proj4,
    extent,
    initextent,
    layers,
    layerstree,
    overviewprojectgid,
    baselayers,
    initbaselayer
  }
  */
  this.state = projectConfig;

  this._processLayers();

  this._projection = Projections.get(this.state.crs,this.state.proj4);
  this._layersStore = this._buildLayersStore();

  this.setters = {
    setBaseLayer: function(id) {
      _.forEach(self.state.baselayers, function(baseLayer) {
        baseLayer.visible = (baseLayer.id == id || (baseLayer.fixed === true));
      })
    }
  };

  base(this);
}

inherit(Project, G3WObject);

var proto = Project.prototype;

proto._processLayers = function() {
  var self = this;
  function traverse(obj) {
    _.forIn(obj, function (layer, key) {
      //verifica che il nodo sia un layer e non un folder
      if (!_.isNil(layer.id)) {
        var fulllayer;
        _.forEach(self.state.layers, function(lyr) {
          if (layer.id == lyr.id) {
            lyr.wmsUrl = self.getWmsUrl();
            lyr.project = self;
            fulllayer = _.merge(lyr, layer);
            return false
          }
        });
        obj[parseInt(key)] = fulllayer;
      }
      if (!_.isNil(layer.nodes)){
        // aggiungo proprietà title per l'albero
        layer.title = layer.name;
        traverse(layer.nodes);
      }
    });
  }
  traverse(this.state.layerstree);

  _.forEach(this.state.baselayers, function(layerConfig) {
    var visible = false;

    if (self.state.initbaselayer) {
      visible = (layerConfig.id == (self.state.initbaselayer));
    }

    if (layerConfig.fixed) {
      visible = layerConfig.fixed;
    }

    layerConfig.visible = visible;
    layerConfig.baselayer = true;
  });
};

// funzione che fa il buil del layers store
// lo istanzia  crea il layersstree
proto._buildLayersStore = function() {
  var self = this;
  var layersStore = new LayersStore();
  var overviewprojectgid = this.state.overviewprojectgid ? this.state.overviewprojectgid.gid : null;
  layersStore.setOptions({
    id: this.state.gid,
    projection: this._projection,
    extent: this.state.extent,
    initextent: this.state.initextent,
    wmsUrl: this.state.WMSUrl,
    catalog: this.state.gid != overviewprojectgid
  });

  _.forEach(this.getLayers(), function(layerConfig) {
    // aggiungo la proiezione
    layerConfig.projection = self._projection;
    var layer = LayerFactory.build(layerConfig);
    layersStore.addLayer(layer);
  });

  layersStore.createLayersTree(this.state.name, {
    layerstree: this.state.layerstree
  });

  return layersStore;
};

proto.getLayers = function() {
  return _.concat(this.state.layers,this.state.baselayers);
};

proto.getState = function() {
  return this.state;
};

// funzione che ritorna id
proto.getId = function() {
  return this.state.id;
};

//funzione che ritorna il tipo
proto.getType = function() {
  return this.state.type;
};

proto.getGid = function() {
  return this.state.gid;
};

proto.getName = function() {
  return this.state.name;
};

proto.getOverviewProjectGid = function() {
  return this.state.overviewprojectgid ? this.state.overviewprojectgid.gid : null;
};

proto.getCrs = function() {
  return this._projection.getCode();
};

proto.getProjection = function() {
  return this._projection;
};

proto.getWmsUrl = function() {
  return this.state.WMSUrl;
};

proto.getInfoFormat = function() {
  return 'application/vnd.ogc.gml';
};

proto.getLayersStore = function() {
  return this._layersStore;
};

module.exports = Project;

},{"core/g3wobject":27,"core/layers/imagelayer":36,"core/layers/layerfactory":38,"core/layers/layersstore":39,"core/utils//utils":71,"core/utils/utils":71,"g3w-ol3/src/projection/projections":100}],67:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var reject = require('core/utils/utils').reject;
var G3WObject = require('core/g3wobject');
var Project = require('core/project/project');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');
var MapLayersStoresRegistry = require('core/map/maplayersstoresregistry');

/* service
Funzione costruttore contentente tre proprieta':
    setup: metodo di inizializzazione
    getLayersState: ritorna l'oggetto LayersState
    getLayersTree: ritorna l'array layersTree dall'oggetto LayersState
*/

// Public interface
function ProjectsRegistry() {
  var self = this;
  this.config = null;
  this.initialized = false;
  //tipo di progetto
  this.projectType = null;
  this.setters = {
    setCurrentProject: function(project) {
      if (this.state.currentProject) {
        LayersStoresRegistry.removeLayersStore(this.state.currentProject.getLayersStore());
      }
      self.state.currentProject = project;
      //aggiunto tipo progetto
      self.setProjectType(project.state.type);
      // lo mette sempre in prima posizione mi serve per la mappa
      CatalogLayersStoresRegistry.addLayersStore(project.getLayersStore(), 0);
      MapLayersStoresRegistry.addLayersStore(project.getLayersStore(), 0);
    }
  };
  //stato del registro progetti
  this.state = {
    baseLayers: {},
    minScale: null,
    maxscale: null,
    currentProject: null
  };
  
  // tutte le configurazioni di base dei progetti, ma di cui non è detto che
  // sia ancora disponibile l'istanza (lazy loading)
  this._pendingProjects = [];
  this._projects = {};
  
  base(this);
}

inherit(ProjectsRegistry, G3WObject);

var proto = ProjectsRegistry.prototype;

proto.init = function(config) {
  var self = this;
  var deferred = $.Deferred();
  //verifico se è già stato inizilizzato
  if (!this.initialized) {
    this.initialized = true;
    //salva la configurazione
    this.config = config;
    // salvo l'overviewproject
    this.overviewproject = config.overviewproject;
    //setta lo state
    this.setupState();
    // vado a prendere la configurazione del progetto corrente
    this.getProject(config.initproject)
    .then(function(project) {
      // vado a settare il progetto corrente
      self.setCurrentProject(project);
      deferred.resolve(project);
    })
    .fail(function() {
      deferred.reject();
    })
  }
  return deferred.promise();
};

proto.setProjectType = function(projectType) {
   this.projectType = projectType;
};

proto.getConfig = function() {
  return this.config;
};


proto.getState = function() {
  return this.state;
};

proto.setupState = function() {
  var self = this;
  self.state.baseLayers = self.config.baselayers;
  self.state.minScale = self.config.minscale;
  self.state.maxScale = self.config.maxscale;
  self.state.crs = self.config.crs;
  self.state.proj4 = self.config.proj4;
  // setto  quale progetto deve essere impostato come overview
  //questo è settato da django-admin
  var overViewProject = (self.config.overviewproject && self.config.overviewproject.gid) ? self.config.overviewproject : null;
  //per ogni progetto ciclo e setto tutti gli attributi comuni
  // come i base layers etc ..
  self.config.projects.forEach(function(project) {
    project.baselayers = _.cloneDeep(self.config.baselayers);
    project.minscale = self.config.minscale;
    project.maxscale = self.config.maxscale;
    project.crs = self.config.crs;
    project.proj4 = self.config.proj4;
    project.overviewprojectgid = overViewProject;
    //aggiungo tutti i progetti ai pending project
    self._pendingProjects.push(project);
  });
};

proto.getProjectType = function() {
  return this.projectType;
};

proto.getPendingProjects = function() {
  return this._pendingProjects;
};

proto.getProjects = function() {
  return this._pendingProjects;
};

proto.getListableProjects = function() {
  var currentProjectId = this.getCurrentProject().getId();
  return _.filter(this.getProjects(), function(project) {
    if (!_.isNil(project.listable)) {
      return project.listable;
    }
    //resituisce solo quelli diversi da overviewprojetc
    // nel caso si stato settato
    if ((project.overviewprojectgid && project.gid != project.overviewprojectgid.gid && project.id != currentProjectId) || (project.id != currentProjectId)) {
      return project;
    }
  })
};

proto.getCurrentProject = function(){
  return this.state.currentProject;
};

// ottengo il progetto dal suo gid;
// ritorna una promise nel caso non fosse stato ancora scaricato
// il config completo (e quindi non sia ancora istanziato Project)
proto.getProject = function(projectGid) {
  var self = this;
  var d = $.Deferred();
  var pendingProject;
  var project = null;
  // scorro atraverso i pending project che contengono oggetti
  // di configurazione dei progetti del gruppo
  this._pendingProjects.forEach(function(_pendingProject) {
    if (_pendingProject.gid == projectGid) {
      pendingProject = _pendingProject;
      project = self._projects[projectGid];
    }
  });
  if (!pendingProject) {
    return reject("Project doesn't exist");
  }

  if (project) {
    return d.resolve(project);
  } else {
    return this._getProjectFullConfig(pendingProject)
    .then(function(projectFullConfig){
      var projectConfig = _.merge(pendingProject,projectFullConfig);
      projectConfig.WMSUrl = self.config.getWmsUrl(projectConfig);
      var project = new Project(projectConfig);
      // aggiungo/ registro il progetto
      self._projects[projectConfig.gid] = project;
      return d.resolve(project);
    })
    .fail(function() {
      return d.reject();
    })
  }
};
  
//ritorna una promises che verrà risolta con la
// configuarzione del progetto corrente
proto._getProjectFullConfig = function(projectBaseConfig) {
  var deferred = $.Deferred();
  var url = this.config.getProjectConfigUrl(projectBaseConfig);
  $.get(url)
    .done(function(projectFullConfig) {
      deferred.resolve(projectFullConfig);
    })
    .fail(function() {
      deferred.reject();
    });
  return deferred.promise();
};


module.exports = new ProjectsRegistry();

},{"core/catalog/cataloglayersstoresregistry":23,"core/g3wobject":27,"core/map/maplayersstoresregistry":59,"core/project/project":66,"core/utils/utils":71}],68:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function QueryService(){
  base(this);
}
inherit(QueryService, G3WObject);

module.exports =  new QueryService;


},{"core/g3wobject":27,"core/utils/utils":71,"gui/gui":114}],69:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Base64 = require('core/utils/utils').Base64;
var G3WObject = require('core/g3wobject');

/*
 * RouterService basato su History.js (https://github.com/browserstate/history.js) e Crossroads (https://github.com/millermedeiros/crossroads.js)
 * Il concetto di base è una RouteQuery, del tipo "map?point=21.2,42.1&zoom=12", 
 * che viene inserito nello stato dell'history del browser e nella URL come parametro querystring in forma codificata (q=map@point!21.2,41.1|zoom!12).
 * Per invocare una RouteQuery:
 * 
 * RouterService.goto("map?point=21.2,42.1&zoom=12");
 * 
 * Chiunque voglia rispondere ad una RouteQuery deve aggiungere una route con RouterService.addRoute(pattern, callback). Es.:
 * 
 * var route = RouterService.addRoute('map/{?query}',function(query){
 *  console.log(query.point);
 *  console.log(query.zoom);
 * });
 * 
 * Patterns:
 *  "map/{foo}": la porzione "foo" è richiesta, ed viene passata come parametro alla callback
 *  "map/:foo:": la porzione "foo" è opzionale, ed eventualmente viene passata come parametro alla callback
 *  "map/:foo*: tutto quello che viene dopo "map/"
 *  "map/{?querystring}": obbligatoria querystring, passata alla callback come oggetto dei parametri
 *  "map/:?querystring:": eventuale querystring, passata alla callback come oggetto dei parametri
 * 
 * Per rimuovere una route:
 * RouterService.removeRoute(route);
*/

// altrimenti due chiamate successive alla stessa route verrebbero ignorate
// e può capitare di tornare a chiamare la stessa route senza averne chiamate prima (perché non tutta la GUI è comandata tramite Router)
crossroads.ignoreState = true;
// tutte le route vengono innescate da un url, invece di feramrsi alla prima (com'è di default)
crossroads.greedy = true;

var RouterService = function(){
  var self = this;
  this._initialLocationQuery;
  this._routeQuery = '';
  this.setters = {
    setRouteQuery: function(routeQuery){
      this._routeQuery = routeQuery;
      crossroads.parse(routeQuery);
    }
  };
  
  base(this);
};
inherit(RouterService,G3WObject);

var proto = RouterService.prototype;

proto.init = function(){
  var query = window.location.search;
  this._setRouteQueryFromLocationQuery(query);
};

proto.addRoute = function(pattern,handler,priority) {
  return crossroads.addRoute(pattern,handler,priority);
};

proto.removeRoute = function(route) {
  return crossroads.removeRoute(route);
};

proto.removeAllRoutes = function() {
  return crossroads.removeAllRoutes();
};

proto.parse = function(request,defaultArgs) {
  return crossroads.parse(request,defaultArgs);
};

proto.goto = function(routeQuery){
  if (!this._initialQuery) {
    this._initialLocationQuery = this._stripInitialQuery(location.search.substring(1));
  }
  if (routeQuery) {
    this.setRouteQuery(routeQuery);
  }
};

proto.makePermalink = function(routeQuery) {
  if (!this._initialQuery) {
    this._initialLocationQuery = this._stripInitialQuery(location.search.substring(1));
  }
  var encodedRouteQuery = this._encodeRouteQuery(routeQuery);
  //encodedRouteQuery = Base64.encode(encodedRouteQuery);
  return '?'+this._initialLocationQuery + '&q='+this._encodeRouteQuery(routeQuery);
};

proto.makeQueryString = function(queryParams){};

proto.slicePath = function(path){
  return path.split('?')[0].split('/');
};
  
proto.sliceFirst = function(path){
  var pathAndQuery = path.split('?');
  var queryString = pathAndQuery[1];
  var pathArr = pathAndQuery[0].split('/');
  var firstPath = pathArr[0];
  path = pathArr.slice(1).join('/');
  path = [path,queryString].join('?');
  return [firstPath,path];
};
  
proto.getQueryParams = function(query){
  query = query.replace('?','');
  var queryParams = {};
  var queryPairs = [];
  if (query != "" && query.indexOf("&") == -1) {
    queryPairs = [query];
  }
  else {
    queryPairs = query.split('&');
  }
  try {
    _.forEach(queryPairs,function(queryPair){
      var pair = queryPair.split('=');
      var key = pair[0];
      var value = pair[1];
      queryParams[key] = value;
    });
  }
  catch (e) {}
  return queryParams;
};

proto.getQueryString = function(path){
  return path.split('?')[1];
};

proto._getQueryPortion = function(query,queryKey){
  var queryPortion;
  try {
    var queryPairs = query.split('&');
    var queryParams = {};
    _.forEach(queryPairs,function(queryPair){
      var pair = queryPair.split('=');
      var key = pair[0];
      if (key == queryKey) {
        queryPortion = queryPair;
      }
    });
  }
  catch (e) {}
  return queryPortion;
};

proto._encodeRouteQuery = function(routeQuery) {
  routeQuery = routeQuery.replace('?','@');
  routeQuery = routeQuery.replace('&','|');
  routeQuery = routeQuery.replace('=','!');
  return routeQuery;
};

proto._decodeRouteQuery = function(routeQuery) {
  routeQuery = routeQuery.replace('@','?');
  routeQuery = routeQuery.replace('|','&');
  routeQuery = routeQuery.replace('!','=');
  return routeQuery;
};

proto._setRouteQueryFromLocationQuery = function(locationQuery) {
  var encodedRouteQuery = this._getRouteQueryFromLocationQuery(locationQuery);
  //encodedRouteQuery = Base64.decode(encodedRouteQuery);
  if (encodedRouteQuery) {
    var routeQuery = this._decodeRouteQuery(encodedRouteQuery);
    this.setRouteQuery(routeQuery);
  }
};

proto._getRouteQueryFromLocationQuery = function(locationQuery) {
  return this.getQueryParams(locationQuery)['q'];
};

proto._stripInitialQuery = function(locationQuery) {
  var previousQuery = this._getQueryPortion(locationQuery,'q');
  if (previousQuery) {
    var previousQueryLength = previousQuery.length;
    var previousQueryPosition = locationQuery.indexOf(previousQuery);
    queryPrefix = _.trimEnd(locationQuery.substring(0,previousQueryPosition),"&");
    querySuffix = locationQuery.substring(previousQueryPosition+previousQueryLength);
    querySuffix = (queryPrefix != "") ? querySuffix : _.trimStart(querySuffix,"&");
    locationQuery = queryPrefix + querySuffix;
  }
  return locationQuery;
};

module.exports = new RouterService;

},{"core/g3wobject":27,"core/utils/utils":71}],70:[function(require,module,exports){
var OGC_PIXEL_WIDTH = 0.28;
var OGC_DPI = 25.4/OGC_PIXEL_WIDTH;

module.exports = {
  resToScale: function(res, metric) {
    var metric = metric || 'm';
    var scale;
    switch (metric) {
      case 'm':
        var scale = (res*1000) / OGC_PIXEL_WIDTH;
        break
    }
    return scale;
  },
  scaleToRes: function(scale, metric) {
    var metric = metric || 'm';
    var resolution;
    switch (metric) {
      case 'm':
        var resolution = (scale * OGC_PIXEL_WIDTH) / 1000;
        break
    }
    return resolution;

  }
};

},{}],71:[function(require,module,exports){

/**
 * Decimal adjustment of a number.
 *
 * @param {String}  type  The type of adjustment.
 * @param {Number}  value The number.
 * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).
 * @returns {Number} The adjusted value.
 */
function decimalAdjust(type, value, exp) {
  // If the exp is undefined or zero...
  if (typeof exp === 'undefined' || +exp === 0) {
    return Math[type](value);
  }
  value = +value;
  exp = +exp;
  // If the value is not a number or the exp is not an integer...
  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
    return NaN;
  }
  // Shift
  value = value.toString().split('e');
  value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
  // Shift back
  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
}

// Decimal round
if (!Math.round10) {
  Math.round10 = function(value, exp) {
    return decimalAdjust('round', value, exp);
  };
}
// Decimal floor
if (!Math.floor10) {
  Math.floor10 = function(value, exp) {
    return decimalAdjust('floor', value, exp);
  };
}
// Decimal ceil
if (!Math.ceil10) {
  Math.ceil10 = function(value, exp) {
    return decimalAdjust('ceil', value, exp);
  };
}

String.prototype.hashCode = function() {
  var hash = 0, i, chr, len;
  if (this.length === 0) return hash;
  for (i = 0, len = this.length; i < len; i++) {
    chr   = this.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0;
  }
  return hash;
};

var Base64 = {_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",encode:function(e){var t="";var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f<e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t="";var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,"");while(f<e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s<<2|o>>4;r=(o&15)<<4|u>>2;i=(u&3)<<6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,"n");var t="";for(var n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r)}else if(r>127&&r<2048){t+=String.fromCharCode(r>>6|192);t+=String.fromCharCode(r&63|128)}else{t+=String.fromCharCode(r>>12|224);t+=String.fromCharCode(r>>6&63|128);t+=String.fromCharCode(r&63|128)}}return t},_utf8_decode:function(e){var t="";var n=0;var r=c1=c2=0;while(n<e.length){r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r);n++}else if(r>191&&r<224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&31)<<6|c2&63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&15)<<12|(c2&63)<<6|c3&63);n+=3}}return t}};


var utils = {
  basemixin: function mixin(destination, source) {
      return utils.merge(destination.prototype, source);
  },
  
  mixin: function mixininstance(destination,source){
      var sourceInstance = new source;
      utils.merge(destination, sourceInstance);
      utils.merge(destination.prototype, source.prototype);
  },


  merge: function merge(destination, source) {
      var key;
      for (key in source) {
          if (utils.hasOwn(source, key)) {
              destination[key] = source[key];
          }
      }
  },

  hasOwn: function hasOwn(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
  },
  
  inherit:function(childCtor, parentCtor) {
    function tempCtor() {}
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    childCtor.prototype.constructor = childCtor;
  },
  
  base: function(me, opt_methodName, var_args) {
    var caller = arguments.callee.caller;
    if (caller.superClass_) {
      // This is a constructor. Call the superclass constructor.
      return caller.superClass_.constructor.apply(
          me, Array.prototype.slice.call(arguments, 1));
    }
    var args = Array.prototype.slice.call(arguments, 2);
    var foundCaller = false;
    for (var ctor = me.constructor;
         ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
      if (ctor.prototype[opt_methodName] === caller) {
        foundCaller = true;
      } else if (foundCaller) {
        return ctor.prototype[opt_methodName].apply(me, args);
      }
    }

    // If we did not find the caller in the prototype chain,
    // then one of two things happened:
    // 1) The caller is an instance method.
    // 2) This method was not called by the right caller.
    if (me[opt_methodName] === caller) {
      return me.constructor.prototype[opt_methodName].apply(me, args);
    } else {
      throw Error(
          'base called from a method of one name ' +
          'to a method of a different name');
    }
  },
  
  noop: function(){},
  
  truefnc: function(){return true},
  
  falsefnc: function(){return true},
  
  resolve: function(value){
    var deferred = $.Deferred();
    deferred.resolve(value);
    return deferred.promise();
  },
  
  reject: function(value){
    var deferred = $.Deferred();
    deferred.reject(value);
    return deferred.promise();
  },
  // Appends query parameters to a URI
  appendParams: function(uri, params) {
    var keyParams = [];
    // Skip any null or undefined parameter values
    Object.keys(params).forEach(function (k) {
      if (params[k] !== null && params[k] !== undefined) {
        keyParams.push(k + '=' + encodeURIComponent(params[k]));
      }
    });
    var qs = keyParams.join('&');
    // remove any trailing ? or &
    uri = uri.replace(/[?&]$/, '');
    // append ? or & depending on whether uri has existing parameters
    uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
    return uri + qs;
  },
  
  Base64: Base64
};

module.exports = utils;

},{}],72:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Step(options){
  base(this);

  options = options || {};
  this._inputs = options.inputs || null;
  this._task = options.task || null;
  this._outputs = options.outputs || null;

  this.state = {
    id: options.id || null,
    name: options.name || null,
    help: options.help || null,
    running: false,
    error: null,
    message: null
  }
}
inherit(Step, G3WObject);

var proto = Step.prototype;

proto.run = function(inputs, context) {
  if (this._task) {
    try {
      this._task.run(inputs, context);
      this.state.running = true;
    }
    catch(err) {
      this.state.running = false;
      this.state.error = err;
    }
  }
};

proto.revert = function() {
  if (this._task && this._task.revert){
   this._task.revert();
  }
};

proto.panic = function() {
  if (this._task && this._task.panic){
    this._task.panic();
  }
};

proto.getId = function() {
  return this.state.id;
};

proto.getName = function() {
  return this.state.name;
};

proto.getHelp = function() {
  return this.state.help;
};

proto.getError = function() {
  return this.state.error;
};

proto.getMessage = function() {
  return this.state.message;
};

proto.setInputs = function(inputs) {
  this._inputs = inputs;
};

proto.getInputs = function() {
  return this._inputs;
};

proto.setTask = function(task) {
  this._task = task;
};

proto.getTask = function() {
  return this._task;
};

proto.setOutputs = function(outputs) {
  this._outputs = outputs;
};

proto.getOutputs = function() {
  return this._outputs;
};


module.exports = Step;
},{"core/g3wobject":27,"core/utils//utils":71,"core/utils/utils":71}],73:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Worflow(){
  base(this);

  this._inputs = null;
  this._context = null;
  this._steps = [];
}
inherit(Worflow, G3WObject);

var proto = Worflow.prototype;

proto.getInputs = function() {
  return this._inputs;
};

proto.getContext = function() {
  return this._context;
};

proto.addStep = function(step) {
  this._steps.push(step);
};

proto.setSteps = function(steps) {
  this._steps = steps;
};

proto.getSteps = function() {
  return this._steps;
};

proto.start = function(inputs, context) {
  var d = $.Deferred();
  this._inputs = inputs;
  this._context = context;
  var flow = new Worflow.Flow();
  flow.start(workflow).
    then(function(outputs) {
      d.resolve(outputs);
    }).
    fail(function(error){
      d.reject(error);
    })
};

Worflow.Flow = function() {
  var self = this;
  var d = $.Deferred();
  var steps = [];
  var counter = 0;
  var context = null;
  var onDone = null;
  var onError = null;

  this.start = function(workflow, ondone, onerror) {
    if (counter > 0) {
      console.log("reset workflow before restarting");
      onerror('workflow not reset');
    }
    var inputs = workflow.getInputs();
    context = workflow.getContext();
    steps = this._workflow.getSteps();
    if (steps) {
      this.runStep(steps[0], inputs);
    }
  };

  this.runStep = function(step, inputs) {
    step.run(inputs, context, _.bind(this.onDone, this), _.bind(this.onError, this));
  };

  this.onDone = function(outputs) {
    if (counter == steps.length) {
      d.resolve(outputs);
      return;
    }
    counter++;
    this.runStep(steps[counter], outputs);
  };

  this.onError = function(error) {
    console.log('step error');
    d.reject(error);
  };
}

module.exports = Worflow;
},{"core/g3wobject":27,"core/utils//utils":71,"core/utils/utils":71}],74:[function(require,module,exports){
var Control = require('./control');
function AddLayersControl() {
  var options = {
    name: "addlayer",
    tipLabel: "AddLayer",
    label: "\ue907"
  };
  Control.call(this, options);
  this._layerstore = null;
}

ol.inherits(AddLayersControl, Control);

var proto = AddLayersControl.prototype;

proto.setMap = function(map) {
  var self = this;
  Control.prototype.setMap.call(this,map);
  $(this.element).on('click', function() {
    self.dispatchEvent('addlayer');
  })
};

proto.layout = function(map) {
  Control.prototype.layout.call(this, map);
};

proto.getLayersSore = function() {
  return this._layerstore;
};

proto.setLayersStore = function(layersStore) {
  this._layerstore = layersStore;
};

module.exports = AddLayersControl;

},{"./control":76}],75:[function(require,module,exports){
var utils = require('../utils');
var AreaIteraction = require('../interactions/areainteraction');
var MeasureControl = require('./measurecontrol');

var AreaControl = function(options) {
  var _options = {
    name: "Area",
    label: "\ue909",
    interactionClass: AreaIteraction
  };
  options = utils.merge(options,_options);
  MeasureControl.call(this, options);
};

ol.inherits(AreaControl, MeasureControl);


module.exports = AreaControl;

},{"../interactions/areainteraction":90,"../utils":101,"./measurecontrol":80}],76:[function(require,module,exports){
var Control = function(options) {
  var name = options.name || "?";
  this.name = name.split(' ').join('-').toLowerCase();
  this.id = this.name+'_'+(Math.floor(Math.random() * 1000000));
  this.positionCode = options.position || 'tl';
  this.priority = options.priority || 0;
  if (!options.element) {
    var className = "ol-"+this.name.split(' ').join('-').toLowerCase();
    var tipLabel = options.tipLabel || this.name;
    var label = options.label || "?";
    options.element = $('<div class="'+className+' ol-unselectable ol-control"><button type="button" title="'+tipLabel+'">'+label+'</button></div>')[0];
  }
  $(options.element).addClass("ol-control-"+this.positionCode);
  var buttonClickHandler = options.buttonClickHandler || Control.prototype._handleClick.bind(this);
  $(options.element).on('click',buttonClickHandler);
  ol.control.Control.call(this,options);
  this._postRender();

};

// sotto classse della classe Control di OL3
ol.inherits(Control, ol.control.Control);

var proto = Control.prototype;

proto.getPosition = function(positionCode) {
  var positionCode = positionCode || this.positionCode;
  var position = {};
  position['top'] = (positionCode.indexOf('t') > -1) ? true : false;
  position['left'] = (positionCode.indexOf('l') > -1) ? true : false;
  return position;
};

proto._handleClick = function(event) {
  event.preventDefault();
  var self = this;
  var map = this.getMap();
  var resetControl = null;
  // remove all the other, eventually toggled, interactioncontrols
  var controls = map.getControls();
  controls.forEach(function(control){
    if(control.id && control.toggle && (control.id != self.id)) {
      control.toggle(false);
      if (control.name == 'reset') {
        resetControl = control;
      }
    }
  });
  if (!self._toggled && resetControl) {
    resetControl.toggle(true);
  }
  this.dispatchEvent('controlclick');
};

//funzione che fa lo shift della posizione
proto.shiftPosition = function(position) {
  $(this.element).css(hWhere, position+'px');
};

// funzione che gestisce il layout
proto.layout = function(map) {
  if (map) {
    var position =  this.getPosition();
    var viewPort = map.getViewport();
    // vado a verificare se trovo elementi con lo stessa classe .ol-control-t o .ol-control-tl(che sono i default di ol3)
    var previusControls = $(viewPort).find('.ol-control-'+this.positionCode+':visible');
    if (previusControls.length) {
      previusControl = previusControls.last();
      var previousOffset = position.left ? previusControl.position().left : previusControl.position().top;
      var hWhere = position.left ? 'left' : 'top';
      var previousWidth = previusControl[0].offsetWidth;
      var hOffset = $(this.element).position()[hWhere] + previousOffset + previousWidth;
      $(this.element).css(hWhere,hOffset+'px');
    }
  }
};

// funzione che viene chiamata al momento che il controllo viene
// aggiunto alla mappa
proto.setMap = function(map) {
  if (map) {
    this.layout(map);
    ol.control.Control.prototype.setMap.call(this, map);
  }
};

// funzione che nasconde il controllo e sposta tutti i controlli a destra
// senza lasciare il buco
proto.hideControl = function() {
  var position = $(this.element).position().left
  var controlWidth = $(this.element).outerWidth();
  var newPosition = position;
  var controls = $(this.element).siblings('.ol-control-tl');
  controls.each(function() {
    if ($(this).position().left > position) {
      newPosition = $(this).position().left;
      if (controlWidth > $(this).outerWidth()) {
        position = position + (controlWidth - $(this).outerWidth())
      } 
      $(this).css('left', position+'px');
      position = newPosition;
      controlWidth = $(this).outerWidth();
    }
  });
  $(this.element).hide();
};

proto._postRender = function() {};

module.exports = Control;

},{}],77:[function(require,module,exports){
var Control = require('./control');
function GeolocationControl() {
  var options = {
    name: "geolocation",
    tipLabel: "Geolocation",
    label: "\ue904"
  };
  Control.call(this, options);
}

ol.inherits(GeolocationControl, Control);

var proto = GeolocationControl.prototype;

proto.setMap = function(map) {
  var self = this;
  Control.prototype.setMap.call(this,map);
  // faccio la gestione tutta interna alla rimozione del controllo
  var geolocation = new ol.Geolocation({
    projection: map.getView().getProjection(),
    tracking: true
  });
  //mi metto in ascolto del proprety change in particolare quando viene settato allow o block
  geolocation.once('change:position', function(e) {
    if (this.getPosition()) {
      $(self.element).removeClass('g3w-ol-disabled');
      $(self.element).on('click', function() {
        var map = self.getMap();
        var view = map.getView();
        coordinates = geolocation.getPosition();
        view.setCenter(coordinates);
        self.dispatchEvent({
          type: 'click',
          coordinates: coordinates
        })
      });
    } else {
      self.hideControl();
    }
  });
  geolocation.once('error', function(e) {
    self.hideControl();
    if (e.code != 1) {
      self.dispatchEvent('error');
    }
  });
};

proto.layout = function(map) {
  Control.prototype.layout.call(this, map);
  $(this.element).addClass('g3w-ol-disabled');
};


module.exports = GeolocationControl;
},{"./control":76}],78:[function(require,module,exports){
var Control = require('./control');

var InteractionControl = function(options) {
  this._toggled = this._toggled || false;
  this._interactionClass = options.interactionClass || null;
  this._interaction = null;
  this._autountoggle = options.autountoggle || false;
  this._geometryTypes = options.geometryTypes || []; // array con tipologie di geometria layer
  this._onSelectLayer = options.onselectlayer || false;
  this._enabled = (options.enabled === false) ? false : true;
  this._onhover = options.onhover || false;
  this._help = options.help  || null;
  this._modalHelp = this._help ? (options.modalHelp || toastr) : null;
  options.buttonClickHandler = InteractionControl.prototype._handleClick.bind(this);
  Control.call(this, options);
  // vado a creare il modal help se esiste un messaggio
  if (this._help) {
    this._createModalHelp();
  }
};

ol.inherits(InteractionControl, Control);

var proto = InteractionControl.prototype;

proto._clearModalHelp = function(id) {
  var self = this;
  $('body').delegate('#'+id,'change', function() {
    self._modalHelp = null;
  });
};

//funzione che si occupa di  visualizzazre la modeal dell'help
proto._showModalHelp = function() {
  var previousToastPositionClass = toastr.options.positionClass;
  // qui c'è una dipendenza con l'app template
  var contentDiv = $('#g3w-view-content');
  if (this._modalHelp) {
    toastr.options.positionClass = 'toast-top-right';
    // se già presente un modale lo chiudo
    this._modalHelp.clear();
    var helpElement = this._modalHelp.info(this._help);
    if (contentDiv) {
      var right = contentDiv.css('width');
      $(helpElement).css('right', right);
    }
    toastr.options.positionClass = previousToastPositionClass;
  }
};

// funzione che crea la help modal
proto._createModalHelp = function() {
  var self = this;
  var id = "close_button"+Math.floor(Math.random()*1000000)+""+Date.now();
  this._help += '<label for="'+id+'" style="float:right">Non mostrare più</label><input type="checkbox" id="'+id+'" class="pull-right"/>';
  // verifico se abilitato e se settato proprietà onhover
  if (this._onhover) {
    $(this.element).on('mouseenter', function() {
      if (!self._enabled) {
        self._showModalHelp();
      }
    });
  }
  this._clearModalHelp(id);
};

proto.getGeometryTypes = function() {
  return this._geometryTypes;
};

proto.getInteraction = function() {
  return this._interaction;
};

proto.isToggled = function() {
  return this._toggled;
};

// funzione per la gestione premuto non premuto
proto.toggle = function(toggle) {
  var toggle = toggle !== undefined ? toggle : !this._toggled;
  //stato del toogle;
  this._toggled = toggle;
  var controlButton = $(this.element).find('button').first();
  if (toggle) {
    this._showModalHelp();
    if (this._interaction) {
      this._interaction.setActive(true);
    }
    controlButton.addClass('g3w-ol-toggled');
  }
  else {
    if (this._interaction) {
      this._interaction.setActive(false);
    }
    controlButton.removeClass('g3w-ol-toggled');
  }
};

// funzione che abilita e disabilita il controllo
proto.setEnable = function(bool) {
  var controlButton = $(this.element).find('button').first();
  if (bool)  {
    controlButton.removeClass('g3w-ol-disabled');
  } else {
    controlButton.addClass('g3w-ol-disabled');
    controlButton.removeClass('g3w-ol-toggled');
    if (this._interaction) {
      this._interaction.setActive(false);
    }
  }
  this._enabled = bool;
};

proto.getEnable = function() {
  return this._enabled;
};

proto.getGeometryTypes = function() {
  return this._geometryTypes;
};

proto.setGeometryTypes = function(types) {
  this._geometryTypes = types;
};

proto.onSelectLayer = function() {
  return this._onSelectLayer;
};

proto.setMap = function(map) {
  if (!this._interaction && this._interactionClass) {
    this._interaction = new this._interactionClass;
    map.addInteraction(this._interaction);
    this._interaction.setActive(false);
  }
  Control.prototype.setMap.call(this,map);
};

proto._handleClick = function(e) {
  if (this._enabled) {
    this.toggle();
    Control.prototype._handleClick.call(this,e);
  }
};

proto.getIteraction = function() {
  return this._interaction;
};


module.exports = InteractionControl;

},{"./control":76}],79:[function(require,module,exports){
var utils = require('../utils');
var LenghtIteraction = require('../interactions/lengthinteraction');
var MeasureControl = require('./measurecontrol');

var LengthControl = function(options) {
  var _options = {
    name: "Lunghezza",
    label: "\ue908",
    interactionClass: LenghtIteraction
  };

  options = utils.merge(options,_options);
  MeasureControl.call(this, options);
};

ol.inherits(LengthControl, MeasureControl);


module.exports = LengthControl;

},{"../interactions/lengthinteraction":92,"../utils":101,"./measurecontrol":80}],80:[function(require,module,exports){
var InteractionControl = require('./interactioncontrol');

var MeasureControl = function(options) {
  this._map = null;
  this._projection = null;
  InteractionControl.call(this, options);
};

ol.inherits(MeasureControl, InteractionControl);

var proto = MeasureControl.prototype;

proto.setMap = function(map) {
  InteractionControl.prototype.setMap.call(this, map);
};

proto.toggle = function(toggle) {
  InteractionControl.prototype.toggle.call(this, toggle);
  if (!this.isToggled()) {
    //vado a fare il clen del measure control che erara stato eventualmente acceso
    // esempio area se attivo su lenght e viceversa
    this.getIteraction().clear();
  }
};

module.exports = MeasureControl;

},{"./interactioncontrol":78}],81:[function(require,module,exports){
var Control = require('./control');
function NominatimControl() {
  var self = this;
  this.options = {
    provider: 'osm',
    placeholder: 'Città, indirizzo ... ',
    targetType: 'text-input',
    lang: 'it-IT',
    limit: 5,
    keepOpen: true,
    preventDefault: false,
    autoComplete: false,
    autoCompleteMinLength: 4,
    debug: false
  };

  var inputQueryId = "gcd-input-query";
  var inputResetId = "gcd-input-reset";
  var cssClasses = {
    "namespace": "ol-geocoder",
    "spin": "gcd-pseudo-rotate",
    "hidden": "gcd-hidden",
    "country": "gcd-country",
    "city": "gcd-city",
    "road": "gcd-road",
    "olControl": "ol-control",
    "glass": {
      "container": "gcd-gl-container",
      "control": "gcd-gl-control",
      "button": "gcd-gl-btn",
      "input": "gcd-gl-input",
      "expanded": "gcd-gl-expanded",
      "reset": "gcd-gl-reset",
      "result": "gcd-gl-result"
    },
    "inputText": {
      "container": "gcd-txt-container",
      "control": "gcd-txt-control",
      "input": "gcd-txt-input",
      "reset": "gcd-txt-reset",
      "icon": "gcd-txt-glass",
      "result": "gcd-txt-result"
    }
  };

  var targetType = {
    GLASS: 'glass-button',
    INPUT: 'text-input'
  };
  var vars = Object.freeze({
    inputQueryId: inputQueryId,
    inputResetId: inputResetId,
    cssClasses: cssClasses,
    default: {
      inputQueryId: inputQueryId,
      inputResetId: inputResetId,
      cssClasses: cssClasses
    }
  });

  var utils = {
    toQueryString: function toQueryString(obj) {
      var this$1 = this;
      return Object.keys(obj).reduce(function (a, k) {
        a.push(
          typeof obj[k] === 'object' ?
            this$1.toQueryString(obj[k]) :
            encodeURIComponent(k) + '=' + encodeURIComponent(obj[k])
        );
        return a;
      }, []).join('&');
    },
    encodeUrlXhr: function encodeUrlXhr(url, data) {
      if(data && typeof data === 'object') {
        var str_data = this.toQueryString(data);
        url += (/\?/.test(url) ? '&' : '?') + str_data;
      }
      return url;
    },
    json: function json(url, data) {
      return $.get(url, data)
      },
    jsonp: function jsonp(url, key, callback) {
        // https://github.com/Fresheyeball/micro-jsonp/blob/master/src/jsonp.js
        var head = document.head,
          script = document.createElement('script'),
          // generate minimally unique name for callback function
          callbackName = 'f' + Math.round(Math.random() * Date.now());

        // set request url
        script.setAttribute('src',
          /*  add callback parameter to the url
           where key is the parameter key supplied
           and callbackName is the parameter value */
          (url + (url.indexOf('?') > 0 ? '&' : '?') + key + '=' + callbackName));

        /*  place jsonp callback on window,
         the script sent by the server should call this
         function as it was passed as a url parameter */
        window[callbackName] = function (json) {
          window[callbackName] = undefined;

          // clean up script tag created for request
          setTimeout(function () {
            head.removeChild(script);
          }, 0);

          // hand data back to the user
          callback(json);
        };

        // actually make the request
        head.appendChild(script);
      },
      now: function now() {
        // Polyfill for window.performance.now()
        // @license http://opensource.org/licenses/MIT
        // copyright Paul Irish 2015
        // https://gist.github.com/paulirish/5438650
        if('performance' in window === false) {
          window.performance = {};
        }

        Date.now = (Date.now || function () {  // thanks IE8
          return new Date().getTime();
        });

        if('now' in window.performance === false) {

          var nowOffset = Date.now();

          if(performance.timing && performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart;
          }

          window.performance.now = function now() {
            return Date.now() - nowOffset;
          };
        }
        return window.performance.now();
      },

      flyTo: function flyTo(map, coord, duration, resolution) {
        resolution = resolution || 2.388657133911758;
        duration = duration || 500;
        var view = map.getView();
        view.animate({duration: duration, resolution: resolution},
          {duration: duration, center: coord});
      },
      randomId: function randomId(prefix) {
        var id = this.now().toString(36);
        return prefix ? prefix + id : id;
      },
      isNumeric: function isNumeric(str) {
        return /^\d+$/.test(str);
      },
      classRegex: function classRegex(classname) {
        return new RegExp(("(^|\\s+) " + classname + " (\\s+|$)"));
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String|Array<String>} classname Class or array of classes.
       * For example: 'class1 class2' or ['class1', 'class2']
       * @param {Number|undefined} timeout Timeout to remove a class.
       */
      addClass: function addClass(element, classname, timeout) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.addClass(each, classname);
          });
          return;
        }

        var array = (Array.isArray(classname))
          ? classname
          : classname.split(/\s+/);
        var i = array.length;

        while (i--) {
          if(!this$1.hasClass(element, array[i])) {
            this$1._addClass(element, array[i], timeout);
          }
        }
      },
      _addClass: function _addClass(el, klass, timeout) {
        var this$1 = this;

        // use native if available
        if(el.classList) {
          el.classList.add(klass);
        } else {
          el.className = (el.className + ' ' + klass).trim();
        }

        if(timeout && this.isNumeric(timeout)) {
          window.setTimeout(function () {
            this$1._removeClass(el, klass);
          }, timeout);
        }
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String|Array<String>} classname Class or array of classes.
       * For example: 'class1 class2' or ['class1', 'class2']
       * @param {Number|undefined} timeout Timeout to add a class.
       */
      removeClass: function removeClass(element, classname, timeout) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.removeClass(each, classname, timeout);
          });
          return;
        }

        var array = (Array.isArray(classname))
          ? classname
          : classname.split(/\s+/);
        var i = array.length;

        while (i--) {
          if(this$1.hasClass(element, array[i])) {
            this$1._removeClass(element, array[i], timeout);
          }
        }
      },
      _removeClass: function _removeClass(el, klass, timeout) {
        var this$1 = this;

        if(el.classList) {
          el.classList.remove(klass);
        } else {
          el.className = (el.className.replace(this.classRegex(klass), ' ')).trim();
        }
        if(timeout && this.isNumeric(timeout)) {
          window.setTimeout(function () {
            this$1._addClass(el, klass);
          }, timeout);
        }
      },
      /**
       * @param {Element} element DOM node.
       * @param {String} classname Classname.
       * @return {Boolean}
       */
      hasClass: function hasClass(element, c) {
        // use native if available
        return element.classList
          ? element.classList.contains(c)
          : this.classRegex(c).test(element.className);
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String} classname Classe.
       */
      toggleClass: function toggleClass(element, classname) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.toggleClass(each, classname);
          });
          return;
        }

        // use native if available
        if(element.classList) {
          element.classList.toggle(classname);
        } else {
          if(this.hasClass(element, classname)) {
            this._removeClass(element, classname);
          } else {
            this._addClass(element, classname);
          }
        }
      },
      /**
       * Abstraction to querySelectorAll for increased
       * performance and greater usability
       * @param {String} selector
       * @param {Element} context (optional)
       * @param {Boolean} find_all (optional)
       * @return (find_all) {Element} : {Array}
       */
      find: function find(selector, context, find_all) {
        if(context === void 0) context = window.document;
        var simpleRe = /^(#?[\w-]+|\.[\w-.]+)$/,
          periodRe = /\./g,
          slice = Array.prototype.slice,
          matches = [];

        // Redirect call to the more performant function
        // if it's a simple selector and return an array
        // for easier usage
        if(simpleRe.test(selector)) {
          switch (selector[0]) {
            case '#':
              matches = [this.$(selector.substr(1))];
              break;
            case '.':
              matches = slice.call(context.getElementsByClassName(
                selector.substr(1).replace(periodRe, ' ')));
              break;
            default:
              matches = slice.call(context.getElementsByTagName(selector));
          }
        } else {
          // If not a simple selector, query the DOM as usual
          // and return an array for easier usage
          matches = slice.call(context.querySelectorAll(selector));
        }
        return (find_all) ? matches : matches[0];
      },
      $: function $(id) {
        id = (id[0] === '#') ? id.substr(1, id.length) : id;
        return document.getElementById(id);
      },
      isElement: function isElement(obj) {
        // DOM, Level2
        if('HTMLElement' in window) {
          return (!!obj && obj instanceof HTMLElement);
        }
        // Older browsers
        return (!!obj && typeof obj === 'object' && obj.nodeType === 1 &&
        !!obj.nodeName);
      },
      getAllChildren: function getAllChildren(node, tag) {
        return [].slice.call(node.getElementsByTagName(tag));
      },
      isEmpty: function isEmpty(str) {
        return (!str || 0 === str.length);
      },
      emptyArray: function emptyArray(array) {
        while (array.length) {
          array.pop();
        }
      },
      anyMatchInArray: function anyMatchInArray(source, target) {
        return source.some(function (each) {
          return target.indexOf(each) >= 0;
        });
      },
      everyMatchInArray: function everyMatchInArray(arr1, arr2) {
        return arr2.every(function (each) {
          return arr1.indexOf(each) >= 0;
        });
      },
      anyItemHasValue: function anyItemHasValue(obj, has) {
        var this$1 = this;
        if(has === void 0) has = false;

        var keys = Object.keys(obj);
        keys.forEach(function (key) {
          if(!this$1.isEmpty(obj[key])) {
            has = true;
          }
        });
        return has;
      },
      removeAllChildren: function removeAllChildren(node) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      },
      removeAll: function removeAll(collection) {
        var node;
        while ((node = collection[0])) {
          node.parentNode.removeChild(node);
        }
      },
      getChildren: function getChildren(node, tag) {
        return [].filter.call(
          node.childNodes, function (el) {
            return tag
              ? el.nodeType === 1 && el.tagName.toLowerCase() === tag
              : el.nodeType === 1;
          }
        );
      },
      template: function template(html, row) {
        var this$1 = this;

        return html.replace(/\{ *([\w_-]+) *\}/g, function (htm, key) {
          var value = (row[key] === undefined) ? '' : row[key];
          return this$1.htmlEscape(value);
        });
      },
      htmlEscape: function htmlEscape(str) {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      },
      /**
       * Overwrites obj1's values with obj2's and adds
       * obj2's if non existent in obj1
       * @returns obj3 a new object based on obj1 and obj2
       */
      mergeOptions: function mergeOptions(obj1, obj2) {
        var obj3 = {};
        for (var attr1 in obj1) {
          obj3[attr1] = obj1[attr1];
        }
        for (var attr2 in obj2) {
          obj3[attr2] = obj2[attr2];
        }
        return obj3;
      },
      createElement: function createElement(node, html) {
        var elem;
        if(Array.isArray(node)) {
          elem = document.createElement(node[0]);

          if(node[1].id) {
            elem.id = node[1].id;
          }
          if(node[1].classname) {
            elem.className = node[1].classname;
          }

          if(node[1].attr) {
            var attr = node[1].attr;
            if(Array.isArray(attr)) {
              var i = -1;
              while (++i < attr.length) {
                elem.setAttribute(attr[i].name, attr[i].value);
              }
            } else {
              elem.setAttribute(attr.name, attr.value);
            }
          }
        } else {
          elem = document.createElement(node);
        }
        elem.innerHTML = html;
        var frag = document.createDocumentFragment();

        while (elem.childNodes[0]) {
          frag.appendChild(elem.childNodes[0]);
        }
        elem.appendChild(frag);
        return elem;
      },
      assert: function assert(condition, message) {
        if(message === void 0) message = 'Assertion failed';

        if(!condition) {
          if(typeof Error !== 'undefined') {
            throw new Error(message);
          }
          throw message; // Fallback
        }
      }
    };

    var klasses = vars.cssClasses;
    var klasses$1 = vars.cssClasses;

  // classe Html //
  var Html = function Html(base) {
    this.options = base.options;
    this.els = this.createControl();
  };

  Html.prototype.createControl = function createControl () {
    var container, containerClass, elements;

    if (this.options.targetType === targetType.INPUT) {
      containerClass = klasses.namespace + ' ' + klasses.inputText.container;
      container = utils.createElement(
        ['div', { classname: containerClass }], Html.input);
      elements = {
        container: container,
        control: utils.find('.' + klasses.inputText.control, container),
        input: utils.find('.' + klasses.inputText.input, container),
        reset: utils.find('.' + klasses.inputText.reset, container),
        result: utils.find('.' + klasses.inputText.result, container)
      };
    } else {
      containerClass = klasses.namespace + ' ' + klasses.glass.container;
      container = utils.createElement(
        ['div', { classname: containerClass }], Html.glass);
      elements = {
        container: container,
        control: utils.find('.' + klasses.glass.control, container),
        button: utils.find('.' + klasses.glass.button, container),
        input: utils.find('.' + klasses.glass.input, container),
        reset: utils.find('.' + klasses.glass.reset, container),
        result: utils.find('.' + klasses.glass.result, container)
      };
    }
    //set placeholder from options
    elements.input.placeholder = this.options.placeholder;
    return elements;
  };

  /* eslint-disable indent */
  Html.glass = [
    '<div class="', klasses.glass.control, ' ', klasses.olControl, '">',
    '<button type="button" class="', klasses.glass.button, '"></button>',
    '<input type="text"',
    ' id="', vars.inputQueryId, '"',
    ' class="', klasses.glass.input, '"',
    ' autocomplete="off" placeholder="Search ...">',
    '<a',
    ' id="', vars.inputResetId, '"',
    ' class="', klasses.glass.reset, ' ', klasses.hidden, '"',
    '></a>',
    '</div>',
    '<ul class="', klasses.glass.result, '"></ul>'
  ].join('');

  Html.input = [
    '<div class="', klasses.inputText.control, '">',
    '<input type="text"',
    ' id="', vars.inputQueryId, '"',
    ' class="', klasses.inputText.input, '"',
    ' autocomplete="off" placeholder="Search ...">',
    '<button type="button" class="btn btn-primary" id="search_nominatim"><i class="fa fa-search" aria-hidden="true"></i></button>',
    '<button type="button"',
    ' id="', vars.inputResetId, '"',
    ' class="', klasses.inputText.reset, ' ', klasses.hidden, '"',
    '></button>',
    '</div>',
    '<ul class="', klasses.inputText.result, '"></ul>'
  ].join('');

  // classe Html fine //

  // classe OpenStreet //

  var OpenStreet = function OpenStreet() {

    this.settings = {
      url: '//nominatim.openstreetmap.org/search/',
      params: {
        q: '',
        format: 'json',
        addressdetails: 1,
        limit: 10,
        countrycodes: 'IT',
        'accept-language': 'it-IT'
      }
    };
  };


  OpenStreet.prototype.getParameters = function getParameters(options) {
    return {
      url: this.settings.url,
      params: {
        q: options.query,
        format: 'json',
        addressdetails: 1,
        limit: options.limit || this.settings.params.limit,
        countrycodes: options.countrycodes || this.settings.params.countrycodes,
        'accept-language': options.lang || this.settings.params['accept-language']
      }
    };
  };

  OpenStreet.prototype.handleResponse = function handleResponse(results) {
    return results.map(function (result) {
      return ({
        lon: result.lon,
        lat: result.lat,
        address: {
          name: result.address.neighbourhood || '',
          road: result.address.road || '',
          postcode: result.address.postcode,
          city: result.address.city || result.address.town,
          state: result.address.state,
          country: result.address.country
        },
        original: {
          formatted: result.display_name,
          details: result.address
        }
      });
    });
  };

  // classe OpenStreet fine //

  // classe Nomitatim //

  var Nominatim = function Nominatim(base, els) {
    this.Base = base;
    this.options = base.options;
    this.options.provider = this.options.provider.toLowerCase();
    this.els = els;
    this.lastQuery = '';
    this.container = this.els.container;
    this.registeredListeners = { mapClick: false };
    this.setListeners();
    this.OpenStreet = new OpenStreet();

  };

  Nominatim.prototype.setListeners = function setListeners () {
    var this$1 = this;
    var timeout, lastQuery;
    var openSearch = function () {
      utils.hasClass(this$1.els.control, klasses$1.glass.expanded) ?
        this$1.collapse() : this$1.expand();
    };
    var query = function (evt) {
      var value = evt.target.value.trim();
      var hit = evt.key ? evt.key === 'Enter' :
        evt.which ? evt.which === 13 :
          evt.keyCode ? evt.keyCode === 13 : false;

      if (hit) {
        evt.preventDefault();
        this$1.query(value);
      }
    };
    var reset = function (evt) {
      this$1.els.input.focus();
      this$1.els.input.value = '';
      this$1.lastQuery = '';
      utils.addClass(this$1.els.reset, klasses$1.hidden);
      this$1.clearResults();
    };
    var handleValue = function (evt) {
      var value = evt.target.value.trim();

      value.length
        ? utils.removeClass(this$1.els.reset, klasses$1.hidden)
        : utils.addClass(this$1.els.reset, klasses$1.hidden);

      if (this$1.options.autoComplete && value !== lastQuery) {
        lastQuery = value;
        timeout && clearTimeout(timeout);
        timeout = setTimeout(function () {
          if (value.length >= this$1.options.autoCompleteMinLength) {
            this$1.query(value);
          }
        }, 200);
      }
    };
    this.els.input.addEventListener('keyup', query, false);
    this.els.input.addEventListener('input', handleValue, false);
    this.els.reset.addEventListener('click', reset, false);
    if (this.options.targetType === targetType.GLASS) {
      this.els.button.addEventListener('click', openSearch, false);
    }
  };

  Nominatim.prototype.query = function query (q) {
    var this$1 = this;
    var ajax = {}, options = this.options;
    var provider = this.getProvider({
      query: q,
      provider: options.provider,
      key: options.key,
      lang: options.lang,
      countrycodes: options.countrycodes,
      limit: options.limit
    });
    if (this.lastQuery === q && this.els.result.firstChild) { return; }
    this.lastQuery = q;
    this.clearResults();
    utils.addClass(this.els.reset, klasses$1.spin);
    ajax.url = document.location.protocol + provider.url;
    ajax.data = provider.params;
    utils.json(ajax)
      .done(function(res) {
        utils.removeClass(this$1.els.reset, klasses$1.spin);
            //will be fullfiled according to provider
            var res_= res.length ? this$1.OpenStreet.handleResponse(res) : undefined;
            this$1.createList(res_);
            if (res_) {
              this$1.listenMapClick();
            }

      })
      .fail(function(error){
        utils.removeClass(this$1.els.reset, klasses$1.spin);
            var li = utils.createElement(
              'li', '<h5>  Il server non risponde</h5>');
            this$1.els.result.appendChild(li);
      })

  };

  Nominatim.prototype.createList = function createList (response) {
    var this$1 = this;
    var ul = this.els.result;
    if (response) {
      response.forEach(function (row) {
        var addressHtml = this$1.addressTemplate(row.address),
          html = ['<a href="#">', addressHtml, '</a>'].join(''),
          li = utils.createElement('li', html);
        li.addEventListener('click', function (evt) {
          evt.preventDefault();
          this$1.chosen(row, addressHtml, row.address, row.original);
        }, false);
        ul.appendChild(li);
      });
    } else {
      li = utils.createElement('li', 'Nessun Risultato');
      ul.appendChild(li);
    }

  };

  Nominatim.prototype.chosen = function chosen(place, addressHtml, addressObj, addressOriginal) {
    var map = this.Base.getMap();
    var coord_ = [parseFloat(place.lon), parseFloat(place.lat)];
    var projection = map.getView().getProjection();
    var coord = ol.proj.transform(coord_, 'EPSG:4326', projection);
    var address = {
      formatted: addressHtml,
      details: addressObj,
      original: addressOriginal
    };
    this.options.keepOpen === false && this.clearResults(true);
    this.Base.dispatchEvent({
      type: 'addresschosen',
      address: address,
      coordinate: coord
    });
  };

  Nominatim.prototype.addressTemplate = function addressTemplate (address) {
    var html = [];
    if (address.name) {
      html.push(['<div class="', klasses$1.road, '">{name}</div>'].join(''));
    }
    if (address.road || address.building || address.house_number) {
      html.push([
        '<div class="', klasses$1.road,
        '">{building} {road} {house_number}</div>'
      ].join(''));
    }
    if (address.city || address.town || address.village) {
      html.push([
        '<div class="', klasses$1.city,
        '">{postcode} {city} {town} {village}</div>'
      ].join(''));
    }
    if (address.state || address.country) {
      html.push([
        '<div class="', klasses$1.country, '">{state} {country}</div>'
      ].join(''));
    }
    return utils.template(html.join('<br>'), address);
  };

  Nominatim.prototype.getProvider = function getProvider (options) {
    return this.OpenStreet.getParameters(options);
  };

  Nominatim.prototype.expand = function expand () {
    var this$1 = this;

    utils.removeClass(this.els.input, klasses$1.spin);
    utils.addClass(this.els.control, klasses$1.glass.expanded);
    window.setTimeout(function () { return this$1.els.input.focus(); }, 100);
    this.listenMapClick();
  };

  Nominatim.prototype.collapse = function collapse () {
    this.els.input.value = '';
    this.els.input.blur();
    utils.addClass(this.els.reset, klasses$1.hidden);
    utils.removeClass(this.els.control, klasses$1.glass.expanded);
    this.clearResults();
  };

  Nominatim.prototype.listenMapClick = function listenMapClick () {
    // already registered
    if (this.registeredListeners.mapClick) { return; }

    var this_ = this;
    var mapElement = this.Base.getMap().getTargetElement();
    this.registeredListeners.mapClick = true;

    //one-time fire click
    mapElement.addEventListener('click', {
      handleEvent: function (evt) {
        this_.clearResults(true);
        mapElement.removeEventListener(evt.type, this, false);
        this_.registeredListeners.mapClick = false;
      }
    }, false);
  };

  Nominatim.prototype.clearResults = function clearResults (collapse) {
    collapse && this.options.targetType === targetType.GLASS ?
      this.collapse() : utils.removeAllChildren(this.els.result);
  };

  Nominatim.prototype.getSource = function getSource () {
    return this.layer.getSource();
  };

  Nominatim.prototype.addLayer = function addLayer () {
    var this$1 = this;

    var found = false;
    var map = this.Base.getMap();

    map.getLayers().forEach(function (layer) {
      if (layer === this$1.layer) { found = true; }
    });
    if (!found) { map.addLayer(this.layer); }
  };

  // classe Nomitatim fine //

  var $html = new Html(this);
  this.container = $html.els.container;
  this.nominatim = new Nominatim(this, $html.els);
  this.layer = this.nominatim.layer;
  Control.call(this, {
    element: this.container,
    name: "nominatim"
  });
}

ol.inherits(NominatimControl, Control);

proto = NominatimControl.prototype;


module.exports = NominatimControl;

},{"./control":76}],82:[function(require,module,exports){
var OLControl = function(options){
  this._control = null;
  this.positionCode = options.position || 'tl';
  
  switch (options.type) {
    case 'zoom':
      this._control = new ol.control.Zoom(options);
      break;
    case 'zoomtoextent':
      this._control = new ol.control.ZoomToExtent(options);
      break;
    case 'scaleline':
      this._control = new ol.control.ScaleLine(options);
      break;
    case 'overview':
      this._control = new ol.control.OverviewMap(options);
  }
  
  $(this._control.element).addClass("ol-control-"+this.positionCode);
  
  ol.control.Control.call(this,{
    element: this._control.element
  });
};

// sotto classe della classe control di OL3
ol.inherits(OLControl, ol.control.Control);
module.exports = OLControl;

var proto = OLControl.prototype;

proto.getPosition = function(positionCode) {
  var positionCode = positionCode || this.positionCode;
  var position = {};
  position['top'] = (positionCode.indexOf('t') > -1) ? true : false;
  position['left'] = (positionCode.indexOf('l') > -1) ? true : false;
  return position;
};

proto.layout = function(map) {
  if (map) {
    var position =  this.getPosition();
    var viewPort = map.getViewport();
    var previusControls = $(viewPort).find('.ol-control-'+this.positionCode);
    if (previusControls.length) {
      previusControl = previusControls.last();
      var previousOffset = position.left ? previusControl.position().left : previusControl.position().right;
      var hWhere = position.left ? 'left' : 'right';
      var previousWidth = previusControl[0].offsetWidth;
      var hOffset = $(this.element).position()[hWhere] + previousOffset + previousWidth + 2;
      $(this.element).css(hWhere,hOffset+'px');
    }
  }
};

proto.setMap = function(map){
  this.layout(map);
  this._control.setMap(map);
};

},{}],83:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var QueryBBoxControl = function(options){
  this._startCoordinate = null;
  var _options = {
    name: "querybbox",
    tipLabel: "Query BBox layer",
    label: "\ue902",
    interactionClass: ol.interaction.DragBox,
    help: '<h4>Guida - Query BBox layer</h4><ul><li>Disegna un rettangolo per interrogare gli strati evidenziati in giallo</li></ul>'
  };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(QueryBBoxControl, InteractionControl);

var proto = QueryBBoxControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });
  this._interaction.on('boxend',function(e){
    var start_coordinate = self._startCoordinate;
    var end_coordinate = e.coordinate;
    var extent = ol.extent.boundingExtent([start_coordinate,end_coordinate]);
    self.dispatchEvent({
      type: 'bboxend',
      extent: extent
    });
    self._startCoordinate = null;
    if (self._autountoggle) {
      self.toggle();
    }
  })
};

module.exports = QueryBBoxControl;

},{"../utils":101,"./interactioncontrol":78}],84:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');

var QueryByPolygonControl = function(options){
  var _options = {
    name: "querybypolygon",
    tipLabel: "Query By Polygon",
    label: "\ue903",
    geometryTypes: ['Polygon', 'MultiPolygon'],
    onselectlayer: true,
    interactionClass: PickCoordinatesInteraction,
    help: '<h4>Guida - Query By Polygon</h4><ul><li>Seleziona uno strato poligonale</li><li>Clicca su una feature dello strato selezionato per lanciare la selezione</li></ul>',
    onhover: true
  };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(QueryByPolygonControl, InteractionControl);

var proto = QueryByPolygonControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });

  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
  this.setEnable(false);
};

module.exports = QueryByPolygonControl;

},{"../interactions/pickcoordinatesinteraction":94,"../utils":101,"./interactioncontrol":78}],85:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');

var QueryControl = function(options){
  var _options = {
    name: "querylayer",
    tipLabel: "Query layer",
    label: "\uea0f",
    interactionClass: PickCoordinatesInteraction
  };
  options = utils.merge(options, _options);
  InteractionControl.call(this, options);
};

ol.inherits(QueryControl, InteractionControl);

var proto = QueryControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });

  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
};

module.exports = QueryControl;

},{"../interactions/pickcoordinatesinteraction":94,"../utils":101,"./interactioncontrol":78}],86:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var ResetControl = function(options){
  this._toggled = true;
  this._startCoordinate = null;
  var _options = {
      name: "reset",
      tipLabel: "Pan",
      label: "\ue901"
    };
  
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);

};

ol.inherits(ResetControl, InteractionControl);

module.exports = ResetControl;

var proto = ResetControl.prototype;

proto._postRender = function(){
  this.toggle(true);
};

},{"../utils":101,"./interactioncontrol":78}],87:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');


var StreetViewControl = function(options) {
  var _options = {
    name: "streetview",
    tipLabel: "StreetView",
    label: "\ue905",
    interactionClass: PickCoordinatesInteraction
  };
  this._sv = null;
  this._panorama = null;
  this._map = null;
  this._projection = null;
  this._streetViewFeature = new ol.Feature();
  this._streetViewFeature.setStyle(style = new ol.style.Style({
    text: new ol.style.Text({
      text: '\ue905',
      font: 'bold 30px icomoon',
      textBaseline: 'Bottom',
      fill: new ol.style.Fill({
        color: '#3c8dbc'
      })
    })
  }));
  var streetVectorSource = new ol.source.Vector({
    features: []
  });

  this._layer = new ol.layer.Vector({
    source: streetVectorSource
  });
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(StreetViewControl, InteractionControl);

var proto = StreetViewControl.prototype;


proto.getLayer = function() {
  return this._layer;
};

proto.setProjection = function(projection) {
  this._projection = projection;
};

proto.setPosition = function(position) {
  var self = this;
  var lnglat;
  var pixel;
  if (!this._sv) {
    this._sv = new google.maps.StreetViewService();
  }
  this._sv.getPanorama({location: position}, function (data) {
    self._panorama = new google.maps.StreetViewPanorama(
      document.getElementById('streetview')
    );
    self._panorama.addListener('position_changed', function() {
      if (self.isToggled()) {
        lnglat = ol.proj.transform([this.getPosition().lng(), this.getPosition().lat()], 'EPSG:4326', self._projection.getCode());
        self._layer.getSource().getFeatures()[0].setGeometry(
          new ol.geom.Point(lnglat)
        );
        pixel = self._map.getPixelFromCoordinate(lnglat);
        if ((pixel[0] + 15) > self._map.getSize()[0] || (pixel[1] + 15) > self._map.getSize()[1] || pixel[0] < 15 || pixel [1] < 15 ) {
          self._map.getView().setCenter(lnglat);
        }
      }
    });
    if (data && data.location) {
      self._panorama.setPov({
        pitch: 0,
        heading: 0
      });
      self._panorama.setPosition(data.location.latLng);
    }
  })
};

proto.setMap = function(map) {
  var self = this;
  this._map = map;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
};

proto.clear = function() {
  this._layer.getSource().clear();
  this._streetViewFeature.setGeometry(null);
};

proto.toggle = function(toggle) {
  InteractionControl.prototype.toggle.call(this, toggle);
  if (!this.isToggled()) {
    this.clear()
  } else {
    this._layer.getSource().addFeatures([this._streetViewFeature]);
  }
};

module.exports = StreetViewControl;

},{"../interactions/pickcoordinatesinteraction":94,"../utils":101,"./interactioncontrol":78}],88:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var ZoomBoxControl = function(options){
  var self = this;
  this._startCoordinate = null;
  var _options = {
      name: "zoombox",
      tipLabel: "Zoom to box",
      label: "\ue901",
      interactionClass: ol.interaction.DragBox
    };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);

};
ol.inherits(ZoomBoxControl, InteractionControl);
module.exports = ZoomBoxControl;

var proto = ZoomBoxControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });
  
  this._interaction.on('boxend',function(e){
    var start_coordinate = self._startCoordinate;
    var end_coordinate = e.coordinate;
    var extent = ol.extent.boundingExtent([start_coordinate,end_coordinate]);
    self.dispatchEvent({
      type: 'zoomend',
      extent: extent
    });
    self._startCoordinate = null;
    if (self._autountoggle) {
      self.toggle();
    }
  });
};


},{"../utils":101,"./interactioncontrol":78}],89:[function(require,module,exports){
var utils = require('./utils');
var maphelpers = require('./map/maphelpers');

(function (name, root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  }
  else if (typeof exports === 'object') {
    module.exports = factory();
  }
  else {
    root[name] = factory();
  }
})('g3wol3', this, function () {
  'use strict';
  
  var helpers = utils.merge({},maphelpers);
  
  return {
    helpers: helpers
  }
});

},{"./map/maphelpers":98,"./utils":101}],90:[function(require,module,exports){
var MeasureInteraction = require('./measureinteraction');

// Area

var AreaIteraction = function() {
  var options = {};
  options.geometryType = "Polygon";
  MeasureInteraction.call(this, options);
};

ol.inherits(AreaIteraction, MeasureInteraction);

module.exports = AreaIteraction;
},{"./measureinteraction":93}],91:[function(require,module,exports){
var DeleteInteractionEvent = function(type, features, coordinate) {
  this.type = type;
  this.features = features;
  this.coordinate = coordinate;
};

var DeleteInteraction = function(options) {
  ol.interaction.Pointer.call(this, {
    handleDownEvent: DeleteInteraction.handleDownEvent_,
    handleMoveEvent: DeleteInteraction.handleMoveEvent_,
    handleUpEvent: DeleteInteraction.handleUpEvent_,
    handleEvent: DeleteInteraction.handleEvent_,
  });

  this.previousCursor_ = undefined;
  this.lastCoordinate_ = null;
  this.features_ = options.features !== undefined ? options.features : null;
};
ol.inherits(DeleteInteraction, ol.interaction.Pointer);

DeleteInteraction.handleEvent_ = function(mapBrowserEvent) {
  if (mapBrowserEvent.type == 'keydown'){
    if(this.features_.getArray().length && mapBrowserEvent.originalEvent.keyCode == 46){
      this.dispatchEvent(
          new DeleteInteractionEvent(
              'deleteend', this.features_,
              event.coordinate));
      return true;
    }
  }
  else{
    return ol.interaction.Pointer.handleEvent.call(this,mapBrowserEvent);
  }
};

DeleteInteraction.handleDownEvent_ = function(event) {
  this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  if (this.lastFeature_) {
    DeleteInteraction.handleMoveEvent_.call(this, event);
    this.dispatchEvent(
            new DeleteInteractionEvent(
                'deleteend', this.features_,
                event.coordinate));
    return true;
  }
  return false;
};

DeleteInteraction.handleMoveEvent_ = function(event) {
  var elem = event.map.getTargetElement();
  var intersectingFeature = event.map.forEachFeatureAtPixel(event.pixel,
      function(feature) {
        return feature;
      });

  if (intersectingFeature) {
    this.previousCursor_ = elem.style.cursor;

    elem.style.cursor =  'pointer';

  } else {
    elem.style.cursor = this.previousCursor_ !== undefined ?
        this.previousCursor_ : '';
    this.previousCursor_ = undefined;
  }
};

DeleteInteraction.prototype.featuresAtPixel_ = function(pixel, map) {
  var found = null;

  var intersectingFeature = map.forEachFeatureAtPixel(pixel,
      function(feature) {
        return feature;
      });

  if (this.features_ &&
     _.includes(this.features_.getArray(), intersectingFeature)) {
    found = intersectingFeature;
  }

  return found;
};

module.exports = DeleteInteraction;

},{}],92:[function(require,module,exports){
var MeasureInteraction = require('./measureinteraction');

// LenghtInteracion
var LengthIteraction = function() {
  var options = {};
  options.geometryType = "LineString";
  MeasureInteraction.call(this, options)
};

ol.inherits(LengthIteraction, MeasureInteraction);


module.exports = LengthIteraction;
},{"./measureinteraction":93}],93:[function(require,module,exports){
// MeasureInteracion

var MeasureIteraction = function(options) {
  this._helpTooltip;
  this._measureTooltipElement;
  this._measureTooltip;
  this._featureGeometryChangelistener;
  this._poinOnMapMoveListener;

  var measureStyle = new ol.style.Style({
    fill: new ol.style.Fill({
      color: 'rgba(255, 255, 255, 0.2)'
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(0, 0, 0, 0.5)',
      lineDash: [10, 10],
      width: 3
    }),
    image: new ol.style.Circle({
      radius: 5,
      stroke: new ol.style.Stroke({
        color: 'rgba(0, 0, 0, 0.7)'
      }),
      fill: new ol.style.Fill({
        color: 'rgba(255, 255, 255, 0.2)'
      })
    })
  });
  var geometryType = options.geometryType || 'LineString';
  this._formatMeasure = null;
  this._helpMsg = null;
  // funzione che serve per gestire il keydow della cancellazione ultimo vertice disegnato
  this._keyDownEventHandler = null;
  switch (geometryType) {
    case 'LineString':
     this._formatMeasure = function(feature) {
        var length;
        length = Math.round(feature.getLength() * 100) / 100;
        var output;
        if (length > 1000) {
          output = (Math.round(length / 1000 * 1000) / 1000) +
            ' ' + 'km';
        } else {
          output = (Math.round(length * 100) / 100) +
            ' ' + 'm';
        }
        return output;
      };
      this._helpMsg = "Clicca sulla mappa per continuare a disegnare la linea.<br>CANC se si vuole cancellare l'ultimo vertice inserito";
      break;
    case 'Polygon':
      this._formatMeasure = function(feature) {
        var area;
        area = Math.round(feature.getArea() * 100) / 100;
        var output;
        if (area > 1000) {
          output = (Math.round(area / 1000 * 1000) / 1000) +
            ' ' + 'km<sup>2</sup>';
        } else {
          output = (Math.round(area * 100) / 100) +
            ' ' + 'm<sup>2</sup>';
        }
        return output;
      };
      this._helpMsg = "Click per continuare a disegnare il poligono.<br>CANC se si vuole cancellare l'ultimo vertice inserito";
      break;
  }
  var source = new ol.source.Vector();
  this._helpTooltipElement;
  this._map = null;
  this._feature = null;
  this._layer = new ol.layer.Vector({
    source: source,
    style: function(feature) {
      var styles = [
        // linestring
        new ol.style.Style({
          stroke: new ol.style.Stroke({
            lineDash: [10, 10],
            width: 3
          }),
          fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
          })
        })
      ];
      return styles;
    }
  });
  ol.interaction.Draw.call(this, {
    source: source,
    type: geometryType,
    style: measureStyle
  });

  this.set('beforeRemove', this.clear);
  this.set('layer', this._layer);

  // registro gli eventi sulle due interaction
  this.on('drawstart', this._drawStart);
  this.on('drawend', this._drawEnd);

};

ol.inherits(MeasureIteraction, ol.interaction.Draw);


var proto = MeasureIteraction.prototype;

proto.clear = function() {
  this._layer.getSource().clear();
  this._clearMessagesAndListeners();
  if (this._map) {
    this._map.removeOverlay(this._measureTooltip);
    this._map.removeLayer(this._layer);
  }
};

proto._clearMessagesAndListeners = function() {
  this._feature = null;
  // unset tooltip so that a new one can be created
  if (this._map) {
    this._measureTooltipElement = null;
    this._helpTooltipElement.innerHTML = '';
    this._helpTooltipElement.classList.add('hidden');
    ol.Observable.unByKey(this._featureGeometryChangelistener);
    ol.Observable.unByKey(this._poinOnMapMoveListener);
    $(document).off('keydown', this._keyDownEventHandler);
  }
};

proto._removeLastPoint = function(event) {
  var geom = this._feature.getGeometry();
  if (event.keyCode === 46) {
    if( geom instanceof ol.geom.Polygon && geom.getCoordinates()[0].length > 2) {
      this.removeLastPoint();
    } else if(geom instanceof ol.geom.LineString && geom.getCoordinates().length > 1) {
      this.removeLastPoint();
    }
  }
};

//funzione drawStart
proto._drawStart = function(evt) {
  var self = this;
  this._map = this.getMap();
  this._createMeasureTooltip();
  this._createHelpTooltip();
  this._feature = evt.feature;
  this._keyDownEventHandler = _.bind(this._removeLastPoint, this);
  $(document).on('keydown', this._keyDownEventHandler);
  // vado a ripulire tutte le features
  this._layer.getSource().clear();
  this._poinOnMapMoveListener = this._map.on('pointermove', function(evt) {
    if (evt.dragging) {
      return;
    }
    if (self._feature) {
      helpMsg = self._helpMsg;
    }
    self._helpTooltipElement.innerHTML = helpMsg;
    self._helpTooltip.setPosition(evt.coordinate);
    self._helpTooltipElement.classList.remove('hidden');
  });
  var tooltipCoord = evt.coordinate;
  this._featureGeometryChangelistener = this._feature.getGeometry().on('change', function(evt) {
    var geom = evt.target;
    var output;
    if (geom instanceof ol.geom.Polygon) {
      tooltipCoord = geom.getInteriorPoint().getCoordinates();
    } else if (geom instanceof ol.geom.LineString) {
      tooltipCoord = geom.getLastCoordinate();
    }
    output = self._formatMeasure(geom);
    self._measureTooltipElement.innerHTML = output;
    self._measureTooltip.setPosition(tooltipCoord);
  });
};

//funzione drawEnd
proto._drawEnd = function() {
  this._measureTooltipElement.className = 'mtooltip mtooltip-static';
  this._measureTooltip.setOffset([0, -7]);
  this._clearMessagesAndListeners();
  this._map.addLayer(this._layer);
};

/**
 * Creates a new help tooltip
 */
proto._createHelpTooltip = function() {
  if (this._helpTooltipElement) {
    this._helpTooltipElement.parentNode.removeChild(this._helpTooltipElement);
  }
  if (this._helpTooltip) {
    this._map.removeOverlay(this._helpTooltip);
  }
  this._helpTooltipElement = document.createElement('div');
  this._helpTooltipElement.className = 'mtooltip hidden';
  this._helpTooltip = new ol.Overlay({
    element: this._helpTooltipElement,
    offset: [15, 0],
    positioning: 'center-left'
  });
  this._map.addOverlay(this._helpTooltip);
};


/**
 * Creates a new measure tooltip
 */
proto._createMeasureTooltip = function() {
  if (this._measureTooltipElement) {
    this._measureTooltipElement.parentNode.removeChild(this._measureTooltipElement);
  }
  if (this._measureTooltip) {
    this._map.removeOverlay(this._measureTooltip);
  }
  this._measureTooltipElement = document.createElement('div');
  this._measureTooltipElement.className = 'mtooltip mtooltip-measure';
  this._measureTooltip = new ol.Overlay({
    element: this._measureTooltipElement,
    offset: [0, -15],
    positioning: 'bottom-center'
  });
  this._map.addOverlay(this._measureTooltip);
};
// END MEASURE CONTROLS //

module.exports = MeasureIteraction;
},{}],94:[function(require,module,exports){
var PickCoordinatesEventType = {
  PICKED: 'picked'
};

var PickCoordinatesEvent = function(type, coordinate) {
  this.type = type;
  this.coordinate = coordinate;
};

var PickCoordinatesInteraction = function(options) {
  this.previousCursor_ = null;
  
  ol.interaction.Pointer.call(this, {
    handleDownEvent: PickCoordinatesInteraction.handleDownEvent_,
    handleUpEvent: PickCoordinatesInteraction.handleUpEvent_,
    handleMoveEvent: PickCoordinatesInteraction.handleMoveEvent_,
  });
};
ol.inherits(PickCoordinatesInteraction, ol.interaction.Pointer);

PickCoordinatesInteraction.handleDownEvent_ = function(event) {
  return true;
};

PickCoordinatesInteraction.handleUpEvent_ = function(event) {
  this.dispatchEvent(
          new PickCoordinatesEvent(
              PickCoordinatesEventType.PICKED,
              event.coordinate));
  return true;
};

PickCoordinatesInteraction.handleMoveEvent_ = function(event) {
  var elem = event.map.getTargetElement();
  elem.style.cursor =  'pointer';
};

PickCoordinatesInteraction.prototype.shouldStopEvent = function(){
  return false;
};

PickCoordinatesInteraction.prototype.setActive = function(active){
  var map = this.getMap();
  if (map) {
    var elem = map.getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setActive.call(this,active);
};

PickCoordinatesInteraction.prototype.setMap = function(map){
  if (!map) {
    var elem = this.getMap().getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setMap.call(this,map);
};

module.exports = PickCoordinatesInteraction;

},{}],95:[function(require,module,exports){
var PickFeatureEventType = {
  PICKED: 'picked'
};

var PickFeatureEvent = function(type, coordinate, feature) {
  this.type = type;
  this.feature = feature;
  this.coordinate = coordinate;
};

var PickFeatureInteraction = function(options) {

  var self = this;
  ol.interaction.Pointer.call(this, {
    handleDownEvent: PickFeatureInteraction.handleDownEvent_,
    handleUpEvent: PickFeatureInteraction.handleUpEvent_,
    handleMoveEvent: PickFeatureInteraction.handleMoveEvent_
  });
  this.features_ = options.features || null;
  this.layers_ = options.layers || null;
  this.pickedFeature_ = null;
  this.layerFilter_ = function(layer) {
    return _.includes(self.layers_, layer);
  };
};
ol.inherits(PickFeatureInteraction, ol.interaction.Pointer);

PickFeatureInteraction.handleDownEvent_ = function(event) {
  this.pickedFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  return true;
};

PickFeatureInteraction.handleUpEvent_ = function(event) {
  if(this.pickedFeature_){
    this.dispatchEvent(
            new PickFeatureEvent(
                PickFeatureEventType.PICKED,
                event.coordinate,
                this.pickedFeature_));
  }
  return true;
};

PickFeatureInteraction.handleMoveEvent_ = function(event) {
  var elem = event.map.getTargetElement();
  var intersectingFeature = this.featuresAtPixel_(event.pixel, event.map);
  if (intersectingFeature) {
    elem.style.cursor =  'pointer';
  } else {
    elem.style.cursor = '';
  }
};

PickFeatureInteraction.prototype.featuresAtPixel_ = function(pixel, map) {
  var featureFound = null;
  var self = this;
  var intersectingFeature = map.forEachFeatureAtPixel(pixel,
      function(feature) {
        if (self.features_) {
          if (self.features_.indexOf(feature) > -1){
            return feature
          }
          else{
            return null;
          }
        }
        return feature;
      }, {
        layerFilter: self.layerFilter_,
        hitTolerance: (isMobile && isMobile.any) ? 10 : 0
      });
  if (intersectingFeature) {
    featureFound = intersectingFeature;
  }
  return featureFound;
};

PickFeatureInteraction.prototype.shouldStopEvent = function(){
  return false;
};

PickFeatureInteraction.prototype.setMap = function(map){
  if (!map) {
    var elem = this.getMap().getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setMap.call(this,map);
};

module.exports = PickFeatureInteraction;

},{}],96:[function(require,module,exports){
var BaseLayers = {};

BaseLayers.OSM = new ol.layer.Tile({
  source: new ol.source.OSM({
    attributions: [
      new ol.Attribution({
        html: 'All maps &copy; ' +
            '<a href="http://www.openstreetmap.org/">OpenStreetMap</a>'
      }),
      ol.source.OSM.ATTRIBUTION
    ],
    url: 'http://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    crossOrigin: null
  }),
  id: 'osm',
  title: 'OSM',
  basemap: true
});

BaseLayers.BING = {};

BaseLayers.BING.Road = new ol.layer.Tile({
  name:'Road',
  visible: false,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'Road'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

BaseLayers.BING.AerialWithLabels = new ol.layer.Tile({
  name: 'AerialWithLabels',
  visible: true,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'AerialWithLabels'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

BaseLayers.BING.Aerial = new ol.layer.Tile({
  name: 'Aerial',
  visible: false,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'Aerial'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

module.exports = BaseLayers;

},{}],97:[function(require,module,exports){
var utils = require('../utils');
var RasterLayers = {};

RasterLayers.TiledWMSLayer = function(layerObj,extraParams){
  var options = {
    layerObj: layerObj,
    extraParams: extraParams || {},
    tiled: true
  };
  return RasterLayers._WMSLayer(options);
};

RasterLayers.WMSLayer = function(layerObj,extraParams){
  var options = {
    layerObj: layerObj,
    extraParams: extraParams || {}
  };
  return RasterLayers._WMSLayer(options);
};

RasterLayers._WMSLayer = function(options){
  var layerObj = options.layerObj;
  var extraParams = options.extraParams;
  var tiled = options.tiled || false;
  
  var params = {
    LAYERS: layerObj.layers || '',
    VERSION: '1.3.0',
    TRANSPARENT: true,
    SLD_VERSION: '1.1.0'
  };
  
  params = utils.merge(params,extraParams);
  
  var sourceOptions = {
    url: layerObj.url,
    params: params,
    ratio: 1
  };
  
  var imageOptions = {
    id: layerObj.id,
    name: layerObj.name,
    opacity: layerObj.opacity || 1.0,
    visible:layerObj.visible,
    maxResolution: layerObj.maxResolution
  };
  
  var imageClass;
  var source;
  if (tiled) {
    source = new ol.source.TileWMS(sourceOptions);
    imageClass = ol.layer.Tile;
    //imageOptions.extent = [1134867,3873002,2505964,5596944];
  }
  else {
    source = new ol.source.ImageWMS(sourceOptions);
    imageClass = ol.layer.Image;
  }
  
  imageOptions.source = source;
  
  return new imageClass(imageOptions);
};

RasterLayers.XYZLayer = function(options){
  if (!options.url){
    return;
  }

  var sourceOptions = {
    url: options.url
  };

  if (options.projection){
    sourceOptions.projection = options.projection;
  }
  if (options.maxZoom) {
    sourceOptions.maxZoom = options.maxZoom;
  }
  if (options.minZoom) {
    sourceOptions.minZoom = options.minZoom;
  }

  return new ol.layer.Tile({
    source: new ol.source.XYZ(sourceOptions)
  });
};

/*RasterLayers.TiledWMSLayer = function(layerObj){
  var layer = new ol.layer.Tile({
    name: layerObj.name,
    opacity: 1.0,
    source: new ol.source.TileWMS({
      url: layerObj.url,
      params: {
        LAYERS: layerObj.layers || '',
        VERSION: '1.3.0',
        TRANSPARENT: true
      }
    }),
    visible: layerObj.visible
  });
  
  return layer;
};*/

module.exports = RasterLayers;


},{"../utils":101}],98:[function(require,module,exports){
BaseLayers = require('../layers/bases');

var MapHelpers = {
  createViewer: function(opts){
    return new _Viewer(opts);
  }
};

var _Viewer = function(opts){
  var controls = ol.control.defaults({
    attributionOptions: {
      collapsible: false
    },
    zoom: false,
    attribution: false
  });//.extend([new ol.control.Zoom()]);
  
  var interactions = ol.interaction.defaults()
    .extend([
      new ol.interaction.DragRotate()
    ]);
  interactions.removeAt(1);// rimuovo douclickzoom
  
  var view;
  if (opts.view instanceof ol.View) {
    view = opts.view;
  }
  else {
    view = new ol.View(opts.view);
  }
  var options = {
    controls: controls,
    interactions: interactions,
    ol3Logo: false,
    view: view,
    keyboardEventTarget: document
  };
  if (opts.id){
    options.target = opts.id;
  }
  var map  = new ol.Map(options);
  this.map = map;
};

_Viewer.prototype.destroy = function(){
  if (this.map) {
    this.map.dispose();
    this.map = null
  }
};

_Viewer.prototype.getView = function() {
  return this.map.getView();
};

_Viewer.prototype.updateMap = function(mapObject){};

_Viewer.prototype.updateView = function(){};

_Viewer.prototype.getMap = function(){
  return this.map;
};

_Viewer.prototype.setTarget = function(id){
  this.map.setTarget(id);
};

_Viewer.prototype.goTo = function(coordinates, options) {
  var options = options || {};
  var animate = options.animate || true;
  var zoom = options.zoom || false;
  var view = this.map.getView();
  if (animate) {
    var panAnimation = {
      duration: 500,
      center: coordinates
    };
    if (zoom) {
      var zoomAnimation = {
        duration: 500,
        zoom: zoom
      };
    } else {
      var zoomAnimation = {
        duration: 500,
        resolution: view.getResolution()
      };
    }
    view.animate(panAnimation,zoomAnimation);
  } else {
    view.setCenter(coordinates);
    if (zoom) {
      view.setZoom(zoom);
    }
  }
};

_Viewer.prototype.goToRes = function(coordinates, options){
  var options = options || {};
  var animate = options.animate || true;
  var view = this.map.getView();
  var resolution = options.resolution || view.getResolution();
  
  if (animate) {
    var panAnimation = {
      duration: 300,
      center: coordinates
    };
    var zoomAnimation = {
      duration: 300,
      resolution: resolution
    };
    view.animate(panAnimation,zoomAnimation);
  } else {
    view.setCenter(coordinates);
    view.setResolution(resolution);
  }
};

_Viewer.prototype.fit = function(geometry, options){
  var view = this.map.getView();
  
  var options = options || {};
  var animate = options.animate || true;
  
  if (animate) {
    var panAnimation = view.animate({
      duration: 300,
      center: view.getCenter()
    });
    var zoomAnimation = view.animate({
      duration: 300,
      resolution: view.getResolution()
    });
    //this.map.getView().animate(panAnimation,zoomAnimation);
  }
  
  if (options.animate) {
    delete options.animate; // non lo passo al metodo di OL3 perché è un'opzione interna
  }
  options.constrainResolution = options.constrainResolution || true;
  
  view.fit(geometry,this.map.getSize(),options);
};

_Viewer.prototype.getZoom = function(){
  var view = this.map.getView();
  return view.getZoom();
};

_Viewer.prototype.getResolution = function(){
  var view = this.map.getView();
  return view.getResolution();
};

_Viewer.prototype.getCenter = function(){
  var view = this.map.getView();
  return view.getCenter();
};

_Viewer.prototype.getBBOX = function(){
  return this.map.getView().calculateExtent(this.map.getSize());
};

_Viewer.prototype.getLayerByName = function(layerName) {
  var layers = this.map.getLayers();
  var length = layers.getLength();
  for (var i = 0; i < length; i++) {
    if (layerName === layers.item(i).get('name')) {
      return layers.item(i);
    }
  }
  return null;
};

_Viewer.prototype.removeLayerByName = function(layerName){
  var layer = this.getLayerByName(layerName);
  if (layer){
    this.map.removeLayer(layer);
    delete layer;
  }
};

_Viewer.prototype.getActiveLayers = function(){
  var activelayers = [];
  this.map.getLayers().forEach(function(layer) {
    var props = layer.getProperties();
    if (props.basemap != true && props.visible){
       activelayers.push(layer);
    }
  });
  
  return activelayers;
};

_Viewer.prototype.removeLayers = function(){
  this.map.getLayers().clear();
};

_Viewer.prototype.getLayersNoBase = function(){
  var layers = [];
  this.map.getLayers().forEach(function(layer) {
    var props = layer.getProperties();
    if (props.basemap != true){
      layers.push(layer);
    }
  });
  
  return layers;
};

_Viewer.prototype.addBaseLayer = function(type){
  var layer;
  type ? layer = BaseLayers[type]:  layer = BaseLayers.BING.Aerial;
  this.map.addLayer(layer);
};

_Viewer.prototype.changeBaseLayer = function(layerName){
  var baseLayer = this.getLayerByName(layername);
  var layers = this.map.getLayers();
  layers.insertAt(0, baseLayer);
};

module.exports = MapHelpers;

},{"../layers/bases":96}],99:[function(require,module,exports){
var GENERIC_GRID_EXTENT = [0,0,8388608,8388608];

var Projection = function(options) {
  if (!options.crs) {
    return null;
  }

  if (options.proj4def) {
    proj4.defs(options.crs,options.proj4def);
  }

  ol.proj.Projection.call(this, {
    code: options.crs,
    extent: options.extent ? options.extent : GENERIC_GRID_EXTENT
  });

  // riespongo axisOrientation_ perché in OL è prinvata
  this._axisOrientation = options.axisOrientation ? options.axisOrientation : 'enu';
  if (options.proj4def) {
    var proj4def = proj4.defs(options.crs);
    if ( proj4def.axis != undefined) {
      this._axisOrientation = proj4def.axis;
    }
  }

};

ol.inherits(Projection, ol.proj.Projection);

var proto = Projection.prototype;

proto.getAxisOrientation = function() {
  return this._axisOrientation;
};

module.exports = Projection;
},{}],100:[function(require,module,exports){
var Projection = require('./projection');

var STANDARD_PROJECTIONS = [3857,900913,4326];

var Projections = {
  get: function(crs,proj4,extent) {
    crs = Projections.normalizeCrs(crs);
    var _proj =  ol.proj.projections? ol.proj.projections : ol.proj;
    var cachedProjection = _proj.get(crs);

    if (cachedProjection) {
      return cachedProjection;
    }

    var projection = new Projection({
      crs: crs,
      proj4def: proj4,
      extent: extent
    });

    _proj.add ? _proj.add(crs, projection) : _proj.addProjection(projection);

    return projection;
  },
  normalizeCrs: function(crs) {
    if (typeof crs == 'number') {
      return "EPSG:"+crs
    }
    crs = crs.replace(/[^\d\.\-]/g, "");
    if (crs != '') {
      return "EPSG:"+parseInt(crs);
    }
  }
};

module.exports = Projections;
},{"./projection":99}],101:[function(require,module,exports){
var utils = {
  merge: function(obj1,obj2){
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }
}

module.exports = utils;

},{}],102:[function(require,module,exports){
var utils = {
  getExtentForViewAndSize: function(center, resolution, rotation, size) {
    var dx = resolution * size[0] / 2;
    var dy = resolution * size[1] / 2;
    var cosRotation = Math.cos(rotation);
    var sinRotation = Math.sin(rotation);
    var xCos = dx * cosRotation;
    var xSin = dx * sinRotation;
    var yCos = dy * cosRotation;
    var ySin = dy * sinRotation;
    var x = center[0];
    var y = center[1];
    var x0 = x - xCos + ySin;
    var x1 = x - xCos - ySin;
    var x2 = x + xCos - ySin;
    var x3 = x + xCos + ySin;
    var y0 = y - xSin - yCos;
    var y1 = y - xSin + yCos;
    var y2 = y + xSin + yCos;
    var y3 = y + xSin - yCos;
    return [Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3)]
  }
};

module.exports = utils;

},{}],103:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');

function CatalogService() {
  var self = this;
  this.state = {
    prstate: ProjectsRegistry.state,
    highlightlayers: false,
    externallayers:[],
    layerstrees: []
  };
  this.setters = {};
  this.addExternalLayer = function(layer) {
    this.state.externallayers.push(layer);
  };
  this.removeExternalLayer = function(name) {
    var self = this;
    _.forEach(this.state.externallayers, function(layer, index) {
      if (layer.name == name) {
        self.state.externallayers.splice(index, 1);
        return false
      }
    });
  };

  // funzione che verifica se il layerssore aggiunto è addatttao per essere aggiunto
  // al layerstrees del catalogo e quindi visibile come albero dei layer
  this.addLayersStoreToLayersTrees = function(layersStore) {
    this.state.layerstrees.push({
      tree: layersStore.getLayersTree(),
      storeid: layersStore.getId()
    });
  };

  base(this);
  // vado a popolare cosa c'è già
  var layersStores = CatalogLayersStoresRegistry.getLayersStores();
  _.forEach(layersStores, function(layersStore) {
    self.addLayersStoreToLayersTrees(layersStore);
  });

  // resto in ascolto di eventuali layersStore aggiunti
  CatalogLayersStoresRegistry.onafter('addLayersStore', function(layersStore) {
    self.addLayersStoreToLayersTrees(layersStore);
  });

  //registro l'eventuale rimozione del layersSore dal LayersRegistryStore
  CatalogLayersStoresRegistry.onafter('removeLayersStore', function(layersStore) {
    _.forEach(self.state.layerstrees, function(layersTree, idx) {
      if (layersTree.storeid == layersStore.getId()) {
        self.state.layerstrees.splice(idx, 1);
        return false;
      }
    });

  });
}

inherit(CatalogService, G3WObject);

module.exports = CatalogService;

},{"core/catalog/cataloglayersstoresregistry":23,"core/g3wobject":27,"core/project/projectsregistry":67,"core/utils/utils":71}],104:[function(require,module,exports){
module.exports = "<!-- item template -->\n<div id=\"catalog\" @contextmenu.prevent.stop=\"\" class=\"tabbable-panel catalog\">\n  <!--<div class=\"title\">{{ title }}</div>-->\n  <div class=\"tabbable-line\">\n    <ul class=\"nav nav-tabs\" role=\"tablist\">\n      <li role=\"presentation\" class=\"active\" :style=\"{width: hasBaseLayers ? '32%' : '48%'}\"><a href=\"#tree\" aria-controls=\"tree\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"tree\">Data</a></li>\n      <li v-if=\"hasBaseLayers\" role=\"presentation\" style=\"width: 32%\"><a href=\"#baselayers\" aria-controls=\"baselayers\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"baselayers\">Layer Base</a></li>\n      <li role=\"presentation\" :style=\"{width: hasBaseLayers ? '32%' : '48%'}\"><a href=\"#legend\" aria-controls=\"legend\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"legend\">Legenda</a></li>\n    </ul>\n    <div  class=\"tab-content\">\n      <div role=\"tabpanel\" class=\"tab-pane active tree\" id=\"tree\">\n        <ul class=\"tree-root\" v-for=\"_layerstree in state.layerstrees\">\n          <tristate-tree  :highlightlayers=\"state.highlightlayers\" :layerstree=\"layerstree\" class=\"item\" v-for=\"layerstree in _layerstree.tree\" :storeid=\"_layerstree.storeid\" :key=\"layerstree.id\">\n          </tristate-tree>\n        </ul>\n        <!--<ul>\n          <tristate-tree  :externallayers=\"state.externallayers\" :layerstree=\"layerstree\" class=\"item\" v-for=\"layerstree in state.externallayers\" :key=\"layerstree.id\">\n          </tristate-tree>\n        </ul>-->\n      </div>\n      <div v-if=\"hasBaseLayers\" role=\"tabpanel\" class=\"tab-pane baselayers\" id=\"baselayers\">\n        <form>\n          <ul>\n            <li v-if=\"!baselayer.fixed\" v-for=\"baselayer in baselayers\">\n              <div class=\"radio\">\n                <label><input type=\"radio\" name=\"baselayer\" v-checked=\"baselayer.visible\" @click=\"setBaseLayer(baselayer.id)\">{{ baselayer.title }}</label>\n              </div>\n            </li>\n          </ul>\n        </form>\n      </div>\n      <layerslegend v-for=\"_layerstree in state.layerstrees\" :layerstree=\"_layerstree\"></layerslegend>\n    </div>\n  </div>\n  <ul id=\"layer-menu\" v-click-outside-layer-menu=\"closeLayerMenu\"  tabindex=\"-1\" v-if=\"layerMenu.show\"  :style=\"{top: layerMenu.top + 'px', left: layerMenu.left + 'px' }\">\n    <li @click.prevent.stop=\"zoomToLayer\"><span class=\"glyphicon glyphicon-search\"> </span> Zoom to Layer</li>\n    <li @click.prevent.stop=\"startEditing\"><span class=\"glyphicon glyphicon-pencil\"> </span> Start Editing</li>\n    <li @click.prevent.stop=\"\" v-if=\"layerMenu.layer.external\" @mouseleave.self=\"showColorMenu(false,$event)\" @mouseover.self=\"showColorMenu(true,$event)\"> Setta/Cambia Colore <i class=\"fa fa-chevron-right\" style=\"padding-left:10px;\" aria-hidden=\"true\"></i>\n      <ul v-if=\"layerMenu.colorMenu.show\" style=\"position:fixed\" :style=\"{ top: layerMenu.colorMenu.top + 'px', left: layerMenu.colorMenu.left +   'px' }\">\n        <li style=\"padding:0;\">\n          <chrome-picker @click.prevent.stop=\"\" v-model=\"layerMenu.colorMenu.color\" @change-color=\"onChangeColor\" style=\"width: 100%\"></chrome-picker>\n        </li>\n      </ul>\n    </li>\n  </ul>\n</div>\n";

},{}],105:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ComponentsRegistry = require('gui/componentsregistry');
var GUI = require('gui/gui');
var ControlsRegistry = require('gui/map/control/registry');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');
var Service = require('../catalogservice');
var ChromeComponent = VueColor.Chrome;
var CatalogEventHub = new Vue();

var vueComponentOptions = {
  template: require('./catalog.html'),
  data: function() {
    return {
      state: null,
      //oggetto per la visualizzazione del contextmenu
      // tasto destro
      layerMenu: {
        show: false,
        top:0,
        left:0,
        name: '',
        layer: null,
        //oggetto colorMenu
        colorMenu: {
          show: false,
          top:0,
          left: 0,
          color: null
        }
      }

    }
  },
  directives: {
    //creo la direttiva per il click fuori dal contextmenu
    'click-outside-layer-menu': {
      bind: function (el, binding, vnode) {
        this.event = function (event) {
          if(!(el == event.target || el.contains(event.target))) {
            vnode.context[binding.expression](event);
          }
        };
        //aggiungo event listener click
        document.body.addEventListener('click', this.event)
      },
      unbind: function (el) {
        document.body.removeEventListener('click', this.event)
      }
    }
  },
  components: {
    'chrome-picker': ChromeComponent
  },
  computed: {
    project: function() {
      return this.state.prstate.currentProject
    },
    title: function() {
      return this.project.state.name;
    },
    baselayers: function(){
      return this.project.state.baselayers;
    },
    hasBaseLayers: function(){
      return this.project.state.baselayers.length>0;
    }
  },
  methods: {
    setBaseLayer: function(id) {
      this.project.setBaseLayer(id);
    },
    zoomToLayer: function() {
      var bbox;
      if (this.layerMenu.layer.bbox) {
        bbox = [this.layerMenu.layer.bbox.minx, this.layerMenu.layer.bbox.miny, this.layerMenu.layer.bbox.maxx, this.layerMenu.layer.bbox.maxy] ;
      }
      var mapService = GUI.getComponent('map').getService();
      mapService.goToBBox(bbox);
      this.layerMenu.show = false;
    },
    startEditing: function() {
      var layer;
      var self = this;
      _.forEach(CatalogLayersStoresRegistry.getLayersStores(), function(layerStore) {
        layer = layerStore.getLayerById(self.layerMenu.layer.id);
        if (layer)
          return false;
      });
      layer.getFeatures();
    },
    closeLayerMenu: function() {
      this.layerMenu.show = false;
      this.showColorMenu(false);
    },
    onChangeColor: function(val) {
      var mapService = GUI.getComponent('map').getService();
      this.layerMenu.colorMenu.color = val;
      var layer = mapService.getLayerByName(this.layerMenu.name);
      layer.setStyle(mapService.setExternalLayerColor(val));
    },
    showColorMenu: function(bool, evt) {
      if(bool) {
        var elem = $(evt.target);
        this.layerMenu.colorMenu.top = elem.offset().top;
        this.layerMenu.colorMenu.left = elem.offset().left + elem.width() + ((elem.outerWidth() - elem.width()) /2);
      }
      this.layerMenu.colorMenu.show = bool;
    }
  },
  mounted: function() {
    var self = this;
    CatalogEventHub.$on('treenodetoogled',function(storeid, node) {
      if (node.external) {
        var mapService = GUI.getComponent('map').getService();
        var layer;
        layer = mapService.getLayerByName(node.name);
        layer.setVisible(!layer.getVisible());
        node.visible = !node.visible;
      } else {
        CatalogLayersStoresRegistry.getLayersStore(storeid).toggleLayer(node.id);
      }
    });

    CatalogEventHub.$on('treenodestoogled',function(storeid, nodes,parentChecked) {
      var layersIds = [];
      function checkNodes(obj) {
        if (obj.nodes) {
          _.forEach(obj.nodes, function(node) {
            checkNodes(node);
          });
        } else {
          layersIds.push(obj.id);
        }
      }
      _.map(nodes,checkNodes);
      CatalogLayersStoresRegistry.getLayersStore(storeid).toggleLayers(layersIds, parentChecked);
    });

    CatalogEventHub.$on('treenodeselected',function(storeid,node) {
      var mapservice = GUI.getComponent('map').getService();
      var layer = CatalogLayersStoresRegistry.getLayersStore(storeid).getLayerById(node.id);
      if (!layer.isSelected()) {
        CatalogLayersStoresRegistry.getLayersStore(storeid).selectLayer(node.id);
        // emetto il segnale layer selezionato dal catalogo
        mapservice.emit('cataloglayerselected', layer);
      } else {
        CatalogLayersStoresRegistry.getLayersStore(storeid).unselectLayer(node.id);
        mapservice.emit('cataloglayerunselected', layer);
      }
    });

    CatalogEventHub.$on('showmenulayer', function(layerstree, evt) {
      self.layerMenu.top = evt.y;
      self.layerMenu.left = evt.x;
      self.layerMenu.name = layerstree.name;
      self.layerMenu.layer = layerstree;
      self.layerMenu.show = true;
      self.layerMenu.colorMenu.color = layerstree.color;
    });

    ControlsRegistry.onafter('registerControl', function(id, control) {
      if (id == 'querybbox') {
        control.getInteraction().on('propertychange', function(evt) {
          if (evt.key == 'active') {
            self.state.highlightlayers=!evt.oldValue;
          }
        })
      }
    });
    $('input:file').filestyle({
      buttonText: "",
      input: false,
      buttonName: "btn-primary",
      iconName: "glyphicon glyphicon-plus"
    });
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);

// se lo voglio usare come componente come elemento html
Vue.component('g3w-catalog', vueComponentOptions);


/* COMPONENTI FIGLI */

// tree component


Vue.component('tristate-tree', {
  template: require('./tristate-tree.html'),
  props: {
    layerstree: {},
    storeid: null,
    //eredito il numero di childs dal parent
    checked: false,
    //highlightlayers: false,
    parentFolder: false,
    externallayers: null
  },
  data: function () {
    return {
      expanded: this.layerstree.expanded,
      parentChecked: !this.checked,
      controltoggled: false,
      n_childs: null
    }
  },
  watch: {
    'checked': function(val) {
      this.layerstree.visible = val;
    }
  },
  computed: {
    isFolder: function () {
      var _visibleChilds = 0;
      var _childsLength = 0;
      (function countLayersVisible(layerstree) {
        _.forEach(layerstree.nodes, function(layer) {
          if (!layer.nodes) _childsLength+=1;
          if (layer.visible) {
            _visibleChilds += 1;
          } else if (layer.nodes) {
            countLayersVisible(layer);
          }
        });
      })(this.layerstree);
      // lo metto qui n_childs perchè nel caso del reload ltiene quello precedente
      this.n_childs = _childsLength;//this.layerstree.nodes ? this.layerstree.nodes.length : 0;
      var isFolder = this.n_childs ? true : false;
      if (isFolder) {
        this.n_parentChilds = this.n_childs - _visibleChilds;
      } 
      return isFolder
    },
    isHidden: function() {
      return this.layerstree.hidden && (this.layerstree.hidden === true);
    },
    selected: function() {
      var isSelected = this.layerstree.selected ? "SI" : "NO";
      return isSelected;
    },
    isHighLight: function() {
      if (this.layerstree.id) {
        // da sostituire con una proprietà precalcolata nello state del layer
        //this.layer = LayersStoresRegistry.getLayersStore().getLayerById(this.layerstree.id);
        //return this.highlightlayers && layer.isWFS() && layer.getProject() && layer.getProject().getProjection() == layer.getProjection();
        //
      }
      return false;
    }

  },
  methods: {
    toggle: function (checkAllLayers) {
      var checkAll = checkAllLayers == 'true' ? true : false;
      if (this.isFolder && !checkAll) {
        this.layerstree.expanded = !this.layerstree.expanded;

      }
      else if (checkAll) {
        if (this.parentChecked && !this.n_parentChilds){
          this.parentChecked = false;
        } else if (this.parentChecked && this.n_parentChilds) {
          this.parentChecked = true;
        }
        else {
          this.parentChecked = !this.parentChecked;
        }
        CatalogEventHub.$emit('treenodestoogled',this.storeid, this.layerstree.nodes, this.parentChecked);
      }
      else {
        CatalogEventHub.$emit('treenodetoogled',this.storeid,this.layerstree);
      }
    },
    select: function () {
      if (!this.isFolder && !this.layerstree.external) {
        CatalogEventHub.$emit('treenodeselected',this.storeid,this.layerstree);
      }
    },
    triClass: function () {
      if (!this.n_parentChilds) {
        return 'fa-check-square-o';
      } else if ((this.n_parentChilds > 0) && (this.n_parentChilds < this.n_childs)) {
        return 'fa-square';
      } else {
        return 'fa-square-o';
      }
    },
    removeExternalLayer: function(name) {
      var mapService = GUI.getComponent('map').getService();
      var layer = mapService.getLayerByName(name);
      mapService.removeExternalLayer(name);
    },
    showLayerMenu: function(layerstree, evt) {
      if (!this.isFolder) {
        CatalogEventHub.$emit('showmenulayer', layerstree, evt);
      }
    }
  }
});

Vue.component('layerslegend',{
    template: require('./legend.html'),
    props: ['layerstree'],
    data: function() {
      return {
        //data qui
      }
    },
    computed: {
      visiblelayers: function(){
        var _visiblelayers = [];
        var layerstree = this.layerstree.tree;
        function traverse(obj){
        _.forIn(obj, function (layer, key) {
              //verifica che il valore dell'id non sia nullo
              if (!_.isNil(layer.id) && layer.visible) {
                  _visiblelayers.push(layer);
              }
              if (!_.isNil(layer.nodes)) {
                  traverse(layer.nodes);
              }
          });
        }
        traverse(layerstree);
        return _visiblelayers;
      }
    },
    watch: {
      'layerstree': {
        handler: function(val, old){
          //codice qui
        },
        deep: true
      }
    },
    mounted: function() {
      Vue.nextTick(function() {
        $('.legend-item').perfectScrollbar();
      });
    }
});

Vue.component('layerslegend-item',{
  template: require('./legend_item.html'),
  props: ['layer'],
  computed: {
    legendurl: function(){
      var self = this;
      var _legendurl;
      _.forEach(CatalogLayersStoresRegistry.getLayersStores(), function(layerStore) {
        if (layerStore.getLayerById(self.layer.id)){
          _legendurl = layerStore.getLayerById(self.layer.id).getLegendUrl();
          return false
        }
      });
      return _legendurl;
    }
  },
  methods: {
    updateLegendScroll: function(evt) {
      $(evt.target).perfectScrollbar('update');
    }
  }
});

/* FINE COMPONENTI FIGLI */

/* INTERFACCIA PUBBLICA */
function CatalogComponent(options) {
  base(this);
  var self = this;
  this.id = "catalog-component";
  this.title = "catalog";
  this.mapComponentId = options.mapcomponentid;
  var service = options.service || new Service;
  this.setService(service);
  this.setInternalComponent(new InternalComponent({
    service: service
  }));
  this.internalComponent.state = this.getService().state;
  function listenToMapVisibility(map) {
    var mapService = map.getService();
    self.state.visible = !mapService.state.hidden;
    mapService.onafter('setHidden',function(hidden) {
      self.state.visible = !mapService.state.hidden;
      self.state.expanded = true;
    })
  }
  if (this.mapComponentId) {
    var map = GUI.getComponent(this.mapComponentId);
    if (!map) {
      ComponentsRegistry.on('componentregistered',function(component){
        if (component.getId() == self.mapComponentId) {
          listenToMapVisibility(component);
        }
      })
    }
    else {
      listenToMapVisibility(map)
    }
  }
  //mergio opzioni con proprità di default del componente
  merge(this, options);
}

inherit(CatalogComponent, Component);

module.exports = CatalogComponent;

},{"../catalogservice":103,"./catalog.html":104,"./legend.html":106,"./legend_item.html":107,"./tristate-tree.html":108,"core/catalog/cataloglayersstoresregistry":23,"core/utils/utils":71,"gui/componentsregistry":110,"gui/gui":114,"gui/map/control/registry":118,"gui/vue/component":152}],106:[function(require,module,exports){
module.exports = "<div role=\"tabpanel\" class=\"tab-pane\" id=\"legend\">\n  <layerslegend-item :layer=\"layer\" v-for=\"layer in visiblelayers\" :key=\"layer.id\"></layerslegend-item>\n</div>\n";

},{}],107:[function(require,module,exports){
module.exports = "  <div class=\"legend-item\" @mouseenter=\"updateLegendScroll($event)\">\n    <img :src=\"legendurl\">\n    <span class=\"divider\"></span>\n  </div>\n";

},{}],108:[function(require,module,exports){
module.exports = "<li class=\"tree-item\" @contextmenu.prevent.stop=\"showLayerMenu(layerstree, $event)\" @click=\"select()\" :class=\"{selected: !isFolder ? layerstree.selected : false, itemmarginbottom: !isFolder }\">\n  <span :class=\"{bold: isFolder, 'fa-chevron-down': layerstree.expanded, 'fa-chevron-right': !layerstree.expanded}\" @click=\"toggle\" v-if=\"isFolder\" class=\"root fa\"></span>\n  <span v-if=\"isFolder\" @click.stop=\"toggle('true')\" :class=\"[triClass()]\" class=\"fa\"></span>\n  <span v-show=\"!layerstree.hidden\" v-else @click.stop=\"toggle\" :class=\"[layerstree.visible  ? 'fa-check-square-o': 'fa-square-o',layerstree.disabled  ? 'disabled': '',  parentFolder ? 'child' : 'root' ]\" class=\"fa checkbox-layer\"></span>\n  <span v-show=\"!layerstree.hidden || isFolder\" class=\"tree-node-title\" :class=\"{bold: isFolder, disabled: layerstree.disabled, highlightlayer: isHighLight }\">{{ layerstree.title }}</span><i v-if=\"layerstree.external\" class=\"glyphicon glyphicon glyphicon-trash link trash pull-right\" @click=\"removeExternalLayer(layerstree.name)\"></i>\n  <ul v-show=\"layerstree.expanded\" v-if=\"isFolder\">\n    <tristate-tree :parentFolder=\"isFolder\" :n_parent-childs=\"n_parentChilds\" :layerstree=\"layerstree\" :storeid=\"storeid\" v-for=\"layerstree in layerstree.nodes\" :key=\"layerstree.id\">\n    </tristate-tree>\n  </ul>\n</li>";

},{}],109:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var merge = require('core/utils/utils').merge;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var VUECOMPONENTSATTRIBUTES = ['methods', 'computed', 'data', 'components'];

var Component = function(options) {

  options = options || {};
  this.internalComponent = null;
  this.id = options.id || Math.random() * 1000;
  this.title = options.title || '';
  this.state = {
    visible: options.visible || true,
    open: options.open || false
  };
  //setters
  this.setters = {
    setOpen: function(bool) {
      this.state.open = bool;
      this._setOpen();
    },
    setVisible: function(bool) {
      this.state.visible = bool;
      this._setVisible();
    },
    reload: function() {
      this._reload();
    }
  };
  base(this);
};

inherit(Component, G3WObject);

var proto = Component.prototype;

// restituisce id del componente
proto.getId = function() {
  return this.id;
};

// setta id del component
proto.setId = function(id) {
  this.id = id;
};

proto.getOpen = function() {
  return this.state.open;
};

proto.getVisible = function() {
  return this.state.visible;
};

// restituice il titolo del componente
proto.getTitle = function() {
  return this.state.title;
};

//setta il titolo del componente
proto.setTitle = function(title) {
  this.state.title = title;
};

//implementati due metodi per poter unificare il metodo di recupero del servizio
//legato al componente
// resituisce il service del componente
proto.getService = function() {
  return this._service;
};

// setta il service del componente
proto.setService = function(service) {
  this._service = service;
};

// restituisce il componente vue interno
proto.getInternalComponent = function() {
  return this.internalComponent;
};

// setta il nuovo internalcomponent
proto.setInternalComponent = function(internalComponent) {
  if (!internalComponent && this.internalComponentClass) {
    this.internalComponent = new this.internalComponentClass;
  }
  else {
    // internal component è un'istanza e non una classe
    this.internalComponent = internalComponent;
  }
};

proto.createVueComponent = function (vueObjOptions) {
  return _.cloneDeep(vueObjOptions);
};

// aggiunge dati all'internalComponent
proto.addInternalComponentData = function(data) {
  _.merge(this.internalComponent, data)
};

// sovrascrive il metodo del service originale con uno nuovo
proto.overwriteServiceMethod = function(methodName, method) {
  this._service[methodName] = method;
};

// sovrascrive i metodi che hanno chiave uguale a quelli presenti nel servizio
proto.overwriteServiceMethods = function(methodsOptions) {
  var self = this;
  _.forEach(methodsOptions, function(method, methodName) {
    self.overwriteServiceMethod(methodName, method);
  })
};

// estendo il servizio con nuovi metodi
proto.extendService = function(serviceOptions) {
  if (this._service) {
    merge(this._service, serviceOptions);
  }
};

// estende in modo generico il vue component
proto.extendInternalComponent = function(internalComponentOptions) {
  var self = this;
  if (this.vueComponent) {
    // faccio il clone altrimenti ho problem con i components
    _.forEach(internalComponentOptions, function(value, key) {
      if (VUECOMPONENTSATTRIBUTES.indexOf(key) > -1) {
        switch (key) {
          case 'methods':
            self.extendInternalComponentMethods(value);
            break;
          case 'components':
            self.extendInternalComponentComponents(value);
            break;
          default:
            merge(self.vueComponent[key], value);
        }
      }
    });
  } else {
    this.vueComponent = internalComponentOptions;
  }
};

//funzione che estende l'attributo components dell'oggetto vue Component
proto.extendInternalComponentComponents = function(components) {
  if (components) {
    merge(this.vueComponent.components, components);
  }
};

// estende i methods il vue component
proto.extendInternalComponentMethods = function(methods) {
  if (methods) {
    // ciclo sulle chiavi dell'oggetto per verificare che sia una funzione
    _.forEach(methods, function (value, key) {
      if (!(value instanceof Function)){
        delete methods[key];
      }
    });
    merge(this.vueComponent.methods, methods);
  }
};

// estende i computed del vue component
proto.extendInternalComponentComputed = function(computed) {
  if (computed) {
    // ciclo sulle chiavi dell'oggetto per verificare che sia una funzione
    _.forEach(computed, function (value, key) {
      if (!(value instanceof Function)){
        delete computed[key];
      }
    });
    merge(this.vueComponent.computed, computed);
  }
};

//setto il template del componente vue
proto.setInternalComponentTemplate = function(template) {
  // dovrò poi aggiungere regole per verificare se il
  // tenplate è compatibile ad un template o no
  if (template) {
    this.vueComponent.template = template;
  }
};

proto.getInternalTemplate = function() {
  return this.vueComponent.template;
};

////////// fine metodi Service Components //////////
/* HOOKS */
/* 
 * Il metodo permette al componente di montarsi nel DOM
 * parentEl: elemento DOM padre, su cui inserirsi; 
 * ritorna una promise, risolta nel momento in cui sarà terminato il montaggio
*/
proto.mount = function(parent) {};

/*
 * Metodo richiamato quando si vuole rimuovere il componente.
 * Ritorna una promessa che sarà risolta nel momento in cui il componente avrà completato la propria rimozione (ed eventuale rilascio di risorse dipendenti)
*/
proto.unmount = function() {};

proto.ismount = function() {
  return true;
};

// se si vuole usare il componete lo deve ridefinire
proto._setOpen = function() {
};


// se si vuole usare il componete lo deve ridefinire
proto._setVisible = function() {};


//funzione che dovrà essere sovrascritta dai singoli componenti
proto._reload = function() {

};

/*
 * Metodo (opzionale) che offre l'opportunità di ricalcolare proprietà dipendenti dalle dimensioni del padre
 * parentHeight: nuova altezza del parent
 * parentWidth: nuova larghezza del parent
 * richiamato ogni volta che il parent subisce un ridimensionamento
*/
proto.layout = function(parentWidth, parentHeight) {};


module.exports = Component;

},{"core/g3wobject":27,"core/utils/utils":71}],110:[function(require,module,exports){
var G3WObject = require('core/g3wobject');
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;

//classe Componet Registry (singleton)
// ha lo scopo di salvare tutti i componenti aggiunti
function ComponentsRegistry() {
  // attributo componets che tiene traccia
  // dei componenti registrati
  this.components = {};
  // funzione per refgistrare il componente
  this.registerComponent = function(component) {
    // recupera l'id del componente
    var id = component.getId();
    // se non è stato precedentemente registrato
    if (!this.components[id]) {
      this.components[id] = component;
      this.emit('componentregistered', component);
    }
  }; 
  //funzione che retituisce il componente in base all'id
  this.getComponent = function(id) {
    return this.components[id];
  };

  this.getComponents = function() {
    return this.components;
  };

  // toglie dal registro dei componenti il componete che si vuole eliminare
  this.unregisterComponent = function(id) {
    var component = this._components[id];
    // verifica che sia presente il componete con l'id passato
    if (component) {
      //verifico che estista la funzione destroy dell'oggetto componente
      if (_.isFunction(component.destroy)) {
        // nel caso lo ditruggo (togliendolo anche visivamente)
        component.destroy();
      }
      //elimino il componente e lo setto a null per evitare
      // che se in un secondo momento lo registro di nuovo
      // questa venga ignorato
      delete component;
      this._components[id] = null;
    }
  };
  base(this);
}
inherit(ComponentsRegistry,G3WObject);

module.exports = new ComponentsRegistry;

},{"core/g3wobject":27,"core/utils/utils":71}],111:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var PickCoordinatesInteraction = require('g3w-ol3/src/interactions/pickcoordinatesinteraction');
var ClipBoard = require('core/clipboardservice');
var QueryService = require('core/query/queryservice');
var ProjectsRegistry = require('core/project/projectsregistry');

var Inputs = {};
Inputs.STRING = 'string';
Inputs.INTEGER = 'integer';
Inputs.FLOAT = 'float';
Inputs.BOOLEAN = 'boolean';

Inputs.defaults = {};
Inputs.defaults[Inputs.STRING] = "";
Inputs.defaults[Inputs.INTEGER] = 0;
Inputs.defaults[Inputs.FLOAT] = 0.0;
Inputs.simpleFieldTypes = [Inputs.STRING,Inputs.INTEGER,Inputs.FLOAT];

Inputs.TEXTAREA = 'textarea';
Inputs.SELECT = 'select';
Inputs.RADIO = 'radio';
Inputs.CHECKBOX = 'checkbox';
Inputs.LAYERPICKER = 'layerpicker';
Inputs.IMAGE = 'image';

Inputs.specialInputs = [Inputs.TEXTAREA, Inputs.SELECT, Inputs.RADIO, Inputs.CHECKBOX, Inputs.LAYERPICKER, Inputs.IMAGE];

function FormService() {
  this._actions = {};
  this.state = null;
  this._pickInteraction = null;
  this.setters = {
    setInitForm: function(options) {
      this._setInitForm(options);
    },
    // setter sul cambio dellle relazioni del form
    setFormRelations: function (relations) {
      this.state.relations = relations;
    },
    // setter sul cambio dei campi
    setFormFields: function (fields) {
      this.state.fields = fields;
    },
    setupFields: function() {
      this._setupFields();
    },
    setupRelationsFields: function() {
      this._setupRelationsFields();
    },
    // setter sull'inserimento dei dati del form
    setFormData: function(fields, relations) {
      this.setFormFields(fields);
      this.setFormRelations(relations);
    },
    // setter del singolo field
    setField: function(field) {
    },
    // settere dello state
    setState: function(state) {
      this._setState(state);
    },
    // setter sull'aggiunta di un'azione sul form
    addActionsForForm: function (actions) {
      // un opportunità per i listener per aggiungere azioni a form
    },
    postRender: function (element) {
      // un opportunità per i listener di intervenire sul DOM
    }
  };
  // inizializzo il form con l'opzioni passate dall'editor al momento del'apertura del form
  this._setInitForm = function(options) {
    this.provider = options.provider || null; // è l' editor che lo chiama
    this.formId = options.formId;
    this.name = options.name; // nome del form
    this.dataid = options.dataid; // "accessi", "giunzioni", ecc.
    this.editor = options.editor || {};
    this.relationOne = options.relationOne || null;
    this.pk = options.pk || null; // eventuale chiave primaria (non tutti i form potrebbero avercela o averne bisogno
    this.tools = options.tools || [];
    this.isnew = (!_.isNil(options.isnew) && _.isBoolean(options.isnew)) ? options.isnew : true;
    this._defaults = options.defaults || Inputs.defaults;
    this.buttons = options.buttons;
    // clipboard
    this._clipBoard = ClipBoard;
    //mi server per estrarre il nome del layer dall'id del form
    // in quanto l'id è creato univoco ma riposrta al suo interno
    // il nome del layer
    var formLayer = this.formId.split('form')[0];
    this._pickedPromise = null;
    // setto lo stato
    this.state = {
      fields: null,
      relations: null,
      editor: this.editor,
      isnew: this.isnew,
      buttons: this.buttons,
      tools: {},
      relationOne: this.relationOne,
      canpaste: _.has(this._clipBoard._data, formLayer)
    };
    //chiamo i setter
    this.setFormFields(options.fields);
    this.setFormRelations(options.relations);
    var elementsBoxes = this.getUniqueRelationsElementId();
    this.state.elementsBoxes = elementsBoxes;
    // qui associo lo state del pannello allo ste del form
    this._setFormTools(this.tools);
    this.editor.setFormService(this);
  };

  //vado a ripulire lo state del form dopo che è stato effettuaro un commit sul server
  this.cleanStateAfterCommit = function(newRelationIds) {
    // verifico che ci sia stato un aggiunta di relazioni
    var addedRelations = (newRelationIds && newRelationIds.length > 0) ? newRelationIds[0].relations :  {}
    var relationsToDelete = [];
    // cliclo sulle relazioni e faccio "pulizia"
    _.forEach(this.state.relations, function (relation) {
      var addedRelation = addedRelations[relation.name];
      // uso forEachRight invece di forEach in quando lo splice shifta gli element e
      // quindi si avrebbe un elemento finale undefined
      _.forEachRight(relation.elements, function (element, index) {
        // verifico gli elementi che sono stati cancellati e cancello
        if(element.state.indexOf('DELETE') > -1) {
          relation.elements.splice(index, 1);
        }
        // nela caso di elementi nuovi inseriti
        if (element.state == 'NEW') {
          _.forEach(addedRelation, function(newElement){
            if (element.id == newElement.clientid) {
              element.id = newElement.id;
              return false
            }
          });
          // assegno lo stato OLD
          element.state = 'OLD';
        }
      });
    });
  };

  this.createPickInteraction = function() {
    this._pickInteraction = new PickCoordinatesInteraction;
    return this._pickInteraction;
  };
  this.getState = function () {
    return this.state;
  };

  this._setState = function(state) {
    this.state = state;
  };
  // funzione che supporta la validazione dei campi obbigatori al fine di abliltare o meno il Salva
  this._checkFieldsValidation = function(fields) {
    var self = this;
    var valid = true;
    var fieldValid = true;
    _.forEach(fields, function(field) {
      if (self._isEditable(field) && self._isVisible(field) && field.validate && field.validate.required) {
        if (_.isNil(field.value) || !_.trim(field.value)) {
          if (!self._isSelect(field)) {
            fieldValid = false;
          }
        }
        valid = valid && fieldValid;
      }
    });
    return valid;
  };
  //funzione che retituisce i fields
  this.getFields = function() {
    return this._fields;
  };
  // funzione che restituisce se nella feture(nel layer) è prevista una relazione ONE
  this._getRelationsOne = function() {
    // overwrite from plugin
    var self = this;
    var relationsOne = [];
    _.forEach(this.state.relations, function(relation, index) {
      if (relation.type == 'ONE') {
        relationsOne.push(self.state.relations[index]);
      }
    });
    return relationsOne;
  };
  //funzione che mi server per estrarre il layer name dall'id del form
  // utile per il clipboard al fine del copia e incolla
  this._getLayerFormFromId = function() {
    return this.formId.split('form')[0];
  };
  //funzione che clona i dati del form per il copia e incolla
  this._copyFormToClipBoard = function() {
    var formData = _.cloneDeep(this.state);
    this._clipBoard.set(this.formId, formData);
    this.state.canpaste = true;
    return true;
  };

  this._setFieldValueLayerFromToRelationField = function(relation, name) {
     ('questa funzione deve essere sovrascritta dal plugin al momento');
  };

  this._checkIfFieldIsOverwritable = function(fieldName, fieldsdArray) {
    var check = null;
    _.forEach(fieldsdArray, function(field) {
      if (!_.isNil(field[fieldName])) {
        check = field[fieldName]
      }
    });
    return check;
  };
  // funzione utlizzazta al fine di copiare i dati di un altra feature seleziona
  // evitando di scrivere i campi non sovrascrivibili. Rimasta con il nome vecchio riferita solo alla primary key
  this._pasteStateWithoutPk = function(fields, relations) {
    //prendo vector layer
    var self = this;
    var layerFields = [];
    var copyAndPasteFieldsNotOverwritable = self.editor.getcopyAndPasteFieldsNotOverwritable();
    var relationFields = {};
    // verifico se sono stati settati campi che non devono essere sovrascitti dal copia e incolla
    // è settato dall'editor specifico
    if (!_.isNil(copyAndPasteFieldsNotOverwritable.layer)) {
      layerFields = copyAndPasteFieldsNotOverwritable.layer;
    }
    if (!_.isNil(copyAndPasteFieldsNotOverwritable.relations)) {
      relationFields = copyAndPasteFieldsNotOverwritable.relations;
    }
    // verifico i fields da non modificare sul layer
    var orginalField;
    _.forEach(fields, function(field, index) {
      orginalField = self._checkIfFieldIsOverwritable(field.name, layerFields);
      //verifico se è una chiave prmaria il campo
      if (self.pk == field.name) {
        fields[index].value = self.isnew ? null : self.state.fields[index].value;
      } else if (!_.isNull(orginalField)) { // caso in cui non è la chiave primaria
        fields[index].value = (orginalField && self.isnew) ? undefined : self.state.fields[index].value;
      }
    });
    // verifico i fileds delle relazioni da non sovrascrivere
    _.forEach(relations, function(relation, relationIndex) {
      _.forEach(relation.elements, function(element, elementIndex) {
        /// aggiungo allo stato della relazione copiata NEW
        relations[relationIndex].elements[elementIndex].state = 'NEW';
        _.forEach(element.fields, function(field, fieldIndex) {
          _.forEach(relationFields[relation.name], function(relationField) {
            if (field.name == relationField) {
              relations[relationIndex].elements[elementIndex].fields[fieldIndex].value = undefined;
            }
          });
        });
      })
    });
    // setto i nuovi fields e relations lasciando quelli vecchi
    this.setFormData(fields, relations);
    var elementsBoxes = this.getUniqueRelationsElementId(false);
    this.state.elementsBoxes = elementsBoxes;
    return true;
  };
  // funzione che server per incollare i dati dalla clipboard nel form
  this._pasteClipBoardToForm = function(layerForm) {
    var formData = this._clipBoard.get(layerForm);
    this._pasteStateWithoutPk(formData.fields, formData.relations);
    this.state.canpaste = false;
  };

  // funzione che verifica se la featuare su cui stiamo lavorando
  // è nuova o vecchia
  this._isNew = function(){
    return this.isnew;
  };
  // funzione che verifa se il campo è obbligatorio o no
  this._hasFieldsRequired = function() {
    var someFieldsRequired = _.some(this.state.fields, function(field){
      return field.validate && field.validate.required;
    });
    var someRelationsRequired = _.some(this.state.relations,function(relation){
      return relation.validate && relation.validate.required;
    });
    return someFieldsRequired || someRelationsRequired;
  };

  // VERIFICA CAMPI

  // funzione che restituisce true/false a seconda se il campo è visibile o no
  this._isVisible = function(field) {
    return !(!field.editable && (field.value == "" || _.isNull(field.value))) && field.name !=this.pk;
  };
  //verifica se il campo è editabile o no
  this._isEditable = function(field) {
    return field.editable;
  };
  // verifica se il campo è considerato tra i seimple(es text)
  this._isSimple = function(field) {

    if (_.includes(Inputs.specialInputs, field.input.type)){
      return false;
    }
    return _.includes(Inputs.simpleFieldTypes, field.type)
  };
  // verifica se l'input è una textarea
  this._isTextarea = function(field) {
    return (field.input.type == Inputs.TEXTAREA);
  };
  // verifica se è una select
  this._isSelect = function(field) {
    return (_.includes(Inputs.specialInputs,field.input.type) && field.input.type == Inputs.SELECT);
  };
  // verifica se è tipo radio button
  this._isRadio = function(field) {
    return (_.includes(Inputs.specialInputs, field.input.type) && field.input.type == Inputs.RADIO);
  };
  // verifica se è tipo checkbox
  this._isCheckbox = function(field) {
    return (_.includes(Inputs.specialInputs,field.input.type) && field.input.type == Inputs.CHECKBOX);
  };
  // verifica se il campo è un picklayer
  this._isLayerPicker = function(field) {
    return (_.includes(Inputs.specialInputs,field.input.type) && field.input.type == Inputs.LAYERPICKER);
  };
  // verifica se il campo è di tipo file
  this._isImage = function(field) {
    return (field.input.type == Inputs.IMAGE);
  };

  // FINE VERIFICA CAMPI

  //una volta cliccato sulla mappa dopo un picklayer ripulisce
  this._cleanUpPickLayer = function() {
    var mapService = GUI.getComponent('map').getService();
    mapService.removeInteraction(this._pickInteraction);
    this._pickInteraction = null;
    GUI.setModal(true);
  };
  this._pickLayerInputFieldChange = function(field, relation) {
    console.log('funzione che deve essere sovrascritta dal plugin');
  };
  // funzione chiata nel caso pick layer
  this._pickLayer = function(field, relation) {
    // ritorno una promessa, se qualcun altro volesse usare
    // il risultato (es. per settare altri campi in base alla feature selezionata)
    var d = $.Deferred();
    GUI.notify.info("Seleziona un'elemento dalla mappa per ottenere il valore di "+ field.label + " o scrivilo direttamentene");
    var self = this;
    // disabilito temporanemante lo strato modale per permettere l'interazione con la mappa
    GUI.setModal(false);
    var mapService = GUI.getComponent('map').getService();
    var layer = mapService.getLayersStore.getLayerById(field.input.options.layerid);
    var relFieldName = field.input.options.field;
    var relFieldLabel = layer.getAttributeLabel(field.input.options.field);
    mapService.addInteraction(this.createPickInteraction());
    this._pickInteraction.on('picked',function(e){
      QueryService.queryByLocation(e.coordinate, [layer])
        .then(function(response){
          var featuresForLayers = response.data;
          if (featuresForLayers.length && featuresForLayers[0].features.length) {
            var attributes = featuresForLayers[0].features[0].getProperties(); // prendo la prima feature del primo (e unico) layer
            var value = attributes[relFieldName] ? attributes[relFieldName] : attributes[relFieldLabel];
            field.value = value;
            d.resolve(attributes);
          }
          else {
            d.reject();
          }
        })
        .fail(function(){
          d.reject();
        })
        .always(function() {
          self._cleanUpPickLayer();
        })
    });
    return d.promise();
  };
  //funzione che server per poter copiare lo state di una feature identificata
  // sul form attuale di un'altra feature
  this._pickLayerToClipBoard = function() {
    //TODO
    var self = this;
    // ritorno una promessa, se qualcun altro volesse
    // usare il risultato (es. per settare altri campi in base alla feature selezionata)
    var d = $.Deferred();
    if (this._pickedPromise) {
      return this._pickedPromise
    }
    // disabilito temporanemante lo strato modale per permettere l'interazione con la mappa
    GUI.setModal(false);
    // recupero mapservice perchè mi permette di ineteragire con la mappa
    var mapService = GUI.getComponent('map').getService();
    var vectorLayer = this.editor.getVectorLayer();
    var layer = mapService.getLayersStore().getLayerById(vectorLayer.id);
    // l'aggiungo alla mappa
    mapService.addInteraction(this.createPickInteraction());
    // on picked
    this._pickInteraction.on('picked', function(e) {
      // qui passo lo stessso layer su cui sto agendo
      QueryService.queryByLocation(e.coordinate, [layer])
        .then(function(response) {
          var featuresForLayers = response.data;
          // verifico se ci sono features selezionate
          if (featuresForLayers.length && featuresForLayers[0].features.length) {
            // rpendo la prima feature
            var featureLayer = featuresForLayers[0].features[0];
            var pk = vectorLayer.getPk();
            var feature = vectorLayer.getFeatureById(featureLayer.get(pk));
            // prendo dal vectorLayer la feature basato sull'id della richiesta
            if (!feature) {
              feature = vectorLayer.getFeatureById(featureLayer.getId());
            }
            var fields = vectorLayer.getFieldsWithValues(feature);
            var relationsPromise = self.editor.getRelationsWithValues(feature);
            relationsPromise
              .then(function(relations) {
                self._pasteStateWithoutPk(fields, relations);
                d.resolve();
              });
          }
        })
        .fail(function() {
          d.reject();
        })
        .always(function() {
          self._cleanUpPickLayer();
        })
    });
    return d.promise();
  };
  // funzione che ritorna il valore di default del campo
  this._getDefaultValue = function(field) {
    if (field.input && field.input.options && field.input.options.default) {
      return field.input.options.default;
    } else if (this._isSelect(field)) {
      return field.input.options.values[0].key;
    }
    return '';
  };
  // restituisce il nome del layer che si è appena cliccato con il picklayer
  this._getlayerPickerLayerName = function(layerId){
    var layer = ProjectsRegistry.getCurrentProject().getLayersStore().getLayerById(layerId);
    if (layer){
      return layer.getName();
    }
    return "";
  };
  // da cancellare?
  this._shouldShowRelation = function(relation) {
    return true;
  };

  // per definire i valori di default nel caso si tratta di un nuovo inserimento
  this._setupFields = function() {
    var self = this;
    var fields = _.filter(this.state.fields,function(field){
      // tutti i campi eccetto la PK (se non nulla)
      if (self.pk && field.value==null){
        return ((field.name != self.pk));
      }
      return true;
    });
    _.forEach(fields,function(field){
      if(_.isNil(field.value)){
        var defaultValue = self._getDefaultValue(field);
        if (defaultValue){
          field.value = defaultValue;
        }
      }
    });
  };
// funzione che setta i campi della relazione
  this._setupRelationsFields = function(relations) {
    var self = this;
    relations = relations || this.state.relations;
    if (relations) {
      _.forEach(relations, function(relation) {
        _.forEach(relation.elements, function(element) {
          self._setupRelationElementFields(element);
        })
      });
    }
  };

  this._setupRelationElementFields = function(element) {
    var self = this;
    _.forEach(element.fields,function(field){
      if(_.isNil(field.value)){
        field.value = self._getDefaultValue(field);
      }
    })
  };

  this._setupPanel = function(){
    var panel = this.internalComponent = new this._formPanel({
      form: this
    });
    if (this.options.buttons) {
      panel.buttons = this.options.buttons;
    }
    var elementsBoxes = this.getUniqueRelationsElementId();
    this.state.elementsBoxes = elementsBoxes;
    // qui associo lo state del pannello allo ste del form
    panel.state = this.state;
    this._setFormTools(this.tools);
    return panel;
  };

  this._setFormTools = function(tools) {
    var self = this;
    _.forEach(tools, function(tool) {
      self.state.tools[tool] = true;
    })
  };

  this.getUniqueRelationsElementId = function(bool) {
    var self = this;
    var elementsBoxes = {};
    var collapsed = _.isNil(bool) ? true : bool;
    _.forEach(this.state.relations, function(relation){
      _.forEach(relation.elements, function(element){
        var boxid = self.getUniqueRelationElementId(relation,element);
        elementsBoxes[boxid] = {
          collapsed: collapsed
        }
      })
    });
    return elementsBoxes;
  };

  this.getUniqueRelationElementId = function(relation, element){
    return relation.name+'_'+element.id;
  };

  this._getField = function(fieldName){
    var field = null;
    _.forEach(this.state.fields,function(f){
      if (f.name == fieldName){
        field = f;
      }
    });
    return field;
  };

  this._setImageStyleInput = function() {
    $('input:file').filestyle({
      buttonText: " Foto",
      buttonName: "btn-primary",
      iconName: "glyphicon glyphicon-camera"
    })
  };

  this._addRelationElement = function(relation) {
    var self = this;
    // chama la funzione editor che crea una relazione
    var element = this.provider.createRelationElement(relation);
    var elementBoxId = this.getUniqueRelationElementId(relation, element);
    Vue.set(this.state.elementsBoxes, elementBoxId,{collapsed:false});
    this._setupRelationElementFields(element);
    relation.elements.push(element);
    _.forEach(element.fields, function(field) {
      if (self._isImage(field)) {
        Vue.nextTick(function() {
          self._setImageStyleInput();
        })
      }
    })
  };

  this._removeRelationElement = function(relation, element){
    var self = this;
    _.forEach(relation.elements,function(_element, idxToRemove){
      if (_element.id == element.id) {
        //relation.elements.splice(idxToRemove,1);
        element.state = element.state+'_DELETED'; // lo marco come elminato
        delete self.state.elementsBoxes.elmentBoxId;
      }
    })
  };

  this._removeRelationElements = function(relation) {
    var self = this;
    _.forEach(relation.elements, function(element){
      self._removeRelationElement(relation, element);
    })
  };

  this._getRelationField = function(fieldName, relationName){
    var field = null;
    _.forEach(this.state.relations,function(relation){
      if (relationName == relation.name){
        _.forEach(relation.fields,function(f){
          if (f.name == fieldName){
            field = f;
          }
        })
      }
    });
    return field;
  };

  this._getRelationElementField = function(fieldName, element) {
    var field;
    _.forEach(element.fields,function(_field){
      if (_field.name == fieldName) {
        field = _field;
      }
    });
    return field;
  };

  base(this);
}

// Make the public service en Event Emitter
inherit(FormService, G3WObject);

module.exports = FormService;
},{"core/clipboardservice":24,"core/g3wobject":27,"core/project/projectsregistry":67,"core/query/queryservice":68,"core/utils/utils":71,"g3w-ol3/src/interactions/pickcoordinatesinteraction":94,"gui/gui":114}],112:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var Component = require('gui/vue/component');
var Service = require('gui/form/formservice');
var base = require('core/utils/utils').base;
var Template = require('./templateform.html');

// FILTRI VUE

Vue.filter('startcase', function (value) {
  return _.startCase(value);
});

Vue.filter('lowerCase', function (value) {
  return _.lowerCase(value);
});

Vue.filter('relationplural', function (relation) {
  return (relation.plural) ? relation.plural : _.startCase(relation.name);
});

//FINE FILTRI VUE

//VUE VALIDATOR
// li manteniamo come commenti giusto per riprendere le Regex nel futuro validatore
/*Vue.validator('email', function (val) {
  return /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(val)
});

Vue.validator('integer', function (val) {
  return /^(-?[1-9]\d*|0)$/.test(val);
});*/

//FINE VUE VALIDATOR

//Definisco l'oggetto che contiene i dati necessari per instanziare un vue component
var vueComponentOptions = {
  template: null,
  data: function() {
    return {
      state: null,
      tools : {
        copypaste: false
      }
    }
  },
  components: {
    //è possibile inserire componenti custom dai vari plugin,
  },
  transitions: {'addremovetransition': 'showhide'},
  methods: {
    exec: function(cbk) {
      var relations = this.state.relations || null;
      cbk(this.state.fields, relations);
      if (this.state.editor.getPickedFeature()) {
        this.state.editor.cleanUpPickedFeature();
      }
      GUI.closeForm();
    },
    btnEnabled: function(button) {
      return button.type != 'save' || (button.type == 'save' && this.isValidForm());
    },
    hasFieldsRequired: function() {
      return this.$options.formService._hasFieldsRequired();
    },
    isEditable: function(field){
      return this.$options.formService._isEditable(field);
    },
    isSimple: function(field) {
      return this.$options.formService._isSimple(field);
    },
    isTextarea: function(field) {
      return this.$options.formService._isTextarea(field);
    },
    isSelectOptionsNull : function(value) {
      if (_.isNil(value)) {
        return 'null';
      } else {
        return value;
      }
    },
    isSelect: function(field){
      return this.$options.formService._isSelect(field);
    },
    isRadio: function(field) {
      return this.$options.formService._isRadio(field);
    },
    isCheckbox: function(field) {
      return this.$options.formService._isCheckbox(field);
    },
    multiCheckBoxValue: function(evt, field) {
      if (!field.value) {
        filed.value = [];
      }
      if (evt.target.checked) {
        field.push(evt.target.value);
      } else {
        _.remove(field, function(n) {
          return n == evt.target.value;
        });
      }
    },
    isLayerPicker: function(field){
      return this.$options.formService._isLayerPicker(field);
    },
    removeImage: function(field) {
      field.value = null;
    },
    isImage: function(field) {
      return this.$options.formService._isImage(field);
    },
    layerPickerPlaceHolder: function(field) {
      return this.$options.formService._getlayerPickerLayerName(field.input.options.layerid);
    },
    pickLayer: function(field, relation) {
      this.checkPickLayer();
      this.$options.formService._pickLayer(field, relation);
    },
    pickLayerInputFieldChange: function(field, relation) {
      this.$options.formService._pickLayerInputFieldChange(field, relation);
    },
    pickLayerToClipBoard: function() {
      this.checkPickLayer();
      this.$options.formService._pickLayerToClipBoard()
      .then(function() {
        //TODO
      })
    },
    isValidForm: function() {
      var self = this;
      var valid = this.$options.formService._checkFieldsValidation(this.state.fields);
      _.forEach(this.state.relations, function(relation) {
        if (self.showRelation(relation)) {
          _.forEach(relation.elements, function (element) {
            // non tengo conto dell'elementi della relazione eliminati
            if (element.state.indexOf('DELETE') > -1) {return true}
            valid = valid && self.$options.formService._checkFieldsValidation(element.fields);
          })
        }
      });
      return valid;
    },
    pickLayerInputChange: function() {
      this.$options.formService._cleanUpPickLayer();
    },
    checkPickLayer: function() {
      if (this.$options.formService._pickInteraction) {
        this.$options.formService._cleanUpPickLayer();
      }
    },
    isVisible: function(field) {
      return this.$options.formService._isVisible(field);
    },
    visibleElements: function(relation) {
      return _.filter(relation.elements,function(element){
        return (element.state != 'NEW_DELETED' && element.state != 'OLD_DELETED');
      });
    },
    visibleElementsLength: function(relation) {
      return this.visibleElements(relation).length;
    },
    showRelation: function(relation) {
      return this.$options.formService._shouldShowRelation(relation);
    },
    relationPkFieldName: function(relation) {
      return relation.pk;
    },
    isRelationElementDeletable: function(relation,element) {
      if (element.new) {
        return true;
      }
      var min;
      if (relation.type == 'ONE') {
        min = 1;
      }
      else {
        min = Number.NEGATIVE_INFINITY;
      }
      if (relation.min) {
        min = Math.min(min.relation.min);
      }
      return min < relation.elements.length;
    },
    canAddRelationElements: function(relation) {
      var canAdd = true;
      if (relation.type == 'ONE') {
        canAdd = (relation.elements.length) ? false : true; // se è una relazione 1:1 e non ho elementi, lo posso aggiungere, altrimenti no
      }
      else {
        var max = relation.max ? relation.max : Number.POSITIVE_INFINITY;
        canAdd = relation.elements.length < max; 
      }
      return canAdd;
    },
    addRelationElement: function(relation) {
      this.$options.formService._addRelationElement(relation);
    },
    removeRelationElement: function(relation, element){
      this.$options.formService._removeRelationElement(relation, element);
    },
    visibleElementFields: function(fields) {
      var self = this;
      return _.filter(fields, function (field) {
        return self.isVisible(field);
      })
    },
    fieldsSubset: function(fields) {
      var attributes = _.filter(fields, function(attribute) {
        return attribute.type != 'image';
      });
      var end = Math.min(3, attributes.length);
      return attributes.slice(0, end);
    },
    fieldsSubsetLength: function(fields) {
      return this.fieldsSubset(fields).length;
    },
    collapseElementBox: function(relation,element) {
      var boxid = this.getUniqueRelationElementId(relation,element);
      if (this.state.elementsBoxes[boxid]) {
        return this.state.elementsBoxes[boxid].collapsed;
      }
    },
    toggleElementBox: function(relation, element) {
      var boxid = this.getUniqueRelationElementId(relation, element);
      this.state.elementsBoxes[boxid].collapsed = !this.state.elementsBoxes[boxid].collapsed;
    },
    getUniqueRelationElementId: function(relation, element) {
      return this.$options.formService.getUniqueRelationElementId(relation, element);
    },
    pasteClipBoardToForm : function() {
      var layerForm = this.$options.formService._getLayerFormFromId();
      this.$options.formService._pasteClipBoardToForm(layerForm);
      this.$validate();
      this.$validate(this.state.relations);
      this.$resetValidation()
    },
    copyToClipBoard : function() {
      this.$options.formService._copyFormToClipBoard();
    },
    onSelectChange: function(field, evt) {
      field.value = evt.target.value;
    },
    onFileChange: function(field, relationIndex, e) {
      var formData = {};
      var spinnerContainer;
      // verifico se esiste il token di django
      var csrftoken = this.$cookie.get('csrftoken');
      if (csrftoken) {
        formData.csrfmiddlewaretoken = csrftoken;
      }
      if (relationIndex) {
        spinnerContainer = $('#foto-spinner'+relationIndex);
      } else {
        spinnerContainer = $('#foto-spinner');
      }
      GUI.showSpinner({
        container: spinnerContainer,
        id: 'fotoloadspinner',
        style: 'white',
        center: true
      });
      $(e.target).fileupload({
        dataType: 'json',
        formData : formData,
        done: function (e, data) {
          $.each(data.result, function (key, value) {
            field.value = value.filename
          });
        },
        fail: function() {
         $(this).siblings('.bootstrap-filestyle').find('input').val(field.value);
         GUI.notify.error('Si è verificato un errore nel caricamento')
        },
        always: function() {
          GUI.hideSpinner('fotoloadspinner');
        }
      });
      //verifico se è stato caricato un file
      var files = e.target.files || e.dataTransfer.files;
      if (!files.length) {
        return;
      }
    },
    createImage: function(file, field) {
      var reader = new FileReader();
      reader.onload = function(e) {
        field.value = e.target.result;
      };
      reader.readAsDataURL(file);
    },
    checkFileSrc: function(value) {
      var value = value;
      if (_.isNil(value)) {
        value = ''
      }
      return value
    },
    setImageStyleInput: function() {
      this.$options.formService._setImageStyleInput();
    }
  },
  computed: {
    isValid: function(field) {
      return this.$validate(field.name);
    },
    hasRelations: function() {
      return this.state.relations.length;
    },
    fields: function() {
      return this.state.fields;
    }
  },
  //aggiunta per  permettere al copia e incolla
  // di aggiornare stile upload image input
  watch: {
    'state.fields': function() {
      this.setImageStyleInput();
    }
  },
  mounted: function() {
    var self = this;
    if (this.state.relationOne && this.state.isnew) {
      var relationsOne = this.$options.formService._getRelationsOne();
      _.forEach(relationsOne, function(relationOne) {
        if (!relationOne.elements.length) {
          self.addRelationElement(relationOne);
        }
      });
    }
    this.$nextTick(function(){
      self.setImageStyleInput();
      self.$options.formService.postRender();
    });
  },
  beforeDestroy: function() {
    // prima di distruggerlo mi assicuro che venga rimosso l'eventuale picklayer interaction
    this.$options.formService._cleanUpPickLayer();
  }
};

function FormComponent(options) {
  var options = options || {};
  options.id = options.id || 'form';
  // qui vado a tenere traccia delle tre cose che mi permettono di customizzare
  // vue component, service e template
  // proprietà necessarie. In futuro le mettermo in una classe Panel
  // da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  base(this, options);
  //settor il service del component (lo istanzio tutte le volte che inizializzo un componente
  var service = options.service ?  new options.service : new Service;
  var vueComponent = options.vueComponentOptions || vueComponentOptions;
  // lo devo fare per problemi con compoents
  this.vueComponent = this.createVueComponent(vueComponent);
  this.setService(service);
  var template = options.template || Template;
  this.setInternalComponentTemplate(template);
  // funzione che permette di settare il componente interno
  this.setInternalComponent = function() {
    var InternalComponent = Vue.extend(this.vueComponent);
    this.internalComponent = new InternalComponent({
      formService: this.getService(),
      template: this.getInternalTemplate()
    });
    // associo lo state del componente interno a quello del service
    // perchè le funzioni che maipolano lo stato del componente sono delegate al service nella
    // maggior parte dei casi
    this.internalComponent.state = this.getService().state;
  };
  // Sovrascrivo il metodo mount padre. Viene richiamato dalla toolbar quando
  // il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
  this.mount = function(parent, append) {
    var self = this;
    // richiama il mont padre
    return base(this, 'mount', parent, append)
      // una volta footo il mount
    .then(function() {
      self.getService().setupFields();
      self.getService().setupRelationsFields();
      // setto il modale a true
      GUI.setModal(true);
    });
  };

  this.layout = function(width,height) {
    var headerHeight = $(this.internalComponent.$el).find(".g3w-form-component_header").height();
    var bodyHeight = height - headerHeight;
    $(this.internalComponent.$el).find(".g3w-form-component_body").height(bodyHeight);
    $(".nano").nanoScroller();
  }
}

inherit(FormComponent, Component);

module.exports = FormComponent;


},{"./templateform.html":113,"core/utils/utils":71,"gui/form/formservice":111,"gui/gui":114,"gui/vue/component":152}],113:[function(require,module,exports){
module.exports = "<div>\n  <div class=\"g3w-form-component_header\">\n    <div class=\"quick-actions-menu\">\n      <div v-if=\"state.tools.copypaste\" class=\"pull-right\">\n        <button v-if='state.isnew' class=\"btn btn-default glyphicon glyphicon-screenshot\" data-placement=\"bottom\" @click=\"pickLayerToClipBoard\"  data-i18n=\"[title]copy_form_data_from_feature\"></button>\n        <button v-if='!state.isnew' class=\"btn btn-default glyphicon glyphicon-copy\" data-placement=\"bottom\" @click=\"copyToClipBoard\"  data-i18n=\"[title]copy_form_data\"></button>\n        <button v-if='state.isnew' class=\"btn btn-default glyphicon glyphicon-paste\" data-placement=\"bottom\" @click=\"pasteClipBoardToForm\" v-disabled=\"!state.canpaste\" data-i18n=\"[title]paste_form_data\"></button>\n      </div>\n    </div>\n  </div>\n  <div class=\"g3w-form-component_body nano\">\n    <form name=\"validation\" novalidate class=\"form-horizontal g3w-form nano-content\">\n        <div class=\"box box-primary\">\n          <div class=\"box-header with-border\">\n            <h3 class=\"box-title\">Attributi elemento</h3>\n            <div class=\"box-tools pull-right\">\n            </div>\n          </div>\n          <div class=\"box-body\">\n            <template v-for=\"field in fields\">\n              <div v-if=\"isVisible(field)\" class=\"form-group has-feedback\">\n                <label :for=\"field.name\" class=\"col-sm-4 control-label\">{{ field.label }}<span v-if=\"field.validate && field.validate.required\">*</span></label>\n                <div class=\"col-sm-8\">\n                  <input v-if=\"isSimple(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                  <textarea v-if=\"isTextarea(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                  </textarea>\n                  <select v-if=\"isSelect(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" @change=\"onSelectChange(field, $event)\" :value=\"isSelectOptionsNull(field.value)\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                    <option v-for=\"value in field.input.options.values\"  :value=\"isSelectOptionsNull(value.key)\" >{{ value.value }}</option>\n                  </select>\n                  <div v-if=\"isLayerPicker(field)\">\n                    <input class=\"form-control picklayerinput\" @click=\"pickLayer(field)\" @change=\"pickLayerInputChange\" :field=\"field.name\" data-toggle=\"tooltip\" :title=\"'Ottieni il dato da un elemento del layer \\'' + layerPickerPlaceHolder(field) + '\\' o scrivilo direttamente qui'\" v-disabled=\"!isEditable(field)\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"'['+layerPickerPlaceHolder(field)+']'\">\n                    <i class=\"glyphicon glyphicon-screenshot form-control-feedback\" ></i>\n                  </div>\n                  <div v-if=\"isRadio(field)\">\n                    <template v-for=\"(value,index) in field.input.options.values\">\n                      <input class=\"magic-radio\" type=\"radio\" :value=\"value.value\" v-model=\"field.value\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" :id=\"field.name + value.value\" :placeholder=\"value.key\">\n                      <label :for=\"field.name + value.value\">{{ value.key }}</label>\n                    </template>\n                  </div>\n                  <div v-if=\"isImage(field)\">\n                    <i v-if=\"checkFileSrc(field.value)\" class=\"glyphicon glyphicon glyphicon-trash pull-right link trash\" @click=\"removeImage(field)\"></i>\n                    <img v-if=\"checkFileSrc(field.value)\" class=\"photo-preview img-responsive img-thumbnail rounded\"  :src=\"field.value\" />\n                    <div id=\"foto-spinner\"></div>\n                    <input type=\"file\" :name=\"field.name\" :data-url=\"field.uploadurl\" :field=\"field.name\" title=\"Foto\" accept=\"image/*;capture=camera\" class=\"filestyle\" @change=\"onFileChange(field, null, $event)\">\n                  </div>\n                </div>\n              </div>\n            </template>\n          </div>\n        </div>\n        <div v-for=\"relation, relationIndex in state.relations\" style=\"margin-top:10px\">\n          <transition name=\"expand\">\n          <div v-if=\"showRelation(relation)\">\n            <div class=\"box box-default\">\n              <div class=\"box-header with-border\">\n                <h3 class=\"box-title\">{{ relation | relationplural }}</h3>\n              </div>\n              <div class=\"box-body\">\n                <table v-if=\"visibleElementsLength(relation)\" class=\"table table-striped\">\n                  <thead>\n                  <tr>\n                    <th v-for=\"field in fieldsSubset(relation.fields)\">{{field.label}}</th>\n                  </tr>\n                  </thead>\n                  <tbody>\n                  <template v-for=\"element in visibleElements(relation)\">\n                    <tr class=\"attributes-preview\" @click=\"toggleElementBox(relation, element)\">\n                      <td v-for=\"relfield in fieldsSubset(element.fields)\">\n                        <span>{{relfield.value}}</span>\n                      </td>\n                      <td class=\"pull-right\">\n                        <i v-if=\"isRelationElementDeletable(relation,element)\" class=\"glyphicon glyphicon glyphicon-trash link trash\" @click.stop.prevent=\"removeRelationElement(relation,element)\"></i>\n                        <i class=\"glyphicon glyphicon-option-horizontal link morelink\"></i>\n                      </td>\n                    </tr>\n                    <tr v-show=\"!collapseElementBox(relation,element)\" class=\"queryresults-featurebox\">\n                      <td :colspan=\"fieldsSubsetLength(element.fields)+1\">\n                        <template v-for=\"field in element.fields\">\n                          <div v-if=\"isVisible(field)\" class=\"form-group has-feedback\">\n                            <label :for=\"field.name\" class=\"col-sm-4 control-label\">{{ field.label }}<span v-if=\"field.validate && field.validate.required\">*</span></label>\n                            <div class=\"col-sm-8\">\n                              <input v-if=\"isSimple(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                              <textarea v-if=\"isTextarea(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"field.input.label\"></textarea>\n                              <select v-if=\"isSelect(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" @change=\"onSelectChange(field, $event)\" :value=\"isSelectOptionsNull(field.value)\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                                <option v-for=\"value in field.input.options.values\"  :value=\"isSelectOptionsNull(value.key)\" >{{ value.value }}</option>\n                              </select>\n                              <div v-if=\"isRadio(field)\">\n                                <template v-for=\"(value, index) in field.input.options.values\">\n                                  <input class=\"magic-radio\" type=\"radio\" :value=\"value.value\" v-model=\"field.value\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" :id=\"field.name + value.value\" :placeholder=\"value.key\">\n                                  <label :for=\"field.name + value.value\">{{ value.key }} </label>\n                                </template>\n                              </div>\n                              <div v-if=\"isCheckbox(field)\">\n                                <template v-for=\"(value, index) in field.input.options.values\">\n                                  <label :for=\"field.name + value.value\">{{ value.key }} </label>\n                                  <input type=\"radio\" :value=\"value.value\" v-model=\"field.value\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" :id=\"field.name + value.value\" :placeholder=\"value.key\">\n                                </template>\n                              </div>\n                              <div v-if=\"isLayerPicker(field)\">\n                                <input class=\"form-control picklayerinput\" @click=\"pickLayer(field, relation)\" @input=\"pickLayerInputFieldChange(field, relation)\"  :field=\"field.name\" data-toggle=\"tooltip\" :title=\"'Ottieni il dato da un elemento del layer \\'' + layerPickerPlaceHolder(field) + '\\' o scrivilo direttamente qui'\" v-disabled=\"!isEditable(field)\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"'['+layerPickerPlaceHolder(field)+']'\">\n                                <i class=\"glyphicon glyphicon-screenshot form-control-feedback\" ></i>\n                              </div>\n                              <div v-if=\"isRadio(field)\">\n                                <template v-for=\"(value,index) in field.input.options.values\">\n                                  <input class=\"magic-radio\" type=\"radio\" :value=\"value.value\" v-model=\"field.value\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" :id=\"field.name + value.value\" :placeholder=\"value.key\">\n                                  <label :for=\"field.name + value.value\">{{ value.key }}</label>\n                                </template>\n                              </div>\n                              <div v-if=\"isImage(field)\" style=\"position:relative;\">\n                                <i v-if=\"checkFileSrc(field.value)\" class=\"glyphicon glyphicon glyphicon-trash pull-right link trash\" @click=\"removeImage(field)\"></i>\n                                <i v-if=\"checkFileSrc(field.value)\" class=\"glyphicon glyphicon glyphicon-trash pull-right link trash\" @click=\"removeImage(field)\"></i>\n                                <img v-if=\"checkFileSrc(field.value)\" class=\"photo-preview img-responsive img-thumbnail rounded\" :src=\"field.value\" />\n                                <div :id=\"'foto-spinner'+relationIndex\"></div>\n                                <input type=\"file\" :name=\"field.name\" :data-url=\"field.uploadurl\" :field=\"field.name\" title=\"Foto\" accept=\"image/*;capture=camera\" class=\"filestyle\" @change=\"onFileChange(field, relationIndex, $event)\">\n                              </div>\n                            </div>\n                          </div>\n                        </template>\n                      </td>\n                    </tr>\n                  </template>\n                  </tbody>\n                </table>\n                <div v-if=\"canAddRelationElements(relation)\" class=\"row\" style=\"margin:0px\"><i class=\"glyphicon glyphicon-plus-sign pull-right btn-add\" @click=\"addRelationElement(relation)\"></i></div>\n              </div>\n            </div>\n          </div>\n          </transition>\n        </div>\n        <div class=\"form-group\">\n          <div class=\"col-sm-offset-4 col-sm-8\">\n            <div v-if=\"hasFieldsRequired\" style=\"margin-bottom:10px\">\n              <span>* Campi richiesti</span>\n            </div>\n            <span v-for=\"button in state.buttons\">\n              <button class=\"btn \" :class=\"[button.class]\" @click.stop.prevent=\"exec(button.cbk)\" v-disabled=\"!btnEnabled(button)\">{{ button.title }}</button>\n            </span>\n          </div>\n        </div>\n    </form>\n  </div>\n</div>";

},{}],114:[function(require,module,exports){
var noop = require('core/utils/utils').noop;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var RouterService = require('core/router');
var ComponentsRegistry = require('gui/componentsregistry');

// rappresenta l'interfaccia globale dell'API della GUI. 
// metodi devono essere implementati (definiti) dall'applicazione ospite
// l'app ospite dovrebbe chiamare anche la funzione GUI.ready() quando la UI è pronta
function GUI() {
  this.ready = false;
  // url delle risorse (immagini, ecc.)
  this.getResourcesUrl = noop;
  // show a Vue form
  this.showForm = noop;
  this.closeForm = noop;
  // mostra una lista di oggetti (es. lista di risultati)
  this.showListing = noop;
  this.closeListing = noop;
  this.hideListing = noop;
  // options conterrà i vari dati sui risultati. Sicuramente avrà la prprietà options.features
  // nel caso di queryByLocation avrà anche options.coordinate
  this.showQueryResults = function(options) {};
  this.hideQueryResults = noop;
  /* editing */
  this.showPanel = noop;
  this.hidePanel = noop;
  //metodi componente
  // aggiunge (e registra) un componente in un placeholder del template - Metodo implementato dal template
  this.addComponent = function(component, placeholder) {};
  this.removeComponent = function(id) {};
  // registra globalmente un componente (non legato ad uno specifico placeholder. Es. componente per mostrare risultati interrogazion)
  this.setComponent = function(component) {
    ComponentsRegistry.registerComponent(component);
  };
  // funzione che mi permette di prendere il componente
  // registrato in base al suo id
  this.getComponent = function(id) {
    return ComponentsRegistry.getComponent(id);
  };
  // funzione che prende tutti i componenti registrati
  this.getComponents = function() {
    return ComponentsRegistry.getComponents();
  };
  //fine metodi componente

  this.goto = function(url) {
    RouterService.goto(url);
  };

  this.ready = function(){
    this.emit('ready');
    this.ready = true;
  };
  
  this.guiResized = function() {
    this.emit('guiresized');
  };

  /* spinner */
  this.showSpinner = function(options){};

  this.hideSpinner = function(id){};

  
  this.notify = noop;
  this.dialog = noop;
}

inherit(GUI,G3WObject);

module.exports = new GUI;

},{"core/g3wobject":27,"core/router":69,"core/utils/utils":71,"gui/componentsregistry":110}],115:[function(require,module,exports){
module.exports = "<div>\n  Lista di oggetti\n</div>\n";

},{}],116:[function(require,module,exports){
var resolve = require('core/utils/utils').resolve;
var reject = require('core/utils/utils').reject;
var GUI = require('gui/gui');
//var MapService = require('core/map/mapservice');

var ListPanelComponent = Vue.extend({
  template: require('./listpanel.html'),
  methods: {
    exec: function(cbk){
      var relations = this.state.relations || null;
      cbk(this.state.fields,relations);
      GUI.closeForm();
    }
  }
});


function ListPanel(options){
  // proprietà necessarie. In futuro le mettermo in una classe Panel da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  this.panelComponent = null;
  this.options =  options || {};
  this.id = options.id || null; // id del form
  this.name = options.name || null; // nome del form
  
  this.state = {
    list: options.list || []
  };
  
  this._listPanelComponent = options.listPanelComponent || ListPanelComponent;
}

var proto = ListPanel.prototype;

// viene richiamato dalla toolbar quando il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
proto.onShow = function(container){
  var panel = this._setupPanel();
  this._mountPanel(panel,container);
  return resolve(true);
};

// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso
proto.onClose = function(){
  this.panelComponent.$destroy(true);
  this.panelComponent = null;
  return resolve(true);
};

proto._setupPanel = function(){
  var panel = this.panelComponent = new this._listPanelComponent({
    panel: this
  });
  panel.state = this.state;
  return panel
};

proto._mountPanel = function(panel,container){
  panel.$mount().$appendTo(container);
};

module.exports = {
  ListPanelComponent: ListPanelComponent,
  ListPanel: ListPanel
};

},{"./listpanel.html":115,"core/utils/utils":71,"gui/gui":114}],117:[function(require,module,exports){
var ResetControl = require('g3w-ol3/src/controls/resetcontrol');
var QueryControl = require('g3w-ol3/src/controls/querycontrol');
var ZoomBoxControl = require('g3w-ol3/src/controls/zoomboxcontrol');
var QueryBBoxControl = require('g3w-ol3/src/controls/querybboxcontrol');
var QueryByPolygonControl = require('g3w-ol3/src/controls/querybypolygoncontrol');
var GeolocationControl = require('g3w-ol3/src/controls/geolocationcontrol');
var StreetViewControl = require('g3w-ol3/src/controls/streetviewcontrol');
var AddLayersControl = require('g3w-ol3/src/controls/addlayers');
var LengthControl = require('g3w-ol3/src/controls/lengthcontrol');
var AreaControl = require('g3w-ol3/src/controls/areacontrol');
var Control = require('g3w-ol3/src/controls/control');
var OLControl = require('g3w-ol3/src/controls/olcontrol');
var NominatimControl = require('g3w-ol3/src/controls/nominatimcontrol');

var ControlsFactory = {
  create: function(options) {
    var control;
    var ControlClass = ControlsFactory.CONTROLS[options.type];
    var layers = options.layers; // opzione che mi server per far visualizzare o meno il controllo
    if (ControlClass) {
      // istanzio il controllo
      control = new ControlClass(options);
    }
    // nel caso siano stati specificati i layers del progetto su cui interrogare
    if (layers && control instanceof Control) {
      // nel caso l'array dei layer è vuoto non visualizzo il controllo
      if (!layers.length) {
        return null
      }
      // ricavo le geometry su cui deve essere fatto i layer
      var controlGeometryTypes = control.getGeometryTypes();
      // imposto il valore iniziale di visible se è un array vuoto vuol dire che non ho specificato nessuna
      // geometria rilevante e quindi deve essere visible
      var visible = (controlGeometryTypes.length) ? false : true;
      _.forEach(layers, function (layer) {
        if (controlGeometryTypes.indexOf(layer.getGeometryType()) > -1) {
          visible = true;
          return false;
        }
      });
      // se visibile allora restituisco il controllo altrimenti null
      if (visible) {
        return control;
      } else {
        return null;
      }
    } else {
      return control;
    }
  }
};

ControlsFactory.CONTROLS = {
  'reset': ResetControl,
  'zoombox': ZoomBoxControl,
  'zoomtoextent': OLControl,
  'query': QueryControl,
  'querybbox': QueryBBoxControl,
  'querybypolygon': QueryByPolygonControl,
  'geolocation': GeolocationControl,
  'streetview': StreetViewControl,
  'zoom': OLControl,
  'scaleline': OLControl,
  'overview': OLControl,
  'nominatim': NominatimControl,
  'addlayers': AddLayersControl,
  'length': LengthControl,
  'area': AreaControl
};

module.exports = ControlsFactory;

},{"g3w-ol3/src/controls/addlayers":74,"g3w-ol3/src/controls/areacontrol":75,"g3w-ol3/src/controls/control":76,"g3w-ol3/src/controls/geolocationcontrol":77,"g3w-ol3/src/controls/lengthcontrol":79,"g3w-ol3/src/controls/nominatimcontrol":81,"g3w-ol3/src/controls/olcontrol":82,"g3w-ol3/src/controls/querybboxcontrol":83,"g3w-ol3/src/controls/querybypolygoncontrol":84,"g3w-ol3/src/controls/querycontrol":85,"g3w-ol3/src/controls/resetcontrol":86,"g3w-ol3/src/controls/streetviewcontrol":87,"g3w-ol3/src/controls/zoomboxcontrol":88}],118:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function ControlsRegistry() {

  this._controls = {};
  this.setters = {
    registerControl : function(id, control) {
      this._registerControl(id, control)
    }
  };

  this._registerControl = function(id, control) {
    this._controls[id] = control;
  };

  this.getControl = function(id) {
    return this._controls[id];
  };

  this.getControls = function() {
    return this._controls;
  };

  this.unregisterControl = function(id) {
    var control = this.getControl(id);
    var mapService = GUI.getComponet('map').getService();
    var map = mapService.getMap();
    if (control) {
      map.removeControl(control);
      delete this._controls[id];
      return true
    }
    return false
  };
  base(this);
}

inherit(ControlsRegistry, G3WObject);

module.exports = new ControlsRegistry;

},{"core/g3wobject":27,"core/utils/utils":71,"gui/gui":114}],119:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var ApplicationService = require('core/applicationservice');
var ProjectsRegistry = require('core/project/projectsregistry');
var Layer = require('core/layers/layer');
var MapLayersStoreRegistry = require('core/map/maplayersstoresregistry');
var LayersStore = require('core/layers/layersstore');
var Filter = require('core/layers/filter/filter');
var WFSProvider = require('core/layers/providers/wfsprovider');
var ol3helpers = require('g3w-ol3/src/g3w.ol3').helpers;
var WMSLayer = require('core/map/layer/wmslayer');
var XYZLayer = require('core/map/layer/xyzlayer');
var ControlsFactory = require('gui/map/control/factory');
var StreetViewService = require('gui/streetview/streetviewservice');
var ControlsRegistry = require('gui/map/control/registry');


function MapService(options) {
  var self = this;
  this.viewer = null;
  this.target = null;
  this._layersStoresEventKeys = {};
  this.project   = null;
  this._mapControls = [];
  this._mapLayers = [];
  this.mapBaseLayers = {};
  this.layersExtraParams = {};
  this.state = {
      bbox: [],
      resolution: null,
      center: null,
      loading: false,
      hidden: true
  };

  this._greyListenerKey = null;
  this._drawShadow = {
    type: 'coordinate',
    outer: [],
    inner: [],
    scale: null,
    rotation: null
  };
  this.config = options.config || ApplicationService.getConfig();
  this._howManyAreLoading = 0;
  this._incrementLoaders = function(){
    if (this._howManyAreLoading == 0){
      this.emit('loadstart');
      GUI.showSpinner({
        container: $('#map-spinner'),
        id: 'maploadspinner',
        style: 'blue'
      });
    }
    this._howManyAreLoading += 1;
  };
  
  this._decrementLoaders = function(){
    this._howManyAreLoading -= 1;
    if (this._howManyAreLoading == 0){
      this.emit('loadend');
      GUI.hideSpinner('maploadspinner');
    }
  };

  if(!_.isNil(options.project)) {
    this.project = options.project;
  } else {
    this.project = ProjectsRegistry.getCurrentProject();
    ProjectsRegistry.onafter('setCurrentProject',function(project){
      self._removeListeners();
      self.project = project;
      self._setupLayers();
      self._resetView();
    })
  }
  this._setupListeners();
  this._marker = null;

  this.setters = {
    setMapView: function(bbox, resolution, center) {
      this.state.bbox = bbox;
      this.state.resolution = resolution;
      this.state.center = center;
      this.updateMapLayers(this._mapLayers);
    },
    setHidden: function(bool) {
      this.state.hidden = bool;
    },
    setupViewer: function(width,height){
      if (width == 0 || height == 0) {
        return
      }
      if (self.viewer) {
        self.viewer.destroy();
        self.viewer = null;
      }
      self._setupViewer(width, height);
      self.state.bbox = this.viewer.getBBOX();
      self.state.resolution = this.viewer.getResolution();
      self.state.center = this.viewer.getCenter();
      self.setupControls();
      self._setupLayers();
      self.emit('viewerset');
    },
    controlClick: function() {}
  };
  
  this.on('cataloglayerselected', function(layer) {
   if (layer) {
     _.forEach(this._mapControls, function(mapcontrol) {
       if (_.indexOf(_.keysIn(mapcontrol.control), 'onSelectLayer') > -1 && mapcontrol.control.onSelectLayer()) {
         if (mapcontrol.control.getGeometryTypes().indexOf(layer.getGeometryType()) > -1 ) {
           mapcontrol.control.setEnable(true);
         } else {
           mapcontrol.control.setEnable(false);
         }
       }
     })
   }
  });

  this.on('cataloglayerunselected', function(layer) {
    _.forEach(this._mapControls, function(mapcontrol) {
      if (_.indexOf(_.keysIn(mapcontrol.control),'onSelectLayer') > -1 && mapcontrol.control.onSelectLayer()) {
        mapcontrol.control.setEnable(false);
      }
    })
  });

  // vado a registrare gli eventi sui layerstores esistesenti nel registro
  _.forEach(MapLayersStoreRegistry.getLayersStores(), function(layerStore) {
    self._setUpEventsKeysToLayersStore(layerStore);
  });

  // sto in ascolto di evantuali aggiunte di layersStore per poter eventualmente
  // aggiungere i suoi layers alla mappa
  MapLayersStoreRegistry.onafter('addLayersStore', function(layerStore) {
    self._setUpEventsKeysToLayersStore(layerStore);
  });
  // sto in ascolto di evantuali aggiunte di layersStore per poter eventualmente
  // aggiungere i suoi layers alla mappa
  MapLayersStoreRegistry.onafter('removeLayersStore', function(layerStore) {
    self._removeEventsKeysToLayersStore(layerStore);
  });
  
  base(this);
}


inherit(MapService, G3WObject);

var proto = MapService.prototype;

// rende questo mapservice slave di un altro MapService
proto.slaveOf = function(mapService, sameLayers){
  // se impostare i layer iniziali uguali a quelli del mapService master
  var sameLayers = sameLayers || false;
};

proto.setLayersExtraParams = function(params,update){
  this.layersExtraParams = _.assign(this.layersExtraParams,params);
  this.emit('extraParamsSet',params,update);
};

proto.getProject = function() {
  return this.project;
};

proto.getMap = function() {
  return this.viewer.map;
};

// funzione che server per definire una proiezione non standard
proto.defineProjection = function(crs) {
  switch(crs) {
    case '3003':
      proj4.defs("EPSG:" + crs, "+proj=tmerc +lat_0=0 +lon_0=9 +k=0.9996 +x_0=1500000 +y_0=0 +ellps=intl +units=m +no_defs");
      break;
  }
};

proto.getProjection = function() {
  return this.project.getProjection();
};

proto.getCrs = function() {
  return this.getProjection().getCode();
};

proto.getViewerElement = function(){
  return this.viewer.map.getTargetElement();
};

proto.getViewport = function(){
  return this.viewer.map.getViewport();
};

proto.getResolution = function() {
  return this.viewer.map.getView().getResolution();
};

proto.getEpsg = function() {
  return this.viewer.map.getView().getProjection().getCode();
};

proto.getGetFeatureInfoUrlForLayer = function(layer,coordinates,resolution,epsg,params) {
  var mapLayer = this.getMapLayerForLayer(layer);
  return mapLayer.getGetFeatureInfoUrl(coordinates,resolution,epsg,params);
};

proto.showMarker = function(coordinates, duration) {
  duration = duration || 1000;
  var self = this;
  this._marker.setPosition(coordinates);
  setTimeout(function(){
    self._marker.setPosition();
  }, duration)
};

// ritorna il layer nella mappa in base al name
proto.getLayerByName = function(name) {
  var map = this.viewer.map;
  var layer = null;
  map.getLayers().forEach(function(lyr) {
    if (lyr.get('name') == name) {
      layer = lyr;
      return false
    }
  });
  return layer;
};

// ritorna il layer della mappa in base all'id
proto.getLayerById = function(id) {
  var map = this.viewer.map;
  map.getLayers().forEach(function(lyr) {
    if (lyr.get('id') == id) {
      layer = lyr;
      return false
    }
  });
  return layer;
};


proto.setupControls = function(){
  var self = this;
  if (this.config && this.config.mapcontrols) {
    _.forEach(this.config.mapcontrols, function(controlType) {
      var control;
      switch (controlType) {
        case 'reset':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
          }
          self.addControl(controlType,control);
          break;
        case 'zoom':
          control = ControlsFactory.create({
            type: controlType,
            zoomInLabel: "\ue98a",
            zoomOutLabel: "\ue98b"
          });
          self.addControl(controlType,control);
          break;
        case 'zoombox':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('zoomend', function (e) {
              self.viewer.fit(e.extent);
            });
            self.addControl(controlType,control);
          }
          break;
        case 'zoomtoextent':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType,
              label: "\ue98c",
              extent: self.project.state.initextent
            });
            self.addControl(controlType,control);
          }
          break;
        case 'query':
          control = ControlsFactory.create({
            type: controlType
          });
          control.on('picked', function(e) {
            var coordinates = e.coordinates;
            self.showMarker(coordinates);
            var showQueryResults = GUI.showContentFactory('query');
            var layers = self.getLayers({
              QUERYABLE: true,
              SELECTEDORALL: true
            });
            var queryPromises = [];// raccoglie tutte le promises dei provider del layer
            _.forEach(layers, function(layer) {
              queryPromises.push(layer.query({
                  coordinates: coordinates,
                  resolution: self.getResolution()
              }))
            });
            //faccio query by location su i layers selezionati o tutti
            var queryResultsPanel = showQueryResults('interrogazione');
            $.when.apply(this, queryPromises)
              .then(function() {
                results = arguments;
                // vado ad unificare i rusltati delle promises
                results.query = results[0].query;
                var data = [];
                _.forEach(results, function(result) {
                  data.push(result.data);
                });
                results.data = data;
                queryResultsPanel.setQueryResponse(results, coordinates, self.state.resolution);
                })
              .fail(function() {
                GUI.notify.error('Si è verificato un errore nella richiesta al server');
                GUI.closeContent();
              })
          });
          self.addControl(controlType,control);
          break;
        case 'querybypolygon':
          var controlLayers = self.getLayers({
            QUERYABLE: true,
            SELECTEDORALL: true
          });
          control = ControlsFactory.create({
            type: controlType,
            layers: controlLayers
          });
          if (control) {

            var showQueryResults = GUI.showContentFactory('query');
            control.on('picked', function (e) {
              var results = {};
              var response = [];
              var queryPromises = [];// raccoglie tutte le promises dei provider del layer
              var geometry;
              var coordinates = e.coordinates;
              var layers = self.getLayers({
                QUERYABLE: true,
                SELECTED: true
              });
              _.forEach(layers, function (layer) {
                queryPromises.push(layer.query({
                  type: 'query',
                  coordinates: coordinates,
                  resolution: self.getResolution()
                }));
              });

              $.when.apply(this, queryPromises)
                .then(function () {
                  queryPromises = [];
                  response = arguments;
                  results = {};
                  // vado ad unificare i rusltati delle promises
                  results.query = response[0].query;
                  var data = [];
                  _.forEach(response, function (result) {
                    data.push(result.data[0]);
                  });
                  results.data = data;
                  if(results && results.data && results.data.length) {
                    geometry = results.data[0].features[0].getGeometry();
                    var queryLayers = self.getLayers({
                      QUERYABLE: true,
                      ALLNOTSELECTED: true,
                      WFS: true
                    });
                    _.forEach(queryLayers, function (layer) {
                      var filterObject = QueryService.createQueryFilterObject({
                        queryLayer: layer,
                        ogcService: 'wfs',
                        filter: {
                          geometry: geometry
                        }
                      });
                      queryPromises.push(layer.query({
                          type: 'filter',
                          filter: filterObject
                        })
                      )
                    });

                    self.highlightGeometry(geometry);
                    var queryResultsPanel = showQueryResults('interrogazione');
                    $.when.apply(this, queryPromises)
                      .then(function () {
                        response = arguments;
                        results = {};
                        // vado ad unificare i rusltati delle promises
                        results.query = response[0].query;
                        var data = [];
                        _.forEach(response, function (result) {
                          data.push(result.data);
                        });
                        results.data = data;
                        queryResultsPanel.setQueryResponse(results, geometry, self.state.resolution);
                      })
                      .fail(function () {
                        GUI.notify.error('Si è verificato un errore nella richiesta al server');
                        GUI.closeContent();
                      })
                      .always(function () {
                        self.clearHighlightGeometry();
                      });
                  }
                })
                .fail(function () {
                  GUI.notify.error('Si è verificato un errore nella richiesta al server');
                  GUI.closeContent();
                })
            });

            self.addControl(controlType, control);
          }
          break;
        case 'querybbox':
          if (!isMobile.any && self.filterableLayersAvailable()) {
            var controlLayers = self.getLayers({
              QUERYABLE: true,
              SELECTEDORALL: true,
              WFS: true
            });
            control = ControlsFactory.create({
              type: controlType,
              layers: controlLayers
            });
            if (control) {
              control.on('bboxend', function (e) {
                var bbox = e.extent;
                var layers = self.getLayers({
                  QUERYABLE: true,
                  SELECTEDORALL: true,
                  WFS: true
                });
                var queryPromises = [];// raccoglie tutte le promises dei provider del layer
                _.forEach(layers, function(layer) {
                  var filter = new Filter();
                  filter.setBBOX(bbox);
                  queryPromises.push(layer.query({
                    filter: filter
                  }))
                });
                var showQueryResults = GUI.showContentFactory('query');
                var queryResultsPanel = showQueryResults('interrogazione');
                $.when.apply(this, queryPromises)
                  .then(function() {
                    results = arguments;
                    // vado ad unificare i rusltati delle promises
                    results.query = results[0].query;
                    var data = [];
                    _.forEach(results, function(result) {
                      data.push(result.data);
                    });
                    results.data = data;
                    queryResultsPanel.setQueryResponse(results, bbox, self.state.resolution);
                  })
                  .fail(function(error) {
                    var msg = 'Si è verificato un errore nella richiesta al server';
                    if (error) {
                      msg += ' '+error;
                    }
                    GUI.notify.error(msg);
                    GUI.closeContent();
                  })
                });
              self.addControl(controlType, control);
            }
          }
          break;
        case 'streetview':
          // streetview
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.setProjection(self.getProjection());
            self.addControl(controlType, control);
            self.on('viewerset', function() {
              self.viewer.map.addLayer(control.getLayer());
            });
            $script("https://maps.googleapis.com/maps/api/js?key=AIzaSyBCHtKGx3yXWZZ7_gwtJKG8a_6hArEFefs",
              function() {
                var position = {
                  lat: null,
                  lng: null
                };
                var streetViewService = new StreetViewService();
                streetViewService.onafter('postRender', function(position) {
                  control.setPosition(position);
                });
                if (control) {
                  control.on('picked', function(e) {
                    var coordinates = e.coordinates;
                    var lonlat = ol.proj.transform(coordinates, self.getProjection().getCode(), 'EPSG:4326');
                    position.lat = lonlat[1];
                    position.lng = lonlat[0];
                    streetViewService.showStreetView(position);
                  });
                  control.on('disabled', function() {
                    if (panorama) {
                      panorama = null;
                    }
                  })
                }
              }
            )
          }
          break;
        case 'scaleline':
          control = ControlsFactory.create({
            type: controlType,
            position: 'br'
          });
          self.addControl(controlType,control);
          break;
        case 'overview':
          if (!isMobile.any) {
            var overviewProjectGid = self.config.overviewproject.gid;
            if (overviewProjectGid) {
              ProjectsRegistry.getProject(overviewProjectGid)
              .then(function(project) {
                var overViewMapLayers = self.getOverviewMapLayers(project);
                control = ControlsFactory.create({
                  type: controlType,
                  position: 'bl',
                  className: 'ol-overviewmap ol-custom-overviewmap',
                  collapseLabel: $('<span class="glyphicon glyphicon-menu-left"></span>')[0],
                  label: $('<span class="glyphicon glyphicon-menu-right"></span>')[0],
                  collapsed: false,
                  layers: overViewMapLayers,
                  view: new ol.View({
                    projection: self.getProjection()
                  })
                });
                self.addControl(controlType,control);
              });
            }
          }
          break;
        case 'nominatim':
          control = ControlsFactory.create({
            type: controlType
          });
          control.on('addresschosen', function (evt) {
            var coordinate = evt.coordinate;
            var geometry =  new ol.geom.Point(coordinate);
            self.highlightGeometry(geometry);
          });
          self.addControl(controlType,control);
          $('#search_nominatim').click(function() {
            control.nominatim.query($('input.gcd-txt-input').val());
          });
          $('.gcd-txt-result').perfectScrollbar();
          break;
        case 'geolocation':
          // nel caso in cui esista il geolocation control o siamo sul mobile
          if (!isMobile.any) {
            // creo il controllo
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('click', function(evt) {
              self.showMarker(evt.coordinates);
            });
            control.on('error', function(e) {
              GUI.notify.error('Non è possibile calcolare la tua posizione. Si è verificato un errore di connessione al server')
            });
            self.addControl(controlType, control);
          }
          break;
        case 'addlayers':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('addlayer', function() {
              if (!control.getLayersStore()) {
                var layersSore = new LayersStore()
              }
              self.emit('addexternallayer');
            });
            self.addControl(controlType, control);
          }
          break;
        case 'length':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            self.addControl(controlType, control);
          }
          break;
        case 'area':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            self.addControl(controlType, control);
          }
          break;
      }
    });
  }
};

// funzione che recupera i layers dagli stores
proto.getLayers = function(filter) {
  filter = filter || {};
  var mapFilter = {
    GEOLAYER: true,
    HIDDEN: false
  };
  filter = _.merge(filter, mapFilter);
  var layers = [];
  _.forEach(MapLayersStoreRegistry.getLayersStores(), function(layerStore) {
    _.merge(layers, layerStore.getLayers(filter));
  });
  return layers;
};

// verifica se esistono layer filtrabili
proto.filterableLayersAvailable = function() {
  var self = this;
  var layers = this.getLayers({
    QUERYABLE: true,
    FILTERABLE: true,
    SELECTEDORALL: true
  });
  return _.some(layers, function(layer) {
    // nel caso il provider dei filtri sia WFS verifico che sia lo stesso sistema di riferimento del progetto, perché QGIS ancora non supporta riproiezione su WFS
    if (layer.getProvider('filter') instanceof WFSProvider) {
      return layer.getProjection().getCode() == self.project.getLayersStore().getProjection().getCode();
    }
    return true;
  });
};

proto.addControl = function(type, control) {
  var self = this;
  this.viewer.map.addControl(control);
  this._mapControls.push({
    type: type,
    control: control,
    visible: true
  });
  control.on('controlclick', function() {
    self.controlClick();
  });
  // vado a registrare il controllo aggiunto
  ControlsRegistry.registerControl(type, control);
};

// mostra uno dei controlli disponibili (ovvero già istanziati in base alla configurazione)
proto.showControl = function(type) {
  this.showControls([type]);
};

// nasconde uno dei controlli disponibili (ovvero già istanziati in base alla configurazione)
proto.hideControl = function(type) {
  this.hideControls([type]);
};

// come sopra ma per un array di tipi di controlli. Es. mapService.showControls(['zoombox','query'])
proto.showControls = function(types) {
  this.toggleControls(true,types);
};

// come sopra ma per un array di tipi di controlli. Es. mapService.hideControls(['zoombox','query'])
proto.hideControls = function(types) {
 this.toggleControls(false,types);
};

// riattiva tutti i controlli disponibili
proto.showAllControls = function() {
  this.toggleControls(true);
};

// rimuove tutti i controlli
proto.hideAllControls = function() {
  this.toggleControls(false);
};

proto.toggleControls = function(toggle, types) {
  var self = this;
  this._removeControls();
  _.forEach(this._mapControls,function(controlObj){
    if (types) {
      if (types.indexOf(controlObj.type) > -1) {
        controlObj.visible = toggle;
      }
    }
    else {
      controlObj.visible = toggle;
    }
  });
  this._layoutControls();
};

proto._layoutControls = function() {
  var self = this;
  _.forEach(this._mapControls,function(controlObj){
    if (controlObj.visible) {
      self.viewer.map.addControl(controlObj.control);
    }
  })
};

proto.removeControl = function(type) {
  var self = this;
  _.forEach(this._mapControls,function(controlObj, ctrlIdx) {
    if (type == controlObj.type) {
      self._mapControls.splice(ctrlIdx,1);
      self.viewer.map.removeControl(controlObj.control);
      return false;
    }
  })
};

proto._removeControls = function() {
  var self = this;
  _.forEach(this._mapControls,function(controlObj){
    self.viewer.map.removeControl(controlObj.control);
  })
};

proto._unToggleControls = function() {
  _.forEach(this._mapControls,function(controlObj){
    if (controlObj.control.toggle) {
      controlObj.control.toggle(false);
    }
  })
};

proto.addMapLayer = function(mapLayer) {
  this._mapLayers.push(mapLayer);
};

proto.getMapLayers = function() {
  return this._mapLayers;
};

proto.getMapLayerForLayer = function(layer) {
  var mapLayer;
  var multilayerId = 'layer_'+layer.getMultiLayerId();
  _.forEach(this.getMapLayers(), function(_mapLayer) {
    if (_mapLayer.getId() == multilayerId) {
      mapLayer = _mapLayer;
      return false;
    }
  });
  return mapLayer;
};

proto.getProjectLayer = function(layerId) {
  return this.layersstore.getLayerById(layerId);
};

proto._resetView = function() {
  var width = this.viewer.map.getSize()[0];
  var height = this.viewer.map.getSize()[1];
  var extent = this.project.state.extent;
  var maxxRes = ol.extent.getWidth(extent) / width;
  var minyRes = ol.extent.getHeight(extent) / height;
  var maxResolution = Math.max(maxxRes,minyRes) > this.viewer.map.getView().getMaxResolution() ? Math.max(maxxRes,minyRes): this.viewer.map.getView().getMaxResolution();
  var view = new ol.View({
    extent: extent,
    projection: this.viewer.map.getView().getProjection(),
    center: this.viewer.map.getView().getCenter(),
    resolution: this.viewer.map.getView().getResolution(),
    maxResolution: maxResolution
  });
  this.viewer.map.setView(view);
};

// funzione che setta la view basata sulle informazioni del progetto
proto._setupViewer = function(width,height) {
  var self = this;
  var projection = this.getProjection();
  // ricavo l'estensione iniziale del progetto)
  var initextent = self.project.state.initextent;
  // ricavo l'estensione del progetto
  var extent = self.project.state.extent;

  var maxxRes = ol.extent.getWidth(extent) / width;
  var minyRes = ol.extent.getHeight(extent) / height;
  // calcolo la massima risoluzione
  var maxResolution = Math.max(maxxRes,minyRes);

  var initxRes = ol.extent.getWidth(initextent) / width;
  var inityRes = ol.extent.getHeight(initextent) / height;
  var initResolution = Math.max(initxRes,inityRes);

  this.viewer = ol3helpers.createViewer({
    id: this.target,
    view: {
      projection: projection,
      /*center: this.config.initcenter || ol.extent.getCenter(extent),
       zoom: this.config.initzoom || 0,
       extent: this.config.constraintextent || extent,
       minZoom: this.config.minzoom || 0, // default di OL3 3.16.0
       maxZoom: this.config.maxzoom || 28 // default di OL3 3.16.0*/
      center: ol.extent.getCenter(initextent),
      extent: extent,
      //minZoom: 0, // default di OL3 3.16.0
      //maxZoom: 28 // default di OL3 3.16.0
      maxResolution: maxResolution
    }
  });

  if (this.config.background_color) {
    $('#' + this.target).css('background-color', this.config.background_color);
  }

  $(this.viewer.map.getViewport()).prepend('<div id="map-spinner" style="position:absolute;right:0px;"></div>');

  this.viewer.map.getInteractions().forEach(function(interaction){
    self._watchInteraction(interaction);
  });

  this.viewer.map.getInteractions().on('add',function(interaction){
    self._watchInteraction(interaction.element);
  });

  this.viewer.map.getInteractions().on('remove',function(interaction){
    //self._onRemoveInteraction(interaction);
  });

  this.viewer.map.getView().setResolution(initResolution);

  this.viewer.map.on('moveend',function(e) {
    self._setMapView();
  });

  this._marker = new ol.Overlay({
    position: undefined,
    positioning: 'center-center',
    element: document.getElementById('marker'),
    stopEvent: false
  });

  this.viewer.map.addOverlay(this._marker);

  this.emit('ready');
};

proto._removeListeners = function() {

  if (this._setBaseLayerListenerKey) {
    this.project.un('setBaseLayer',this._setBaseLayerListenerKey);
  }
};

// vado a registrare tuti gli ebventi del layersStore
proto._removeEventsKeysToLayersStore = function(layerStore) {
  var self = this;
  var layerStoreId = layerStore.getId();
  if (self._layersStoresEventKeys[layerStoreId]) {
    _.forEach(self._layersStoresEventKeys[layerStoreId], function(eventObj) {
      _.forEach(eventObj, function(eventKey, event) {
        layerStore.un(event, eventKey);
      })
    })
  }
};

// vado a registrare tuti gli eventi del layersStore
proto._setUpEventsKeysToLayersStore = function(layerStore) {
  var self = this;
  var layerStoreId = layerStore.getId();
  if (!this._layersStoresEventKeys[layerStoreId]) {
    this._layersStoresEventKeys[layerStoreId] = [];
    var layerVisibleKey = layerStore.onafter('setLayersVisible', function (layersIds) {
      var mapLayers = _.map(layersIds, function(layerId) {
        var layer = layerStore.getLayerById(layerId);
        return self.getMapLayerForLayer(layer);
      });
      self.updateMapLayers(mapLayers);
    });
    this._layersStoresEventKeys[layerStore.getId()].push({
      setLayersVisible:layerVisibleKey
    });
  }
};

proto._setupListeners = function(){

  this._setBaseLayerListenerKey = this.project.onafter('setBaseLayer',function(){
    self.updateMapLayers(self.mapBaseLayers);
  });
};

proto._setupBaseLayers = function(){
  var self = this;
  var baseLayers = self.getLayers({
    BASELAYER: true
  });
  if (!baseLayers.length){
    return;
  }
  this.mapBaseLayers = {};
  _.forEach(baseLayers,function(layer){

    if (layer.isWMS()) {
      var config = {
        url: layer.getWmsUrl(),
        id: layer.state.id,
        tiled: layer.state.tiled
      };
      var mapLayer = new WMSLayer(config);
    }

    else {
      switch(layer.getServerType()){
        case 'OSM':
          var OSMLayer = require('core/map/layer/osmlayer');
          var mapLayer = new OSMLayer({
            id: layer.state.id
          });
          break;
        case 'Bing':
          var BingLayer = require('core/map/layer/binglayer');
          var mapLayer = new BingLayer({
            id: layer.state.id
          });
          break;
      }
    }

    self.addMapLayer(mapLayer);
    self.registerListeners(mapLayer);
    mapLayer.addLayer(layer);
    self.mapBaseLayers[layer.getId()] = mapLayer;
  });

  _.forEach(_.values(this.mapBaseLayers).reverse(),function(mapLayer){
    self.viewer.map.addLayer(mapLayer.getOLLayer());
    mapLayer.update(self.state);
  });
};

proto._setupLayers = function(){
  var self = this;
  this.viewer.removeLayers();
  this._setupBaseLayers();
  this._reset();
  // recupero i layers dai vari layerstore mettendo coem condizione HIDDEN e GEOLAYER
  var layers = this.getLayers();
  //raggruppo per valore del multilayer con chiave valore multilayer
  // e valore array
  var multiLayers = _.groupBy(layers, function(layer){
    return layer.getMultiLayerId();
  });
  //una volta raggruppati per multilayer dove la chiave è il valore del multilayer
  // e il valore è un array di uno o più Layers, distinguo tra layers singoli o multipli e tra layer cachati o non
  _.forEach(multiLayers, function(layers, id) {
    var multilayerId = 'layer_'+id;
    var mapLayer;
    var layer = layers[0];
    if (layers.length == 1 && layer.isCached()) {
      mapLayer = new XYZLayer({
        id: multilayerId,
        projection: self.getProjection()
      });
      self.addMapLayer(mapLayer);
      self.registerListeners(mapLayer);
      mapLayer.addLayer(layer);
    }
    // in casi di multilayers
    else {
      // creo configurazione per costruire il layer wms
      //creo il wms layer
      mapLayer = new WMSLayer({
        // getWMSUrl funzione creata in fase di inizializzazione dell'applicazione
        url: layer.getWmsUrl(),
        id: multilayerId
      }, self.layersExtraParams);
      self.addMapLayer(mapLayer);
      self.registerListeners(mapLayer);
      // lo aggiungo alla lista dei mapLayers
      _.forEach(layers.reverse(), function(sub_layer) {
        // per ogni layer appartenete allo stesso multilayer (è un array)
        // viene aggiunto al mapLayer (WMSLayer) perecedentemente creato
        mapLayer.addLayer(sub_layer);
      });
    }
  });

  // una volta creati tutti i mapLayer apparteneti alla mappa
  _.forEach(this.getMapLayers().reverse(), function(mapLayer) {
    // scorro sui mapLayer (reverse) e aggiungo alla mappa
    self.viewer.map.addLayer(mapLayer.getOLLayer());
    mapLayer.update(self.state, self.layersExtraParams);
  });
  return this.mapLayers;
};

proto.getOverviewMapLayers = function(project) {
  var projectLayers = project.getLayersStore().getLayers({
    VISIBLE: true,
    GEOLAYER: true,
    HIDDEN: false
  });
  

  var multiLayers = _.groupBy(projectLayers,function(layer){
    return layer.getMultiLayerId();
  });
  
  var overviewMapLayers = [];
  _.forEach(multiLayers,function(layers,id){
    var multilayerId = 'overview_layer_'+id;
    var tiled = layers[0].state.tiled;
    var config = {
      url: project.getWmsUrl(),
      id: multilayerId,
      tiled: tiled
    };
    var mapLayer = new WMSLayer(config);
    _.forEach(layers.reverse(),function(layer){
      mapLayer.addLayer(layer);
    });
    overviewMapLayers.push(mapLayer.getOLLayer(true));
  });
  
  return overviewMapLayers.reverse();
};

proto.updateMapLayers = function(mapLayers) {
  var self = this;
  _.forEach(mapLayers, function(mapLayer) {
    mapLayer.update(self.state, self.layersExtraParams);
  })
};
// funzione che registra i listeners sulla creazione del mapLayers
proto.registerListeners = function(mapLayer) {

  var self = this;
  mapLayer.on('loadstart',function(){
    self._incrementLoaders();
  });
  mapLayer.on('loadend',function(){
    self._decrementLoaders(false);
  });
  
  this.on('extraParamsSet',function(extraParams,update){
    if (update) {
      mapLayer.update(this.state,extraParams);
    }
  })
};

proto.setTarget = function(elId){
  this.target = elId;
};

proto.addInteraction = function(interaction) {
  this._unToggleControls();
  this.viewer.map.addInteraction(interaction);
  interaction.setActive(true);
};

proto.removeInteraction = function(interaction){
  this.viewer.map.removeInteraction(interaction);

};

// emetto evento quando viene attivata un interazione di tipo Pointer
// (utile ad es. per disattivare/riattivare i tool di editing)
proto._watchInteraction = function(interaction) {
  var self = this;
  interaction.on('change:active',function(e) {
    if ((e.target instanceof ol.interaction.Pointer) && e.target.getActive()) {
      self.emit('pointerInteractionSet',e.target);
    }
  })
};

proto.goTo = function(coordinates,zoom) {
  var options = {
    zoom: zoom || 6
  };
  this.viewer.goTo(coordinates,options);
};

proto.goToRes = function(coordinates,resolution){
  var options = {
    resolution: resolution
  };
  this.viewer.goToRes(coordinates,options);
};

proto.goToBBox = function(bbox) {
  this.viewer.fit(bbox);
};


proto.goToWGS84 = function(coordinates,zoom){
  var coordinates = ol.proj.transform(coordinates,'EPSG:4326','EPSG:'+this.project.state.crs);
  this.goTo(coordinates,zoom);
};

proto.extentToWGS84 = function(extent){
  return ol.proj.transformExtent(extent,'EPSG:'+this.project.state.crs,'EPSG:4326');
};

proto.getResolutionForMeters = function(meters) {
  var viewport = this.viewer.map.getViewport();
  return meters / Math.max(viewport.clientWidth,viewport.clientHeight);
};

var highlightLayer = null;
var animatingHighlight = false;

proto.highlightGeometry = function(geometryObj,options) {
  var self = this;
  this.clearHighlightGeometry();
  var options = options || {};
  var zoom = (typeof options.zoom == 'boolean') ? options.zoom : true;
  var highlight = (typeof options.highlight == 'boolean') ? options.highlight : true;
  var duration = options.duration || 2000;
  var view = this.viewer.map.getView();
  
  var geometry;
  if (geometryObj instanceof ol.geom.Geometry){
    geometry = geometryObj;
  }
  else {
    var format = new ol.format.GeoJSON;
    geometry = format.readGeometry(geometryObj);
  }

  if (options.fromWGS84) {
    geometry.transform('EPSG:4326','EPSG:'+ProjectService.state.project.crs);
  }
  
  var geometryType = geometry.getType();
  if (zoom) {
    if (geometryType == 'Point' || (geometryType == 'MultiPoint' && geometry.getPoints().length == 1)) {
      var coordinates = geometryType == 'Point' ? geometry.getCoordinates() : geometry.getPoint(0).getCoordinates();
      if (this.project.state.crs != 4326 && this.project.state.crs != 3857) {
        // zoom ad una risoluzione in cui la mappa copra 100m
        var res = this.getResolutionForMeters(100);
        self.goToRes(coordinates,res);
      }
      else {
        zoom = self.viewer.map.getView().getZoom() > 6 ? self.viewer.map.getView().getZoom() : 6;
        self.goTo(coordinates, zoom);
      }
    }
    else {
      this.viewer.fit(geometry,options);
    }
  }

  if (highlight) {
    var feature = new ol.Feature({
      geometry: geometry
    });

    if (!highlightLayer) {
      highlightLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: function(feature){
          var styles = [];
          var geometryType = feature.getGeometry().getType();
          if (geometryType == 'LineString' || geometryType == 'MultiLineString') {
            var style = new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'rgb(255,255,0)',
                width: 4
              })
            });
            styles.push(style);
          }
          else if (geometryType == 'Point' || geometryType == 'MultiPoint') {
            var style = new ol.style.Style({
              image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                  color: 'rgb(255,255,0)'
                })
              }),
              zIndex: Infinity
            });
            styles.push(style);
          } else if (geometryType == 'MultiPolygon' || geometryType == 'Polygon') {
            var style = new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'rgb(255,255,0)',
                width: 4
              }),
              fill: new ol.style.Fill({
                color: 'rgba(255, 255, 0, 0.5)'
              })
            });
            styles.push(style);
          }
          return styles;
        }
      });
      highlightLayer.setMap(this.viewer.map);
    }

    highlightLayer.getSource().clear();
    highlightLayer.getSource().addFeature(feature);

    if (duration) {
      animatingHighlight = true;
      setTimeout(function(){
        highlightLayer.getSource().clear();
        animatingHighlight = false;
      },duration);
    }
  }
};

proto.clearHighlightGeometry = function() {
  if (highlightLayer && ! animatingHighlight) {
    highlightLayer.getSource().clear();
  }
};

proto.refreshMap = function() {
  _.forEach(this._mapLayers, function(wmsLayer) {
    wmsLayer.getOLLayer().getSource().updateParams({"time": Date.now()});
  });
};

// funzione mi server per poter in pratica
// fare l'updatesize della mappa qundo il div che la contine cambia
// in questo modo la mappa non si streccia (chimata dalla viewport)
proto.layout = function(width, height) {
  if (!this.viewer) {
    this.setupViewer(width,height);
  }
  if (this.viewer) {
    this.setHidden((width == 0 || height == 0));
    this.getMap().updateSize();
    this._setMapView();
  }
};

proto._reset = function() {
  this._mapLayers = [];
};

proto._setMapView = function() {
  var bbox = this.viewer.getBBOX();
  var resolution = this.viewer.getResolution();
  var center = this.viewer.getCenter();
  this.setMapView(bbox, resolution, center);
};

proto.getMapSize = function() {
  var map = this.viewer.map;
  return map.getSize();
};

proto.setInnerGreyCoverScale = function(scale) {
  this._drawShadow.scale = scale;
};

proto._resetDrawShadowInner = function() {
  this._drawShadow = {
    type: 'coordinate',
    outer: [],
    inner: [],
    scale: null,
    rotation: null
  };
};

proto.setInnerGreyCoverBBox = function(options) {
  var options = options || {};
  var map = this.viewer.map;
  var type = options.type || 'coordinate'; // di solito sollo coordinate
  var inner = options.inner || null;
  var rotation = options.rotation;
  var scale = options.scale;
  var lowerLeftInner;
  var upperRightInner;
  if (inner) {
    switch (type) {
      case 'coordinate':
        lowerLeftInner = map.getPixelFromCoordinate([inner[0], inner[1]]);
        upperRightInner = map.getPixelFromCoordinate([inner[2], inner[3]]);
        break;
      case 'pixel':
        lowerLeftInner = [inner[0], inner[1]];
        upperRightInner = [inner[2], inner[3]];
        break
    }
    var y_min = lowerLeftInner[1] * ol.has.DEVICE_PIXEL_RATIO;
    var x_min = lowerLeftInner[0] * ol.has.DEVICE_PIXEL_RATIO;
    var y_max = upperRightInner[1] * ol.has.DEVICE_PIXEL_RATIO;
    var x_max = upperRightInner[0] * ol.has.DEVICE_PIXEL_RATIO;
    this._drawShadow.inner[0] = x_min;
    this._drawShadow.inner[1] = y_min;
    this._drawShadow.inner[2] = x_max;
    this._drawShadow.inner[3] = y_max;
  }
  if (_.isNil(scale)) {
    this._drawShadow.scale = this._drawShadow.scale || 1;
  } else {
    this._drawShadow.scale = scale;
  }
  if (_.isNil(rotation)) {
    this._drawShadow.rotation = this._drawShadow.rotation || 0;
  } else {
    this._drawShadow.rotation = rotation;
  }
  if (this._drawShadow.outer) {
    map.render();
  }
};

// funzione grigio mappa precompose mapcompose
proto.startDrawGreyCover = function() {
  var self = this;
    // after rendering the layer, restore the canvas context
  var map = this.viewer.map;
  var x_min, x_max, y_min, y_max, rotation, scale;
  //verifico che non ci sia già un greyListener
  if (this._greyListenerKey) {
      this.stopDrawGreyCover();
  }

  function postcompose(evt) {
    var ctx = evt.context;
    var size = this.getSize();
    // Inner polygon,must be counter-clockwise
    var height = size[1] * ol.has.DEVICE_PIXEL_RATIO;
    var width = size[0] * ol.has.DEVICE_PIXEL_RATIO;
    self._drawShadow.outer = [0,0,width, height];
    ctx.restore();
    ctx.beginPath();
    // Outside polygon, must be clockwise
    ctx.moveTo(0, 0);
    ctx.lineTo(width, 0);
    ctx.lineTo(width, height);
    ctx.lineTo(0, height);
    ctx.lineTo(0, 0);
    ctx.closePath();
    // fine bbox esterno (tutta la mappa-)
    if (self._drawShadow.inner.length) {
      ctx.save();
      x_min = self._drawShadow.inner[0];
      y_min = self._drawShadow.inner[3];
      x_max = self._drawShadow.inner[2];
      y_max = self._drawShadow.inner[1];
      rotation = self._drawShadow.rotation;
      scale = self._drawShadow.scale;
      // Inner polygon,must be counter-clockwise antiorario
      ctx.translate((x_max+x_min)/2, (y_max+y_min)/2);
      ctx.rotate(rotation*Math.PI / 180);
      ctx.moveTo(-((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.lineTo(((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.lineTo(((x_max-x_min)/2),-((y_max-y_min)/2));
      ctx.lineTo(-((x_max-x_min)/2),-((y_max-y_min)/2));
      ctx.lineTo(-((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.closePath();
      // fine bbox interno
    }
    ctx.fillStyle = 'rgba(0, 5, 25, 0.40)';
    ctx.fill();
    ctx.restore();
  }
  this._greyListenerKey = map.on('postcompose', postcompose);
};

proto.stopDrawGreyCover = function() {
  var map = this.viewer.map;
  ol.Observable.unByKey(this._greyListenerKey);
  this._greyListenerKey = null;
  if (this._drawShadow.inner.length) {
    this._resetDrawShadowInner();
  }
  map.render();
};

// funzione che rimuove layer aggiunti esterni
proto.removeExternalLayer = function(name) {
  var layer = this.getLayerByName(name);
  var catalogService = GUI.getComponent('catalog').getService();
  var QueryResultService = GUI.getComponent('queryresults').getService();
  QueryResultService.unregisterVectorLayer(layer);
  this.viewer.map.removeLayer(layer);
  catalogService.removeExternalLayer(name);
};

// funzione che aggiunge layer esterni
proto.addExternalLayer = function(externalLayer) {

  //funzione che mippermette di fare il loadind del layer sulla mappa
  function loadExternalLayer(format, data) {
    features = format.readFeatures(data, {
      dataProjection: 'EPSG:'+ crs,
      featureProjection: self.getEpsg()
    });
    vectorSource = new ol.source.Vector({
      features: features
    });
    vectorLayer = new ol.layer.Vector({
      source: vectorSource,
      //style: styleFunction,
      name: name
    });
    //vado a settare il colore al vector layer
    vectorLayer.setStyle(self.setExternalLayerColor(color));
    extent = vectorLayer.getSource().getExtent();
    //setto il bbox perchè mi servirà nel catalog
    externalLayer.bbox = {
      minx: extent[0],
      miny: extent[1],
      maxx: extent[2],
      maxy: extent[3]
    };
    map.addLayer(vectorLayer);
    //vado a registrae il layer vettoriale per la query
    QueryResultService.registerVectorLayer(vectorLayer);
    //vado ad aggiungere il layer esterno
    catalogService.addExternalLayer(externalLayer);
    map.getView().fit(vectorSource.getExtent());
  }

  var self = this;
  var format,
    features,
    vectorSource,
    vectorLayer,
    extent;
  var map = this.viewer.map;
  var name = externalLayer.name;
  var color = externalLayer.color;
  var type = externalLayer.type;
  var crs = externalLayer.crs;
  var data = externalLayer.data;
  var catalogService = GUI.getComponent('catalog').getService();
  var QueryResultService = GUI.getComponent('queryresults').getService();
  // cerco di verificare se esiste già un layer nella mappa
  var layer = this.getLayerByName(name);
  // aggiungo solo nel caso di layer non presente
  if (!layer) {
    // nel caso in cui i sistemi di riferimento del layer e della mappa sono diversi
    // vado a definirne il sistema (caso a sistemi di proiezione non standard in OL3 diversi da 3857 e 4326)
    if (crs != self.getCrs()) {
      self.defineProjection(crs);
    }
    //verifico il tipo di file uplodato
    switch (type) {
      case 'geojson':
        format = new ol.format.GeoJSON();
        loadExternalLayer(format, data);
        break;
      case 'kml':
        format = new ol.format.KML({
          extractStyles: false
        });
        loadExternalLayer(format, data);
        break;
      case 'zip':
        // qui non specifico l'epsg in quanto lo legge da solo
        // dal file prj
        var geoJSONFile;
        loadshp({
          url: data,
          encoding: 'big5',
          EPSG: crs
        }, function(geojson) {
          if (!geoJSONFile) {
            geoJSONFile = geojson;
            crs = '4326';
            data = JSON.stringify(geojson);
            format = new ol.format.GeoJSON();
            loadExternalLayer(format, data);
          }
        });
        break;
    }
  } else {
    GUI.notify.info('Layer già aggiunto');
  }
};

// setta il colore al layer caricati esternamente
proto.setExternalLayerColor = function(color) {
  // stile
  var color = color.rgba;
  color = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ','  + color.a + ')';
  var defaultStyle = {
    'Point': new ol.style.Style({
      image: new ol.style.Circle({
        fill: new ol.style.Fill({
          color: color
        }),
        radius: 5,
        stroke: new ol.style.Stroke({
          color: color,
          width: 1
        })
      })
    }),
    'LineString': new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'Polygon': new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(255,255,255,0.5)'
      }),
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'MultiPoint': new ol.style.Style({
      image: new ol.style.Circle({
        fill: new ol.style.Fill({
          color: color
        }),
        radius: 5,
        stroke: new ol.style.Stroke({
          color: color,
          width: 1
        })
      })
    }),
    'MultiLineString': new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'MultiPolygon': new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(255,255,255,0.5)'
      }),
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    })
  };
  var styleFunction = function(feature, resolution) {
    var featureStyleFunction = feature.getStyleFunction();
    if (featureStyleFunction) {
      return featureStyleFunction.call(feature, resolution);
    } else {
      return defaultStyle[feature.getGeometry().getType()];
    }
  };

  return styleFunction
};

module.exports = MapService;

},{"core/applicationservice":22,"core/g3wobject":27,"core/layers/filter/filter":34,"core/layers/layer":37,"core/layers/layersstore":39,"core/layers/providers/wfsprovider":46,"core/map/layer/binglayer":51,"core/map/layer/osmlayer":55,"core/map/layer/wmslayer":57,"core/map/layer/xyzlayer":58,"core/map/maplayersstoresregistry":59,"core/project/projectsregistry":67,"core/utils/utils":71,"g3w-ol3/src/g3w.ol3":89,"gui/gui":114,"gui/map/control/factory":117,"gui/map/control/registry":118,"gui/streetview/streetviewservice":146}],120:[function(require,module,exports){
module.exports = "<!-- Modal -->\n<div class=\"modal fade\" id=\"modal-addlayer\" role=\"dialog\">\n  <div class=\"modal-dialog\">\n    <!-- Modal content-->\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\">&times;</button>\n        <h4 class=\"modal-title\">Aggiungi Layer</h4>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"form-group\">\n          <label for=\"proiezione-layer\">Seleziona il sistema di proiezione del layer</label>\n          <select class=\"form-control\" id=\"proiezione-layer\" v-model=\"layer.crs\">\n            <option value=\"3003\">EPSG:3003</option>\n            <option value=\"3857\">EPSG:3857</option>\n            <option value=\"4326\">EPSG:4326</option>\n          </select>\n        </div>\n        <p style=\"font-weight: 700;\">Seleziona il colore del layer</p>\n        <chrome-picker v-model=\"layer.color\" @change-color=\"onChangeColor\" style=\"width:90%;margin:auto\"></chrome-picker>\n        <form id=\"addcustomlayer\">\n          <input type=\"file\" title=\" \" @change=\"onAddLayer($event)\" accept=\".kml,.geojson, .KML, .GEOJSON, .zip\">\n          <h4>Trascina qui il file o clicca sull'area</h4>\n          <h4 v-if=\"layer.name\">{{ layer.name }}</h4>\n          <div>\n            <i class=\"fa fa-cloud-upload fa-5x\" aria-hidden=\"true\"></i>\n          </div>\n          <p>.geojson, .kml, .zip(shapefile)</p>\n        </form>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default pull-left\" @click=\"addLayer\" data-dismiss=\"modal\">Aggiungi</button>\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\" @click=\"clearLayer\">Chiudi</button>\n      </div>\n    </div>\n  </div>\n</div>";

},{}],121:[function(require,module,exports){
module.exports = "<div :id=\"target\" style=\"width:100%;height:100%\">\n  <div style=\"display: none;\">\n    <div id=\"marker\"></div>\n  </div>\n  <addlayer :service=\"service\"></addlayer>\n</div>\n\n\n";

},{}],122:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var MapService = require('../mapservice');
//componente vue.color
var ChromeComponent = VueColor.Chrome;
// setto la funzione mounted così tutti i componenti erediteranno da questo
ChromeComponent.mounted =  function() {
  this.$nextTick(function() {
    //vado a rimuovere elementi che non mi servono
    $('.vue-color__chrome__toggle-btn').remove();
    $('.vue-color__editable-input__label').remove();
    $('.vue-color__chrome__saturation-wrap').css('padding-bottom','100px');
    $('.vue-color__chrome').css({
      'box-shadow': '0 0 0 0',
      'border': '1px solid #97A1A8'
    });
  });
};

var AddLayerComponent = {
  template: require('./addlayer.html'),
  props: ['service'],
  data: function() {
    return {
      layer: {
        name: null,
        type: null,
        crs: null,
        color: {
          hex: '#194d33',
          rgba: {
            r: 25,
            g: 77,
            b: 51,
            a: 1
          },
          a: 1
        },
        data: null,
        visible: true,
        title: null,
        id: null,
        external: true
      }
    }
  },
  components: {
    'chrome-picker': ChromeComponent
  },
  mounted: function(){
    this.layer.crs = this.service.getCrs();
    this.service.on('addexternallayer', function() {
      $('#modal-addlayer').modal('show');
    });
  },
  methods: {
    onChangeColor: function(val) {
      this.layer.color = val;
    },
    onAddLayer: function(evt) {
      var self = this;
      var reader = new FileReader();
      var name = evt.target.files[0].name;
      this.layer.name = name;
      this.layer.title = name;
      this.layer.id = name;
      var type = evt.target.files[0].name.split('.');
      this.layer.type = type[type.length-1].toLowerCase();
      if (this.layer.type == 'zip') {
        self.layer.data = evt.target.files[0];
        $('input:file').val(null);
      } else {
        reader.onload = function(evt) {
          self.layer.data = evt.target.result;
          // vado a rimuovere il valore del layer ultimo aggiunto per
          // fare in mdo che l'evento change possa scattare
          $('input:file').val(null);
        };
        reader.readAsText(evt.target.files[0]);
      }
    },
    addLayer: function() {
      if (this.layer.name) {
        //devo fare il cloen al fine di evitare che quando
        // riapro la modale ci si sempre il
        var layer = _.cloneDeep(this.layer);
        this.service.addExternalLayer(layer);
        $('#modal-addlayer').modal('hide');
        this.clearLayer();
      }
    },
    clearLayer: function() {
      this.layer.name = null;
      this.layer.title = null;
      this.layer.id = null;
      this.layer.type = null;
      this.layer.crs = this.service.getCrs();
      this.layer.color = {
        hex: '#194d33',
          rgba: {
          r: 25,
            g: 77,
            b: 51,
            a: 1
        },
        a: 1
      };
      this.layer.data = null;
    }
  }
};

// componente vue della mappa
var vueComponentOptions = {
  template: require('./map.html'),
  data: function() {
    return {
      target: 'map', // specidica l'id
      service: this.$options.mapService
    }
  },
  components: {
    'addlayer': AddLayerComponent
  },
  mounted: function() {
    var self = this;
    var mapService = this.$options.mapService;
    this.crs = mapService.getCrs();
    this.$nextTick(function() {
      mapService.setTarget(self.$el.id);
    });
    // questo serve per quando viene cambiato progetto/vista cartografica,
    // in cui viene ricreato il viewer (e quindi la mappa)
    mapService.onafter('setupViewer',function() {
      mapService.setTarget(self.$el.id);
    });
  }
};
// registro internamente
var InternalComponent = Vue.extend(vueComponentOptions);
// viene definito il componte map
Vue.component('g3w-map', vueComponentOptions);
//componente mappa
function MapComponent(options) {
  base(this, options);
  this.id = "map-component";
  this.title = "Catalogo dati";
  this.target = options.target || 'map';
  this.setService(new MapService(options));
  merge(this, options);
  this.internalComponent = new InternalComponent({
    mapService: this._service // definisco il mapservice
  });
  this.internalComponent.target = this.target;
}

inherit(MapComponent, Component);

var proto = MapComponent.prototype;
// funzione che ne definisce il layout della mappa
// ed è chamata dall viewport per risettare le size delle due view
proto.layout = function(width, height) {
  // setto alterzza e larghezza nuove
  $('#'+this.target).height(height);
  $('#'+this.target).width(width);
  this._service.layout(width,height);
};

module.exports =  MapComponent;


},{"../mapservice":119,"./addlayer.html":120,"./map.html":121,"core/utils/utils":71,"gui/vue/component":152}],123:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var resolvedValue = require('core/utils/utils').resolve;
var G3WObject = require('core/g3wobject');

var Panel = function(options) {
  this.internalPanel = null;
  var options = options || {};
  this.id = options.id || null;
  this.title = options.title || '';
};

inherit(Panel, G3WObject);

var proto = Panel.prototype;

proto.getId = function(){
  return this.id;
};

proto.getTitle = function(){
  return this.title;
};

proto.getInternalPanel = function() {
  return this.internalPanel;
};

proto.setInternalPanel = function(internalPanel) {
  this.internalPanel = internalPanel;
};

/* HOOKS */

/*
 * Il metodo permette al pannello di montarsi nel DOM
 * parent: elemento DOM padre, su cui inserirsi;
 * ritorna una promise, risolta nel momento in cui sarà terminato il montaggio
*/

// SONO DUE TIPOLOGIE DI MONTAGGIO CON IL QUALE IL PANNELLO
// CHE VERRA' MONTATO AL VOLO CON IL METODO MOUNT A SECONDA DEL TIPO DI PANNELLO RICHIESTO

// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso

proto.mount = function(parent) {
  var panel = this.internalPanel;
  var iCinstance = panel.$mount();
  $(parent).append(iCinstance.$el);
  iCinstance.$nextTick(function(){
    $(parent).localize();
    if (panel.onShow) {
      panel.onShow();
    }
  });
  return resolvedValue(true);
};

/*
 * Metodo richiamato quando si vuole rimuovere il panello.
 * Ritorna una promessa che sarà risolta nel momento in cui il pannello avrà completato la propria rimozione (ed eventuale rilascio di risorse dipendenti)
*/
proto.unmount = function() {
  var panel = this.internalPanel;
  var deferred = $.Deferred();
  panel.$destroy(true);
  $(panel.$el).remove();
  // lo setta di nuovo a null
  if (panel.onClose) {
    panel.onClose();
  }
  this.internalComponent = null;
  deferred.resolve();
  return deferred.promise();
};

/*
 * Metodo (opzionale) che offre l'opportunità di ricalcolare proprietà dipendenti dalle dimensioni del padre
 * parentHeight: nuova altezza del parent
 * parentWidth: nuova larghezza del parent
 * richiamato ogni volta che il parent subisce un ridimensionamento
*/
proto.onResize = function(parentWidth,parentHeight){};


module.exports = Panel;

},{"core/g3wobject":27,"core/utils/utils":71}],124:[function(require,module,exports){
var scale = [
  {
    value:500,
    label:'1:500'
  },
  {
    value:1000,
    label:'1:1.000'
  },
  {
    value:2000,
    label:'1:2.000'
  },
  {
    value:2500,
    label:'1:2.500'
  },
  {
    value:5000,
    label:'1:5.000'
  },
  {
    value:10000,
    label:'1:10.000'
  },
  {
    value:25000,
    label:'1:25.000'
  },
  {
    value:50000,
    label:'1:50.000'
  },
  {
    value:100000,
    label:'1:100.000'
  },
  {
    value:250000,
    label:'1:250.000'
  },
  {
    value:500000,
    label:'1:500.000'
  },
  {
    value:1000000,
    label:'1:1.000.000'
  }
];
var dpis = [150, 300];

module.exports = {
  scale: scale,
  dpis: dpis
};

},{}],125:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var PrintService = require('core/print/printservice');
var resToScale = require('core/utils/geo').resToScale;
var scaleToRes = require('core/utils/geo').scaleToRes;
var printConfig = require('./printconfig');
var PrintPage = require('./vue/printpage');
var scale = printConfig.scale;
var dpis = printConfig.dpis;


function PrintComponentService() {
  base(this);
  // mi dice se è stato inizilizzato o meno
  this._initialized = false;
  // inizializzo lo state
  this.state = {};
  this._moveMapKeyEvent = null;
  // istanzio il componete page per la visualizzazione del pdf
  this._page = null;
  this._mapService = null;
  this._map = null;
  this._isOpen = false;
  // oggetto che va a mappare scale e risoluzione
  // si aggiornerà via via che verranno fatti zoom in e zoom out
  // tramite l'evento moveend
  this._scalesResolutions = {};
  // inizializzazione
  this.init = function() {
    // recupero il project
    this._project = ProjectsRegistry.getCurrentProject();
    // prendo le informazioni del print
    this.state.print = this._project.state.print;
    // setto lo state visible
    this.state.visible = (this.state.print && this.state.print.length) ? true : false;
    this.state.isShow = false;
    this.state.loading = false;
    this.state.url = null;
    if (this.state.visible) {
      // Imposto le configurazioni inziali da rivedere
      this.state.template = this.state.print[0].name;
      this.state.rotation = 0;
      this.state.inner = null;
      this.state.center = null;
      this.state.size = null;
      this.state.scale = scale;
      this.state.scala = null;
      this.state.dpis = dpis;
      this.state.dpi = dpis[0];
      this.state.map = null;//;this.state.print[0].maps[0].name;
      this.state.width = null;//this.state.print[0].maps[0].w;
      this.state.height = null;//this.state.print[0].maps[0].h;
    }
  };
  // metodo per il cambio di template
  this.changeTemplate = function() {
    var self = this;
    if (!this.state.template) return;
    var template = this.state.template;
    _.forEach(this.state.print, function(print) {
      if (print.name == template) {
        // al momento hardcoded mpa0
        self.state.width = print.maps[0].w;
        self.state.height = print.maps[0].h;
        self.state.map = print.maps[0].name;
      }
    });
    this._setPrintArea();
  };

  // metodo per il cambio di scala attraverso la select
  this.changeScale = function() {
    if (!this.state.scala) return;
    // vado a cambiare la print area
    this._setPrintArea();
  };

  // metodo per il cambio di rotazione
  this.changeRotation = function() {
    this._mapService.setInnerGreyCoverBBox({
      rotation: this.state.rotation
    });
    this._changePrintOutput();
  };

  // funzione che restituisce le options del print
  this._getOptionsPrint = function() {
    var options = {
      scale: this.state.scala, // scala scelta
      extent: this.state.inner.join(), // estensione
      rotation: this.state.rotation, // rotazione
      dpi: this.state.dpi,// dpi
      template: this.state.template, // nome template
      map: this.state.map // tipo mappa (sempre map0)
    };
    return options;
  };

  // funzione print
  this.print = function() {
    var self = this;
    this._page = new PrintPage({
      service: self
    });
    var options = this._getOptionsPrint();
    // apro il content
    GUI.setContent({
      content: self._page,
      title: 'Stampa',
      perc:100
    });
    PrintService.print(options)
    .then(function(data, status, xhr) {
      // setto l'url
      self.state.url = this.url;
    })
    .fail(function() {
      GUI.notify.error('Si è verificato un errore nella richiesta al server');
      GUI.closeContent();
    })
  };

  this._calculateInternalPrintExtent = function(resolution) {
    // rapporto tra largheza e altezza della mappa nel template
    var rapportoMappaTemplate = this.state.width/this.state.height;
    // rapporto larghezza e altezza della mappa nel client (viewport)
    var rapportoMappaClient = this.state.size[0]/this.state.size[1];
    var width, height;
    if (rapportoMappaClient > 1) { // mappa orizzontale
      if (rapportoMappaTemplate > 1) {
        if (rapportoMappaTemplate > rapportoMappaClient) {
          width = this.state.size[0] / 2; // numero di pixel raggio larghezza
        } else {
          width = (this.state.size[0] * (rapportoMappaTemplate/rapportoMappaClient))/2;
        }
        // setto un padding
        width = width - parseInt(width/10);

        height = width / rapportoMappaTemplate; // numero di pixel raggio altezza
      } else {
        height = this.state.size[1] / 2; // numero di pixel raggio larghezza
        // setto un padding
        height = height - parseInt(height/10);
        width = height * rapportoMappaTemplate ; // numero di pixel raggio altezza
      }
    } else { // mappa verticale
      if (rapportoMappaTemplate > 1) {
        width = this.state.size[0] / 2; // numero di pixel raggio larghezza
        // setto un padding
        width = width - parseInt(width/10);

        height = width / rapportoMappaTemplate; // numero di pixel raggio altezza
      } else {
        if (rapportoMappaTemplate < rapportoMappaClient) {
          height = this.state.size[1] / 2; // numero di pixel raggio larghezza
        } else {
          height = (this.state.size[1] * (rapportoMappaClient/rapportoMappaTemplate))/2;
        }
        // setto un padding
        height = height - parseInt(height/10);
        width = height * rapportoMappaTemplate ; // numero di pixel raggio altezza
      }
    }
    // vado a calcolare la x_min e x_max
    x_min = this.state.center[0] - (width*resolution);
    x_max = this.state.center[0] + (width*resolution);
    // vado a caloclare la y_min e y_max
    y_min = this.state.center[1] - (height*resolution);
    y_max = this.state.center[1] + (height*resolution);
    this.state.inner =  [x_min, y_min, x_max, y_max];
  };

  // funzione che setta il BBOX della printArea
  this._setPrintArea = function() {
    // size della mappa
    this.state.size = this._map.getSize();
    this.state.currentScala = resToScale(this._map.getView().getResolution());
    // centro della mappa
    this.state.center = this._map.getView().getCenter();
    // vado a prendere la risoluzione dell'area
    var resolution = scaleToRes(this.state.scala);
    this._calculateInternalPrintExtent(resolution);
    this._mapService.setInnerGreyCoverBBox({
      inner: this.state.inner,
      rotation: this.state.rotation
    });
  };

  // metodo chiusura print panel
  this._clearPrint = function() {
    // rimovo l'evento movend della mappa
    ol.Observable.unByKey(this._moveMapKeyEvent);
    // lo setto a null
    this._moveMapKeyEvent = null;
    // dico al mapservice di fermare il disegno del print area
    this._mapService.stopDrawGreyCover();
  };

  // funzione che fa il change dell'ouput pdf quando
  // ci spostiamo nella mappa o cambiano i parametri del print
  // al momento non usata
  this._changePrintOutput = function() {
    var self = this;
    // verifico se l'otuput pdf è visibile
    if (this.state.isShow) {
      this.state.loading = true;
      var options = this._getOptionsPrint();
      PrintService.print(options)
        .then(function (url) {
          if (self.state.url == url) {
            self.state.loading = false;
          }
          self.state.url = url;
        })
    }
  };

  // la funzione mi serve per adattare le scale da visulzizzare in base alle
  // varie risoluzione della mappa basate su maResolution della view
  this._setAllScalesBasedOnMaxResolution = function(maxResolution) {
    var self = this;
    var resolution = maxResolution;
    var mapScala = resToScale(resolution);
    // ordino le scale dal più grande al più piccolo
    var orderScales = _.orderBy(this.state.scale, ['value'], ['desc']);
    var scale = [];
    _.forEach(orderScales, function(scala) {
      if (mapScala > scala.value) {
        scale.push(scala);
        resolution = scaleToRes(scala.value);
        self._scalesResolutions[scala.value] = resolution;
        resolution = resolution / 2;
      }
    });
    // riordino in modo crescente
    this.state.scale = _.orderBy(scale, ['value'], ['asc']);
  };

  // funzione che mi restituisce la scala da settare inizialmente
  this._setInitialScalaSelect = function() {
    var self = this;
    // prendo la risoluzione della mappa
    var initialResolution = this._map.getView().getResolution();
    // ci calcolo la scala associata alla resoluzione iniziale della mappa
    var initialScala = resToScale(initialResolution);
    var found = false;
    _.forEach(this.state.scale, function(scala, index) {
      // qui vado a settare la scala in base alla risoluzione inziale della mappa
      if (initialScala < scala.value && !self.state.scala) {
        var idx = index ? index -1 : index;
        self.state.scala = self.state.scale[idx].value;
        $('#scala').val(self.state.scala);
        found = true;
        return false
      }
    });
    if (!found) {
      this.state.scala = this.state.scale[this.state.scale.length-1].value;
    }
  };

  //setta la scala in base alla risoluzione
  this._setCurrentScala = function(resolution) {
    var self = this;
    _.forEach(this._scalesResolutions, function(res, scala) {
      if (res == resolution) {
        self.state.scala = scala;
        return false
      }
    });
  };

  // funzione che ha lo scopo di settare il moveend della mappa
  this._setMoveendMapEvent = function() {
    var self = this;
    // prendo la chiave dell'evento moveend
    this._moveMapKeyEvent = this._map.on('moveend', function() {
      /// setto nella select la scala corrispondente
      // vado a settare la print area
      self._setPrintArea();
    })
  };

  //funzione che setta l'area iniziale
  this._showPrintArea = function() {
    // vado ad impostare l'area di stampa
    this._setPrintArea();
    // dico al mapservice di disegnare l'area di stampa
    this._mapService.startDrawGreyCover();
  };


  // funzione che setta la massima e iniziale scala del progetto
  this._initPrintConfig = function() {
    var resolution;
    if (!this._initialized) {
      // prendo la massima risoluzione della mappa
      var maxResolution = this._map.getView().getMaxResolution();
      // ricavo le scale adatte alle mie risoluzioni
      this._setAllScalesBasedOnMaxResolution(maxResolution);
      //se non è stata ancora inizializzata allora vado a settare
      // setto la scala iniziale nella select in base alla risoluzione di partenza del progetto
      this._setInitialScalaSelect();
      //dico che è stata inzializzata
      this._initialized = true;
    } else {
      // prendo la risoluzione corrente
      resolution = this._map.getView().getResolution();
      // vado a cambiare la scala
      this._setCurrentScala(resolution);
    }
  };

  // funzione che ricava sempre map0
  this._setMapInfo = function() {
    var self = this;
    _.forEach(this.state.print[0].maps, function(map) {
      if (map.name == 'map0') {
        self.state.map = map.name;
        self.state.width = map.w;
        self.state.height = map.h;
        return false;
      }
    })
  };

  // metodo per la visualizzazione dell'area grigia o meno
  // chamata dal metodo _setOpen del componente
  this.showPrintArea = function(bool) {
    this._mapService = GUI.getComponent('map').getService();
    this._map = this._mapService.viewer.map;
    if (bool) {
      this._setMapInfo();
      // registo il moveend map event
      this._setMoveendMapEvent();
      // setto la scala iniziale derivato dalle proprietà della mappa
      // e limito la selezione delle scale
      this._initPrintConfig();
      // setto la area di print
      this._showPrintArea();
    } else {
      // vado a ripulire tutti le cose legate al print
      this._clearPrint();
    }
  };

  this.reload = function() {
    var self = this;
    this._project = ProjectsRegistry.getCurrentProject();
    this._mapService = GUI.getComponent('map').getService();
    this._map = this._mapService.viewer.map;
    // prendo le informazioni del print
    this.state.print = this._project.state.print;
    // setto lo state visible
    this.state.visible = (this.state.print && this.state.print.length) ? true : false;
    //verifico se è visibile nel senso se ci sono informazioni
    //sul print per quel progetto
    if (this.state.visible) {
      this.state.template = this.state.print[0].name;
      // setto la area di print
      if (!this._initialized) {
        this.init();
      }
      this._initPrintConfig();
      this._mapService.on('changeviewaftercurrentproject', function() {
        var maxResolution = self._map.getView().getMaxResolution();
        // ricavo le scale adatte alle mie risoluzioni
        self.state.scale = scale;
        self._setAllScalesBasedOnMaxResolution(maxResolution);
      });
    } else {
      // vado a ripulire tutti le cose legate al print
      this._clearPrint();
    }
  }
}

inherit(PrintComponentService, G3WObject);

module.exports = PrintComponentService;
},{"./printconfig":124,"./vue/printpage":129,"core/g3wobject":27,"core/print/printservice":63,"core/project/projectsregistry":67,"core/utils/geo":70,"core/utils/utils":71,"gui/gui":114}],126:[function(require,module,exports){
module.exports = "<ul id=\"print\" class=\"treeview-menu\">\n  <li>\n    <form id=\"g3w-search-form\" class=\"form-horizonal\">\n      <div class=\"box-body\">\n        <label for=\"templates\">Template</label>\n        <select class=\"form-control\" @change=\"onChangeTemplate\" v-model=\"state.template\" id=\"templates\" placeholder=\"Seleziona il template\">\n          <option v-for=\"print in state.print\">{{ print.name }}</option>\n        </select>\n        <label for=\"scala\">Scala</label>\n        <select class=\"form-control\" @change=\"onChangeScale\" v-model=\"state.scala\" id=\"scala\" placeholder=\"Seleziona la scala\">\n          <option v-for=\"scala in state.scale\" :value=\"scala.value\">{{ scala.label }}</option>\n        </select>\n        <label for=\"dpi\">dpi</label>\n        <select class=\"form-control\" @change=\"onChangeDpi\"  v-model=\"state.dpi\" id=\"dpi\" placeholder=\"Seleziona i dpi\">\n          <option v-for=\"dpi in state.dpis\" >{{ dpi }}</option>\n        </select>\n        <label for=\"rotation\">Rotazione</label>\n        <input min=\"-360\" max=\"360\"  @input=\"onChangeRotation\" v-model=\"state.rotation\" id=\"rotation\" class=\"form-control\" type=\"number\">\n      </div>\n      <div class=\"box-footer\" style=\"background-color: transparent\">\n        <span>\n          <button style=\"width:100%; background-color: #3c8dbc\" class=\"btn \" @click.stop.prevent=\"exec(button.cbk)\" v-disabled=\"btnEnabled(button)\">{{ button.title }}</button>\n        </span>\n      </div>\n    </form>\n    <div id=\"message\" style=\"text-align:center; padding:3px; color: yellow\" class=\"message\" v-show=\"btnEnabled(button)\">\n      <div>\n        <span>Muovendoti all'interno della mappa</span>\n      </div>\n      <div>\n        <span>o cambiando i parametri della stampa</span>\n      </div>\n      <div>\n        <span>il PDF si aggiornerà automaticamente</span>\n      </div>\n    </div>\n  </li>\n</ul>\n";

},{}],127:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var Component = require('gui/vue/component');
var PrintService = require('gui/print/printservice');
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;

var vueComponentOptions = {
  template: require('./print.html'),
  data: function() {
    var self = this;
    return {
      state: null,
      button: {
        title: "Crea PDF",
        class: "btn-success",
        type:"stampa",
        disabled: false,
        cbk: function() {
          self.print()
        }
      }
    }
  },
  methods: {
    exec: function(cbk) {
      cbk();
    },
    btnEnabled: function(button) {
      return button.disabled;
    },
    isAnnullaButton: function(type) {
      return type == 'annulla'
    },
    // metodo per il cambio di template
    onChangeTemplate: function() {
      this.$options.service.changeTemplate();
    },
    // metodo per il cambio di scala
    onChangeScale: function() {
      this.$options.service.changeScale()
    },
    // metodo per il cambio di DPI
    onChangeDpi: function() {

    },
    // metodo per il cambio di rotazione
    onChangeRotation: function(evt) {
      if (this.state.rotation >= 0 && !_.isNil(this.state.rotation) && this.state.rotation != '') {
        this.state.rotation = (this.state.rotation > 360) ? 360 : this.state.rotation;
        evt.target.value = this.state.rotation;
      } else if (this.state.rotation < 0) {
        this.state.rotation = (this.state.rotation < -360) ? -360 : this.state.rotation;
        evt.target.value = this.state.rotation;
      } else {
        this.state.rotation = 0;
      }

      this.$options.service.changeRotation();
    },
    // funzione dedicata alla visualizzazione dell'ouput del print
    print: function() {
      this.$options.service.print();
    }
  }
};


function PrintComponent(options) {
  // proprietà necessarie. In futuro le mettermo in una classe Panel
  // da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  base(this, options);
  this.title = "print";
  // qui vado a tenere traccia delle due cose che mi permettono di customizzare
  // vue component e service
  this.vueComponent = vueComponentOptions;
  //merge(this, options);
  // dichiaro l'internal Component
  this.internalComponent = null;
  // setto il service del component (istanzio il nuovo servizio)
  var service = options.service || new PrintService;
  this.setService(service);
  this._service.init();
  // setto il componente interno
  this.setInternalComponent = function () {
    var InternalComponent = Vue.extend(this.vueComponent);
    this.internalComponent = new InternalComponent({
      service: service
    });
    // setto la visibilità del print in base a quella del servizio calcolata sull'array
    // print restituita dal server
    this.state.visible = service.state.visible;
    // assegno all'internal componente lo state mergiato
    this.internalComponent.state = service.state;
    // ritorno l'internal component
    return this.internalComponent;
  };

  //sovrascrivo il metodo reload
  this._reload = function() {
    var service = this.getService();
    service.reload();
    this.state.visible = service.state.visible;
  };

  // funzione che viene chaimata quando viene visualizzato il contentuto del componente Stampa
  // nella sidebar
  this._setOpen = function() {
    this._service.showPrintArea(this.state.open);
  };
  merge(this, options);

}

inherit(PrintComponent, Component);

module.exports = PrintComponent;



},{"./print.html":126,"core/utils/utils":71,"gui/print/printservice":125,"gui/vue/component":152}],128:[function(require,module,exports){
module.exports = "<div id=\"pdf-output\" style=\"height:100%\">\n  <div v-show=\"state.loading\" class=\"bar-loader\"></div>\n  <iframe id=\"pdf\" style=\"border:0px;width:100%;height:100%\" :src=\"state.url\"></iframe>\n</div>";

},{}],129:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');

var InternalComponent = Vue.extend({
  template: require('./printpage.html'),
  data: function() {
    return {
      state: null
    }
  },
  mounted: function() {
    var self = this;
    this.state.loading = true;
    this.$nextTick(function(){
      $('#pdf').load(function(){
        self.state.loading = false;
      })
    });
  }
});

var PrintPage = function(options) {
  base(this);
  var options = options || {};
  var service = options.service;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent();
  this.setInternalComponent(internalComponent);
  this.internalComponent.state = service.state;
};

inherit(PrintPage, Component);


module.exports = PrintPage;



},{"./printpage.html":128,"core/utils/utils":71,"gui/vue/component":152}],130:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function PhotoService(options) {
  var options = options || {};
  this.state = {};
  base(this);
}

inherit(PhotoService, G3WObject);

module.exports = PhotoService;

},{"core/g3wobject":27,"core/utils/utils":71}],131:[function(require,module,exports){
module.exports = "<div id=\"photo\" style=\"margin: 10px;\">\n  <img :src=\"url\" style=\"width: 100%;\">\n</div>";

},{}],132:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var Service = require('../photoservice');

var InternalComponent = Vue.extend({
  template: require('./photo.html'),
  data: function() {
    return {
      state: null,
      url: this.$options.url
    }
  }
});

var PhotoComponent = function(options) {
  base(this);
  var options = options || {};
  var service = options.service || new Service({});
  var url = options.url || null;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service,
    url: url
  });
  this.setInternalComponent(internalComponent);
  this.internalComponent.state = service.state;
};

inherit(PhotoComponent, Component);


module.exports = PhotoComponent;



},{"../photoservice":130,"./photo.html":131,"core/utils/utils":71,"gui/vue/component":152}],133:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectsRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');


function RelationsService(options) {
  this.state = {};
  this._project = ProjectsRegistry.getCurrentProject();
  base(this);

  this.getRelations = function(options) {
    var projectId = this._project.state.id;
    options = options || {};
    var value = options.value || null;
    var id = options.id || null;
    return $.get('/qdjango/api/relations/'+projectId+'/'+id+'/'+value)
  };
  this.buildRelationTable = function(relations) {
    var columns = _.keys(relations[0]);
    var rows = [];
    _.forEach(relations, function(relation){
      rows.push(_.values(relation));
    });
    return {
      columns: columns,
      rows: rows
    }
  };
}

inherit(RelationsService, G3WObject);

module.exports = RelationsService;

},{"core/g3wobject":27,"core/project/projectsregistry":67,"core/utils/utils":71,"gui/gui":114}],134:[function(require,module,exports){
module.exports = "<div class=\"query-relation\">\n  <div class=\"back-btn\" @click=\"back\">\n    <span class=\"back-link\">\n      <span class=\"glyphicon glyphicon-chevron-left\"></span>\n      Ritorna alle Relazioni\n    </span>\n  </div>\n  <div class=\"header\">\n    <div>\n      Dati relativi alla relazione <b>{{ relation.name }}</b>\n    </div>\n  </div>\n  <div class=\"nano\" v-if=\"table.rows.length\">\n    <div class=\"nano-content\">\n      <table class=\"table table-striped\">\n        <thead>\n          <tr>\n            <th v-for=\"column in table.columns\">{{ column }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-for=\"row in table.rows\">\n            <td v-for=\"value in row\">{{ value }}</td>\n          </tr>\n        </tbody>\n        </table>\n    </div>\n  </div>\n  <div v-else> Non ci sono relazioni </div>\n\n</div>\n";

},{}],135:[function(require,module,exports){
module.exports = "<div class=\"query-relations\">\n  <div class=\"header\">\n    <div>Elenco Relazioni della feature <span v-for=\"info in featureInfo()\"><b>{{ info.key }}</b>: {{ info.value }} </span></div>\n  </div>\n  <div class=\"nano\">\n    <div class=\"nano-content\">\n      <table class=\"table table-bordered table-hover\">\n        <thead>\n        </thead>\n        <tbody>\n          <tr @click=\"showRelation(relation)\" v-for=\"relation in relations\" style=\"cursor:pointer\">\n            <td>\n              <span >{{ relation.name }}</span>\n              <span class=\"glyphicon glyphicon-chevron-right pull-right\" aria-hidden=\"true\"></span>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n";

},{}],136:[function(require,module,exports){
module.exports = "<div class=\"query-relations-page\">\n    <component\n        :is=\"currentview\"\n        :relations=\"relations\"\n        :relation=\"relation\"\n        :feature=\"feature\"\n        :table=\"table\">\n    </component>\n</div>";

},{}],137:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var Service = require('../relationsservice');



/* Lista delle relationi associate  */
var relationsComponent = {
  template: require('./relations.html'),
  props: ['relations', 'feature'],
  methods: {
    showRelation: function(relation) {
      this.$parent.showRelation(relation);
    },
    featureInfo: function() {
      var infoFeatures = [];
      var index = 0;
      _.forEach(this.feature.attributes, function(value, key) {
        if (index > 2) return false;
        if (value && _.isString(value) && value.indexOf('/') == -1 ) {
          infoFeatures.push({
            key: key,
            value: value
          });
          index+=1;
        }

      });
      return infoFeatures
    }
  }
};
/*-----------------------------------*/

/* Tabella relation */
var relationComponent = {
  template: require('./relation.html'),
  props: ['table', 'relation'],
  methods: {
    back: function() {
      this.$parent.setRelationsList();
    }
  }
};
/*-----------------------------------*/

var InternalComponent = Vue.extend({
  template: require('./relationspage.html'),
  data: function() {
    return {
      state: null,
      table: null,
      relation: null,
      relations: this.$options.relations,
      feature: this.$options.feature,
      currentview: 'relations' // proprietà che serve per switchare tra componenti
    }
  },
  components: {
    'relations': relationsComponent,
    'relation': relationComponent
  },
  methods: {
    showRelation: function(relation) {
      var self = this;
      this.relation = relation;
      var field = relation.fieldRef.referencedField;
      var value = this.feature.attributes[field];
      this.$options.service.getRelations({
        id: relation.id,
        value: value
      }).then(function(relations) {
        self.table = self.$options.service.buildRelationTable(relations);
        self.currentview = 'relation';
        Vue.nextTick(function() {
          $(".nano").nanoScroller();
        })
      })
    },
    setRelationsList: function() {
      this.currentview = 'relations';
    }
  }
});

var RelationsPage = function(options) {
  base(this);
  var options = options || {};
  var service = options.service || new Service({});
  var relations = options.relations || [];
  var feature = options.feature || null;
  // istanzio il componente interno
  this.setService(service);
  // istanzio il componente interno
  var internalComponent = new InternalComponent({
    service: service,
    relations: relations,
    feature: feature
  });
  this.setInternalComponent(internalComponent);
  internalComponent.state = service.state;
};
inherit(RelationsPage, Component);


module.exports = RelationsPage;



},{"../relationsservice":133,"./relation.html":134,"./relations.html":135,"./relationspage.html":136,"core/utils/utils":71,"gui/vue/component":152}],138:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectsRegistry = require('core/project/projectsregistry');
var Layer = require('core/layers/layer');
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var VectorLayer = require('core/map/layer/vectorlayer');
var ComponentsRegistry = require('gui/componentsregistry');
var QueryService = require('core/query/queryservice');
var PhotoComponent = require('./components/photo/vue/photo');
var RelationsPage = require('./components/relations/vue/relationspage');


function QueryResultsService() {
  var self = this;
  // prendo le relazioni dal progetto e se ci sono e le raggruppo per referencedLayer
  this._relations = ProjectsRegistry.getCurrentProject().state.relations ? _.groupBy(ProjectsRegistry.getCurrentProject().state.relations,'referencedLayer'): null;
  this._actions = {
    'zoomto': QueryResultsService.zoomToElement,
    'highlightgeometry': QueryResultsService.highlightGeometry,
    'clearHighlightGeometry': QueryResultsService.clearHighlightGeometry
  };
  this.state = {};
  this.init = function(options) {
    this.clearState();
  };

  // array dei layers vettoriali
  this._vectorLayers = [];

  this.setters = {
    setQueryResponse: function(queryResponse, coordinates, resolution ) {
      this.clearState();
      this.state.query = queryResponse.query;
      //recupero tutti i mlayers dalll'attributo data della risposta
      // costuendo il formato digeribile dal componente query
      var layers = this._digestFeaturesForLayers(queryResponse.data);
      //setto i layers data
      this.setLayersData(layers);
    },
    setLayersData: function(layers) {
      // un opportunità per aggiungere / modificare i risultati dell'interrogazione
      this.state.loading = false;
      this.state.layers =  layers;
      this.setActionsForLayers(layers);
    },
    addActionsForLayers: function(actions) {
      // un opportunità per i listener per aggiungere azioni a layer e feature
    },
    postRender: function(element) {
      // un opportunità per i listener di intervenire sul DOM
    }
  };
  // fa il clear dello state
  this.clearState = function() {
    this.state.layers = [];
    this.state.query = {};
    this.state.querytitle = "";
    this.state.loading = true;
    this.state.layersactions = {};
  };

  this.getState = function() {
    return this.state;
  };

  this.setState = function(state) {
    this.state = state;
  };

  this.setTitle = function(querytitle) {
    this.state.querytitle = querytitle || "";
  };
  
  this.reset = function() {
    this.clearState();
  };
  // funzione che serve a far digerire i risultati delle features
  this._digestFeaturesForLayers = function(featuresForLayers) {
    
    var self = this;
    var id = 0;
    // variabile che tiene traccia dei layer sotto query
    var layers = [];
    var layerAttributes,
      layerRelationsAttributes,
      layerTitle,
      layerId;
    _.forEach(featuresForLayers, function(featuresForLayer) {
      featuresForLayer = featuresForLayer[0];
      // prendo il layer
      var layer = featuresForLayer.layer;
      // verifico che tipo ti vector layer ci sono
      if (layer instanceof Layer) {
        layerAttributes = layer.getAttributes();
        layerRelationsAttributes = layer.getRelationsAttributes();
        layerTitle = layer.getTitle();
        layerId = layer.getId();
      }
      else if (layer instanceof ol.layer.Vector){
        layerAttributes = layer.getProperties();
        layerRelationsAttributes =  [];
        layerTitle = layer.get('name');
        layerId = layer.get('id');
      };

      var layerObj = {
        title: layerTitle,
        id: layerId,
        attributes: [],
        features: [],
        hasgeometry: false,
        show: true,
        expandable: true,
        hasImageField: false, // regola che mi permette di vedere se esiste un campo image
        relationsattributes: layerRelationsAttributes,
        error: ''
      };

      // verifico che ci siano feature legate a quel layer che sono il risultato della query
      if (featuresForLayer.features && featuresForLayer.features.length) {
        // prendo solo gli attributi effettivamente ritornati dal WMS (usando la prima feature disponibile)
        layerObj.attributes = self._parseAttributes(layerAttributes, featuresForLayer.features[0].getProperties()),
        // faccio una ricerca sugli attributi del layer se esiste un campo image
        // se si lo setto a true
        _.forEach(layerObj.attributes, function(attribute) {
          if (attribute.type == 'image') {
            layerObj.hasImageField = true;
          }
        });
        // a questo punto scorro sulle features selezionate dal risultato della query
        _.forEach(featuresForLayer.features, function(feature){
          var fid = feature.getId() ? feature.getId() : id;
          var geometry = feature.getGeometry();
          // verifico se il layer ha la geometria
          if (geometry) {
            // setto che ha geometria mi servirà per le action
            layerObj.hasgeometry = true
          }
          // creo un feature object
          var featureObj = {
            id: fid,
            attributes: feature.getProperties(),
            geometry: feature.getGeometry(),
            show: true
            // aggiungo le relazioni
          };
          layerObj.features.push(featureObj);
          id += 1;
        });
        layers.push(layerObj);
      }
      else if (featuresForLayer.error){
        layerObj.error = featuresForLayer.error;
        console.log(featuresForLayer.error);
      }
    });
    return layers;
  };
  
  this._parseAttributes = function(layerAttributes, featureAttributes) {
    var featureAttributesNames = _.keys(featureAttributes);
    featureAttributesNames = _.filter(featureAttributesNames,function(featureAttributesName){
      return ['boundedBy','geom','the_geom','geometry','bbox', 'GEOMETRY'].indexOf(featureAttributesName) == -1;
    });
    if (layerAttributes && layerAttributes.length) {
      var featureAttributesNames = _.keys(featureAttributes);
      return _.filter(layerAttributes,function(attribute){
        return featureAttributesNames.indexOf(attribute.name) > -1;
      })
    }
    // se layer.attributes è vuoto
    // (es. quando l'interrogazione è verso un layer esterno di cui non so i campi)
    // costruisco la struttura "fittizia" usando l'attributo sia come name che come label
    else {
      return _.map(featureAttributesNames, function(featureAttributesName){
        return {
          name: featureAttributesName,
          label: featureAttributesName
        }
      })
    }
  };

  // metodo per settare le azioni che si possono fare sulle feature del layer
  this.setActionsForLayers = function(layers) {
    var self = this;
    // scorro su ogni layer che ho nella risposta
    _.forEach(layers, function(layer) {
      // se non esistono azioni su uno specifico layer creo
      // array di azioni con chiave id del layer (in quanto valore univoco)
      if (!self.state.layersactions[layer.id]) {
        self.state.layersactions[layer.id] = [];
      }
      // verifico se il layer ha gemetria
      if (layer.hasgeometry) {
        // se prsente aggiungo oggetto azione che mi server per fare
        // il goTo geometry
        self.state.layersactions[layer.id].push({
          id: 'gotogeometry',
          class: 'glyphicon glyphicon-map-marker',
          hint: 'Visualizza sulla mappa',
          cbk: QueryResultsService.goToGeometry
        })
      }
      // vado a costruire l'action delle query-relazioni
      if (self._relations) {
        // scorro sulle relazioni e vado a verificare se ci sono relazioni che riguardano quel determintato layer
        _.forEach(self._relations, function(relations, id) {
          // verifico se l'id del layer è uguale all'id della relazione
          if (layer.id == id) {
            self.state.layersactions[layer.id].push({
              id: 'show-query-relations',
              class: 'fa fa-sitemap',
              hint: 'Visualizza Relazioni',
              cbk: QueryResultsService.showQueryRelations,
              relations: relations
            })
          }
          return false;
        })
      }
    });
    this.addActionsForLayers(self.state.layersactions);
  };
  
  this.trigger = function(actionId, layer, feature) {
    var actionMethod = this._actions[actionId];
    if (actionMethod) {
      actionMethod(layer, feature);
    }
    if (layer) {
      var layerActions = self.state.layersactions[layer.id];
      if (layerActions) {
        var action;
        _.forEach(layerActions, function(layerAction){
          if (layerAction.id == actionId) {
            action = layerAction;
          }
        });
        if (action) {
          this.triggerLayerAction(action,layer,feature);
        }
      }
    }
  };

  this.triggerLayerAction = function(action,layer,feature) {
    if (action.cbk) {
      action.cbk(layer,feature, action)
    }
    if (action.route) {
      var url;
      var urlTemplate = action.route;
      url = urlTemplate.replace(/{(\w*)}/g,function(m,key){
        return feature.attributes.hasOwnProperty(key) ? feature.attributes[key] : "";
      });
      if (url && url != '') {
        GUI.goto(url);
      }
    }
  };

  //funzione che permette di vedere la foto a schermo intero
  this.showFullPhoto = function(url) {
    GUI.pushContent({
      content: new PhotoComponent({
        url: url
      }),
      backonclose: true,
      closable: false
    });
  };

  // funzione che mi serve per registrare il vector layer al fine di fare le query
  this.registerVectorLayer = function(vectorLayer) {
    if (this._vectorLayers.indexOf(vectorLayer) == -1) {
      //vado ad aggiungere informazioni utili alla visualizzazioni nel query
      vectorLayer.state = {};
      vectorLayer.state.title = vectorLayer.name;
      vectorLayer.state.id = vectorLayer.id;
      this._vectorLayers.push(vectorLayer);
    }
  };

  // funzione che mi serve per unregistrare il vector layer dalla query
  this.unregisterVectorLayer = function(vectorLayer) {
    var index = this._vectorLayers.indexOf(vectorLayer);
    if ( index != -1) {
      this._vectorLayers.splice(index, 1);
    }
  };

  // funzione che permette ai layer vettoriali di aggancirsi alla query info
  this._addVectorLayersDataToQueryResponse = function() {
    var self = this;
    this.onbefore('setQueryResponse', function (queryResponse, coordinates, resolution) {
      var mapService = ComponentsRegistry.getComponent('map').getService();
      var isVisible = false;
      _.forEach(self._vectorLayers, function(vectorLayer) {
        var features = [];
        var feature,
          intersectGeom;
        // la prima condizione mi server se viene fatto un setQueryResponse sul singolo layer vettoriale
        // ad esempio con un pickfeature per evitare che venga scatenato un'altra query
        // nel caso di attivazione di uno dei query control (la momento bbox, info e polygon)
        // la setQueryresponse ha priorità sugli altri di fatto cancellando la setResqponseqeusry dello specifico vectorLayer
        switch (vectorLayer.constructor) {
          case VectorLayer:
            isVisible = !vectorLayer.isVisible();
            break;
          case ol.layer.Vector:
            isVisible = !vectorLayer.getVisible();
            break;
        }
        if ((queryResponse.data && queryResponse.data.length && queryResponse.data[0].layer == vectorLayer) || !coordinates || isVisible ) { return true}
        // caso in cui è stato fatto una precedente richiesta identify e quindi devo attaccare il risultato
        // non mi piace perchè devo usare altro metodo
        // caso query info
        if (_.isArray(coordinates)) {
          if (coordinates.length == 2) {
            var pixel = mapService.viewer.map.getPixelFromCoordinate(coordinates);
            feature = mapService.viewer.map.forEachFeatureAtPixel(pixel, function (feature, layer) {
              return feature;
            },  {
              layerFilter: function(layer) {
                return layer === vectorLayer;
              }
            });
            if (feature) {
              QueryService.convertG3wRelations(feature);
              features.push(feature);
            }
          } else if (coordinates.length == 4) {
            intersectGeom = ol.geom.Polygon.fromExtent(coordinates);
            switch (vectorLayer.constructor) {
              case VectorLayer:
                features = vectorLayer.getIntersectedFeatures(intersectGeom);
                break;
              case ol.layer.Vector:
                _.forEach(vectorLayer.getSource().getFeatures(), function(feature) {
                  if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
                    features.push(feature);
                  }
                });
                break;
            }
          }
        } else if (coordinates instanceof ol.geom.Polygon || coordinates instanceof ol.geom.MultiPolygon) {
          intersectGeom = coordinates;
          switch (vectorLayer.constructor) {
            case VectorLayer:
              features = vectorLayer.getIntersectedFeatures(intersectGeom);
              break;
            case ol.layer.Vector:
              _.forEach(vectorLayer.getSource().getFeatures(), function(feature) {
                if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
                  features.push(feature);
                }
              });
              break;
          }
        }
        _.forEach(features, function(feature) {
          QueryService.convertG3wRelations(feature);
        });
        // vado a pushare le features verificando prima se c'è stato un risultato
        queryResponse.data = queryResponse.data ? queryResponse.data : [];
        queryResponse.data.push({
          features: features,
          layer: vectorLayer
        });
      })
    });
  };

  base(this);
  // lancio subito la registrazione
  this._addVectorLayersDataToQueryResponse();
}

QueryResultsService.zoomToElement = function(layer,feature) {
  //TODO
};

QueryResultsService.goToGeometry = function(layer,feature) {
  if (feature.geometry) {
    var mapService = ComponentsRegistry.getComponent('map').getService();
    mapService.highlightGeometry(feature.geometry, {duration: 4000});
  }
};

QueryResultsService.highlightGeometry = function(layer,feature) {
  if (feature.geometry) {
    var mapService = ComponentsRegistry.getComponent('map').getService();
    mapService.highlightGeometry(feature.geometry,{zoom: false});
  }
};

QueryResultsService.clearHighlightGeometry = function(layer, feature) {
  var mapService = ComponentsRegistry.getComponent('map').getService();
  mapService.clearHighlightGeometry();
};

QueryResultsService.showQueryRelations = function(layer, feature, action) {
  GUI.pushContent({
    content: new RelationsPage({
      relations: action.relations,
      feature: feature
    }),
    backonclose: true,
    closable: false
  });
};

// Make the public service en Event Emitter
inherit(QueryResultsService, G3WObject);

module.exports = QueryResultsService;

},{"./components/photo/vue/photo":132,"./components/relations/vue/relationspage":137,"core/g3wobject":27,"core/layers/layer":37,"core/map/layer/vectorlayer":56,"core/project/projectsregistry":67,"core/query/queryservice":68,"core/utils/utils":71,"gui/componentsregistry":110,"gui/gui":114}],139:[function(require,module,exports){
module.exports = "<div id=\"search-results\" class=\"queryresults-wrapper\">\n  <h3 v-if=\"state.querytitle\">Risultati {{state.querytitle.toLowerCase()}}</h3>\n  <div v-show=\"state.loading\" class=\"bar-loader\"></div>\n  <div class=\"queryresults-container\">\n    <ul v-if=\"hasResults()\" class=\"queryresults\" id=\"queryresults\">\n      <li v-if=\"layerHasFeatures(layer) && layer.show\" v-for=\"layer in state.layers\">\n        <div class=\"box box-primary\">\n          <div class=\"box-header with-border\" data-widget=\"collapse\">\n            <h3 class=\"box-title\">{{ layer.title }} ({{layer.features.length}})</h3>\n            <div class=\"box-tools pull-right\">\n              <button class=\"btn btn-box-tool\" data-widget=\"collapse\"><i class=\"btn-collapser fa fa-minus\"></i></button>\n            </div>\n          </div>\n          <div class=\"box-body\">\n            <table class=\"table table-striped\">\n              <thead>\n              <tr>\n                <th v-if=\"layer.hasgeometry\"></th>\n                <th v-for=\"(attribute, index) in attributesSubset(layer.attributes)\" :style=\"{ width:cellWidth(index,layer) + '%' }\">{{attribute.label}}</th>\n                <th :style=\"{ width:headerExpandActionCellWidth + '%' }\"></th>\n              </tr>\n              </thead>\n              <tbody>\n              <template v-if=\"feature.show\" v-for=\"feature in layer.features\">\n                <tr @click=\"toggleFeatureBoxAndZoom(layer,feature);\" @mouseover=\"trigger('highlightgeometry',layer,feature)\" @mouseout=\"trigger('clearHighlightGeometry')\" class=\"featurebox-header\">\n                  <td v-if=\"geometryAvailable(feature)\" class=\"action-cell\">\n                    <span @click.stop.prevent=\"trigger('gotogeometry',layer,feature)\" class=\"glyphicon glyphicon-map-marker action-button-icon\"></span>\n                  </td>\n                  <td v-for=\"attribute in attributesSubset(layer.attributes)\">\n                    <span>{{feature.attributes[attribute.name]}}</span>\n                  </td>\n                  <td class=\"action-cell\">\n                    <span class=\"fa link morelink\" :class=\"[collapsedFeatureBox(layer,feature) ? 'fa-plus' : 'fa-minus']\"></span>\n                  </td>\n                </tr>\n                <tr v-show=\"!collapsedFeatureBox(layer,feature)\" class=\"featurebox-body\">\n                  <td :colspan=\"attributesSubsetLength(layer.attributes)+2\">\n                    <div class=\"action-buttons-container\">\n                      <template v-for=\"action in state.layersactions[layer.id]\">\n                        <div @click=\"trigger(action.id,layer,feature)\"  class=\"action-button hint--top-right\" data-placement=\"auto bottom\" data-toggle=\"tooltip\" :title=\"action.hint\">\n                          <span :class=\"'action-button-icon ' + action.class\"></span>\n                        </div>\n                      </template>\n                    </div>\n                    <table>\n                      <tr v-for=\"attribute in layer.attributes\">\n                        <td class=\"attr-label\">{{attribute.label}}</td>\n                        <!--<td class=\"attr-value\">{{feature.attributes[attribute.name]}}</td>-->\n                        <td class=\"attr-value\">\n                          <span v-if=\"is('simple',layer,attribute.name,feature.attributes[attribute.name])\">{{feature.attributes[attribute.name]}}</span>\n                          <img v-if=\"is('photo',layer,attribute.name,feature.attributes[attribute.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(feature.attributes[attribute.name]))\" :src=\"isRelativePath(feature.attributes[attribute.name])\">\n                          <!--<span v-if=\"isRoute(layer,feature,attribute)\" class=\"link dashboardlink\" @click=\"goto(layer,feature.attributes[attribute.name])\">{{ feature.attributes[attribute.name] }}</span>-->\n                          <!--<img v-if=\"isPhoto(layer,feature,attribute)\" :data-url=\"getPhotoUrl(feature.attributes[attribute.name])\" style=\"max-width:50px\" :src=\"getPhotoUrl(feature.attributes[attribute.name],thumb)\" />-->\n                          <img v-else-if=\"checkField('image', attribute.label, layer.attributes)\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(attribute.value))\" :src=\"isRelativePath(attribute.value)\">\n                          <a v-if=\"is('link',layer,attribute.name,feature.attributes[attribute.name])\" :href=\"feature.attributes[attribute.name]\" target=\"_blank\" class=\"glyphicon glyphicon-link\"></a>\n                        </td>\n                      </tr>\n                    </table>\n                  </td>\n                </tr>\n                <tr v-show=\"collapsedFeatureBox(layer,feature) && feature.attributes.relations\">\n                  <td :colspan=\"attributesSubsetLength(layer.attributes)+2\">\n                    <!--Relazioni-->\n                    <div class=\"queryresults-container\">\n                      <ul class=\"queryresults\" id=\"relations\">\n                        <template v-for=\"relation in feature.attributes.relations\">\n                          <li>\n                            <div class=\"box box-solid box-default relationsbox collapsed-box\">\n                              <div class=\"box-header with-border\" data-widget=\"collapse\">\n                                <h3 class=\"box-title\">{{ relation.name }} ({{ relation.elements.length }})</h3>\n                                <div class=\"box-tools pull-right\">\n                                  <button class=\"btn btn-box-tool\" data-widget=\"collapse\"><i class=\"btn-collapser fa fa-plus\"></i></button>\n                                </div>\n                              </div>\n                              <div class=\"box-body\">\n                                <template v-for=\"(element, index) in relation.elements\">\n                                  <table class=\"table table-striped\">\n                                    <thead>\n                                    <tr>\n                                      <th v-for=\"attribute in relationsAttributesSubset(element)\">\n                                        {{attribute.label}}\n                                      </th>\n                                      <th></th>\n                                    </tr>\n                                    </thead>\n                                    <tbody>\n                                    <tr @click=\"toggleFeatureBox(layer, feature, relation.name+index)\"  class=\"featurebox-header\">\n                                      <td v-for=\"attribute in relationsAttributesSubset(element)\">\n                                        <span>{{attribute.value}}</span>\n                                      </td>\n                                      <td class=\"action-cell text-center\">\n                                        <span class=\"fa link morelink\" :class=\"[collapsedFeatureBox(layer, feature, relation.name+index) ? 'fa-minus' : 'fa-plus']\" style=\"text-align: right\"></span>\n                                      </td>\n                                    </tr>\n                                    <tr v-show=\"collapsedFeatureBox(layer, feature, relation.name+index)\" class=\"featurebox-body\">\n                                      <td :colspan=\"relationsAttributesSubsetLength(element)+1\">\n                                        <table>\n                                          <tr v-for=\"relattribute in relationsAttributes(element)\">\n                                            <td class=\"attr-label\">{{relattribute.label}}</td>\n                                            <!--<td class=\"attr-value\">{{attribute.value}}</td>-->\n                                            <td class=\"attr-value\">\n                                              <div v-if=\"isArray(relattribute.value)\" v-for=\"value in relattribute.value\">\n                                                <div v-for=\"value, label in value\">\n                                                  <span>{{ label }}</span><span class=\"pull-right\">{{ value }}</span>\n                                                </div>\n                                                <span class=\"divider\"></span>\n                                              </div>\n                                              <span v-if=\"isSimple(layer,relattribute.name, relattribute.value)\">{{relattribute.value}}</span>\n                                              <!--<img v-if=\"is('photo',layer,relattribute.name,feature.attributes[attribute.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(feature.attributes[attribute.name]))\" :src=\"isRelativePath(feature.attributes[attribute.name])\">-->\n                                              <!--<img v-if=\"relattribute.label == 'image'\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">-->\n                                              <img v-else-if=\"checkField('image', relattribute.label, layer.relationsattributes[relation.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">\n                                              <img v-else-if=\"is('photo',layer, relattribute.name, relattribute.value)\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">\n                                              <!--&lt;!&ndash;<span v-if=\"isRoute(layer,feature,attribute)\" class=\"link dashboardlink\" @click=\"goto(layer,feature.attributes[attribute.name])\">{{ feature.attributes[attribute.name] }}</span>&ndash;&gt;-->\n                                              <!--<img v-if=\"isPhoto(layer,feature,attribute)\" v-bind:data-url=\"getPhotoUrl(feature.attributes[attribute.name])\" style=\"max-width:50px\" :src=\"getPhotoUrl(feature.attributes[attribute.name],thumb)\" />-->\n                                              <a v-if=\"isLink(layer,relattribute.name, relattribute.value)\" :href=\"relattribute.value\" target=\"_blank\" class=\"glyphicon glyphicon-link\"></a>\n                                            </td>\n                                          </tr>\n                                        </table>\n                                      </td>\n                                    </tr>\n                                    </tbody>\n                                  </table>\n                                </template>\n                              </div>\n                            </div>\n                          </li>\n                        </template>\n                      </ul>\n                    </div>\n                    <!--Fine Relazioni-->\n                  </td>\n                </tr>\n              </template>\n              </tbody>\n            </table>\n          </div>\n        </div>\n      </li>\n    </ul>\n  </div>\n  <span v-if=\"!hasResults() && !state.loading\">Nessun risultato</span>\n</div>\n\n";

},{}],140:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var QueryResultsService = require('gui/queryresults/queryresultsservice');
var ProjectsRegistry = require('core/project/projectsregistry');

Fields = {};
Fields.SIMPLE = 'simple';
Fields.LINK = 'link';
Fields.PHOTO = 'photo';
Fields.IMAGE = 'image';
Fields.POINTLINK = 'pointlink';
Fields.ROUTE = 'route';

function getFieldType(layer, name, value) {

  var URLPattern = /^(https?:\/\/[^\s]+)/g;
  var PhotoPattern = /[^\s]+.(png|jpg|jpeg)$/g;
  if (_.isNil(value)) {
    return Fields.SIMPLE;
  }
  value = value.toString();

  var extension = value.split('.').pop();
  if (value.match(PhotoPattern)) {
    return Fields.PHOTO;
  }

  if (value.match(URLPattern)) {
    return Fields.LINK;
  }

  return Fields.SIMPLE;
}

function fieldIs(TYPE,layer,attributeName,attributeValue) {
  var fieldType = getFieldType(layer,attributeName,attributeValue);
  return fieldType === TYPE;
}

var maxSubsetLength = 3;
var headerExpandActionCellWidth = 10;
var headerActionsCellWidth = 10;

var vueComponentOptions = {
  template: require('./queryresults.html'),
  data: function() {
    return {
      state: this.$options.queryResultsService.state,
      layersFeaturesBoxes: {},
      headerExpandActionCellWidth: headerExpandActionCellWidth,
      headerActionsCellWidth: headerActionsCellWidth
    }
  },
  methods: {
    isArray: function (value) {
      return _.isArray(value);
    },
    isSimple: function(layer,attributeName,attributeValue) {
      return !this.isArray(attributeValue) && fieldIs(Fields.SIMPLE,layer,attributeName,attributeValue);
    },
    isLink: function(layer,attributeName,attributeValue) {
      return fieldIs(Fields.LINK,layer,attributeName,attributeValue);
    },
    is: function(type,layer,attributeName,attributeValue) {
      return fieldIs(type,layer,attributeName,attributeValue);
    },
    checkField: function(type, fieldname, attributes) {
      var isType = false;
      _.forEach(attributes, function(attribute) {
        if (attribute.name == fieldname) {
          isType = attribute.type == type;
        }
      });

      return isType;
    },
    isRelativePath: function(url) {
      if (!_.startsWith(url,'/')) {
        return ProjectsRegistry.getConfig().mediaurl + url
      }
      return url
    },
    layerHasFeatures: function(layer) {
      if (layer.features) {
        return layer.features.length > 0;
      }
      return false;
    },
    hasResults: function() {
      return this.state.layers.length;
    },
    layerHasActions: function(layer) {
      return this.state.layersactions[layer.id].length > 0;
    },
    featureHasActions: function(layer,feature) {
      return this.geometryAvailable(feature);
    },
    /*getLayerActions: function(layer) {
     return this.$options.queryResultsService.getLayerActions(layer);
     },*/
    geometryAvailable: function(feature) {
      return feature.geometry ? true : false;
    },
    attributesSubset: function(attributes) {
      // faccio un filtro sul campo immagine perchè non ha senso far vedere
      // la stringa con il path dell'immagine
      var attributes = _.filter(attributes, function(attribute) {
        return attribute.type != 'image';
      });
      var end = Math.min(maxSubsetLength, attributes.length);
      return attributes.slice(0, end);
    },
    relationsAttributesSubset: function(relationAttributes) {
      var attributes = [];

      _.forEach(relationAttributes, function (value, attribute) {
        if (_.isArray(value)) return;
        attributes.push({label: attribute, value: value})
      });
      var end = Math.min(maxSubsetLength, attributes.length);
      return attributes.slice(0, end);
    },
    relationsAttributes: function(relationAttributes) {
      var attributes = [];
      _.forEach(relationAttributes, function (value, attribute) {
        attributes.push({label: attribute, value: value})
      });
      return attributes;
    },
    attributesSubsetLength: function(attributes) {
      return this.attributesSubset(attributes).length;
    },
    cellWidth: function(index,layer) {
      var subsetLength = this.attributesSubsetLength(layer.attributes);
      var diff = maxSubsetLength - subsetLength;
      actionsCellWidth = layer.hasgeometry ? headerActionsCellWidth : 0;
      var headerAttributeCellTotalWidth = 100 - headerExpandActionCellWidth - actionsCellWidth;
      var baseCellWidth = headerAttributeCellTotalWidth / maxSubsetLength;
      if ((index == subsetLength-1) && diff>0) {
        return baseCellWidth * (diff+1);
      }
      else {
        return baseCellWidth;
      }
    },
    featureBoxColspan: function(layer) {
      var colspan = this.attributesSubsetLength(layer.attributes);
      if (layer.expandable) {
        colspan += 1;
      }
      if (layer.hasgeometry) {
        colspan += 1;
      }
      return colspan;
    },
    relationsAttributesSubsetLength: function(elements) {
      return this.relationsAttributesSubset(elements).length;
    },
    collapsedFeatureBox: function(layer, feature, relation_index) {
      var collapsed = true;
      var boxid;
      if (!_.isNil(relation_index)) {
        boxid = layer.id + '_' + feature.id+ '_' + relation_index;
      } else {
        boxid = layer.id + '_' + feature.id;
      }
      if (this.layersFeaturesBoxes[boxid]) {
        collapsed = this.layersFeaturesBoxes[boxid].collapsed;
      }
      return collapsed;
    },
    toggleFeatureBox: function(layer, feature, relation_index) {
      var boxid;
      if (!_.isNil(relation_index)) {
        boxid = layer.id + '_' + feature.id+ '_' + relation_index;
      } else {
        boxid = layer.id + '_' + feature.id;
      }
      this.layersFeaturesBoxes[boxid].collapsed = !this.layersFeaturesBoxes[boxid].collapsed;
    },
    toggleFeatureBoxAndZoom: function(layer, feature, relation_index) {;
      // Disattivo zoom to sul toggle della featurebox. Casomai lo ripristineremo quando sarà gestito tramite qualche setting
      /*if (this.collapsedFeatureBox(layer, feature, relation_index)) {
       this.trigger('gotogeometry',layer,feature)
       }*/
      this.toggleFeatureBox(layer, feature, relation_index);
    },
    trigger: function(action,layer,feature) {
      this.$options.queryResultsService.trigger(action,layer,feature);
    },
    showFullPhoto: function(url) {
      this.$options.queryResultsService.showFullPhoto(url);
    }
  },
  watch: {
    // i listeners del queryResultsService.postRender
    // potrebbero avere bisogno di modificare il DOM dopo che sono cambiati
    // (per qualsiasi motivo) i dati e quindi Vue rirenderizza il DOM
    'state.layers': function(layers) {
      var self = this;
      if (layers.length) {
        this.$nextTick(function() {
          self.$options.queryResultsService.postRender(self.$el);
        })
      }
    }
  },
  mounted: function() {
    Vue.nextTick(function() {
      // vado a settare i tooltip
      $('[data-toggle="tooltip"]').tooltip();
    })
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);

function QueryResultsComponent(options) {
  base(this, options);
  var self = this;
  this.id = "queryresults";
  this.title = "Query Results";
  this._service = new QueryResultsService();
  //usato quando è stato distrutto
  this.setInternalComponent = function() {
    this.internalComponent = new InternalComponent({
      queryResultsService: this._service
    });
    this.createLayersFeaturesBoxes();
    this.internalComponent.querytitle = this._service.state.querytitle;
  };

  this.getElement = function() {
    if (this.internalComponent) {
      return this.internalComponent.$el;
    }
  };

  this._service.onafter('setLayersData',function() {
    if (!self.internalComponent) {
      self.setInternalComponent();
    }
    self.createLayersFeaturesBoxes();
  });

  merge(this, options);

  this.createLayersFeaturesBoxes = function() {
    var layersFeaturesBoxes = {};
    var layers = this._service.state.layers;
    _.forEach(layers, function(layer) {
      //da rivedere meglio
      if (layer.attributes.length <= maxSubsetLength && !layer.hasImageField) {
        layer.expandable = false;
      }
      _.forEach(layer.features, function(feature, index) {
        // se è la prima feature e il layer ha più di maxSubsetLength attributi, allora la espando già in apertura
        //var collapsed = (index == 0 && layer.attributes.length > maxSubsetLength) ? false : true;
        var collapsed = true;
        var boxid = layer.id+'_'+feature.id;
        layersFeaturesBoxes[boxid] = {
          collapsed: collapsed
        };
        if (feature.attributes.relations) {
          boxid = '';
          _.forEach(feature.attributes.relations, function(relation) {
            boxid = layer.id + '_' + feature.id + '_' + relation.name;
            _.forEach(relation.elements, function(element, index){
              layersFeaturesBoxes[boxid+index] = {
                collapsed: true
              };
            });
          })
        }
      })
    });
    this.internalComponent.layersFeaturesBoxes = layersFeaturesBoxes;
  };
  // sovracrive il metodo pader mount del component
  /*this.mount = function(parent, append) {
    var self = this;
    // richiama il mont padre
    return base(this, 'mount', parent, append)
  };*/

  this.layout = function(width,height) {
    //TODO
  }
}
inherit(QueryResultsComponent, Component);

module.exports = QueryResultsComponent;
},{"./queryresults.html":139,"core/project/projectsregistry":67,"core/utils/utils":71,"gui/queryresults/queryresultsservice":138,"gui/vue/component":152}],141:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var ProjectsRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');
var SearchPanel = require('gui/search/vue/panel/searchpanel');

function SearchesService(){

  this.init = function(searchesObject) {
    var searches = searchesObject || ProjectsRegistry.getCurrentProject().state.search;
    this.state.searches = searches;
  };
  this.state = {
    searches: []
  };
  this.showSearchPanel = function(panelConfig) {
    var panel =  new SearchPanel();// creo panello search
    panel.init(panelConfig);//inizializzo pannello se
    GUI.showPanel(panel);
    return panel;
  };

  this.cleanSearchPanels = function() {
    this.state.panels = {};
  };

  this.stop = function(){
    var deferred = $.Deferred();
    deferred.resolve();
    return deferred.promise();
  };

  this.reload = function() {
    var searches = ProjectsRegistry.getCurrentProject().state.search;
    Vue.set(this.state, 'searches', searches);
  }
}

// Make the public service en Event Emitter
inherit(SearchesService, G3WObject);

module.exports = SearchesService;

},{"core/g3wobject":27,"core/project/projectsregistry":67,"core/utils/utils":71,"gui/gui":114,"gui/search/vue/panel/searchpanel":143}],142:[function(require,module,exports){
module.exports = "<div class=\"g3w-search-panel form-group\">\n  <h4><b>{{ title }}</b></h4>\n  <form id=\"g3w-search-form\">\n    <template v-for=\"(forminput, index) in forminputs\">\n      <div v-if=\"forminput.input.type == 'numberfield'\" class=\"form-group numeric\">\n        <label :for=\"forminput.id + ' '\">{{ forminput.label }}</label>\n        <input type=\"number\" v-model=\"formInputValues[index].value\" class=\"form-control\" :id=\"forminput.id\">\n      </div>\n      <div v-if=\"forminput.input.type == 'textfield' || forminput.input.type == 'textField'\" class=\"form-group text\">\n        <label :for=\"forminput.id\">{{ forminput.label }}</label>\n        <input type=\"text\" v-model=\"formInputValues[index].value\" class=\"form-control\" :id=\"forminput.id\">\n      </div>\n    </template>\n    <div class=\"form-group\">\n      <button style=\"background-color:#3c8dbc\" class=\"btn btn-block pull-right\" @click=\"doSearch($event)\" data-i18n=\"dosearch\">Search</button>\n    </div>\n  </form>\n</div>\n";

},{}],143:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var localize = require('core/i18n/i18n.service').t;
var resolve = require('core/utils/utils').resolve;
var GUI = require('gui/gui');
var QueryService = require('core/query/queryservice');
var ListPanel = require('gui/listpanel').ListPanel;
var Panel = require('gui/panel');
var ProjectsRegistry = require('core/project/projectsregistry');

//componente vue pannello search
var SearchPanelComponet = Vue.extend({
  template: require('./searchpanel.html'),
  data: function() {
    return {
      title: "",
      forminputs: [],
      filterObject: {},
      formInputValues : [],
      queryurl: null
    }
  },
  methods: {
    doSearch: function(event) {
      var self = this;
      event.preventDefault();
      //al momento molto farragginoso ma da rivedere
      //per associazione valore input
      this.filterObject = this.fillFilterInputsWithValues(this.filterObject, this.formInputValues);
      // forzo il cambiamento dell'url se esiste il query url
      if (this.queryurl) {
        this.filterObject.url = this.queryurl;
      }
      var showQueryResults = GUI.showContentFactory('query');
      var queryResultsPanel = showQueryResults(self.title);
      QueryService.queryByFilter([this.filterObject])
      .then(function(results) {
         queryResultsPanel.setQueryResponse(results);
      })
      .fail(function() {
        GUI.notify.error('Si è verificato un errore nella richiesta al server');
        GUI.closeContent();
      })
    }
  }
});

//costruttore del pannello e del suo componente vue
function SearchPanel(options) {
  self = this;
  var options = options || {};
  this.config = {};
  this.filter = {};
  this.id = null;
  this.querylayerid = null;
  this.internalPanel = options.internalPanel || new SearchPanelComponet();
  //funzione inizializzazione
  this.init = function(config) {
    this.config = config || {};
    this.name = this.config.name || this.name;
    this.id = this.config.id || this.id;
    // rpendo il filtro restituito dal server
    this.filter = this.config.options.filter || this.filter;
    this.internalPanel.queryurl = this.config.options.queryurl || null;
    var queryLayerId = this.config.options.querylayerid || this.querylayerid;
    // recupero il query layer dall'id della configurazione
    this.queryLayer = ProjectsRegistry.getCurrentProject().getLayersStore().getLayerById(queryLayerId);
    //vado a riempire gli input del form del pannello con campo e valore
    this.fillInputsFormFromFilter();
    //creo e assegno l'oggetto filtro
    var filterObjFromConfig = QueryService.createQueryFilterFromConfig(this.filter);
    //alla fine creo l'ggetto finale del filtro da passare poi al provider QGISWMS o WFS etc.. che contiene sia
    //il filtro che url, il nome del layer il tipo di server etc ..
    this.internalPanel.filterObject = QueryService.createQueryFilterObject({
      queryLayers: [this.queryLayer],
      filter: filterObjFromConfig
    });
    // da migliorare
    this.internalPanel.filterObject = this.internalPanel.filterObject[0];
    //soluzione momentanea assegno  la funzione del SearchPanle ma come pattern è sbagliato
    //vorrei delegarlo a SearchesService ma lo stesso stanzia questo (loop) come uscirne???
    //creare un searchpanelservice?
    this.internalPanel.fillFilterInputsWithValues = this.fillFilterInputsWithValues;
    this.internalPanel.title = this.name;
  };
  //funzione che popola gli inputs che ci saranno nel form del pannello ricerca
  //oltre costruire un oggetto che legherà i valori degli inputs del form con gli oggetti
  //'operazionali' del filtro
  this.fillInputsFormFromFilter = function() {
    var id = 0;
    var formValue;
    _.forEach(this.filter,function(v,k,obj) {
      _.forEach(v, function(input){
        //sempre nuovo oggetto
        formValue = {};
        //inserisco l'id all'input
        input.id = id;
        //aggiungo il tipo al valore per fare conversione da stringa a tipo input
        formValue.type = input.input.type;
        ////TEMPORANEO !!! DEVO PRENDERE IL VERO VALORE DI DEFAULT
        formValue.value = null;
        //popolo gli inputs:
        // valori
        self.internalPanel.formInputValues.push(formValue);
        //input
        self.internalPanel.forminputs.push(input);
        id+=1;
      });
    });
  };
  //funzione che associa i valori dell'inputs form al relativo oggetto "operazionde del filtro"
  this.fillFilterInputsWithValues = function(filterObject, formInputValues, globalIndex) {
    //funzione conversione da valore restituito dall'input (sempre stringa) al vero tipo di valore
    function convertInputValueToInputType(type, value) {
      switch(type) {
        case 'numberfield':
             value = parseInt(value);
             break;
        default:
             break;
      }
      return value;
    }
    //ciclo sull'oggetto filtro che ha come chiave root 'AND' o 'OR'
    _.forEach(filterObject.filter, function(v,k) {
      //scorro attraverso l'array di elementi operazionali da confrontare
      _.forEach(v, function(input, idx) {
        //elemento operazionale {'=':{}}
        _.forEach(input, function(v, k, obj) {
          //vado a leggere l'oggetto attributo
          if (_.isArray(v)) {
            //richiama la funzione ricorsivamente .. andrà bene ?
            fillFilterInputsWithValues(input, formInputValues, idx);
          } else {
            _.forEach(v, function(v, k, obj) {
              //considero l'index globale in modo che inputs di operazioni booleane interne
              //vengono considerate
              index = (globalIndex) ? globalIndex + idx : idx;
              obj[k] = convertInputValueToInputType(formInputValues[index].type, formInputValues[index].value);
            });
          }
        });
      });
    });
    return filterObject;
  };
}

inherit(SearchPanel, Panel);

module.exports = SearchPanel;

},{"./searchpanel.html":142,"core/i18n/i18n.service":30,"core/project/projectsregistry":67,"core/query/queryservice":68,"core/utils/utils":71,"gui/gui":114,"gui/listpanel":116,"gui/panel":123}],144:[function(require,module,exports){
module.exports = "<ul id=\"g3w-search\" class=\"treeview-menu g3w-search g3w-tools menu-items\">\n  <li v-for=\"search in state.searches\" class=\"menu-item\" @click=\"showSearchPanel(search)\">\n    <i class=\"fa fa-circle-o\"></i>\n    <span>{{ search.name }}</span>\n  </li>\n</ul>\n";

},{}],145:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ProjectsRegistry = require('core/project/projectsregistry');
var SearchesService = require('gui/search/searchesservice');

var vueComponentOptions = {
   template: require('./search.html'),
   data: function() {
    	return {
    	  state: null
    	};
   },
   methods: {
    showSearchPanel: function(search) {
        this.$options.searchesService.showSearchPanel(search);
    }
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);
// se lo voglio usare come componente come elemento html

/* COMPONENTI FIGLI */
/* FINE COMPONENTI FIGLI */

/* INTERFACCIA PUBBLICA */
function SearchComponent(options){
  base(this,options);
  this.id = "search-component";
  this.title = "search";
  this._service = new SearchesService();
  this.internalComponent = new InternalComponent({
    searchesService: this._service
  });
  this.internalComponent.state = this._service.state;
  this.state.visible = ProjectsRegistry.getCurrentProject().state.search.length > 0;
  merge(this, options);
  this.initService = function() {
    //inizializzo il servizio
    this._service.init();
  };

  this._reload = function() {
    this.state.visible = ProjectsRegistry.getCurrentProject().state.search.length > 0;
    this._service.reload();
  }
}

inherit(SearchComponent, Component);
module.exports = SearchComponent;

},{"./search.html":144,"core/project/projectsregistry":67,"core/utils/utils":71,"gui/search/searchesservice":141,"gui/vue/component":152}],146:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var StreetViewComponent = require('gui/streetview/vue/streetview');

function StreetViewService() {
  this._position = null;
  this.setters = {
    postRender: function(position) {
      //hook postrender
    }
  };

  this.getPosition = function() {
    return this._position;
  };

  this.showStreetView = function(position) {
    this._position = position;
    GUI.setContent({
      content: new StreetViewComponent({
        service: this
      }),
      title: 'StreetView'
    });
  };
  base(this);
}

inherit(StreetViewService, G3WObject);

module.exports = StreetViewService;

},{"core/g3wobject":27,"core/utils/utils":71,"gui/gui":114,"gui/streetview/vue/streetview":148}],147:[function(require,module,exports){
module.exports = "<div id=\"streetview\"></div>";

},{}],148:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');

var InternalComponent = Vue.extend({
  template: require('./streetview.html'),
  data: function() {
    return {
      state: null
    }
  },
  mounted: function() {
    var self = this;
    this.$nextTick(function() {
      var position = self.$options.service.getPosition();
      self.$options.service.postRender(position);
    });
  }
});

var StreetViewComponent = function(options) {
  base(this);
  var options = options || {};
  var service = options.service;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service
  });
  this.setInternalComponent(internalComponent);
  this.unmount = function() {
    return base(this, 'unmount');
  }
};

inherit(StreetViewComponent, Component);


module.exports = StreetViewComponent;



},{"./streetview.html":147,"core/utils/utils":71,"gui/vue/component":152}],149:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function ToolsService(){
  var self = this;
  this.config = null;
  this._actions = {};
  this.state = {
    toolsGroups: []
  };
  this.setters = {
    addTools: function(order, groupName, tools) {
      self._addTools(order, groupName, tools);
    },
    addToolGroup: function(order, group) {
      self.state.toolsGroups.splice(order, 0, group);
    },
    removeTools:function() {
      self._removeTools();
    }
  };
  
  this._addTools = function(order, groupName, tools) {
    var self = this;
    var group = this._getToolsGroup(groupName);
    if (!group) {
      group = {
        name: groupName,
        tools: []
      };
      this.addToolGroup(order, group);
    }
    _.forEach(tools, function(tool){
      group.tools.push(tool);
      self._addAction(tool);
    });
  };

  this._removeTool = function(toolIdx) {
    this.state.toolsGroups = this.state.toolsGroups.splice(toolIdx, 1);
  };

  this._removeTools = function() {
    var self = this;
    _.forEach(this.state.toolsGroups, function(toolGroup, toolIdx) {
      self.state.toolsGroups.splice(0,1);
    })
  };

  this.updateToolsGroup = function(order, groupConfig) {
    Vue.set(this.state.toolsGroups, order, groupConfig);
  };

  this.getState = function() {
    return this.state;
  };

  this.fireAction = function(actionId){
    var action = this._actions[actionId];
    action();
  };

  this._getToolsGroup = function(groupName) {
    var group = null;
    _.forEach(this.state.toolsGroups,function(_group){
      if (_group.name == groupName) {
        group = _group;
      }
    });
    return group;
  };

  this._addAction = function(tool) {
    var actionId = Math.floor(Math.random() * 1000000)+1;
    tool.actionId = actionId;
    this._actions[actionId] = tool.action;
  };

  base(this);
}

inherit(ToolsService, G3WObject);

module.exports = ToolsService;

},{"core/g3wobject":27,"core/utils/utils":71}],150:[function(require,module,exports){
module.exports = "<ul class=\"g3w-tools treeview-menu\">\n  <li v-for=\"group in state.toolsGroups\">\n    <div class=\"tool-header\">\n      <i class=\"fa fa-gear\"></i>\n      <span style=\"\">{{ group.name }}</span>\n    </div>\n    <div :id=\"group.name + '-tools'\" class=\"tool-box\">\n      <template v-for=\"tool in group.tools\">\n        <div v-if=\"tool.type == 'checkbox' \" class=\"checkbox\">\n          <label>\n            <input style=\"cursor:pointer\" :id=\"tool.layerName\" v-model=\"tool.isCheck\" type=\"checkbox\" :value=\"tool.layerName\" @click=\"fireAction(tool.actionId)\">{{ tool.name }}\n          </label>\n        </div>\n        <div v-else class=\"tool\" @click=\"fireAction(tool.actionId)\">\n          <i class=\"fa fa-caret-right\"></i>\n          <span >{{ tool.name }}</span>\n        </div>\n      </template>\n    </div>\n  </li>\n</ul>\n\n";

},{}],151:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ToolsService = require('gui/tools/toolsservice');

var InternalComponent = Vue.extend({
  template: require('./tools.html'),
  data: function() {
    return {
      state: null
    }
  },
  methods: {
    fireAction: function(actionId) {
      this.$options.toolsService.fireAction(actionId);
    }
  }
});

function ToolsComponent(options) {

  base(this,options);
  var self = this;
  this._service = new ToolsService();
  this.id = "tools-component";
  this.title = "tools";
  this.state.visible = false;

  // vado a settare l'onafter nel caso di un add tools che di un remove tool
  this._service.onafter('addTools', function() {
    self.state.visible = self._service.state.toolsGroups.length > 0;
  });
  this._service.onafter('removeTools', function() {
    self.state.visible = self._service.state.toolsGroups.length > 0;
  });
  /* ----------------------*/
  merge(this, options);
  this.internalComponent = new InternalComponent({
    toolsService: this._service
  });
  //sostituisco lo state del servizio allo state del componente vue interno
  this.internalComponent.state = this._service.state;
}

inherit(ToolsComponent, Component);

var proto = ToolsComponent.prototype;

module.exports = ToolsComponent;

},{"./tools.html":150,"core/i18n/i18n.service":30,"core/utils/utils":71,"gui/tools/toolsservice":149,"gui/vue/component":152}],152:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var resolve = require('core/utils/utils').resolve;
var BaseComponent = require('gui/component');
// classe componente
var Component = function(options) {
  base(this, options);
};
// eredita le caratteristiche del componente base
inherit(Component, BaseComponent);

//prototype
var proto = Component.prototype;
// viene richiamato dalla toolbar o da qualsiasi parte per montare il componente vue su un particolare elemento dom padre
// quando il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
proto.mount = function(parent, append) {
  var self = this;
  var d = $.Deferred();
  // verifica che sia stato settato il componente interno
  if (!this.internalComponent) {
    this.setInternalComponent();
  }
  // verifica se è in append o no
  if (append) {
    var iCinstance = this.internalComponent.$mount();
    $(parent).append(iCinstance.$el);
  }
  else {
    this.internalComponent.$mount(parent);
  }
  //return resolve(true);
  Vue.nextTick(function(){
    $(parent).localize();
    // risolve la promessa
    d.resolve(true);
  });
  return d.promise();
};
// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso
proto.unmount = function() {
  // il problema che distruggere
  if (_.isNil(this.internalComponent)) {
    var a = 1;
    return resolve();
  }
  this.internalComponent.$destroy(true);
  $(this.internalComponent.$el).remove();
  // lo setta di nuovo a null
  this.internalComponent = null;
  return resolve();
};
// funzione che verifica se il componente interno è montato
proto.ismount = function() {
  return this.internalComponent && this.internalComponent.$el;
};

proto.layout = function(width,height) {
  if (this.internalComponent) {
    //this.internalComponent.$broadcast('layout');
  }
};
module.exports = Component;

},{"core/utils/utils":71,"gui/component":109}],153:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;

Vue.directive("disabled",function(el, binding){
    if (binding.value){
      el.setAttribute('disabled','disabled');
    }
    else {
      el.removeAttribute('disabled');
    }
  }
);

Vue.directive("checked",function(el, binding){
    if (binding.value){
      el.setAttribute('checked','checked');
    }
    else {
      el.removeAttribute('checked');
    }
  }
);

Vue.directive("selected-first",function(el, binding){
    if (binding.value==0){
      el.setAttribute('selected','');
    }
    else {
      el.removeAttribute('selected');
    }
  }
);

Vue.directive("t",function(el, binding){
  return t(binding.value);
});

},{"core/i18n/i18n.service":30}],154:[function(require,module,exports){
var g3w = g3w || {};

g3w.core = {
  G3WObject: require('core/g3wobject'),
  utils: require('core/utils/utils'),
  ApplicationService: require('core/applicationservice'),
  ApiService: require('core/apiservice'),
  Router: require('core/router'),
  i18n: require('core/i18n/i18n.service'),
  editing: {
    Session: require('core/editing/session'),
    Editor: require('core/editing/editor')
  },
  geometry: {
    Geom: require('core/geometry/geom'),
    Geometry: require('core/geometry/geometry')
  },
  project: {
    ProjectsRegistry: require('core/project/projectsregistry'),
    Project: require('core/project/project')
  },
  map: {
    MapLayersStoreRegistry: require('core/map/maplayersstoresregistry'),
    layer: {
      WmsLayer: require('core/map/layer/wmslayer'),
      VectorLayerLoader: require('core/map/layer/loader/vectorloaderlayer'),
    }
  },
  catalog: {
    CatalogLayersStoresRegistry: require('core/catalog/cataloglayersstoresregistry')
  },
  layer: {
    LayersStoreRegistry: require('core/layers/layersstoresregistry'), //nel caso un plugin volesse instanziare un layersstoreregistry proprio
    LayersStore: require('core/layers/layersstore'),
    Layer: require('core/layers/layer'),
    LayerFactory: require('core/layers/layerfactory'),
    TableLayer: require('core/layers/tablelayer'),
    VectorLayer: require('core/layers/vectorlayer'),
    ImageLayer: require('core/layers/imagelayer'),
    geometry: {
      Geometry: require('core/geometry/geometry'),
      geom: require('core/geometry/geom')
    },
    MapLayer: require('core/map/layer/maplayer')
  },
  query: {
    QueryService: require('core/query/queryservice')
  },
  interaction: {
    PickCoordinatesInteraction: require('g3w-ol3/src/interactions/pickcoordinatesinteraction'),
    PickFeatureInteraction: require('g3w-ol3/src/interactions/pickfeatureinteraction')
  },
  plugin: {
    Plugin: require('core/plugin/plugin'),
    PluginsRegistry: require('core/plugin/pluginsregistry'),
    PluginService: require('core/plugin/pluginservice')
  },
  workflow: {
    Step: require('core/workflow/step'),
    Workflow: require('core/workflow/workflow')
  }
};

g3w.gui = {
  GUI: require('gui/gui'),
  Panel: require('gui/panel'),
  ControlFactory: require('gui/map/control/factory'),
  vue: {
    Component: require('gui/vue/component'),
    SearchComponent: require('gui/search/vue/search'),
    SearchPanel: require('gui/search/vue/panel/searchpanel'),
    PrintComponent: require('gui/print/vue/print'),
    CatalogComponent: require('gui/catalog/vue/catalog'),
    MapComponent: require('gui/map/vue/map'),
    ToolsComponent: require('gui/tools/vue/tools'),
    QueryResultsComponent : require('gui/queryresults/vue/queryresults'),
    FormComponent: require('gui/form/vue/form')
  }
};

g3w.ol3 = {
  interactions : {
    PickFeatureInteraction : require('g3w-ol3/src/interactions/pickfeatureinteraction'),
    PickCoordsInteraction: require('g3w-ol3/src/interactions/pickcoordinatesinteraction'),
    DeleteFeatureInteraction: require('g3w-ol3/src/interactions/deletefeatureinteraction')
  },
  controls: {
  }
};

module.exports = {
  core: g3w.core,
  gui: g3w.gui,
  ol3: g3w.ol3
};

},{"core/apiservice":21,"core/applicationservice":22,"core/catalog/cataloglayersstoresregistry":23,"core/editing/editor":25,"core/editing/session":26,"core/g3wobject":27,"core/geometry/geom":28,"core/geometry/geometry":29,"core/i18n/i18n.service":30,"core/layers/imagelayer":36,"core/layers/layer":37,"core/layers/layerfactory":38,"core/layers/layersstore":39,"core/layers/layersstoresregistry":40,"core/layers/tablelayer":49,"core/layers/vectorlayer":50,"core/map/layer/loader/vectorloaderlayer":53,"core/map/layer/maplayer":54,"core/map/layer/wmslayer":57,"core/map/maplayersstoresregistry":59,"core/plugin/plugin":60,"core/plugin/pluginservice":61,"core/plugin/pluginsregistry":62,"core/project/project":66,"core/project/projectsregistry":67,"core/query/queryservice":68,"core/router":69,"core/utils/utils":71,"core/workflow/step":72,"core/workflow/workflow":73,"g3w-ol3/src/interactions/deletefeatureinteraction":91,"g3w-ol3/src/interactions/pickcoordinatesinteraction":94,"g3w-ol3/src/interactions/pickfeatureinteraction":95,"gui/catalog/vue/catalog":105,"gui/form/vue/form":112,"gui/gui":114,"gui/map/control/factory":117,"gui/map/vue/map":122,"gui/panel":123,"gui/print/vue/print":127,"gui/queryresults/vue/queryresults":140,"gui/search/vue/panel/searchpanel":143,"gui/search/vue/search":145,"gui/tools/vue/tools":151,"gui/vue/component":152}]},{},[3]);
