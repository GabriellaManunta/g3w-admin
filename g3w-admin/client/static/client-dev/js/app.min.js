(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var apptitle = "G3W Client";

var plugins = {
};

var tools = {
  tools:  []
};

var i18n = {
  resources: require('./locales/app.js')
};

var client =  {
  debug:  true,
  local:  false
};

var server =  {
  urls:  {
    baseurl: '/',
    ows:  'ows',
    api:  'api',
    initconfig:  'api/initconfig',
    config:  'api/config'
  }
};

module.exports = {
  apptitle: apptitle,
  client: client,
  server: server,
  plugins:  plugins,
  tools:  tools,
  i18n: i18n
};

},{"./locales/app.js":2}],2:[function(require,module,exports){
var translations = {
    "it": {
        "translation": {
            "component": "Componente Generico",
            "search": "Ricerche",
            "print": "Stampa",
            "dosearch": "Cerca",
            "catalog": "Mappa",
            "baselayers": "Basi",
            "tools": "Strumenti",
            "tree": "Strati",
            "legend": "Legenda",
            "street_search": "Cerca indirizzo",
            "show": "Mostra",
            "hide": "Nascondi",
            "street_search": "Cerca indirizzo",
            "copy_form_data": "Copia i dati del modulo",
            "paste_form_data": "Incolla",
            "copy_form_data_from_feature": "Copia i dati dalla mappa",
            "could_not_load_vector_layers": "Errore di connessione al server: non è stato possibile caricare i vettoriali richiesti"
        }
    }
};

module.exports = translations;

},{}],3:[function(require,module,exports){
var i18ninit = require('sdk').core.i18n.init;
// oggetto
var ApplicationService = require('sdk/sdk').core.ApplicationService;
// oggetto application template che si occupa di gestire il template dell'applicazione
var ApplicationTemplate = require('./template/js/template');
// configurazione dell'applicazione
var config = require('./config/config.js');
// SETTO LA VARIABILE GLOBALE g3wsdk, COME SE AVESSI USATO sdk.js
window.g3wsdk = require('sdk');
//imposto il timeout delle richieste ajax di jquery
// $.ajaxSetup({
//    timeout: 5000 // in milliseconds
// });
// inizilaizza l'internalizzazione
i18ninit(config.i18n);

// questa funzione che ala configurazione inizale dell'applicazione
// tutte le cose in comune
function createApplicationConfig() {
  return {
    apptitle: config.apptitle || '',
    logo_img: config.group.header_logo_img,
    logo_link: config.group.header_logo_link,
    terms_of_use_text: config.group.header_terms_of_use_text,
    terms_of_use_link: config.group.terms_of_use_link,
    debug: config.client.debug || false,
    group: config.group,
    urls: config.server.urls,
    mediaurl: config.server.urls.mediaurl,
    resourcesurl: config.server.urls.clienturl,
    projects: config.group.projects,
    initproject: config.group.initproject,
    overviewproject: (config.group.overviewproject && config.group.overviewproject.gid) ? config.group.overviewproject : null,
    baselayers: config.group.baselayers,
    mapcontrols: config.group.mapcontrols,
    background_color: config.group.background_color,
    crs: config.group.crs,
    proj4: config.group.proj4,
    minscale: config.group.minscale,
    maxscale: config.group.maxscale,
    // richiesto da ProjectService
    getWmsUrl: function(project){
      return config.server.urls.baseurl+config.server.urls.ows+'/'+config.group.id+'/'+project.type+'/'+project.id;
    },
    // richiesto da ProjectsRegistry per acquisire informazioni specifiche del progetto
    getProjectConfigUrl: function(project){
      return config.server.urls.baseurl+config.server.urls.config+'/'+config.group.id+'/'+project.type+'/'+project.id;
    },
    plugins: config.group.plugins,
    tools: config.tools,
    views: config.views || {},
    user: config.user || null
  };
}

// questa è la configurazione base del template che conterrà tutti gli
// elementi previsti dal template. Nella definizione sono tutti oggetti vuoti
// Sarà l'applicazione a scegliere di riempire gli elementi
function createTemplateConfig() {
  // recupero i componenti
  var CatalogComponent = require('sdk').gui.vue.CatalogComponent;
  var SearchComponent = require('sdk').gui.vue.SearchComponent;
  var PrintComponent = require('sdk').gui.vue.PrintComponent;
  var ToolsComponent = require('sdk').gui.vue.ToolsComponent;
  var MapComponent = require('sdk').gui.vue.MapComponent;
  var ContentsComponent = require('./template/js/contentsviewer');
  //al momento si utilizza quesllo quenerico ma si potrebbe costruire un componente
  //ad hoc per i risultati
  var QueryResultsComponent = require('sdk').gui.vue.QueryResultsComponent;
  return {
    title: config.apptitle,
    placeholders: {
      navbar: {
        components: []
      },
      sidebar: {
        components: [
          new PrintComponent({
            id: 'print',
            open: false,
            collapsible: true, //  i permette di capire se cliccandoci sopra posso lanciare il setOpen del componente
            icon: "fa fa-print"
          }),
          new SearchComponent({
            id: 'search',
            open: false,
            collapsible: true,
            icon: "fa fa-search"
          }),
          new CatalogComponent({
            id: 'catalog',
            open: false,
            collapsible: false,
            icon: "fa fa-map-o"
          }),
          // qui vanno i plugins sotto forma di tools
          new ToolsComponent({
            id: 'tools',
            open: false,
            collapsible: true,
            icon: "fa fa-gears"
          })
        ]
      },
      floatbar:{
        components: []
      }
    },
    othercomponents: [
      new QueryResultsComponent({
        id: 'queryresults'
      })
    ],
    viewport: {
      // placeholder del contenuto (view content) inizialmente Vista Secondaria (nascosta)
      components: {
        map: new MapComponent({
          id: 'map'
        }),
        content: new ContentsComponent({
          id: 'contents'
        })
      }
    }
  }
}

function sendErrorToApplicationTemplate(reloadFnc,error) {
  if (error && error.responseJSON && error.responseJSON.error.data) {
    error = error.responseJSON.error.data
  } else {
    error = 'Errore di connessione'
  }
  // stato un erore ne caricamento della configurazione del progetto
  // passo la stessa funzione di bootstrap
  ApplicationTemplate.fail(reloadFnc, error);
}

ApplicationService.on('ready', function() {
  //istanzio l'appication template passando la configurazione
  // del template e l'applicationService che fornisce API del progetto
  var templateConfig = createTemplateConfig();
  //istanzio l'application Template passando il templateconfig, l'applicationservice
  applicationTemplate = new ApplicationTemplate(templateConfig, this);
  //inizializzo e faccio partire con il metodo init
  applicationTemplate.init();
  // quando (dopo la chiamta e il setup del layout etc..) dell'application template
  // è ready lancio l'applicationTemplate service postBoostrat
  applicationTemplate.on('ready', function() {
    ApplicationService.postBootstrap();
  });
});

// funzione che viene lanciata al momento di caricare app.js
var bootstrap = function() {
  //ottengo al configurazione inizilae del gruppo di progetti
  // config.server.urls.initconfig: è l'api url a cui chiedere la configurazione iniziale
  ApplicationService.obtainInitConfig(config.server.urls.initconfig)
  .then(function(initConfig) {
    // una volta ottenuta la configurazione inziale
    // vado a scrivere gli url dei file statici e del media url
    config.server.urls.baseurl = initConfig.baseurl;
    config.server.urls.staticurl = initConfig.staticurl;
    config.server.urls.clienturl = initConfig.staticurl+initConfig.client;
    config.server.urls.mediaurl = initConfig.mediaurl;
    config.group = initConfig.group;
    config.user = initConfig.user;
    var applicationConfig = createApplicationConfig();
    // unavolta ottenuta la configurazione e settetat in modo digeribile all'applicazione
    // la vado a pssare al metodo init dell'application service
    ApplicationService.init(applicationConfig, true) // lancio manualmente il postBootstrp
      .then(function() {
        // andato tutto a buon fine
      })
      .fail(function(error) {
        sendErrorToApplicationTemplate(bootstrap, error);
      })
  })
  .fail(function(error) {
    sendErrorToApplicationTemplate(bootstrap, error);
  })
};

// lancio subito il bootstrap
bootstrap();


},{"./config/config.js":1,"./template/js/contentsviewer":13,"./template/js/template":19,"sdk":158,"sdk/sdk":158}],4:[function(require,module,exports){
module.exports = "<div class=\"wrapper\">\n  <header class=\"main-header\">\n    <!-- Logo -->\n    <!-- Header Navbar: style can be found in header.less -->\n    <nav class=\"navbar navbar-static-top\" role=\"navigation\">\n      <!-- Toggle button on navbar only for mobile -->\n      <a v-if=\"isMobile()\" href=\"#\" class=\"sidebar-toggle\" data-toggle=\"offcanvas\" role=\"button\">\n        <span class=\"sr-only\">Expand</span>\n      </a>\n      <div class=\"logo-wrapper\">\n        <a v-if=\"logo_url\" :href=\"logo_link\" :target=\"logo_link_target\" class=\"\"><img :src=\"logo_url\" style=\"height:40px\"></a>\n        <span class=\"\">{{project_title}}</span>\n      </div>\n      <div v-if=\"user\" class=\"navbar-custom-menu\">\n        <ul class=\"nav navbar-nav\">\n          <li class=\"dropdown user\" v-if=\"numberOfProjectsInGroup > 1\">\n            <a href=\"#\" @click=\"openProjectsMenu\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n              <i class=\"fa fa-th\" aria-hidden=\"true\"></i>\n              <span> Cambia Mappa</span>\n            </a>\n          </li>\n          <li class=\"dropdown user user-menu\">\n            <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n              <i class=\"fa fa-user\"></i>\n              <span class=\"hidden-xs\">{{ user.username }}</span>\n            </a>\n            <ul class=\"dropdown-menu\">\n              <li class=\"user-header\">\n                <p>\n                  {{ user.first_name }} {{ user.last_name }}\n                </p>\n              </li>\n              <li class=\"user-footer\">\n                <div class=\"pull-left\">\n                  <a :href=\"user.admin_url\" class=\"btn btn-default btn-flat\"><i class=\"fa fa-folder\"></i> Admin</a>\n                </div>\n                <div class=\"pull-right\">\n                  <a :href=\"user.logout_url\" class=\"btn btn-default btn-flat\"><i class=\"fa fa-sign-out\"></i>Sign out</a>\n                </div>\n              </li>\n            </ul>\n          </li>\n          <li class=\"dropdown user user-menu\">\n            <a href=\"#\" data-toggle=\"modal\" data-target=\"#credits\" class=\"dropdown-toggle\">\n              <span>Credits</span>\n            </a>\n          </li>\n        </ul>\n      </div>\n    </nav>\n  </header>\n  <!-- Left side column. contains the logo and sidebar -->\n  <sidebar></sidebar>\n  <!-- Content Wrapper. Contains page content -->\n  <div class=\"content-wrapper\" style=\"background-color:white\">\n    <viewport></viewport>\n  </div>\n  <!-- /.content-wrapper -->\n  <!-- Control Sidebar -->\n  <floatbar></floatbar>\n  <!-- /.control-sidebar -->\n  <!-- Add the sidebar's background. This div must be placed\n       immediately after the control sidebar -->\n  <div class=\"control-sidebar-bg\"></div>\n  <!--full screen modal element-->\n  <div class=\"modal fade modal-fullscreen force-fullscreen\" id=\"full-screen-modal\" tabindex=\"-1\" role=\"dialog\" data-backdrop=\"static\" data-keyboard=\"false\" aria-labelledby=\"full-screen-modal\" aria-hidden=\"true\"></div>\n  <!---->\n  <div id=\"credits\" class=\"modal fade\">\n    <div class=\"modal-dialog\" role=\"document\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n          </button>\n          <a style=\"text-align: center!important;\" href=\"http://www.gis3w.it\" target=\"_blank\">\n            <img src=\"http://gis3w.it/wp-content/uploads/sites/7/2017/01/logo_gis3w_156_85.png?x22227\" class=\"img-responsive center-block\" alt=\"\">\n            <div style=\"text-align: center!important; margin-bottom:50px; margin-top:20px; color:#000000\">\n              <h4>GIS3W di Lorenzetti Walter e C. S.a.S.</h4>\n            </div>\n          </a>\n          <address id=\"address-credits\" style=\"line-height: 2; text-align: center;\">\n            <i class=\"fa fa-map-marker\" aria-hidden=\"true\"></i>\n            <span> Viale Verdi, 24 - Montecatini Terme (PT)</span></br>\n            <i class=\"fa fa-mobile\" aria-hidden=\"true\"></i>\n            <span> +39 347 6597931</span></br>\n            <i class=\"fa fa-fax\" aria-hidden=\"true\"></i>\n            <span> +39 0572 901639</span></br>\n            <i class=\"fa fa-envelope\" aria-hidden=\"true\">\n            </i>\n            <span><a href=\"mailto:info@gis3w.it\" style=\"color:#000000\"> info@gis3w.it</a></span>\n          </address>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],5:[function(require,module,exports){
module.exports = "<div id=\"contents\" class=\"contents\"></div>\n";

},{}],6:[function(require,module,exports){
module.exports = "<aside class=\"control-sidebar control-sidebar-light\" >\n  <a v-show=\"panelsinstack\" href=\"#\" class=\"floatbar-aside-toggle\" data-toggle=\"control-sidebar\" role=\"button\">\n    <span class=\"sr-only\">Expand</span>\n  </a>\n  <div id=\"floatbar-spinner\" style=\"position:absolute\"></div>\n  <div v-show=\"panelsinstack\" class=\"g3w-sidebarpanel\">\n    <div v-if=\"closable\" class=\"row\">\n      <div class=\"col-xs-12 col-sm-12 col-md-12\">\n        <button class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closePanel\"></button>\n      </div>\n    </div>\n    <div v-if=\"panelname\">\n      <h4 class=\"g3w-floatbarpanel-name\">{{ panelname }}</h4>\n    </div>\n    <div id=\"g3w-floatbarpanel-placeholder\" class=\"g3w-floatbarpanel-placeholder\"></div>\n  </div>\n</aside>\n";

},{}],7:[function(require,module,exports){
module.exports = "<div id=\"menu-projects\" class=\"container nano\">\n  <div v-show=\"loading\" class=\"bar-loader\"></div>\n  <div class=\"nano-content\">\n    <div class=\"row row-equal\">\n      <!-- item -->\n      <div v-for=\"menuitem in state.menuitems\"  @click=\"trigger(menuitem)\" class=\"col-xs-12 col-sm-4 project-menu\">\n        <div class=\"project-menu-item-image\">\n          <img :src=\"logoSrc(menuitem.thumbnail)\" class=\"img-responsive\">\n        </div>\n        <div class=\"project-menu-item-content\">\n          <div class=\"project-menu-item-text\">\n            <h4 class=\"project-menu-item-title\">{{ menuitem.title }}</h4>\n            <div v-html=\"menuitem.description\"></div>\n          </div>\n        </div>\n      </div>\n      <div v-if=\"!state.menuitems.length\" style=\"margin-left:15px;\">\n        <h2>Non ci sono altri progetti in questo gruppo cartografico</h2>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],8:[function(require,module,exports){
module.exports = "<li  v-show=\"state.visible\" class=\"treeview sidebaritem\" :class=\"{'active': open}\">\n  <a @click=\"onClickItem\" href=\"#\">\n    <i :class=\"icon\"></i>\n    <span class=\"treeview-label\">{{title | t}}</span>\n    <i class=\"fa fa-angle-left pull-right\"></i>\n  </a>\n  <div id=\"g3w-sidebarcomponent-placeholder\"></div>\n</li>\n";

},{}],9:[function(require,module,exports){
module.exports = "<aside class=\"main-sidebar\">\n  <!-- sidebar: style can be found in sidebar.less -->\n  <!-- Sidebar toggle button-->\n  <!-- Toggle button on the left side of main sidebar only if not mobile -->\n  <a v-if=\"!isMobile()\" href=\"#\" class=\"sidebar-aside-toggle\" data-toggle=\"offcanvas\" role=\"button\">\n    <span class=\"sr-only\">Expand</span>\n  </a>\n  <!--<div class=\"quick-actions-menu\">-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-share-alt\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-modal-window\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-print\"></button>-->\n    <!--<button class=\"btn btn-default btn-circle-medium glyphicon glyphicon-search\"></button>-->\n  <!--</div>-->\n\t<section class=\"sidebar\">\n    <div v-show=\"panelsinstack\" class=\"g3w-sidebarpanel\">\n      <div style=\"overflow: hidden;line-height: 14px;margin-top: 4px; font-size:1.5em\">\n          <button class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closePanel\"></button>\n      </div>\n      <div id=\"g3w-sidebarpanel-placeholder\" class=\"g3w-sidebarpanel-placeholder\"></div>\n    </div>\n\t  <ul id=\"g3w-sidebarcomponents\" v-show=\"showmainpanel\" class=\"sidebar-menu\"></ul>\n\t</section>\n\t<!-- /.sidebar -->\n</aside>\n";

},{}],10:[function(require,module,exports){
module.exports = "<div class=\"g3w-viewport\">\n  <div id=\"g3w-view-map\" class=\"g3w-view map\" :style=\"{width:state.map.sizes.width+'px',height:state.map.sizes.height+'px'}\">\n  </div>\n  <div id=\"g3w-view-content\" class=\"g3w-view content\" :style=\"{width:state.content.sizes.width+'px',height:state.content.sizes.height+'px'}\">\n    <div v-if=\"(showtitle && contentTitle) || previousTitle || (state.content.closable && state.content.aside)\" class=\"close-panel-block\">\n      <div v-if=\"previousTitle\" class=\"g3w_contents_back\">\n        <span  @click=\"gotoPreviousContent()\"><span class=\"glyphicon glyphicon-chevron-left\"></span> Torna {{ previousTitle }}</span>\n      </div>\n      <button v-if=\"state.content.closable && state.content.aside\" class=\"glyphicon glyphicon-remove pull-right close-panel-button\" @click=\"closeContent\"></button>\n      <div v-if=\"showtitle && contentTitle\">\n        <span>{{ contentTitle }}</span>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],11:[function(require,module,exports){
var ApplicationService = require('core/applicationservice');
var ProjectsRegistry = require('core/project/projectsregistry');
var ProjectsMenuComponent = require('./projectsmenu');
var GUI = require('sdk/gui/gui');
var layout = require('./layout');
var AppUI = Vue.extend({
  template: require('../html/app.html'),
  mounted: function(){
    this.$nextTick(function(){
      /* start to render LayoutManager layout */
      layout.loading(false);
      layout.setup();
      //Fix the problem with right sidebar and layout boxed
      layout.pushMenu.expandOnHover();
      layout.controlSidebar._fix($(".control-sidebar-bg"));
      layout.controlSidebar._fix($(".control-sidebar"));
      var controlsidebarEl = layout.options.controlSidebarOptions.selector;
      function setFloatBarMaxHeight(){
        $(controlsidebarEl).css('max-height',$(window).innerHeight());
        $('.g3w-sidebarpanel').css('height',$(window).height() - $(".main-header").height());
      }
      setFloatBarMaxHeight();
      function setModalHeight(){
        $('#g3w-modal-overlay').css('height',$(window).height());
      }
      $(window).resize(function() {
        setFloatBarMaxHeight();
        setModalHeight();
      });
    })
  },
  computed: {
    logo_url: function() {
      var config = ApplicationService.getConfig();
      var logo_url;
      if (config.logo_img && config.logo_img!='') {
        logo_url = config.mediaurl+config.logo_img;
      }
      return logo_url;
    },
    logo_link: function() {
      var logo_link = this.getLogoLink();
      return logo_link ? logo_link : "#";
    },
    logo_link_target: function() {
      var logo_link = this.getLogoLink();
      return logo_link ? "_blank" : "";
    },
    project_title: function() {
      var currentProject = ProjectsRegistry.getCurrentProject();
      return currentProject.state.name;
    },
    user: function() {
      var user = ApplicationService.getConfig().user;
      // verifico nel caso fosse un oggetto vuoto
      if (_.isEmpty(user)) {user = null}
      return user;
    },
    numberOfProjectsInGroup: function() {
      return ProjectsRegistry.getProjects().length;
    }
  },
  methods: {
    closePanel: function(){
      sidebarService.closePanel();
    },
    isMobile: function(){return isMobile.any},
    getLogoLink: function() {
      var logo_link = null;
      if (ApplicationService.getConfig().logo_link) {
        logo_link = ApplicationService.getConfig().logo_link;
      }
      return logo_link;
    },
    openProjectsMenu: function() {
      var contentsComponent = GUI.getComponent('contents');
      // verifico che il content è il projectsmenu
      if (contentsComponent.getComponentById('projectsmenu')) {
        GUI.closeContent();
      } else {
        GUI.setContent({
          content: new ProjectsMenuComponent(),
          title: '',
          perc:100
        });
      }
    }
  }
});

module.exports = AppUI;
},{"../html/app.html":4,"./layout":15,"./projectsmenu":17,"core/applicationservice":22,"core/project/projectsregistry":69,"sdk/gui/gui":118}],12:[function(require,module,exports){
var utils = require('sdk/core/utils/utils');
var inherit = require('sdk/core/utils/utils').inherit;
var G3WObject = require('sdk/core/g3wobject');
var Component = require('gui/vue/component');
var Panel = require('gui/panel');

//classe barstack
// Ha lo scopo di montare stack di pannelli
// sopra ogni parte del parent in questione
function BarStack() {
  this._parent = null;
  // state del barstak contenente array pannelli
  this.state = {
    contentsdata: []
  }
}

//eredita dall'oggetto G3WOBJECT
inherit(BarStack, G3WObject);

var proto = BarStack.prototype;

// funzione che immette il componente (di qualsiasi tipo) nel parent element
proto.push = function(content, options) {
  // parent è l'identificativo dell'elemento DOM sui cui montare (in append o meno) il component/panel
  this._parent = options.parent;
  // chiamo il metodo mount del barstack
  return this._mount(content, options);
};

// toglie l'ultimo componente dallo stack
proto.pop = function(){
  var self = this;
  var d = $.Deferred();
  // qui potremo chiedere al pannello se può essere chiuso...
  if (this.state.contentsdata.length) {
    var content = this.state.contentsdata.slice(-1)[0].content;
    return this._unmount(content)
    .then(function(){
      self.state.contentsdata.pop();
    })
  }
  else {
    d.resolve();
  }
  return d.promise();
};

// fa il clear di tutto lo stack in una volta sola
proto.clear = function() {
  var self = this;
  var d = $.Deferred();
  if (this.state.contentsdata.length) {
    var unmountRequests = [];
    _.forEach(this.state.contentsdata, function (data, idx) {
      unmountRequests.push(self._unmount(data.content));
    });
    $.when(unmountRequests).then(function () {
      //self.state.contentsdata = [];
      self.state.contentsdata.splice(0,self.state.contentsdata.length);
      d.resolve();
    });
  }
  else {
    d.resolve();
  }
  return d.promise();
};

proto.getContentData = function() {
  return this.state.contentsdata
};

proto.getCurrentContentData = function() {
  return this.state.contentsdata[this.state.contentsdata.length - 1];
};

proto.getPreviousContentData = function() {
  return this.state.contentsdata[this.state.contentsdata.length - 2];
};

// funzione che fa il mopnt del componente
proto._mount = function(content, options) {
  // verifico il tipo di content passato:
  //oggetto JQuery
  if (content instanceof jQuery) {
    return this._setJqueryContent(content);
  }
  //stringa
  else if (_.isString(content)) {
    var jqueryEl = $(content);
    // nel caso in cui content sia testo puro, devo wrapparlo in un tag HTML in modo che $() generi un elemento DOM
    if (!jqueryEl.length) {
      jqueryEl = $('<div>'+content+'</div>');
    }
    return this._setJqueryContent(jqueryEl);
  }
  // istanza componente (vue alla fine)
  else if (content.mount && typeof content.mount == 'function') {
    this._checkDuplicateVueContent(content); // nel caso esista già prima lo rimuovo
    return this._setVueContent(content,options)
  }
  // infine è elemento dom
  else {
    return this._setDOMContent(content);
  }
};

//funzione che permettere di appendere oggetto jquery
proto._setJqueryContent = function(content,options) {
  $(this._parent).append(content);
  this.state.contentsdata.push({
    content: content,
    options: options
  });
  return utils.resolve();
};

//funzione che appende dom element
proto._setDOMContent = function(content,options) {
  this._parent.appendChild(content);
  this.state.contentsdata.push({
    content: content,
    options: options
  });
  return utils.resolve();
};

// funzione che monta il componte su parent
proto._setVueContent = function(content, options) {
  var self = this;
  var d = $.Deferred();
  var append = options.append || false;
  content.mount(this._parent, append)
  .then(function(){
    $(parent).localize();
    // inserisco nell'array del content data un oggetto avente attributi:
    // content: oggetto component
    // options: oprizioni riguardanti title, perc etc ...
    self.state.contentsdata.push({
      content: content,
      options: options
    });
    d.resolve();
  });
  return d.promise();
};

// verifica nel caso di un componente vue
proto._checkDuplicateVueContent = function(content) {
  var self = this;
  var idxToRemove = null;
  var id = content.getId();
  _.forEach(this.state.contentsdata, function(data,idx) {
    if (data.content.getId && (data.content.getId() == id)) {
      idxToRemove = idx;
    }
  });
  if (!_.isNull(idxToRemove)) {
    var data = self.state.contentsdata[idxToRemove];
    data.content.unmount()
      .then(function() {
        self.state.contentsdata.splice(idxToRemove,1);
      });
  }
};

// smonta il componente
proto._unmount = function(content) {
  var self = this;
  var d = $.Deferred();
  if (content instanceof Component || content instanceof Panel) {
    content.unmount()
    .then(function(){
      d.resolve();
    });
  }
  else {
    $(this._parent).empty();
    d.resolve();
  }
  return d.promise();
};

proto.forEach = function(cbk) {
  _.forEach(this.state.contentsdata,function(data){
    cbk(data.content);
  })
};

// resituisce la lunghezza (numero elementi) dello stack
proto.getLength = function() {
  return this.state.contentsdata.length;
};

module.exports = BarStack;

},{"gui/panel":127,"gui/vue/component":156,"sdk/core/g3wobject":34,"sdk/core/utils/utils":77}],13:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Stack = require('./barstack.js');
// componente base
var Component = require('gui/vue/component');

// componente interno (VUE) del content della viewport
var InternalComponent = Vue.extend({
  template: require('../html/contentsviewer.html'), // altro non è che <div id="contents" class="contents"></div>
  data: function() {
    return {
      state: null
    }
  }
});

// componente content Viewer
function ContentsViewerComponent(options) {
  base(this, options);
  this.stack = new Stack();
  // setta come servizio se stesso
  this.setService(this);
  this.title = "contents";
  // lo state del component padre è
  /*
   this.state = {
    visible: options.visible || true,
    open: options.open || false
   }
   */
  this.contentsdata = this.stack.state.contentsdata;
  this.state.visible = true;
  // vado a settare il componente interno
  // sfruttando il metodo del componente base
  this.setInternalComponent(new InternalComponent({
    service: this
  }));
  // setto lo state del componente interno vue uguale allo state del service
  // che non è altro lo state component padre state={open, visible};
  this.internalComponent.state = this.state;
}

/// stooto classe di Component
inherit(ContentsViewerComponent, Component);

var proto = ContentsViewerComponent.prototype;

// setta il contenuto dell content
proto.setContent = function(options) {
  var self = this;
  var d = $.Deferred();
  var push = options.push || false;
  var content = options.content;
  // svuoto sempre lo stack, così ho sempre un solo elemento (la gestione dello stack è delegata alla viewport).
  // Uso comunque barstack perché implementa già la logica di montaggio dei contenuti nel DOM
  if (!push) {
    // elemino tutto lo stack content
    this.clearContents()
    .then(function() {
      self.addContent(content, options)
      .then(function(){
        d.resolve();
      })
    })
  }
  else {
    this.addContent(content,options)
    .then(function(){
      d.resolve();
    })
  }
  this.setOpen(true);
  return d.promise();
};

//aggiunge al componente base content componenti
proto.addContent = function(content, options) {
  var self = this;
  // l'emento parente è proprio il template content
  options.parent = this.internalComponent.$el;
  // definisce l'append a true
  options.append = true;
  // stack.push è una promise
  return this.stack.push(content, options)
  .then(function() {
    // prendo il contentuo dello stack
    self.contentsdata = self.stack.state.contentsdata;
    // aggiorna la visibilità dei vari componenti vue montati
    self.updateContentVisibility();
  })
};

// rimuove il contenuto dallo stack
proto.removeContent = function() {
  this.setOpen(false);
  return this.clearContents();
};

// usato da viewport.js
proto.popContent = function() {
  var self = this;
  return this.stack.pop()
  .then(function() {
    // solo dopo che lo stack è stato aggiornato aggiorna il contentsdata
    self.contentsdata = self.stack.state.contentsdata;
    // aggiorna la visibilità dei vari componenti vue montanti
    self.updateContentVisibility();
  });
};

// recupera il component attraverso la classe
proto.getComponentByClass = function(componentClass) {
  var component;
  var contentdata = this.stack.getContentData();
  _.forEach(contentdata, function(content) {
    if (content.content instanceof componentClass) {
      component = content.content;
      return false
    }
  });
  return component
};

// recupera il component attraverso l'id del componente
proto.getComponentById = function(id) {
  var component;
  var contentdata = this.stack.getContentData();
  _.forEach(contentdata, function(content) {
    if (content.content.id == id) {
      component = content.content;
      return false
    }
  });
  return component
};

proto.getContentData = function() {
  return this.stack.getContentData();
};

// restituisce il current contentdata
proto.getCurrentContentData = function(){
  return this.stack.getCurrentContentData();
};

// restituisce il previuos content data
proto.getPreviousContentData = function() {
  return this.stack.getPreviousContentData();
};

// funzione che aggiorna la visibilità dei componenti del content
proto.updateContentVisibility = function() {
  // hide tuttigli elementi all'infuri che l'ultimo
  var contentsEls = $(this.internalComponent.$el).children();
  contentsEls.hide();
  contentsEls.last().show();
};

// fa il clear dello stack in quanto si vuole che lo stack del contenteComponente
// deve essere sempre vuoto in partenza
proto.clearContents = function() {
  var self = this;
  return this.stack.clear()
  .then(function() {
    self.contentsdata = self.stack.state.contentsdata;
  })
};

// funzione che serve per definire di volta in volta il layout del content
// i parametri sono l'altezza e la larghezza dell'elemento parent contenitore
proto.layout = function(parentWidth, parentHeight) {
  var self = this;
  // elemento template del componente vue
  var el = $(this.internalComponent.$el);
  //lancia la callback solo dopo che è stato aggiornato lo stato di Vue
  Vue.nextTick(function() {
    // el.parent() è il div g3w-view-content
    var height = el.parent().height() - el.siblings('.close-panel-block').outerHeight(true) - el.siblings('.g3w_contents_back').outerHeight(true);
    el.height(height);
    el.children().first().height(height);
    var contentsdata = self.stack.state.contentsdata;
    contentsdata.forEach(function(data) {
      //vado a scorrere su tutti i cmponenti caricari nello stack
      if (typeof data.content.layout == 'function') {
        // vado a chiamare la funzione layout di tutti i componenti presenti nello stack
        data.content.layout(parentWidth, height);
      }
    })
  })
};

module.exports = ContentsViewerComponent;

},{"../html/contentsviewer.html":5,"./barstack.js":12,"core/utils/utils":77,"gui/vue/component":156}],14:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
var Stack = require('./barstack.js');
var GUI = require('sdk/gui/gui');

function FloatbarService(){
  this.stack = new Stack();
  this.init = function(layout){
    this.layout = layout;
    this.sidebarEl = $(this.layout.options.controlSidebarOptions.selector);
    this._zindex = this.sidebarEl.css("z-index");
    this._modalOverlay = null;
    this._modal = false;
    this._isopen = false;
  };

  this.isOpen = function() {
    return this._isopen;
  };

  this.open = function() {
    this.layout.floatBar.open(this.sidebarEl,true);
    this._isopen = true;
  };

  this.close = function() {
    this.layout.floatBar.close(this.sidebarEl,true);
    this._isopen = false;
  };

  this.showPanel = function(panel,options){
    var options = options || {};
    var append = options.append || false;
    var modal = options.modal || false;
    options.parent = "#g3w-floatbarpanel-placeholder";
    this.stack.push(panel, options);
    if (!this._isopen) {
      this.open();
    };
  };
  
  this.closePanel = function(panel){
    if (panel) {
      this.stack.remove(panel);
    }
    else {
      this.stack.pop();
    }
    if (!this.stack.getLength()) {
      if (this._modal){
        GUI.setModal(false);
        this.close();
        $('.control-sidebar-bg').toggleClass('control-sidebar-bg-shadow');
        this.sidebarEl.css("z-index","");
        this.sidebarEl.css("padding-top","50px");
        $('.control-sidebar-bg').css("z-index","");
        this._modal = false;
      }
      else {
        this.close();
      }
    }
  };
  
  this.hidePanel = function(){
    this.close();
  };
}

var floatbarService = new FloatbarService();

var FloatbarComponent = Vue.extend({
    template: require('../html/floatbar.html'),
    data: function() {
    	return {
        stack: floatbarService.stack.state,
      };
    },
    computed: {
      // quanti pannelli sono attivi nello stack
      panelsinstack: function(){
        return this.stack.contentsdata.length>0;
      },
      panelname: function(){
        var name;
        if (this.stack.contentsdata.length){
          name = this.stack.contentsdata.slice(-1)[0].content.getTitle();
        }
        return name;
      },
      closable: function() {
        return floatbarService.closable;
      }
    },
    watch: {
      // TODO: Brutto, ma è l'unico (per ora) modo flessibile che ho trovato per implementare il concetto di stack... 
      "stack.contentsdata": function(){
        var children = $("#g3w-floatbarpanel-placeholder").children();
        _.forEach(children,function(child,index){
          if (index == children.length-1){
            $(child).show();
          }
          else {
            $(child).hide();
          }
        })
      }
    },
    methods: {
      closePanel: function(){
        floatbarService.closePanel();
      }
    }
});

module.exports = {
  FloatbarService: floatbarService,
  FloatbarComponent: FloatbarComponent
};

},{"../html/floatbar.html":6,"./barstack.js":12,"sdk/core/i18n/i18n.service":39,"sdk/gui/gui":118}],15:[function(require,module,exports){
//Make sure jQuery has been loaded before app.js
if (typeof jQuery === "undefined") {
  throw new Error("LayoutManager requires jQuery");
}

$.LayoutManager = {};

/* --------------------
 * - LayoutManager Options -
 * --------------------
 * Modify these options to suit your implementation
 */
$.LayoutManager.options = {
  //Add slimscroll to navbar menus
  //This requires you to load the slimscroll plugin
  //in every page before app.js
  navbarMenuSlimscroll: true,
  navbarMenuSlimscrollWidth: "0px", //The width of the scroll bar
  navbarMenuHeight: "200px", //The height of the inner menu
  //General animation speed for JS animated elements such as box collapse/expand and
  //sidebar treeview slide up/down. This options accepts an integer as milliseconds,
  //'fast', 'normal', or 'slow'
  animationSpeed:'fast',
  //Sidebar push menu toggle button selector
  sidebarToggleSelector: "[data-toggle='offcanvas']",
  //Activate sidebar push menu
  sidebarPushMenu: true,
  //Activate sidebar slimscroll if the fixed layout is set (requires SlimScroll Plugin)
  sidebarSlimScroll: true,
  //Enable sidebar expand on hover effect for sidebar mini
  //This option is forced to true if both the fixed layout and sidebar mini
  //are used together
  sidebarExpandOnHover: false,
  //BoxRefresh Plugin
  enableBoxRefresh: true,
  //Bootstrap.js tooltip
  enableBSToppltip: true,
  BSTooltipSelector: "[data-toggle='tooltip']",
  //Enable Fast Click. Fastclick.js creates a more
  //native touch experience with touch devices. If you
  //choose to enable the plugin, make sure you load the script
  //before LayoutManager's app.js
  enableFastclick: true,
  //Control Sidebar Options
  enableControlSidebar: true,
  controlSidebarOptions: {
    //Which button should trigger the open/close event
    toggleBtnSelector: "[data-toggle='control-sidebar']",
    //The sidebar selector
    selector: ".control-sidebar",
    //Enable slide over content
    slide: true
  },
  //Box Widget Plugin. Enable this plugin
  //to allow boxes to be collapsed and/or removed
  enableBoxWidget: true,
  //Box Widget plugin options
  boxWidgetOptions: {
    boxWidgetIcons: {
      //Collapse icon
      collapse: 'fa-minus',
      //Open icon
      open: 'fa-plus',
      //Remove icon
      remove: 'fa-times'
    },
    boxWidgetSelectors: {
      //Remove button selector
      remove: '[data-widget="remove"]',
      //Collapse button selector
      collapse: '[data-widget="collapse"]'
    }
  },
  //Direct Chat plugin options
  directChat: {
    //Enable direct chat by default
    enable: true,
    //The button to open and close the chat contacts pane
    contactToggleSelector: '[data-widget="chat-pane-toggle"]'
  },
  //Define the set of colors to use globally around the website
  colors: {
    lightBlue: "#3c8dbc",
    red: "#f56954",
    green: "#00a65a",
    aqua: "#00c0ef",
    yellow: "#f39c12",
    blue: "#0073b7",
    navy: "#001F3F",
    teal: "#39CCCC",
    olive: "#3D9970",
    lime: "#01FF70",
    orange: "#FF851B",
    fuchsia: "#F012BE",
    purple: "#8E24AA",
    maroon: "#D81B60",
    black: "#222222",
    gray: "#d2d6de"
  },
  //The standard screen sizes that bootstrap uses.
  //If you change these in the variables.less file, change
  //them here too.
  screenSizes: {
    xs: 480,
    sm: 768,
    md: 992,
    lg: 1200
  }
};


/* ----------------------------------
 * - Initialize the LayoutManager Object -
 * ----------------------------------
 * All LayoutManager functions are implemented below.
 */
$.LayoutManager._init = function() {
  'use strict';
  /* Layout
   * ======
   * Fixes the layout height in case min-height fails.
   *
   * @type Object
   * @usage $.LayoutManager.layout.activate()
   *        $.LayoutManager.layout.fix()
   *        $.LayoutManager.layout.fixSidebar()
   */
  $.LayoutManager.layout = {
    activate: function () {
      var _this = this;
      _this.fix();
      _this.fixSidebar();
      $(window, ".wrapper").resize(function () {
        _this.fix();
        _this.fixSidebar();
      });
    },
    fix: function () {
      //Get window height and the wrapper height
      var neg = $('.main-header').outerHeight() + $('.main-footer').outerHeight();
      var window_height = $(window).height();
      var sidebar_height = $(".sidebar").height();
      //Set the min-height of the content and sidebar based on the
      //the height of the document.
      if ($("body").hasClass("fixed")) {
        $(".content-wrapper, .right-side").css('min-height', window_height - $('.main-footer').outerHeight());
        $(".content-wrapper, .right-side").css('height', window_height - $('.main-footer').outerHeight());
      } else {
        var postSetWidth;
        if (window_height >= sidebar_height) {
          $(".content-wrapper, .right-side").css('min-height', window_height - neg);
          postSetWidth = window_height - neg;
        } else {
          $(".content-wrapper, .right-side").css('min-height', sidebar_height);
          postSetWidth = sidebar_height;
        }
        //Fix for the control sidebar height
        var controlSidebar = $($.LayoutManager.options.controlSidebarOptions.selector);
        if (typeof controlSidebar !== "undefined") {
          if (controlSidebar.height() > postSetWidth)
            $(".content-wrapper, .right-side").css('min-height', controlSidebar.height());
        }

      }
    },
    fixSidebar: function () {
      //Make sure the body tag has the .fixed class
      if (!$("body").hasClass("fixed")) {
        if (typeof $.fn.slimScroll != 'undefined') {
          $(".sidebar").slimScroll({destroy: true}).height("auto");
        }
        return;
      } else if (typeof $.fn.slimScroll == 'undefined' && window.console) {
        window.console.error("Error: the fixed layout requires the slimscroll plugin!");
      }
      //Enable slimscroll for fixed layout
      if ($.LayoutManager.options.sidebarSlimScroll) {
        if (typeof $.fn.slimScroll != 'undefined') {
          //Destroy if it exists
          $(".sidebar").slimScroll({destroy: true}).height("auto");
          //Add slimscroll
          $(".sidebar").slimscroll({
            height: ($(window).height() - $(".main-header").height()) + "px",
            color: "rgba(255,255,255,0.7)",
            size: "3px"
          });
        }
      }
      else {
         $(".sidebar").css({'height': ($(window).height() - $(".main-header").height()) + "px"})
      }
      
      /*$(".sidebar li a").each(function(){
        var $this = $(this);
        var checkElement = $this.next();
        if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
          //Get the parent menu
          var parent = $this.parents('ul').first();
          var parent_li = $this.parent("li");
          var li_siblings = parent_li.siblings();
          var parent_find_active;
          var sidebar_content_height = parent.height() - parent.find('li.header').outerHeight();
          var treeviewHeight = parent_li.outerHeight();
          li_siblings.not('.header').each(function(index, el) {
                  treeviewHeight+=$(el).find('a').outerHeight();
          });
          var section_height = (sidebar_content_height - treeviewHeight);
          checkElement.css({
            'height': section_height + 'px',
            'max-height':section_height + 'px',
            'overflow-y': 'auto'
          });
        }
      });*/
      
    }
    
  };

  /* PushMenu()
   * ==========
   * Adds the push menu functionality to the sidebar.
   *
   * @type Function
   * @usage: $.LayoutManager.pushMenu("[data-toggle='offcanvas']")
   */
  $.LayoutManager.pushMenu = {
    activate: function (toggleBtn) {
      //Get the screen sizes
      var screenSizes = $.LayoutManager.options.screenSizes;

      //Enable sidebar toggle
      $(toggleBtn).on('click', function (e) {
        e.preventDefault();

        //Enable sidebar push menu
        if ($(window).width() > (screenSizes.sm - 1)) {
          if ($("body").hasClass('sidebar-collapse')) {
            $("body").removeClass('sidebar-collapse').trigger('expanded.pushMenu');
          } else {
            $("body").addClass('sidebar-collapse').trigger('collapsed.pushMenu');
          }
        }
        //Handle sidebar push menu for small screens
        else {
          if ($("body").hasClass('sidebar-open')) {
            $("body").removeClass('sidebar-open').removeClass('sidebar-collapse').trigger('collapsed.pushMenu');
          } else {
            $("body").addClass('sidebar-open').trigger('expanded.pushMenu');
          }
        }
      });

      /*$(".content-wrapper").click(function () {
        //Enable hide menu when clicking on the content-wrapper on small screens
        if ($(window).width() <= (screenSizes.sm - 1) && $("body").hasClass("sidebar-open")) {
          $("body").removeClass('sidebar-open');
        }
      });*/

      //Enable expand on hover for sidebar mini
      if ($.LayoutManager.options.sidebarExpandOnHover || ($('body').hasClass('fixed') && $('body').hasClass('sidebar-mini'))) {
        this.expandOnHover();
      }
    },
    expandOnHover: function () {
      var _this = this;
      var screenWidth = $.LayoutManager.options.screenSizes.sm - 1;
      //Expand sidebar on hover
      $('.main-sidebar').hover(function () {
        if ($('body').hasClass('sidebar-mini') && $("body").hasClass('sidebar-collapse') && $(window).width() > screenWidth) {
          _this.expand();
        }
      }, function () {
        if ($('body').hasClass('sidebar-mini') && $('body').hasClass('sidebar-expanded-on-hover') && $(window).width() > screenWidth) {
          _this.collapse();
        }
      });
    },
    expand: function () {
      $("body").removeClass('sidebar-collapse').addClass('sidebar-expanded-on-hover');
    },
    collapse: function () {
      if ($('body').hasClass('sidebar-expanded-on-hover')) {
        $('body').removeClass('sidebar-expanded-on-hover').addClass('sidebar-collapse');
      }
    }
  };

  /* Tree()
   * ======
   * Converts the sidebar into a multilevel
   * tree view menu.
   *
   * @type Function
   * @Usage: $.LayoutManager.tree('.sidebar')
   */
  $.LayoutManager.tree = function (menu) {
    var _this = this;
    var animationSpeed = $.LayoutManager.options.animationSpeed;
    //click event //
    $(document).on('click', menu + ' li a', function (e) {

      //Get the clicked link and the next element
      var $this = $(this);
      //is the content of the "accordion" ul //
      var checkElement = $this.next();

      //Check if the next element is a menu and is visible
      if ((checkElement.is('.treeview-menu')) && (checkElement.is(':visible'))) {
        //Close the menu
        checkElement.slideUp(animationSpeed, function () {
          checkElement.parent("li.treeview").removeClass("active");
          checkElement.removeClass('menu-open');
          //Fix the layout in case the sidebar stretches over the height of the window
          //_this.layout.fix();
        });

      }
      //If the menu is not visible
      else if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
        //Get the parent menu
        var parent = $this.parents('ul').first();
        var parent_li = $this.parent("li");
        var li_siblings = parent_li.siblings();
        var parent_find_active;
        var sidebar_content_height = parent.height() - parent.find('li.header').outerHeight();
        var treeviewHeight = parent_li.outerHeight();
        li_siblings.not('.header').each(function(index, el) {
                treeviewHeight+=$(el).find('a').outerHeight();
        });
        var section_height = (sidebar_content_height - treeviewHeight);
        /*checkElement.css({
          'height': section_height + 'px',
          'max-height':section_height + 'px',
          //'overflow-y': 'auto'
        });*/
        //Close all open menus within the parent
        var ul = parent.find('ul.treeview-menu:visible').slideUp(animationSpeed);
        //Remove the menu-open class from the parent
        ul.removeClass('menu-open');
        //Get the parent li
        //Open the target menu and add the menu-open class
        checkElement.slideDown(animationSpeed, function () {
          //Add the class active to the parent li
          checkElement.addClass('menu-open');
          parent_find_active = parent.find('li.treeview.active');
          parent_find_active.removeClass('active');
          parent_li.addClass('active');
          //Fix the layout in case the sidebar stretches over the height of the window
          _this.layout.fix();
        });
      }
      //if this isn't a link, prevent the page from being redirected
      if (checkElement.is('.treeview-menu')) {
        e.preventDefault();
      }
      
      //$.LayoutManager.layout.fix();
      //$.LayoutManager.layout.fixSidebar();
    });
  };

  /* ControlSidebar
   * ==============
   * Adds functionality to the right sidebar
   *
   * @type Object
   * @usage $.LayoutManager.controlSidebar.activate(options)
   */
  $.LayoutManager.floatBar = $.LayoutManager.controlSidebar = {
    //instantiate the object
    activate: function () {
      //Get the object
      var _this = this;
      //Update options
      var o = $.LayoutManager.options.controlSidebarOptions;
      //Get the sidebar
      var sidebar = $(o.selector);
      //The toggle button
      var btn = $(o.toggleBtnSelector);

      //Listen to the click event
      btn.on('click', function (e) {
        e.preventDefault();
        //If the sidebar is not open
        if (!sidebar.hasClass('control-sidebar-open') && !$('body').hasClass('control-sidebar-open')) {
          //Open the sidebar
          _this.open(sidebar, o.slide);
        } else {
          _this.close(sidebar, o.slide);
        }
      });

      //If the body has a boxed layout, fix the sidebar bg position
      var bg = $(".control-sidebar-bg");
      _this._fix(bg);

      //If the body has a fixed layout, make the control sidebar fixed
      if ($('body').hasClass('fixed')) {
        _this._fixForFixed(sidebar);
      } else {
        //If the content height is less than the sidebar's height, force max height
        if ($('.content-wrapper, .right-side').height() < sidebar.height()) {
          _this._fixForContent(sidebar);
        }
      }
    },
    //Open the control sidebar
    open: function (sidebar, slide) {
      //Slide over content
      if (slide) {
        sidebar.addClass('control-sidebar-open');
      } else {
        //Push the content by adding the open class to the body instead
        //of the sidebar itself
        $('body').addClass('control-sidebar-open');
      }
    },
    //Close the control sidebar
    close: function (sidebar, slide) {
      if (slide) {
        sidebar.removeClass('control-sidebar-open');
      } else {
        $('body').removeClass('control-sidebar-open');
      }
    },
    _fix: function (sidebar) {
      var _this = this;
      if ($("body").hasClass('layout-boxed')) {
        sidebar.css('position', 'absolute');
        sidebar.height($(".wrapper").height());
        $(window).resize(function () {
          _this._fix(sidebar);
        });
      } else {
        sidebar.css({
          'position': 'fixed',
          'height': 'auto'
        });
      }
    },
    _fixForFixed: function (sidebar) {
      sidebar.css({
        'position': 'fixed',
        'max-height': '100%',
        //'overflow': 'auto',  // non dovrebbe fare danni questo commento, serve per non nascondere il pulsanti "Chiudi pannello"
        'padding-bottom': '50px'
      });
    },
    _fixForContent: function (sidebar) {
      $(".content-wrapper, .right-side").css('min-height', sidebar.height());
    }
  };

  /* BoxWidget
   * =========
   * BoxWidget is a plugin to handle collapsing and
   * removing boxes from the screen.
   *
   * @type Object
   * @usage $.LayoutManager.boxWidget.activate()
   *        Set all your options in the main $.LayoutManager.options object
   */
  $.LayoutManager.boxWidget = {
    selectors: $.LayoutManager.options.boxWidgetOptions.boxWidgetSelectors,
    icons: $.LayoutManager.options.boxWidgetOptions.boxWidgetIcons,
    animationSpeed: $.LayoutManager.options.animationSpeed,
    activate: function (_box) {
      var _this = this;
      if (!_box) {
        _box = document; // activate all boxes per default
      }
      //Listen for collapse event triggers
      $(_box).on('click', _this.selectors.collapse, function (e) {
        e.preventDefault();
        _this.collapse($(this));
      });

      //Listen for remove event triggers
      $(_box).on('click', _this.selectors.remove, function (e) {
        e.preventDefault();
        _this.remove($(this));
      });
    },
    collapse: function (element) {
      var _this = this;
      //Find the box parent
      var box = element.parents(".box").first();
      //Find the body and the footer
      var box_content = box.find("> .box-body, > .box-footer, > form  >.box-body, > form > .box-footer");
      if (!box.hasClass("collapsed-box")) {
        //Convert minus into plus
        element.find(".btn-collapser")
                .removeClass(_this.icons.collapse)
                .addClass(_this.icons.open);
        //Hide the content
        box_content.slideUp(_this.animationSpeed, function () {
          box.addClass("collapsed-box");
        });
      } else {
        //Convert plus into minus
        element.find(".btn-collapser")
                .removeClass(_this.icons.open)
                .addClass(_this.icons.collapse);
        //Show the content
        box_content.slideDown(_this.animationSpeed, function () {
          box.removeClass("collapsed-box");
        });
      }
    },
    remove: function (element) {
      //Find the box parent
      var box = element.parents(".box").first();
      box.slideUp(this.animationSpeed);
    }
  };
  
  return $.LayoutManager;
};

/* ------------------
 * - Custom Plugins -
 * ------------------
 * All custom plugins are defined below.
 */

/*
 * BOX REFRESH BUTTON
 * ------------------
 * This is a custom plugin to use with the component BOX. It allows you to add
 * a refresh button to the box. It converts the box's state to a loading state.
 *
 * @type plugin
 * @usage $("#box-widget").boxRefresh( options );
 */
$.LayoutManager.addRefreshButton = function () {
  "use strict";

  $.fn.boxRefresh = function (options) {

    // Render options
    var settings = $.extend({
      //Refresh button selector
      trigger: ".refresh-btn",
      //File source to be loaded (e.g: ajax/src.php)
      source: "",
      //Callbacks
      onLoadStart: function (box) {
        return box;
      }, //Right after the button has been clicked
      onLoadDone: function (box) {
        return box;
      } //When the source has been loaded

    }, options);

    //The overlay
    var overlay = $('<div class="overlay"><div class="fa fa-refresh fa-spin"></div></div>');

    return this.each(function () {
      //if a source is specified
      if (settings.source === "") {
        if (window.console) {
          window.console.log("Please specify a source first - boxRefresh()");
        }
        return;
      }
      //the box
      var box = $(this);
      //the button
      var rBtn = box.find(settings.trigger).first();

      //On trigger click
      rBtn.on('click', function (e) {
        e.preventDefault();
        //Add loading overlay
        start(box);

        //Perform ajax call
        box.find(".box-body").load(settings.source, function () {
          done(box);
        });
      });
    });

    function start(box) {
      //Add overlay and loading img
      box.append(overlay);

      settings.onLoadStart.call(box);
    }

    function done(box) {
      //Remove overlay and loading img
      box.find(overlay).remove();

      settings.onLoadDone.call(box);
    }

  };
  return $.LayoutManager;
};

/*
 * EXPLICIT BOX ACTIVATION
 * -----------------------
 * This is a custom plugin to use with the component BOX. It allows you to activate
 * a box inserted in the DOM after the app.js was loaded.
 *
 * @type plugin
 * @usage $("#box-widget").activateBox();
 */
$.LayoutManager.activateBox = function () {
  'use strict';

  $.fn.activateBox = function () {
    $.LayoutManager.boxWidget.activate(this);
  };
  
  return $.LayoutManager;
};

/*
 * TODO LIST CUSTOM PLUGIN
 * -----------------------
 * This plugin depends on iCheck plugin for checkbox and radio inputs
 *
 * @type plugin
 * @usage $("#todo-widget").todolist( options );
 */

$.LayoutManager.listCustomPlugin = function () {

	  'use strict';

	  $.fn.todolist = function (options) {
	    // Render options
	    var settings = $.extend({
	      //When the user checks the input
	      onCheck: function (ele) {
	        return ele;
	      },
	      //When the user unchecks the input
	      onUncheck: function (ele) {
	        return ele;
	      }
	    }, options);

	    return this.each(function () {

	      if (typeof $.fn.iCheck != 'undefined') {
	        $('input', this).on('ifChecked', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          settings.onCheck.call(ele);
	        });

	        $('input', this).on('ifUnchecked', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          settings.onUncheck.call(ele);
	        });
	      } else {
	        $('input', this).on('change', function () {
	          var ele = $(this).parents("li").first();
	          ele.toggleClass("done");
	          if ($('input', ele).is(":checked")) {
	            settings.onCheck.call(ele);
	          } else {
	            settings.onUncheck.call(ele);
	          }
	        });
	      }
	    });
	  };
	  return $.LayoutManager;
	};
	
	/* ------------------
	 * - Implementation -
	 * ------------------
	 * The next block of code implements LayoutManager's
	 * functions and plugins as specified by the
	 * options above.
	 */
	$.LayoutManager.setup = function ()
	{
	  "use strict";

	  //Fix for IE page transitions
	  $("body").removeClass("hold-transition");

	  //Extend options if external options exist
	  if (typeof LayoutManagerOptions !== "undefined") {
	    $.extend(true,
	            $.LayoutManager.options,
	            LayoutManagerOptions);
	  }

	  //Easy access to options
	  var o = $.LayoutManager.options;

	  //Set up the object
	  $.LayoutManager._init();

	  //Activate the layout maker
	  $.LayoutManager.layout.activate();

	  //Enable sidebar tree view controls
	  $.LayoutManager.tree('.sidebar');

	  //Enable control sidebar
	  if (o.enableControlSidebar) {
	    $.LayoutManager.controlSidebar.activate();
	  }

	  //Add slimscroll to navbar dropdown
	  if (o.navbarMenuSlimscroll && typeof $.fn.slimscroll != 'undefined') {
	    $(".navbar .menu").slimscroll({
	      height: o.navbarMenuHeight,
	      alwaysVisible: false,
	      size: o.navbarMenuSlimscrollWidth
	    }).css("width", "100%");
	  }

	  //Activate sidebar push menu
	  if (o.sidebarPushMenu) {
	    $.LayoutManager.pushMenu.activate(o.sidebarToggleSelector);
	  }

	  //Activate Bootstrap tooltip
	  if (o.enableBSToppltip) {
	    $('body').tooltip({
	      selector: o.BSTooltipSelector
	    });
	  }

	  //Activate box widget
	  if (o.enableBoxWidget) {
	    $.LayoutManager.boxWidget.activate();
	  }

	  //Activate fast click
	  if (o.enableFastclick && typeof FastClick != 'undefined') {
	    FastClick.attach(document.body);
	  }

	  //Activate direct chat widget
	  if (o.directChat.enable) {
	    $(document).on('click', o.directChat.contactToggleSelector, function () {
	      var box = $(this).parents('.direct-chat').first();
	      box.toggleClass('direct-chat-contacts-open');
	    });
	  }

	  /*
	   * INITIALIZE BUTTON TOGGLE
	   * ------------------------
	   */
	  $('.btn-group[data-toggle="btn-toggle"]').each(function () {
	    var group = $(this);
	    $(this).find(".btn").on('click', function (e) {
	      group.find(".btn.active").removeClass("active");
	      $(this).addClass("active");
	      e.preventDefault();
	    });

	  });
	  
	  return $.LayoutManager
	  	.addRefreshButton()
	  	.activateBox()
	  	.listCustomPlugin();
	};

$.LayoutManager.loading = function(start) {
  $('#initerror').remove();
  var start = _.isBoolean(start) ? start : true;
  if (start) {
    $('body').append('<div id="loadspinner" class="loading"></div>');
  }
  else {
    $('#loadspinner').remove();
  }
};

$.LayoutManager.reload = function(errorMsg) {
  $('body').append('<div id="initerror"><h2>Oops!!! Si è verificato un errore</h2>' +
    '<h4>Causa:  '+ errorMsg+'</h4>' +
    '<h5>Al momento non è possibile caricare la mappa</h5>' +
    '<button id="reload" type="button" class="btn btn-primary center-block" onclick="$.LayoutManager.loading();$.LayoutManager.bootstrap()">' +
    '<span class="glyphicon glyphicon-refresh"></span> <strong>Riprova</strong></button>' +
    '</div>'
  );
};

module.exports = $.LayoutManager;

},{}],16:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var GUI = require('gui/gui');
var ProjectsRegistry = require('core/project/projectsregistry');

var InternalComponent = Vue.extend({
  template: require('../html/menu.html'),
  data: function() {
    return {
      state: null,
      loading: false
    }

  },
  methods: {
    trigger: function(item) {
      var self = this;
      if (item.cbk) {
        //setto il modale a schermo intero
        $('#full-screen-modal').modal('show');
        this.loading = true;
        item.cbk.apply(item)
          .then(function(){
            self.loading = false;
            // tyolgo il modale a schermo intero
            $('#full-screen-modal').modal('hide');
          })
          .fail(function() {
            GUI.notify.error("<h4>Errore di caricamento della nuova mappa.</h4>" +
              "<h5>Controllare la connessione internet o contattare l'amministratore</h5>");
            $('#full-screen-modal').modal('hide');
            self.loading = false;
          })
      }
      else if (item.href) {
        window.open(item.href, '_blank');
      }
      else if (item.route) {
        GUI.goto(item.route);
      }
      else {
        console.log("Nessuna azione per "+item.title);
      }
    },
    logoSrc: function(src) {
      if (src.indexOf('./') > -1) {
        return ProjectsRegistry.config.mediaurl + src;
      } else {
        return src;
      }
    }
  },
  mounted: function() {
    Vue.nextTick(function () {
      $("#menu-projects.nano").nanoScroller();
    })
  }
});

function MenuComponent(options){
  options = options || {};
  base(this,options);
  //this.id = "menu_"+Date.now();
  this.title = options.title || "menu";
  this.state.visible = true;
  this.state.menuitems = options.menuitems;
  merge(this, options);
  this.internalComponent = new InternalComponent({
    service: this
  });
  this.internalComponent.state = this.state;
}
inherit(MenuComponent, Component);

var proto = MenuComponent.prototype;

proto.trigger = function(item) {

};

module.exports = MenuComponent;


},{"../html/menu.html":7,"core/i18n/i18n.service":39,"core/project/projectsregistry":69,"core/utils/utils":77,"gui/gui":118,"gui/vue/component":156}],17:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('core/plugin/pluginsregistry');
var MenuComponent = require('./menu');
var SidebarService = require('./sidebar').SidebarService;
var GUI = require('sdk').gui.GUI;

function ProjectsMenuComponent(options) {
  options = options || {};
  options.id = 'projectsmenu';
  base(this, options);
  var menuitems = [];
  var projects = ProjectRegistry.getListableProjects();
  _.forEach(projects, function(project){
    menuitems.push({
      title: project.title,
      description: project.description,
      thumbnail: project.thumbnail,
      cbk: function() {
        var d = $.Deferred();
        var currentProject;
        ProjectRegistry.getProject(project.gid)
        .then(function(project) {
          GUI.closeContent()
            .then(function() {
              currentProject = project;
              var currentUrl = window.location.href;
              var paths = currentUrl.split('/');
              if (!paths[ paths.length-1 ]) {
                paths[ paths.length-2 ] = project.getId();
                paths[ paths.length-3 ] = project.getType();
              } else {
                paths[ paths.length-1 ] = project.getId();
                paths[ paths.length-2 ] = project.getType();
              }
              //window.location = paths.join('/');
              // cambio la url
              history.pushState(null, null, paths.join('/'));
              // vado a afre il reload dei plugins
              PluginsRegistry.reloadPlugins(project);
              ProjectRegistry.setCurrentProject(currentProject);
              // vado a fare il reloads dei component
              SidebarService.reloadComponents();
              d.resolve();
            })
        })
        .fail(function() {
          d.reject();
        });
        return d.promise();
      }
    })
  });
  this.state.menuitems = menuitems;
}

inherit(ProjectsMenuComponent, MenuComponent);

module.exports = ProjectsMenuComponent;



},{"./menu":16,"./sidebar":18,"core/i18n/i18n.service":39,"core/plugin/pluginsregistry":64,"core/project/projectsregistry":69,"core/utils/utils":77,"sdk":158}],18:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
var inherit = require('sdk/core/utils/utils').inherit;
var Stack = require('./barstack.js');
var G3WObject = require('sdk/core/g3wobject');
var base = require('sdk/core/utils/utils').base;

//sidebar item che non è altro che un li della sidebar dove sarà possibile impostare
//titolo tipo di icona etc .. customizzata per ogni componente
var SidebarItem = Vue.extend({
  template: require('../html/sidebar-item.html'),
  data: function() {
    return {
        main: true,
        component: null,
        active: false,
        title: 'component',
        open: false,
        icon: null,
        state: null
      };
  },
  methods: {
    onClickItem: function() {
      var self = this;
      var sidebarService = this.$options.service;
      this.component.setOpen(!this.component.state.open);
      // setto lo stato del componente open
      _.forEach(sidebarService.state.components, function (component) {
        if (component != self.component && self.component.collapsible) {
          component.setOpen(false);
        }
      })
    }
  }
});

// service sidebar
function SidebarService() {
  //stack della sidebar
  this.stack = new Stack();
  // metto i setter close sidebarpanel per catturare l'evento
  // della chiusura del pannello sulla sidebar
  this.setters = {
    closeSidebarPanel: function()  {
      //hook function
    },
    openCloseItem: function(bool) {
    }
  };
  //stato del servizio
  this.state = {
    components: []
  };
  //inizializzazione del servizio (non sembra chaimato mai)
  this.init = function(layout) {
    this.layout = layout;
  };
  // funzione che serve ad aggiungere componeti alla sidebar
  this.addComponents = function(components){
    var self = this;
    // per ogni componente (istanza) appartenete alla sidebar viene chiamato il metodo
    // addComponent
    _.forEach(components,function(component){
      self.addComponent(component);
    });
    // rtorno true alla fine dell'aggiunta dei componenti perchè mi serve
    // al template durante il buoldtemplate di dire se è stato regitstrato (true) o meno
    return true;
  };
  // funzione che aggiunge il singolo componente sulla sidebar
  // aggiungo anche possibilità di insicare la positione nella sidebar
  this.addComponent = function(component, position) {
    //faccio montare il sidebar-item che contiene al suo interno il placeholder del componente vero e proprio
    //in questo modo il componente non si dovrà occupare di costruire anche l'elemento li della sidebar
    //ma conterrà solo il contenuto
    var sidebarItem = new SidebarItem({
      service: this
    });
    //setto le parti della sidebar-item che cambiano da componente a componente (da rivedere)
    sidebarItem.title = component.title || sidebarItem.title;
    sidebarItem.open = component.state.open;//(component.open === undefined) ? sidebarItem.open : component.open;
    sidebarItem.icon = component.icon || sidebarItem.icon;
    sidebarItem.state = component.state || true;
    sidebarItem.collapsible = component.collapsible || true;
    sidebarItem.component = component;
    //lo appendo al g3w-sidebarcomponents (template sidebar.html)
    var itemcomponent = sidebarItem.$mount();
    if (_.isNil(position)) {
      this.state.components.push(component);
      $('#g3w-sidebarcomponents').append(itemcomponent.$el);
    } else {
      this.state.components = this.state.components.splice(0,0,component);
      $('#g3w-sidebarcomponents').children().each(function(index, element) {
        if (position == index) {
          $(itemcomponent.$el).insertBefore(element);
        }
      });
    }
    //monto il componete nella g3w-sidebarcomponent-placeholder (template sidebar-item.html);
    component.mount("#g3w-sidebarcomponent-placeholder");
    // verifico che il componete abbia l'iniService come metodo
    if (_.has(component, 'initService')) {
      //se si lo chiamo inizializzazione del servizo
      component.initService();
    }
    return true;
  };

  // restituisce il component in base all'id
  this.getComponent = function(id) {
    var Component;
    _.forEach(this.state.components, function(component) {
      if (component.getId() == id) {
        Component = component;
        return false;
      }
    });
    return Component;
  };

  // restiuisce tutti i componenti
  this.getComponents = function() {
    return this.state.components;
  };

  this.reloadComponent = function(id) {
    var component = this.getComponent(id);
    component.reload();
  };

  this.reloadComponents = function() {
    // vado a forzare la chisura del panel
    this.closePanel();
    _.forEach(this.state.components, function(component) {
      if (component.collapsible && component.state.open) {
        $(component.getInternalComponent().$el).siblings().click();
        component.setOpen(false);
      }
      component.reload();
    })
  };
  //rimuove il component
  this.removeComponent = function(component) {
    var self = this;
    _.forEach(this.state.components, function(sidebarComponent, index) {
      if (component == sidebarComponent) {
        component.unmount();
        self.state.components.splice(index, 1);
        return false;
      }
    })
  };
  // visualizzazione pannello sullo stack
  this.showPanel = function(panel) {
    var parent = "#g3w-sidebarpanel-placeholder";
    // utilizzo il metodo push dello stack per montare il panel sul sidebar
    this.stack.push(panel, {
      parent: parent
    });
  };
  // chiusura pannello
  this.closePanel = function() {
    this.closeSidebarPanel();
    var panel = this.stack.pop();
  };

  base(this);
}

// eredito da G3Wobject così posso agire su onafter etc ..
inherit(SidebarService, G3WObject);

var sidebarService = new SidebarService;

var SidebarComponent = Vue.extend({
    template: require('../html/sidebar.html'),
    data: function() {
    	return {
        components: sidebarService.state.components,
        panels: sidebarService.stack.state.contentsdata,
        bOpen: true,
    		bPageMode: false,
    		header: t('main navigation')
        };
    },
    computed: {
      // quanti pannelli sono attivi nello stack
      panelsinstack: function(){
        return this.panels.length > 0;
      },
      showmainpanel: function(){
        return this.components.length>0 && !this.panelsinstack;
      },
      componentname: function(){
        var name = "";
        if (this.components.length){
          name = this.components.slice(-1)[0].getTitle();
        }
        return name;
      },
      panelname: function(){
        var name = "";
        if (this.panels.length){
          name = this.panels.slice(-1)[0].content.getTitle();
        }
        return name;
      }
    },
    methods: {
      closePanel: function(){
        sidebarService.closePanel();
      },
      isMobile: function(){
        return isMobile.any
      }
    }
});

module.exports = {
  SidebarService: sidebarService,
  SidebarComponent: SidebarComponent
};

},{"../html/sidebar-item.html":8,"../html/sidebar.html":9,"./barstack.js":12,"sdk/core/g3wobject":34,"sdk/core/i18n/i18n.service":39,"sdk/core/utils/utils":77}],19:[function(require,module,exports){
var t = require('sdk/core/i18n/i18n.service').t;
require('sdk/gui/vue/vue.directives');
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ComponentsRegistry = require('sdk/gui/componentsregistry');
var GUI = require('sdk/gui/gui');
// temporaneo per far funzionare le cose
var config = {
  client:{}
};
// vado a recuperare le parti che compongono l'applicazione
var sidebar = require('./sidebar');
var floatbar = require('./floatbar');
var viewport = require('./viewport');
var AppUI = require('./applicationui');
var layout = require('./layout');

// forse da trovare un posto migliore per attivare lo spinner iniziale...
layout.loading(true);
// classe che serve per instaziare e settare il template dell'applicazione
var ApplicationTemplate = function(templateConfig, ApplicationService) {
  self = this;
  this.templateConfig = templateConfig;
  this.init = function() {
    var config = ApplicationService.getConfig();
    // fa il setup dell'interfaccia
    // dichiarando i metodi generali dell'applicazione GUI.showForm etc ..
    this._setupInterface();
    // fa il setup del layout
    this._setupLayout();
    //vado a registrare tutti i servizi dell'appilazione
    this._setUpServices();
  };

  // setup layout
  // funzione che registra i componenti vue dell'applicazione
  this._setupLayout = function(){
    Vue.filter('t', function (value) {
      return t(value);
    });

    // veramente brutto ma ora non saprei fare diversamente: quando non siamo su mobile definiamo un left per dare spazio al sidebar-aside-toggle
    if (!isMobile.any) {
      $("<style type='text/css'> .ol-control-tl {" +
        "top: 7px;" +
        "left:43px;" +
      "}</style>").appendTo("head");
    }
    // Inizializzo i componenti vue dell'applicazione
    // prima che venga istanziato l'oggetto vue padre
    Vue.component('sidebar', sidebar.SidebarComponent);
    Vue.component('viewport', viewport.ViewportComponent);
    Vue.component('floatbar', floatbar.FloatbarComponent);
    Vue.component('app', AppUI);
    //inizializza l'applicazione Vue oggetto vue padre dell'applicazione
    var app = new Vue({
      el: '#app',
      mounted: function() {
        //una volta che l'istanza vue è pronta
        // inzio a costruire il template aggiungendo i vari componenti
        self._buildTemplate();
        // faccio il localize
        $(document).localize();
        this.$nextTick(function(){
          // setto la viewport passadogli la configurazione del viewport dell'applicazione
          self._setViewport(self.templateConfig.viewport);
          // emetto l'evento ready
          self.emit('ready');
          GUI.ready();
        });
      }
    });
  };
  //funzione che server per registrare tutti i servizi legati
  // alle vaie pari dell'appliazione
  this._setUpServices = function() {
    // registro i servizi dei componenti principali applicazione
    // sidebar, viewport etc..
    _.forEach(ApplicationTemplate.Services, function(service, element) {
      ApplicationService.registerService(element, service);
    });
    // registro tutti i servizi del componenti figli
    _.forEach(GUI.getComponents(), function(component) {
      ApplicationService.registerService(component.id, component.getService());
    })
  };
  // funzione che costruice il template
  this._buildTemplate = function() {
    var self = this;
    floatbar.FloatbarService.init(layout);
    // recupero i plceholders dalla configurazione del template
    var placeholdersConfig = this.templateConfig.placeholders;
    // ciclo su ogni placeholder
    _.forEach(placeholdersConfig, function(options, placeholder) {
      // per ogni placeholder ci possono essere più componenti ciclo e aggiungo
      //che vuol dire montare i varic componenti vue nei rispettivi placeholder
      self._addComponents(options.components, placeholder);
    });
    //registro altri componenti che non hanno una collocazione spaziale precisa
    // come da esempio QueryResultsComponent, form  che possono essere montati sulla floatbar o altre parti del template
    this._addOtherComponents();
  };

  //aggiungere compineti non legati ad un placeholder
  this._addOtherComponents = function() {
    var self = this;
    // verifico che ci siano altrimcomponenti rispetto a quelli in posizione standard
    if (this.templateConfig.othercomponents) {
      self._addComponents(this.templateConfig.othercomponents);
    }
  };
  // metodo per il setting della vieport
  this._setViewport = function(viewportOptions) {
    // sono passati i componenti della viewport
    // es.: map e content
    /*

    components: {
      map: new MapComponent({
        id: 'map'
      }),
      content: new ContentsComponent({
        id: 'content',
      })
     }

     */
    if (viewportOptions) {
      // inizializzo il service della viewport
      ApplicationTemplate.Services.viewport.init(viewportOptions);
      // passo i componenti della viewport per essere aggiunti alla viewport
      this._addComponents(viewportOptions.components);
    }
  };
  // aggiunge componente al template
  this._addComponent = function(component, placeholder) {
    this._addComponents([component], placeholder);
  };
  // aggiunge componenti al template e registra con componentregistry
  this._addComponents = function(components, placeholder) {
    var register = true;
    // qui entro solo e soltanto se è stato passato un placeholder e che questo
    // sia tra i componeti dei placeholders previsti
    // ad esempio nel caso della vieport (setViewport) non viene passato nessun placeholder
    // e quindi non viene chiamato addComponet del servizio viewport in quanto è
    // chaitao quando viene inizializzazto (chiamato init) del servizio
    if (placeholder && ApplicationTemplate.PLACEHOLDERS.indexOf(placeholder) > -1) {
      // recupero il service del placeholder associato (sidebar, navbar etc..)
      var placeholderService = ApplicationTemplate.Services[placeholder];
      // se non è nullo o vuoto
      if (placeholderService) {
        // delego il servizio del placheholder di aggiungere il componente
        register = placeholderService.addComponents(components);
      }
    }
    // ciclo sui componenti
    _.forEach(components, function(component) {
      // verifico se è stato registrato
      // nel cosa in cui non è stato registrato (esempio caso otherscomponents)
      if (register) {
        // registro il componente
        ComponentsRegistry.registerComponent(component);
      }
    })
  };
  // rimuovo il componente andando a toglierlo al component registry
  this._removeComponent = function(componentId) {
    ComponentsRegistry.unregisterComponent(componentId);
  };
  // funzione che visualizza la modelae overlay
  this._showModalOverlay = function(bool) {
    var mapService = GUI.getComponent('map').getService();
    if (bool) {
      mapService.startDrawGreyCover();
    } else {
      mapService.stopDrawGreyCover();
    }
  };
  this._showSidebar = function() {
    //codice qui
  };
  this._hideSidebar = function() {
    //codice qui
  };
  // setup dell'interfaccia dell'applicazione
  // qui definisco i metodi generali dell'applicazione
  // per poter interagire con essa attraverso maggiormente con l'oggetto GUI
  this._setupInterface = function() {
    /* DEFINIZIONE INTERFACCIA PUBBLICA */
    /* Metodi comuni a tutti i template */
    GUI.layout = layout;
    GUI.addComponent = _.bind(this._addComponent, this);
    GUI.removeComponent = _.bind(this._removeComponent, this);
    /* Metodi da definire (tramite binding) */
    GUI.getResourcesUrl = _.bind(function() {
      return ApplicationService.getConfig().resourcesurl;
    },this);
    //LIST
    GUI.showList = _.bind(floatbar.FloatbarService.showPanel, floatbar.FloatbarService);
    GUI.closeList = _.bind(floatbar.FloatbarService.closePanel, floatbar.FloatbarService);
    GUI.hideList = _.bind(floatbar.FloatbarService.hidePanel, floatbar.FloatbarService);
    // TABLE
    GUI.showTable = function() {};
    GUI.closeTable = function() {};
    //esempio di metodo generico Aside Results e Form etc...
    // metodo che restituisce il metodo GUI
    // a cui passare oggetto per la visualizzazione del Panello sul content component
    GUI.showContentFactory = function(type) {
      var showPanelContent;
      switch (type) {
        case 'query':
          showPanelContent = GUI.showQueryResults;
          break;
        case 'form':
          showPanelContent = GUI.showForm;
          break;
      }
      return showPanelContent;
    };
    // funzione per la visualizzazione del form
    // viene utilizzata ad esempio dall'editor per visualizzare il form nel content component
    GUI.showForm = function(options) {
      // recupero il compomponete Form base
      var FormComponent = require('sdk').gui.vue.FormComponent;
      // verifico che sia stato definito un formcomponent dall'editor custom del plugin
      // Istanzio sempre un componente nuovo
      var formComponent = options.formComponent ? new options.formComponent :  new FormComponent({
        id: 'form'
      });
      //recupero il servizio (che darà sempre una nuova istanza)
      var formService = formComponent.getService();
      // inizializzo il form con le opzioni ad esempio passate dall'editor (fields, relations etc..)
      formService.setInitForm(options);
      // agggiunto un ulteriore parametro closable che di default è true
      // e quindi sarà possibile chidere il pannello con la x
      // parametri : [content, title, push, perc, split, closable]
      GUI.setContent({
        content: formComponent,
        push: false, //significa che ci deve essere solo lui( cancellando eventuali precedenti form)
        closable: false
      });
      //ritorno il formService
      return formService;
    };
    // chiudo il form che chiama il metodo removeContent del service viewport
    GUI.closeForm = function() {
      viewport.ViewportService.removeContent();
      // forzo a far si che il modale venga tolto
      GUI.setModal(false);
    };

    // chide la colonna di dentra del content
    // ritorna una promise
    GUI.closeContent = function() {
      return viewport.ViewportService.closeContent();
    };

    // funzione per la visuzlizzazione dei risultati
    GUI.showQueryResults = function(title, results) {
      // prendo il componente
      var queryResultsComponent = GUI.getComponent('queryresults');
      // prendo il servizio del componente
      var queryResultService = queryResultsComponent.getService();
      queryResultService.reset();
      if (results) {
        queryResultService.setQueryResponse(results);
      }
      var contentsComponent = GUI.getComponent('contents');
      //vado a verificare se non c'è contentuto oppure se è stato fatta una sola query
      if (!contentsComponent.getContentData().length || (contentsComponent.getContentData().length == 1 && contentsComponent.getCurrentContentData().content.getId() == 'queryresults')) {
        GUI.showContextualContent(
          {
            content: queryResultsComponent,
            title: "Risultati " + title
          }
        );
      } else {
        if (contentsComponent.getCurrentContentData().content.getId() == 'queryresults') {
          contentsComponent.popContent();
        }
        GUI.pushContent({
          content: queryResultsComponent,
          backonclose: true,
          closable:false,
          perc: 50,
          title: "Risultati " + title
        });
      }
      return queryResultService;
    };
    //temporaneo show panel
    GUI.showPanel = _.bind(sidebar.SidebarService.showPanel, sidebar.SidebarService);
    GUI.closePanel = _.bind(sidebar.SidebarService.closePanel, sidebar.SidebarService);

    /* ------------------ */

    toastr.options.positionClass = 'toast-top-center';
    toastr.options.preventDuplicates = true;
    toastr.options.timeOut = 2000;

    /* --------------------- */
    // proxy della libreria toastr
    GUI.notify = toastr;
    // proxy della libreria bootbox
    GUI.dialog = bootbox;
    /* spinner */
    GUI.showSpinner = function(options){
      var container = options.container || 'body';
      var id = options.id || 'loadspinner';
      var where = options.where || 'prepend'; // append | prepend
      var style = options.style || '';
      var transparent = options.transparent ? 'background-color: transparent' : '';
      var center = options.center ? 'margin: auto' : '';
      if (!$("#"+id).length) {
        $(container)[where].call($(container),'<div id="'+id+'" class="spinner-wrapper '+style+'" style="'+transparent+'"><div class="spinner '+style+'" style="'+ center+'"></div></div>');
      }
    };
    //fa sparire lo spinner di caricamento
    GUI.hideSpinner = function(id){
      $("#"+id).remove();
    };
    /* end spinner*/
    /* fine metodi comuni */

    /* Metodi specifici del template */
    // FLOATBAR //
    GUI.showFloatbar = function() {
      floatbar.FloatbarService.open();
    };
    GUI.hideFloatbar = function() {
      floatbar.FloatbarService.close();
    };
    // SIDEBAR //
    GUI.showSidebar = _.bind(this._showSidebar, this);
    GUI.hideSidebar = _.bind(this._hideSidebar, this);
    // MODAL
    GUI.setModal = _.bind(this._showModalOverlay, this);

    // VIEWPORT //
    GUI.setPrimaryView = function(viewName) {
      viewport.ViewportService.setPrimaryView(viewName);
    };
    // Mostra la mappa nascondendo la vista dei contenuti
    GUI.showMap = function() {
      viewport.ViewportService.showMap();
    };
    // Mostra la mappa come vista aside (nel caso sia attiva la vista contenuti). Percentuale di default 30%
    GUI.showContextualMap = function(perc,split) {
      perc = perc || 30;
      viewport.ViewportService.showContextualMap({
        perc: perc,
        split: split
      })
    };
    GUI.setContextualMapComponent = function(mapComponent) {
      viewport.ViewportService.setContextualMapComponent(mapComponent);
    };
    GUI.resetContextualMapComponent = function() {
      viewport.ViewportService.resetContextualMapComponent();
    };
    // Mostra il contenuto (100%)
    GUI.showContent = function(options) {
      options =  options || {};
      options.perc = 100;
      GUI.setContent(options);
    };
    // Mostra il contenuto. Il contenuto può essere una string HTML,
    // un elemento DOM o un componente Vue. Percentuale di default 50%
    GUI.showContextualContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 50;
      GUI.setContent(options)
    };
    // funzione che server ad aggiungere il componente
    // allo stack del content (in append)
    // Le differenze rispetto a setContent sono :
    //  - nel fatto che push è sempre a true e quindi il component viene impilato su altro componente
    //  - ha un parametro in più che è il backonclose che specifica se nel cosa venga clicckato sulla x
    //    il contentComponet viene chiuso totalmente e lo stack resettato o rimosso solo quel componete
    GUI.pushContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 100;
      options.push = true;
      GUI.setContent(options);
    };
    // Aggiunge contenuto allo stack
    GUI.pushContextualContent = function(options) {
      options =  options || {};
      options.perc = options.perc || 50;
      options.push = true;
      GUI.setContent(options);
    };
    // funzione che setta i parametri del contenuto del content
    // come il componete etc..
    GUI.setContent = function(options) {
      options = options || {};
      // vado a verificare le opzioni passate e setto valori di default
      // in caso di mancata assegnazione
      options.content = options.content || null;
      options.title = options.title || "";
      options.push = _.isBoolean(options.push) ? options.push : false;
      options.perc = options.perc || 0;
      options.split = options.split || 'h';
      options.backonclose = _.isBoolean(options.backonclose) ? options.backonclose : false;
      options.showtitle = _.isBoolean(options.showtitle) ? options.showtitle : true;
      // chiamo il metodo showContent del servizio
      // viewport per poter visualizzare il content
      viewport.ViewportService.showContent(options);
    };

    /* FINE VIEWPORT */
    /* fine metodi specifici */
    /* FINE DEFINIZIONE INTERFACCIA PUBBLICA */
  };
  base(this);
};

inherit(ApplicationTemplate,G3WObject);

// funzione di classe
ApplicationTemplate.fail = function(bootstrap, errorMsg) {
  layout.loading(false);
  if (!layout.bootstrap) layout.bootstrap = bootstrap;
  layout.reload(errorMsg);
};

// questi sono i plceholder previsti ne standard dell'applicazione
ApplicationTemplate.PLACEHOLDERS = [
  'navbar',
  'sidebar',
  'viewport',
  'floatbar'
];

// questi sono i servizi dei contenitori di componenti
ApplicationTemplate.Services = {
  navbar: null,
  sidebar: sidebar.SidebarService,
  viewport: viewport.ViewportService,
  floatbar: sidebar.FloatbarService
};

module.exports =  ApplicationTemplate;


},{"./applicationui":11,"./floatbar":14,"./layout":15,"./sidebar":18,"./viewport":20,"core/g3wobject":34,"core/utils/utils":77,"sdk":158,"sdk/core/i18n/i18n.service":39,"sdk/gui/componentsregistry":111,"sdk/gui/gui":118,"sdk/gui/vue/vue.directives":157}],20:[function(require,module,exports){
var inherit = require('sdk').core.utils.inherit;
var base = require('sdk').core.utils.base;
var G3WObject = require('sdk').core.G3WObject;
var GUI = require('sdk').gui.GUI;

// calsse servizio della viewport
var ViewportService = function() {
  // contiene lo stato della viewport
  this.state = {
    primaryView: 'map', // di default la vista primaria è la prima
    // percentuale della secondary view
    secondaryPerc: 0,
    // come viene splittatta la vista (h = orizzontale, v = verticale)
    split: 'h',
    //mappa
    map: {
      sizes: {
        width: 0,
        height: 0
      },
      aside: false
    },
    //content
    content:{
      sizes: {
        width: 0,
        height: 0
      },
      aside: true,
      stack: [], // array contentente gli elementi nello stack del contents
      closable: true, // specifica se chiudibile o meno (presenza della x)
      backonclose: false, // se al click della x deve essere chiso il contenuto tutto o toglierer l'ultomo contenuto dalla stack
      contentsdata:[] // array contenete i dati del content
    }
  };
  // sono i contentuti della viewport (mappa e content)
  this._components = {
    map: null,
    content: null
  };
  // contenuti di default
  this._defaultMapComponent;
  this._contextualMapComponent;

  // altezza e largezza minima della secondary view
  // imposte per evitare che la secondaryView (principalmente il content) possa diventare
  // molto piccola (esempio impostando un perc = 1) e quindi rendere illeggibile
  // il contenuto
  this._secondaryViewMinWidth = 300;
  this._secondaryViewMinHeight = 200;
  // attributo che serve per
  this._immediateComponentsLayout = true;
  /* INTERFACCIA PUBBLICA */
  // funzione che va ad aggiungere i comnponenti alla viewport
  // funzione di inizialilizzazione
  this.init = function(options) {
    var options = options || {};
    // verifica se è stata settata/specificata la primary view altrimenti mette la mappa di default
    this.state.primaryView = options.primaryview ? options.primaryview : 'map';
    // verifica se è stato settato la modalità di splitting altrimenti mette quello orizzontale
    this.state.split = options.split ? options.split : 'h';
    // aggiunge i componenti ( che sono map e content)
    this._addComponents(options.components);
  };

  // aggiunge i componenti alla viewport
  this._addComponents = function(components) {
    var self = this;
    // components è un oggetto contente chiave nome componente e valure istanza componente
    // nel caso attuale (vedi index.js)
    /*
     {
      map: new MapComponent({
        id: 'map'
      }),
      content: new ContentsComponent({
        id: 'contents'
      })
     }
     */
    _.forEach(components, function(component, viewName) {
      // verifica che i componenti siano map o content
      if (['map', 'content'].indexOf(viewName) > -1) {
        // monto (chiamo il metodo mount che tuttti i componeti hanno) componente sull'id specifico del componenti della mappa
        // map e content
        // monto con append a true
        component.mount('#g3w-view-'+viewName, true)
          .then(function() {
            // una volta che è stato montato aggiungo
            // all'array components
            self._components[viewName] = component;
            // verifico se il nome della view è la mappa
            if (viewName == 'map') {
              // setto il il componete come componente mappa di default
              self._defaultMapComponent = component;
            }
          });
      }
    })
  };


  // funzione showMap per la visulizzazione della mappa
  this.showMap = function() {
    this._toggleMapComponentVisibility(this._defaultMapComponent,true);
    this._components['map'] = this._defaultMapComponent;
    this._showView('map');
  };

  this.showContextualMap = function(options) {
    var self = this;
    if (!this._contextualMapComponent) {
      this._contextualMapComponent = this._defaultMapComponent;
    }
    if (this._contextualMapComponent != this._defaultMapComponent) {
      this._toggleMapComponentVisibility(this._defaultMapComponent,false);
    }
    if (!this._contextualMapComponent.ismount()) {
      var contextualMapComponent = this._contextualMapComponent;
      contextualMapComponent.mount('#g3w-view-map', true)
        .then(function(){
          self._components['map'] = contextualMapComponent;
        });
    }
    else {
      self._components['map'] = this._contextualMapComponent;
      this._toggleMapComponentVisibility(this._contextualMapComponent,true);
    }
    this._showView('map',options);
  };

  // funzione che recupera il componente mappa di default
  this.recoverDefaultMap = function() {
    // se il componente mappa è diversa dal componente mappa di default
    if (this._components['map'] != this._defaultMapComponent) {
      this._components['map'] = this._defaultMapComponent;
      this._toggleMapComponentVisibility(this._contextualMapComponent,false);
      this._toggleMapComponentVisibility(this._defaultMapComponent,true);
    }
  };

  this.setContextualMapComponent = function(mapComponent) {
    var self = this;
    if (mapComponent == this._defaultMapComponent) {
      return;
    }
    if (this._contextualMapComponent) {
      this._contextualMapComponent.unmount();
    }
    this._contextualMapComponent = mapComponent;
  };

  this.resetContextualMapComponent = function() {
    if (this._contextualMapComponent) {
      this._contextualMapComponent.unmount();
    }
    this._contextualMapComponent = this._defaultMapComponent;
  };

  this._toggleMapComponentVisibility = function(mapComponent,toggle) {
    mapComponent.internalComponent.$el.style.display = toggle ? 'block' : 'none';
  };

  // chiude la mappa
  this.closeMap = function() {
    this.state.secondaryPerc = (this.state.primaryView == 'map') ? 100 : 0;
    this.recoverDefaultMap();
    this._layout();
  };

  // visualizza il contentuto della content della viewport
  /*
   options: {
     content: può essere una stringa di testo, un elemento jQuery o un componente Vue
     title: il title da mostrare nella finestra dei contenuti
     push (opzionale, default false): se il contenuto deve essere impilato sul precedente (con possibilità di tornare indietro nello stack dei contenuti (contentStack)
     split (opzionale, default 'h'): 'h' || 'v' splittare le finestre orizzontalmente o verticalmente. per ora testato solo orizzontalmente
     perc (opzionale, default 50): valore numerico, indica la percentuale delle finestra dei contenuti (es. 33 -> 2/3 saranno di mappa e 1/3 di contenuti)
   }
   */
  // funzione che è chiamata da GUI.setContent per visualizzare conentuto all'interno del content component
  this.showContent = function(options) {
    var self = this;
    // verifica se è stato settato l'opzione push
    options.push = options.push || false;
    // vado a settare tutti i parametri per il content come la parcentuale, titolo, etc ..
    this._prepareContentView(options);
    // setto immediateComponentsLayout a false
    this._immediateComponentsLayout = false;
    this._showView('content', options, true);
    self._components.content.setContent(options)
      .then(function(){
        //var data = self._components.content.getCurrentContentData();
        //self._prepareView(data.options);
        self._layoutComponents();
        self._immediateComponentsLayout = true;
      });
  };

  // funzione che toglie l'ultimo content al contentStack
  this.popContent = function() {
    var self = this;
    // verifica che ci sia il conentuto nel compontentStack
    if (this.state.content.contentsdata.length) {
      this.recoverDefaultMap();
      // recupero il precedente content dallo stack
      var data = this._components.content.getPreviousContentData();
      self._prepareContentView(data.options);
      this._immediateComponentsLayout = false;
      this._showView('content');
      this._components.content.popContent()
        .then(function(){
          self._layoutComponents();
          self._immediateComponentsLayout = true;
        })
    }
  };

  // chiude il content
  this.closeContent = function() {
    this._components.content.removeContent();
    //fa il recover della mappa di default
    this.recoverDefaultMap();
    // chiudo la View secondaria ritornando una promise
    return this.closeSecondaryView();
  };

  // funzione che rimuove il cont dalla viewport o solo una parte
  this.removeContent = function() {
    // verifico che l'attributo backonclose sia true o false
    // per fare in modo che lo stack del contentStack si completamente rimosso
    // o tolto solamente il componente
    if (this.state.content.backonclose && this.state.content.contentsdata.length > 1) {
      this.popContent();
    } else {
      this._components.content.removeContent();
      //fa il recover della mappa di default
      this.recoverDefaultMap();
      // chido la View secondaria
      return this.closeSecondaryView();
    }
  };

  // risposte se è view primaria
  this.isPrimaryView = function(viewName) {
    return this.state.primaryView == viewName;
  };

  // metodo per definire qual'è la vista primaria
  this.setPrimaryView = function(viewTag) {
    if (this.state.primaryView != viewTag) {
      this.state.primaryView = viewTag;
    }
    this._layout();
  };

  // visualizza la primary view a seconda della percentuale passata come argomento
  this.showPrimaryView = function(perc) {
    if (perc && this.state.secondaryVisible && this.state.secondaryPerc == 100) {
      this.state.secondaryPerc = 100 - perc;
      this._layout();
    }
  };

  // metodo per la visualizzazione della vista secondaria
  // nella maggior parte dei casi è il content
  this.showSecondaryView = function(split, perc) {
    // setto la visibilità dello stato della seconda view
    this.state.secondaryVisible = true;
    this.state.split = split ? split : this.state.split;
    this.state.secondaryPerc = perc ? perc : this.state.perc;
    // richiamo la funzione layout
    this._layout();
  };

  // chiudo la view secondaria
  this.closeSecondaryView = function(componentId) {
    var d = $.Deferred();
    var self = this;
    var secondaryViewComponent = this._components[this._otherView(this.state.primaryView)];
    if (secondaryViewComponent.clearContents) {
      secondaryViewComponent.clearContents()
        .then(function(){
          self.state.secondaryVisible = false;
          self._layout();
          Vue.nextTick(function() {
            d.resolve();
          })
        });
    }
    else {
      this.state.secondaryVisible = false;
      // questo è il metodo che esegue il layout delle viste,
      // e dà ad ogni componente l'opportunità di ricalcolare il proprio layout
      this._layout();
      Vue.nextTick(function() {
        d.resolve();
      })
    }
    return d.promise();
  };

  //ritorna il valore di default della percentuale della view a sconda del tipo
  // di content
  this.getDefaultViewPerc = function(viewName) {
    return this.isPrimaryView(viewName) ? 100 : 50;
  };

  // ritorna la vista opposta rispoetto a quella passata
  this._otherView = function(viewName) {
    return (viewName == 'map') ? 'content' : 'map';
  };

  this._isSecondary = function(view) {
    return this.state.primaryView != view;
  };

  // meccanismo per il ricalcolo delle dimensioni della viewport e dei suoi componenti figli
  this._setPrimaryView = function(viewTag) {
    if (this.state.primaryView != viewTag) {
      this.state.primaryView = viewTag;
    }
  };

  // setto gli attributi del content della viewport
  this._prepareContentView = function(options) {
    this.state.content.preferredPerc = options.perc || this.getDefaultViewPerc('content');
    this.state.content.title = options.title;
    this.state.content.closable =  _.isNil(options.closable) ? true : options.closable;
    this.state.content.backonclose = _.isNil(options.backonclose) ? true : options.backonclose;
    this.state.content.contentsdata = this._components.content.contentsdata;
  };

  // metodo che si occupa delle gestione di tutta la logica di visualizzazione delle due viste (mappa e contenuti)
  // viewName può essere: map o content
  // le opzione specificano percentuali , splitting tittolo etc ..
  this._showView = function(viewName, options) {
    options = options || {};
    // prende il parametro percentuale
    var perc = options.perc || this.getDefaultViewPerc(viewName);
    // prende la tipologia di split della viewport
    var split = options.split || 'h';
    var aside;
    // verifica se la view in question è la primaria o meno
    if (this.isPrimaryView(viewName)) {
      aside = (typeof(options.aside) == 'undefined') ? false : options.aside;
    }
    else {
      aside = true;
    }
    // setto il valore di aside della view
    this.state[viewName].aside = aside;
    // calcolo la percentuale della view secondaria
    var secondaryPerc = this.isPrimaryView(viewName) ? 100 - perc : perc;
    if (secondaryPerc > 0) {
      // vado a visualizzare la secondaru view
      this.showSecondaryView(split, secondaryPerc);
    } else {
      // vado a chidere la view secondaria
      return this.closeSecondaryView();
    }
  };

  // funzione che restituisce le misure in alterzza e larghezza per cui
  // il contentuo deve essere spostato per evitare che venga messo sotto
  //sidebar-aside-toggle nel caso di un content al 100% a tutta viewport
  this._getReducedSizes = function(){
    var contentEl = $('.content');
    var reducedWidth = 0;
    var reducedHeight = 0;
    if (contentEl && this.state.secondaryVisible && this.state.secondaryPerc == 100) {
      var sideBarToggleEl = $('.sidebar-aside-toggle');
      if (sideBarToggleEl && sideBarToggleEl.is(':visible')) {
        var toggleWidth = sideBarToggleEl.outerWidth();
        contentEl.css('padding-left',toggleWidth + 5);
        reducedWidth = (toggleWidth - 5);
      }
    }
    else {
      contentEl.css('padding-left', 15);
    }
    return {
      reducedWidth: reducedWidth,
      reducedHeight: reducedHeight
    }
  };

  // funzione principale che si occupa dell'intero layout della vieport
  this._layout = function() {
    var self = this;
    // prende il tipo di split
    var splitClassToAdd = (this.state.split == 'h') ? 'split-h' : 'split-v';
    var splitClassToRemove =  (this.state.split == 'h') ? 'split-v' : 'split-c';
    // vengono aggiunte e rimosse le classi
    $(".g3w-viewport .g3w-view").addClass(splitClassToAdd);
    $(".g3w-viewport .g3w-view").removeClass(splitClassToRemove);
    var reducesdSizes = this._getReducedSizes();
    // setta il size delle vista
    this._setViewSizes(reducesdSizes.reducedWidth,reducesdSizes.reducedHeight);
    // cloaseMap button
    var closeMapBtn = $('#closemap-btn');
    if (!closeMapBtn.length) {
      var closeMapBtn = $('<div id="closemap-btn" @click="closeMap" style="\
        position: absolute;\
        right: 10px;\
        top: 7px;\
        line-height: 1;\
        padding: 7px 2px;\
        font-size: 1.5em;\
        background-color: #3c8dbc;\
        color: white;\
        z-index:1000;\
        height: 39px;\
        width: 39px">\
          <button class="glyphicon glyphicon-remove pull-right close-panel-button" style="background-color: transparent;border: 0px;"></button>\
        </div>');
      closeMapBtn.on('click',function(){
        self.closeMap();
      });
      var mapView = $(".g3w-viewport .map");
      mapView.append(closeMapBtn);
    }

    if (this.state.secondaryVisible) {
      if (this._isSecondary('content') && (this.state.secondaryPerc < this.state.content.preferredPerc)) {
        closeMapBtn.show()
      }
      else {
        closeMapBtn.hide();
      }
    }
    else {
      closeMapBtn.hide();
    }

    if (this._immediateComponentsLayout) {
      this._layoutComponents();
    }
  };

  // funzione che setta i size delle view (primaria e secondari)
  this._setViewSizes = function() {
    // view primaria e secondaria
    var primaryView = this.state.primaryView;
    // recupera la seconda View che è non è la primary (verosimilmente 'content')
    var secondaryView = this._otherView(primaryView);
    // altezza e larghezza della viewport
    var viewportWidth = this._viewportWidth();
    var viewportHeight = this._viewportHeight();
    // asegna alla primary view l'altezza e la larghezza della viewport
    var primaryWidth = viewportWidth;
    var primaryHeight = viewportHeight;
    var scale = this.state.secondaryPerc / 100;
    // verifica il tipo di plistting
    // caso orizzontale
    if (this.state.split == 'h') {
      secondaryWidth = this.state.secondaryVisible ? Math.max((viewportWidth * scale),this._secondaryViewMinWidth) : 0;
      secondaryHeight = viewportHeight;
      primaryWidth = viewportWidth - secondaryWidth;
      primaryHeight = viewportHeight;
    }
    else {
      secondaryWidth = viewportWidth;
      secondaryHeight = this.state.secondaryVisible ? Math.max((viewportHeight * scale),this._secondaryViewMinHeight) : 0;
      primaryWidth = viewportWidth;
      primaryHeight = viewportHeight - secondaryHeight;
    }
    // riassegno le giuste proporzione in sia height e width alla primary e secondary view
    // primary ViewSizes
    this.state[primaryView].sizes.width = primaryWidth;
    this.state[primaryView].sizes.height = primaryHeight;
    // secondaryViewSizes
    this.state[secondaryView].sizes.width = secondaryWidth;
    this.state[secondaryView].sizes.height = secondaryHeight;
  };

  // funzione che restituisce l'altezza che deve avere la viewPort
  this._viewportHeight = function() {
    var topHeight = $(".navbar").innerHeight();
    return $(window).innerHeight() - topHeight;
  };

  // funzione che restituisce la larghezza della view
  this._viewportWidth = function() {
    // prendo la posizione della posizione a sinistra
    // della sidebar
    var offset = $(".main-sidebar").offset().left;
    var width = $(".main-sidebar").innerWidth();
    var sideBarSpace = width + offset;
    // resituisco la larghezza riservata alla viewport
    return $(window).innerWidth() - sideBarSpace;
  };

  // funzione che va a caricare i componenti (della viewport)
  // solo dopo che le size delle view sono state corrette
  this._layoutComponents = function() {
    var self = this;
    Vue.nextTick(function(){
      var reducesdSizes = self._getReducedSizes();
      reducedWidth = reducesdSizes.reducedWidth || 0;
      reducedHeight = reducesdSizes.reducedHeight || 0;
      _.forEach(self._components, function(component, name) {
        // viene chiamato il metodo per il ricacolo delle dimensioni nei componenti figli
        var width = self.state[name].sizes.width - reducedWidth ;
        var height = self.state[name].sizes.height - reducedHeight;
        // ogni componente (mappa e contenuto) qui
        // ha l'opportunità di ricalcolare il proprio il layout.
        // Usato per esempio dalla mappa per reagire al resize della viewport
        component.layout(width, height);
      })
    });
  };

  // funzione che viene chiamata la prima volta che
  // si instanzia la viewport
  this._firstLayout = function() {
    var self = this;
    var drawing = false;
    var resizeFired = false;

    // funzione che fa il trigger del resize
    function triggerResize() {
      resizeFired = true;
      drawResize();
    }

    function drawResize() {
      if (resizeFired === true) {
        resizeFired = false;
        drawing = true;
        // chiama la funzione che si occupa ti settare
        // il layout della viewport
        self._layout(true);
        //funzione javascript nativa del browser (html5) che serve
        // per il Controllo temporizzazione per animazioni basate su script
        requestAnimationFrame(drawResize);
      } else {
        drawing = false;
      }
    }
    // registra la funzione che deve essere lanciata una volta che
    // la GUI e pronta (si ha quando è stato chiamato il metodo _buildTemplate di template.js)
    // che non fa altro che aggiungere alle varie parti dell'applicazione
    GUI.on('ready',function(){
      // prendo al primary view (verosimilmente 'map')
      var primaryView = self.state.primaryView;
      // secondary view 'content' di solito
      var secondaryView = self._otherView(primaryView);
      // seleziono l'elemento secondario con JQuery
      var secondaryEl = $(".g3w-viewport ."+secondaryView);
      // prendo (se esiste il valore css della seconday view min-width)
      var secondaryViewMinWidth = secondaryEl.css('min-width');
      if ((secondaryViewMinWidth != "") && !_.isNaN(parseFloat(secondaryViewMinWidth))) {
        self._secondaryViewMinWidth =  parseFloat(secondaryViewMinWidth);
      }
      var secondaryViewMinHeight = secondaryEl.css('min-height');
      if ((secondaryViewMinHeight != "") && !_.isNaN(parseFloat(secondaryViewMinHeight))) {
        self._secondaryViewMinHeight =  parseFloat(secondaryViewMinHeight);
      }
      self._layout(true);
      // resize scatenato da GUI
      GUI.on('guiresized',function() {
        triggerResize();
      });
      // resize della window
      $(window).resize(function() {
        // set resizedFired to true and execute drawResize if it's not already running
        if (drawing === false) {
          triggerResize();
        }
      });
      // resize sul ridimensionamento della sidebar
      $('.main-sidebar').on('webkitTransitionEnd transitionend msTransitionEnd oTransitionEnd', function () {
        $(this).trigger('trans-end');
        triggerResize();
      });
    });
  };
  this._firstLayout();
  base(this);
};
// eredita da G3WOBJECT
inherit(ViewportService, G3WObject);

//singleton
var viewportService = new ViewportService;

// COMPONENTE VUE VIEWPORT
var ViewportComponent = Vue.extend({
  template: require('../html/viewport.html'),
  data: function() {
    return {
      state: viewportService.state // lo stato del compoente è quello del servizio
    }
  },
  computed: {
    // proprietà derivata (booleana) che è legata al contentsdata dell'oggetto content
    showtitle: function() {
      var showtitle = true;
      // prende l'array di componenti dello stack del content
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length) {
        var options = contentsData[contentsData.length - 1].options;
        if (_.isBoolean(options.showtitle)) showtitle = options.showtitle;
      }
      return showtitle;
    },
    contentTitle: function() {
      // cambia il titolo prendendo l'ultimo elemento aggiunto alla stack
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length) {
        return contentsData[contentsData.length - 1].options.title;
      }
    },
    previousTitle: function() {
      // prende il titolo del precendete elemento
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length > 1) {
        if (!contentsData[contentsData.length - 2].options.title) {
          return 'indietro'
        }
        return 'a ' + contentsData[contentsData.length - 2].options.title;
      }
      return false;
    },
    contentSmallerThenPreferred: function() {
      return this.state.secondaryPerc < this.state.content.preferredPerc;
    }
  },
  methods: {
    closeContent: function() {
      viewportService.removeContent();
    },
    closeMap: function() {
      viewportService.closeMap();
    },
    gotoPreviousContent: function() {
      viewportService.popContent();
    }
  }
});

module.exports = {
  ViewportService: viewportService,
  ViewportComponent: ViewportComponent
};

},{"../html/viewport.html":10,"sdk":158}],21:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var reject = require('core/utils/utils').reject;

function ApiService(){
  this._config = null;
  this._baseUrl = null;
  this.init = function(config) {
    var deferred = $.Deferred();
    this._config = config;
    // prende l'url base delle api dal config dell'applicazione
    this._baseUrl = config.urls.api;
    this._apiEndpoints = config.urls.apiEndpoints;
    deferred.resolve();
    return deferred.promise();
  };
  //incrementi
  var howManyAreLoading = 0;
  this._incrementLoaders = function(){
    if (howManyAreLoading == 0){
      this.emit('apiquerystart');
    }
    howManyAreLoading += 1;
  };
  
  this._decrementLoaders = function(){
    howManyAreLoading -= 1;
    if (howManyAreLoading == 0){
      this.emit('apiqueryend');
    }
  };
  this.get = function(api, options) {
    var self = this;
    var apiEndPoint = this._apiEndpoints[api];
    if (apiEndPoint) {
      var completeUrl = this._baseUrl + '/' + apiEndPoint;
      if (options.request) {
         completeUrl = completeUrl + '/' + options.request;
      }
      var params = options.params || {};
      
      self.emit(api+'querystart');
      this._incrementLoaders();
      return $.get(completeUrl,params)
      .done(function(response){
        self.emit(api+'queryend',response);
        return response;
      })
      .fail(function(e){
        self.emit(api+'queryfail',e);
        return e;
      })
      .always(function(){
        self._decrementLoaders();
      });
    }
    else {
      return reject();
    }
  };
  base(this);
}

inherit(ApiService,G3WObject);

module.exports = new ApiService;

},{"core/g3wobject":34,"core/utils/utils":77}],22:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ApiService = require('core/apiservice');
var RouterService = require('core/router');
var ProjectsRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('core/plugin/pluginsregistry');
var ClipboardService = require('core/clipboardservice');

//oggetto servizio per la gestione dell'applicazione
var ApplicationService = function() {
  var self = this;
  this.secret = "### G3W Client Application Service ###";
  this.ready = false;
  this.complete = false;
  this._modalOverlay = null;
  this._acquirePostBoostrap = false;
  // oggetto che tiene tutti i servizi dei vari sidebar etc..
  // utili per il plugin
  this._applicationServices = {};
  this.config = {};
  this._initConfigUrl = null;
  this._initConfig = {};
  // chiama il costruttore di G3WObject (che in questo momento non fa niente)
  base(this);
  // funzione inizializzazione che prende la configurazione dal server
  this.init = function(config, acquirePostBoostrap){
    this._config = config;
    if (acquirePostBoostrap) {
      this._acquirePostBoostrap = true;
    }
    // lancio il bootstrap dell'applicazione
    return this._bootstrap();
  };
  // restituisce la configurazione
  this.getConfig = function() {
    return this._config;
  };
  // restituisce il router service
  this.getRouterService = function() {
    return RouterService;
  };
  // clipboard service
  this.getClipboardService = function() {
    return ClipboardService;
  };

  // funzione che ottiene la configurazione dal server
  this.obtainInitConfig = function(initConfigUrl) {
    var self = this;
    if (!this._initConfigUrl) {
      this._initConfigUrl = initConfigUrl;
    }
    var d = $.Deferred();
    //se esiste un oggetto globale initiConfig
    //risolvo con quell'oggetto
    if (window.initConfig) {
      this._initConfig = window.initConfig;
      return d.resolve(window.initConfig);
    }
    // altrimenti devo prenderlo dal server usando il percorso indicato in ?project=<percorso>
    else {
      var projectPath;
      var queryTuples;
      if (location.search) {
        queryTuples = location.search.substring(1).split('&');
        _.forEach(queryTuples, function (queryTuple) {
          //se esiste la parola project nel url
          if(queryTuple.indexOf("project") > -1) {
            //prendo il valore del path progetto (nomeprogetto/tipoprogetto/idprogetto)
            //esempio comune-di-capannori/qdjango/22/
            projectPath = queryTuple.split("=")[1];
          }
        });
      } else {
        // prevista per il reload in fase di admin
        projectPath = location.pathname.split('/').splice(-4,3).join('/');
      }
      if (projectPath) {
        var initUrl = this._initConfigUrl;
        if (projectPath) {
          initUrl = initUrl + '/' + projectPath;
        }
        //recupro dal server la configurazione di quel progetto
        $.get(initUrl)
          .then(function(initConfig) {
            //initConfig è l'oggetto contenete:
            //group, mediaurl, staticurl, user
            initConfig.staticurl = "../dist/"; // in locale forziamo il path degli asset
            initConfig.clienturl = "../dist/"; // in locale forziamo il path degli asset
            self._initConfig = initConfig;
            // setto la variabile initConfig
            window.initConfig = initConfig;
            d.resolve(initConfig);
          })
          .fail(function(error) {
            d.reject(error);
          })
      }
    }
    return d.promise();
  };

  this.getInitConfig = function() {
    return this._initConfig;
  };

  this.getInitConfigUrl = function() {
    return this._initConfigUrl;
  };

  this.setInitConfigUrl = function(initConfigUrl) {
    this._initConfigUrl = initConfigUrl;
  };

  // funzione post boostratp
  this.postBootstrap = function() {
    if (!this.complete) {
      RouterService.init();
      // una volta inizializzati i progetti e l'api service
      // registra i plugins passando gli static urls e l'oggetto plugins
      PluginsRegistry.init({
        pluginsBaseUrl: self._config.urls.staticurl,
        pluginsConfigs: self._config.plugins,
        otherPluginsConfig: ProjectsRegistry.getCurrentProject().getState()
      });
      this.complete = true;
    }
  };

  // funzione bootstrap (quando viene chiamato l'init)
  this._bootstrap = function() {
    var self = this;
    var d = $.Deferred();
    //nel caso in cui (prima volta) l'application service non è pronta
    //faccio una serie di cose
    if (!this.ready) {
      // Inizializza la configurazione dei servizi.
      // Ognungo cercherà dal config quello di cui avrà bisogno
      // una volta finita la configurazione emetto l'evento ready.
      // A questo punto potrò avviare l'istanza Vue globale
      $.when(
        // registra i progetti
        ProjectsRegistry.init(this._config),
        // inizializza api service
        ApiService.init(this._config)
      ).then(function() {
        // emetto l'evento ready
        self.emit('ready');
        if (!self._acquirePostBoostrap) {
          self.postBootstrap();
        }
        this.initialized = true;
        d.resolve();
      }).fail(function(error) {
        d.reject(error);
      })
    }
    return d.promise();
  };

  this.registerService = function(element, service) {
    this._applicationServices[element] = service;
  };

  this.unregisterService = function(element) {
    delete this._applicationServices[element];
  };

  this.getService = function(element) {
    return this._applicationServices[element];
  };

  this.errorHandler = function(error) {
    console.log(error);
  }

};

inherit(ApplicationService,G3WObject);


module.exports = new ApplicationService;

},{"core/apiservice":21,"core/clipboardservice":23,"core/g3wobject":34,"core/plugin/pluginsregistry":64,"core/project/projectsregistry":69,"core/router":75,"core/utils/utils":77}],23:[function(require,module,exports){
function ClipboardService() {
  this._data = {};
  this.set = function(formId, data) {
    // clipBoardId : id del form, data sono fileds e relations passate al form
    // il clipBoardForm mi serve per capire se attivare o meno la clipboard
    // se e solo se si riferisce allo stesso id
    var formLayer = formId.split('form')[0];
    this._data[formLayer] = data;
  };

  this.get = function(formLayer) {
    var data = this._data[formLayer] || {};
    this._data[formLayer] = {};
    return data;
  };

}
module.exports = new ClipboardService;

},{}],24:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var RelationEditBuffer = require('./relationeditbuffer');

function EditBuffer(editor, options) {
  var options = options || {};
  //editor a cui appartiene
  this._editor = editor;
  // clone del vector layer originale
  this._origVectorLayer = new ol.layer.Vector({
    source: new ol.source.Vector()
  });
  // clona il vector layer originale vecotr layer
  this._cloneLayer();
  //buffer delle geometrie
  this._geometriesBuffer = {};
  // buffer degli attributi
  this._attributesBuffer = {};
  // buffer degli attributi delle relazioni
  this._relationsBuffers = {};
  // verifico se sono state passate optioni come
  //ad esempio il relationEditBuffer
  this._relationEditBuffer = options.relationEditBuffer || RelationEditBuffer;
}

inherit(EditBuffer, G3WObject);

module.exports = EditBuffer;

var proto = EditBuffer.prototype;

//funzione commit
proto.commit = function() {
  var self = this;
  var vectorLayer = this._editor.getVectorLayer();
  // prendo tutte le feature dal vettore di editing dell'editor
  var newFeatures = this._editor.getEditVectorLayer().getFeatures();
  if (newFeatures) {
    //aggiungo le features nuove al layer vettoriale originale
    // che vengono visualizzate sul vector layer
    _.forEach(newFeatures, function(feature, index) {
      newFeatures[index] = self._editor._transformCoordinateFeatureFromLayerToMap(feature);
    });
    vectorLayer.addFeatures(newFeatures);
  }
  _.forEach(this._geometriesBuffer, function(geometry, featureId) {
    if (!self._isNewFeature(featureId)) {
      var feature = vectorLayer.getFeatureById(featureId);
      //caso di update .. nel caso di delete la feature è nulla
      if (feature) {
        feature = self._editor._transformCoordinateFeatureFromLayerToMap(feature);
        //RISETTO FEATURE STYLE AL VECCHIO
        feature.setStyle(null);
        vectorLayer.modifyFeatureGeometry(featureId, feature.getGeometry());
      }
    }
  });
  // faccio il clear del layere di editing
  this._editor.getEditVectorLayer().clear();
  // faccio il clear del buffer
  this._clearBuffers();
  //faccio il clone del Layer Vector originale della mappa
  this._cloneLayer();
};

proto.undoAll = function(){
  this._resetVectorLayer();
  this._clearBuffers();
};

proto.destroy = function(){
  this._clearBuffers();
};

proto.generateId = function() {
  return this._editor.generateId();
};

// funzione che agginge la feature geometrica nel buffer
// geometry
proto.addFeature = function(feature) {
  // nel caso non abbia una un id (caso nuova feature) la genero causale
  if(!feature.getId()) {
    feature.setId(this.generateId());
  }
  // aggiungo la feature al buffer (nel cso di nuova feature
  this._addEditToGeometryBuffer(feature, 'add');
};

// funzione chiamata in fase di update della Feature
proto.updateFeature = function(feature) {
  this._addEditToGeometryBuffer(feature, 'update');
};

proto.deleteFeature = function(feature, relations) {
  // aggiunge alla editbuffer la geometria della feature cancellata
  this._addEditToGeometryBuffer(feature, 'delete');
  //vado anche ad aggiungere al buffer delle relazioni da cancellare
  // relative alla feature cancellata
  this._addEditToValuesBuffers(feature, relations, 'delete');
};

// funzione che server per fare update di una feature
proto.updateFields = function(feature, relations) {
  // nel caso di una nuova feature
  if (!feature.getId()) {
    // genero id random e lo setto alla feature
    feature.setId(this.generateId());
  }// vado a chiamare la funzione che mi aggiorna i campi della feature e delle relazioni
  this._addEditToValuesBuffers(feature, relations);
};

proto.getFeatureAttributes = function(fid){
  if(this._attributesBuffer[fid]){
    return this._attributesBuffer[fid].slice(-1)[0];
  }
  return null;
};

proto.areFeatureAttributesEdited = function(fid){
  if (this._attributesBuffer[fid]){
    return this._attributesBuffer[fid].length > -1;
  }
  return false;
};
// funzione che se nel buffer delle relazioni
// è stato inserito già modifiche su relazioni di quella feature
proto.hasRelationsEdits = function(fid){
  var hasEdits = false;
  _.forEach(this._relationsBuffers[fid], function(relationBuffer) {
    hasEdits = hasEdits || relationBuffer.hasRelationElements();
  });
  return hasEdits;
};

proto.getRelationsEdits = function(fid){
  var relations = {};
  _.forEach(this._relationsBuffers[fid], function(relationBuffer){
    relations[relationBuffer.getRelationName()] = relationBuffer.getRelationElements();
  });
  return relations;
};
// funzione che colleziona tutti gli (unici) delle featues modificate
// dei buffer geometry e attribute
proto.collectFeatureIds = function() {
  var geometriesBuffers = this._geometriesBuffer;
  var attributesBuffers = this._attributesBuffer;
  var modifiedFids = [];
  modifiedFids = _.concat(modifiedFids,_.keys(geometriesBuffers));
  modifiedFids = _.concat(modifiedFids,_.keys(attributesBuffers));
  return _.uniq(modifiedFids);
};
// che colleziona tutte le modifche fatte quando viene premuto o fatto salva
// dall'editor o passaggio da un editing isNewdi un layer all'altro
proto.collectFeatures = function(state, asGeoJSON){
  var self = this;
  var asGeoJSON = asGeoJSON || false;
  // prendo il jsono format per poter poi fare il posto verso il server
  var GeoJSONFormat = new ol.format.GeoJSON();
  var modifiedFids = this.collectFeatureIds();
  var layer;
  if (state == 'new') {
    layer = self._editor.getEditVectorLayer();
  }
  else {
    layer = self._editor.getVectorLayer();
  }
  var features = [];
  _.forEach(modifiedFids, function(fid) {
    var feature = layer.getFeatureById(fid);
    var isNew = self._isNewFeature(fid);
    var addedFeature = (state == 'new' && isNew && feature);
    var updatedFeature = (state == 'updated' && !isNew && feature);
    var deletedFeature = (state == 'deleted' && !isNew && !feature);
    if (addedFeature || updatedFeature) {
      if (asGeoJSON){
        feature = GeoJSONFormat.writeFeatureObject(feature);
      }
      features.push(feature);
    }
    else if (deletedFeature) {
      features.push(fid);
    }
  });
  return features;
};

proto.createFeature = function(fid, geometry, attributes) {
  var feature = new ol.Feature();
  feature.setId(fid);
  feature.setGeometry(geometry);
  feature.setProperties(attributes);
  return feature;
};

// funzione richiamata dall'edior che mmi servono poi per inviarle via post al server
// Tale funzione riporta tutte le informazioni relative alle relazioni
proto.collectRelations = function() {
    // costruisco l'oggetto relations edit
    // che servirà per separare i tipi di azioni da fare sulle singole relazioni
    // update, add, delete
  var relationsEdits = {
    add: [],
    delete: [],
    update: []
  };
  // scorro sul relation buffers
  _.forEach(this._relationsBuffers, function(relationsBuffers, fid) {
    var newRelationEdits = {
      fid: fid,
      relations: {}
    };
    var updatedRelationEdits = {
      fid: fid,
      relations: {}
    };
    var deletedRelationEdits = {
      fid: fid,
      relations: {}
    };
    _.forEach(relationsBuffers, function (relationBuffer) {

      var relationName = relationBuffer.getRelationName();
      var newElements = relationBuffer.getRelationElementsOnlyFieldsValues('NEW');
      var updatedElements = relationBuffer.getRelationElementsOnlyFieldsValues('OLD'); // nel buffer vengono inseriti sempre tutti gli elementi preesistenti (che siano effettivamente aggiornati o meno)
      var deletedElements = relationBuffer.getRelationElementsOnlyFieldsValues('OLD_DELETED');

      var newElementsEdits = [];
      var updatedElementsEdits = [];
      var deletedElementsEdits = [];

      _.forEach(newElements,function(element){
        newElementsEdits.push({
          id: element.id,
          fields: element.fields
        })
      });

      _.forEach(updatedElements,function(element){
        updatedElementsEdits.push({
          id: element.id,
          fields: element.fields
        })
      });

      _.forEach(deletedElements,function(element){
        deletedElementsEdits.push({
          id: element.id
        })
      });

      newRelationEdits.relations[relationName] = newElementsEdits;
      updatedRelationEdits.relations[relationName] = updatedElementsEdits;
      deletedRelationEdits.relations[relationName] = deletedElementsEdits;

    });
    relationsEdits.add.push(newRelationEdits);
    relationsEdits.update.push(updatedRelationEdits);
    relationsEdits.delete.push(deletedRelationEdits);

  });
  return relationsEdits;
};

// funzione che mette in relazione feature e relazioni
// e aggiorna i campi della feature nell'editbuffer
proto._addEditToValuesBuffers = function(feature, relations) {
  // prende id della feature
  var id = feature.getId();
  // prende gli attributi della feature
  var attributes = feature.getProperties();
  // prendo il buffer degli attributi
  var attributesBuffer = this._attributesBuffer;
  //verifica se l'oggetto attributebuffer ha l'id del layer
  if (!_.has(attributesBuffer, id)) {
    //nel caso non ci sia crea la chiave e assegna un array vuoto
    attributesBuffer[id] = [];
  }
  // a quel punto inserisco una nuova modifica nell'array delle modifiche
  // che rigurada quella particolare feature identificata dalla chiave id
  // dentro negli attributi c'è anche la geometria
  attributesBuffer[id].push(attributes);
  // se snono state passate relazioni
  this._addDeleteRelationsBuffers(relations, id);
  // setto l'edito a dirty
  this._setDirty(true);
};

proto._addEditToGeometryBuffer = function(feature, operation) {
  // al momento non prende in considerazione, update , add valori di operation
  // in quanto verifica se è una nuova feature o no
  // recupero il buffer delle geometrie
  var geometriesBuffer = this._geometriesBuffer;
  // prendo il buffer degli attributi
  // recupero l'id della feature
  var id = feature.getId();
  // recupero la geometria
  var geometry = feature.getGeometry();
  // caso operazione delete
  if (operation == 'delete'){
    geometry = null;
    // prendo il layer originale o l'editing Layer
    var layer = this._isNewFeature(id) ? this._editor.getEditVectorLayer() : this._editor.getVectorLayer();
    // rimuovo la feature dalla source
    layer.getSource().removeFeature(feature);
  }
  // se non presente nel geometry buffer
  // creo array riferita a quella feature per monitorare tutte le modifice che avverranno
  // su quella feature
  if (!_.has(geometriesBuffer,id)) {
    geometriesBuffer[id] = [];
  }
  geometriesBuffer[id].push(geometry);
  this._setDirty(true);
};

proto._addDeleteRelationsBuffers = function(relations, fid) {
  var self = this;
  // se snono state passate relazioni
  if (relations) {
    // clico su ognuna di essere
    _.forEach(relations, function(relation) {
      //se esiste già nell'oggetto relation buffer legate a quella feature
      if (!_.has(self._relationsBuffers, fid)) {
        // atrimenti faccio come ho fatto sopra per il buffer degli attributi
        // ma ora sul buffer delle relazioni e non più un array ma un ogetto
        // caratterizzato dal nome della relazione
        self._relationsBuffers[fid] = {};
      }
      // verifico oltre alla chiave della feature se contiene il nome della relazione
      // che non è altro il nome del layer che in relazione con la feature del layer che si sta
      // editando
      if (!_.has(self._relationsBuffers[fid], relation.name)) {
        // se non presente creo una nuova istanza di RelationEditBuffer
        self._relationsBuffers[fid][relation.name] = new self._relationEditBuffer(self, relation.name);
      }
      // prendo l'istanza di RelationEditBuffer (creata sul momento o esistente)
      var relationBuffer = self._relationsBuffers[fid][relation.name];
      // chiamo il metodo updateRelation dell'istanza
      relationBuffer.updateRelation(relation);
    });
  }
};

// guardo se è una feature già  presente nel buffer delle nuove geometrie
proto._isNewFeature = function(fid){
  //return id.toString().indexOf('_new_') > -1;
  return this._editor.isNewFeature(fid);
};
// funzione edit buffer che chiama il set dirty
proto._setDirty = function(bool) {
  // faccio un OR logico tra quello inviato da qualsiasi punto del'edit buffer
  // o quello dal relationEditBuffer object (che si può verificare)
  // nel caso in cui faccio un clena dell'editing della relazione
  // e la verifica sei i vari buffer sono oggetti vuoti
  var isDirty = bool || !_.isEmpty(this._geometriesBuffer) || !_.isEmpty(this._attributesBuffer) || !_.isEmpty(this._relationsAttributesBuffer);
  this._editor._setDirty(isDirty);
};

proto._resetVectorLayer = function(){
  this._editor.vectoLayer = this._origVectorLayer;
  this._origVectorLayer.getSource().clear();
};

// fa il cela di tutti i buffers
// e chiama il setDirty dell'edito passanogli false
// quindi disabilitando il tasto salva per inviare le modifiche
proto._clearBuffers = function() {
  this._geometriesBuffer = {};
  this._attributesBuffer = {};
  this._relationsAttributesBuffer = {};
  this._relationsBuffers = {};
  this._editor._setDirty(false);
};
//funzione cloneLayer
proto._cloneLayer = function() {
  var clonedFeatures = [];
  //ciclo sul tutte le feature del layer vettoriale originale
  this._editor.getVectorLayer().getSource().forEachFeature(function(feature) {
    clonedFeatures.push(feature.clone());
  }, this);
  // aggiungo tali feature sul layer "originale del buffer"
  this._origVectorLayer.getSource().addFeatures(clonedFeatures);
};
},{"./relationeditbuffer":26,"core/g3wobject":34,"core/utils/utils":77}],25:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var resolve = require('core/utils/utils').resolve;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var VectorLayer = require('core/map/layer/vectorlayer');
// BASE TOOLS ////
var AddFeatureTool = require('./tools/addfeaturetool');
var MoveFeatureTool = require('./tools/movepointtool');
var ModifyFeatureTool = require('./tools/modifyfeaturetool');
var DeleteFeatureTool = require('./tools/deletefeaturetool');
var PickFeatureTool = require('./tools/pickfeaturetool');
var CutLineTool = require('./tools/cutlinetool');
/// BUFFER /////
var EditBuffer = require('./editbuffer');
// Editor di vettori puntuali
function Editor(options) {
  var options = options || {};
  // indica il componente for che verrà utilizzato dall'editor
  // in caso di operazione di editing (nuovo/edit) di una feature
  this._formComponent = options.formComponent || null;
  // servizio che gestisce l'interazione con la mappa e i suoi elementi
  this._mapService = options.mapService || {};
  // layer vettoriale associato all'editor
  this._vectorLayer = null;
  // vector layer temporaneo dove vengono effettuati gli editing temporaneamente
  this._editVectorLayer = null;
  // è la classe buffer che contiene tutte le operazioni di editing fatte
  this._editBufferClass = options.editBufferClass || EditBuffer;
  this._editBuffer = null;
  // tool attivo
  this._activeTool = null;
  // indica nel caso di true che è stato modificato il layer vettoriale
  this._dirty = false;
  // prefisso delle nuove  feature
  this._newPrefix = '_new_';
  // feature loccate
  this._featureLocks = null;
  // mi dice se è stato avviato o meno
  this._started = false;
  // definisce lo stile del vettore di editing
  this._editingVectorStyle = options.editingVectorStyle || null;
  // verifica se bisogna attivare le relazioni ONE all'aggiunta di una nuova feature
  this.checkOneRelation = options.checkOneRelation || false;
  // mi indicano quale campi non devono essere sovrascritti nel copy and paste
  this._copyAndPasteFieldsNotOverwritable = options.copyAndPasteFieldsNotOverwritable || {};
  // mi indicano i campi del layer che sono in relazione con campi di relazioni
  this._fieldsLayerbindToRelationsFileds = options.fieldsLayerbindToRelationsFileds || {};
  // tools del form come ad esempio copypaste etc ..
  this._formTools = options.formTools || ['copypaste'];
  // la picked feature
  this._pickedFeature = null;
  // form service
  this._formService = null;
  // setters listeners
  this._setterslisteners = {
    before: {},
    after: {}
  };
  // definisce il tipo di geometrie
  this._geometrytypes = [
    'Point',
    'MultiPoint',
    'LineString',
    'Line',
    'MultiLineString',
    'Polygon',
    'MultiPolygon'
  ];
  // elenco dei tool e delle relative classi per tipo di geometria (in base a vector.geometrytype)
  this._toolsForGeometryTypes = {
    'Point': {
      addfeature: AddFeatureTool,
      movefeature: MoveFeatureTool,
      deletefeature: DeleteFeatureTool,
      editattributes: PickFeatureTool
    },
    'MultiPoint': {
      addfeature: AddFeatureTool,
      movefeature: MoveFeatureTool,
      deletefeature: DeleteFeatureTool,
      editattributes: PickFeatureTool
    },
    'Line': {
      addfeature: AddFeatureTool,
      modifyvertex: ModifyFeatureTool,
      movefeature: MoveFeatureTool,
      deletefeature: DeleteFeatureTool,
      editattributes: PickFeatureTool,
      cutline: CutLineTool
    },
    'LineString': {
      addfeature: AddFeatureTool,
      modifyvertex: ModifyFeatureTool,
      movefeature: MoveFeatureTool,
      deletefeature: DeleteFeatureTool,
      editattributes: PickFeatureTool,
      cutline: CutLineTool
    },
    'Polygon': {
      addfeature: AddFeatureTool,
      modifyvertex: ModifyFeatureTool,
      movefeature: MoveFeatureTool,
      deletefeature: DeleteFeatureTool,
      editattributes: PickFeatureTool
    },
    'MultiPolygon': {
      addfeature: AddFeatureTool,
      modifyvertex: ModifyFeatureTool,
      movefeature: MoveFeatureTool,
      deletefeature: DeleteFeatureTool,
      editattributes: PickFeatureTool
    }
  };
  //ACTIVE TOOL -- ISTANZA CON I SUOI METODI E ATTRIBUTI
  this._activeTool = new function() {
    this.type = null;
    this.instance = null;
    // funzione che prende memeoria del tipo di tool e ne prende l'istanza
    this.setTool = function(type, instance) {
      this.type = type;
      this.instance = instance;
    };
    // restituisce il type
    this.getType = function() {
      return this.type;
    };
    // restituisce l'istanza
    this.getTool = function() {
      return this.instance;
    };
    // fa il clear del tool
    this.clear = function() {
      this.type = null;
      this.instance = null;
    };
  };
  // TOOLS
  //terrà traccia dei tool attivi per quel layer vettoriale
  //ad esempio nel caso di un layer Point
  //avrà tale struttura
  /*
   this._tools = {
     addfeature: AddFeatureTool,
     movefeature: MoveFeatureTool,
     deletefeature: DeleteFeatureTool,
     editattributes: PickFeatureTool
  }
  */
  this._tools = {};
  // sono i listeners di default per tutti
  this._setupAddFeatureAttributesEditingListeners();
  this._setupEditAttributesListeners();
  this._askConfirmToDeleteEditingListener();
  //this._setupMoveFeatureEditingListeners();
  //this._setupDeleteFeatureEditingListeners();

  base(this);
}

inherit(Editor, G3WObject);

var proto = Editor.prototype;

// LISTENERS COMUNI A TUTTI

// delete editing listener
proto._askConfirmToDeleteEditingListener = function() {
  var self = this;
  this.onbeforeasync('deleteFeature', function(feature, isNew, next) {
    self._deleteFeatureDialog(next);
  });
};

proto._deleteFeatureDialog = function(next) {
  GUI.dialog.confirm("Vuoi eliminare l'elemento selezionato?",function(result) {
    next(result);
  });
};

// apre form attributi per inserimento
proto._setupAddFeatureAttributesEditingListeners = function() {
  var self = this;
  this.onbeforeasync('addFeature', function(feature, next) {
    self._openEditorForm('new', feature, next);
  }, 100);
};

// apre form attributi per editazione
proto._setupEditAttributesListeners = function() {
  var self = this;
  this.onbeforeasync('pickFeature', function(feature, next) {
    var new_old = self.isNewFeature(feature.getId()) ? 'new' : 'old';
    self._openEditorForm(new_old, feature, next);
  });
};

proto.getcopyAndPasteFieldsNotOverwritable = function() {
  return this._copyAndPasteFieldsNotOverwritable;
};

proto.setcopyAndPasteFieldsNotOverwritable = function(obj) {
    this._copyAndPasteFieldsNotOverwritable = obj;
};

proto.getfieldsLayerbindToRelationsFileds = function() {
  return this._fieldsLayerbindToRelationsFileds;
};
// setta il form service

proto.setFormService = function(formService) {
  this._formService = formService;
};

// prendo il form Service

proto.getFormService = function() {
  return this._formService;
};

// restituisce il mapservice
proto.getMapService = function() {
  return this._mapService;
};
// restituisce la picked feature
proto.getPickedFeature = function() {
  return this._pickedFeature;
};

proto.setPickedFeature = function(pickedFeature) {
  this._pickedFeature = pickedFeature;
};

proto.cleanUpPickedFeature = function() {
  this._pickedFeature.setStyle(null);
  this._pickedFeature = null;
};

// setto i dati del form
proto.setFormData = function(formData) {
  this.formData = formData;
};

// associa l'oggetto VectorLayer su cui si vuole fare l'editing
// inoltre setta i tipi di tools da poter collegare
// al tipo di layer sempre in base al tipo di geometria del layer
proto.setVectorLayer = function(vectorLayer) {
  //verifica il tipo di geometria del layer vettoriale
  var geometrytype = vectorLayer.geometrytype;
  //verifica se è nella tipologia di geometria compatibile con l'editor
  if (!geometrytype || !this._isCompatibleType(geometrytype)) {
    throw Error("Vector geometry type "+geometrytype+" is not valid for editing");
  }
  //nel caso in cui la geometria riscontrata corrisponde ad una geometria valida dell'editor
  //setta i tools dell'editor relativi al tipo di geometria
  this._setToolsForVectorType(geometrytype);
  //assegno il layer vettoriale alla proprità dell'editor
  this._vectorLayer = vectorLayer;
};

// funzione che crea e aggiunge il layer vettoraile di editing alla mappa
proto.addEditingLayerToMap = function(geometryType) {
  // istanzio l'editVectorLayer che è un vettore di appoggio (nuovo)
  // dove vado a fare le modifiche
  this._editVectorLayer = new VectorLayer({
    name: "editvector",
    geometrytype: geometryType
  });
  if (this._editingVectorStyle) {
    this._editVectorLayer.setStyle(this._editingVectorStyle.url);
  }
  //il getMapLyer non è altro che la versione ol.Vector del vectorLayer oggetto
  this._mapService.viewer.map.addLayer(this._editVectorLayer.getMapLayer());
};

//funzione che rimove il vettore di eding dalla mappa e lo resetta
proto.removeEditingLayerFromMap = function() {
  this._mapService.viewer.removeLayerByName(this._editVectorLayer.name);
  this._editVectorLayer = null;
};

// avvia la sessione di editazione con un determinato tool (es. addfeature)
proto.start = function() {
  // TODO: aggiungere notifica nel caso questo if non si verifichi
  var res = false;
  // se è sia stato settato il vectorLayer
  if (this._vectorLayer) {
    //prima di tutto stoppo editor
    this.stop();
    //chiamo la funzione che mi crea il vettoriale di editing dove vendono apportate
    // tutte le modifice del layer
    this.addEditingLayerToMap(this._vectorLayer.geometrytype);
    // istanzio l'EditBuffer
    this._editBuffer = new this._editBufferClass(this);
    //assegno all'attributo _started true;
    this._setStarted(true);
    res = true;
  }
  return res;
};

// termina l'editazione
proto.stop = function() {
  if (this.isStarted()) {
    if (this.stopTool()) {
      //distruggo l'edit buffer
      this._editBuffer.destroy();
      //lo setto a null
      this._editBuffer = null;
      //rimuovo il layer dalla mappa
      this.removeEditingLayerFromMap();
      //setto editor started a false
      this._setStarted(false);
      return true;
    }
    return false;
  }
  return true;
};

proto.destroy = function() {
  if (this.stop()) {
    this.removeAllListeners();
  }
};

//setta il tool corrent per il layer in editing
proto.setTool = function(toolType, options) {
  // al momento stopTool ritorna sempre true
  // quindi if sotto mai verificata
  if (!this.stopTool()) {
    return false;
  }
  // recupera il tool dai tols assegnati in base al tipo di tools richiesto
  // es. toolType = editattributes per editare gli attributi di una featue
  var toolClass = this._tools[toolType];
  // se esiste il tool richiesto
  if (toolClass) {
    //creo l'istanza della classe Tool tutte le volte che vado a settare il tool
    var toolInstance = new toolClass(this, options);
    // setto le proprità type dell'oggetto acriveTool
    // instance e type
    this._activeTool.setTool(toolType, toolInstance);
    // setto i listeners legati al tool scelto
    this._setToolSettersListeners(toolInstance);
    // faccio partire (chiamando il metodo run dell'istanza tool) il tool
    toolInstance.run();
    return true;
  }
};

// funzione chiamata da setTool o da latro che
// verifica se è stata già istanziato un tool
// al fine di interrompere l'editing sul layer
proto.stopTool = function() {
  //verifica se esiste l'istanza del tool (come attiva)
  // e se se nella stop del tool (che non fa altro che rimuovere le interaction dalla mappa)
  // si è verificato o meno un errore (tale funzione al momento ritorna true)
  if (this._activeTool.instance && !this._activeTool.instance.stop()) {
    return false;
  }
  // fa la chisura del form (penso sempre per sicurezza)
  GUI.closeForm();
  // chiude in ogni caso il setModal(grigio sopra la mappa)
  GUI.setModal(false);
  // se non è verificata la condizione sopra (dovuta ad esempio alla non istanziazione di nessus tool)
  // si chiama il metodo clear
  // dell'active Tool che setta il type e l'instace a null (al momento si verifica sempre)
  this._activeTool.clear();
  return true;
};


// ritorna l'activeTool
proto.getActiveTool = function() {
  return this._activeTool;
};

proto.isStarted = function() {
  return this._started;
};

proto.hasActiveTool = function() {
  return !_.isNull(this._activeTool.instance);
};

proto.isToolActive = function(toolType) {
  if (this._activeTool.toolType) {
    return this._activeTool.toolType == toolType;
  }
  return false;
};

proto.commit = function(responseNew) {
  // il parametro newFeatureData contiene informazioni
  // ritornate dal server nel caso di inserimento di nuove relazioni
  // con id
  this._editBuffer.commit();
  // vad ad eliminare le feature cancellate (quelle con stato DELETE)
  // perchè non mi servono più come relazione temporanee e rinominare
  // lo stato delle relazioni NEW to OLD con l'id ritornato dal server
  if (this._formService) {
    this._formService.cleanStateAfterCommit(responseNew);
  }
};

proto.undoAll = function() {
  this._editBuffer.undoAll();
};

proto.setFeatureLocks = function(featureLocks) {
  this._featureLocks = featureLocks;
};

proto.getFeatureLocks = function() {
  return this._featureLocks;
};

proto.getFeatureLockIds = function() {
  return _.map(this._vectorLayer.getFeatureLocks(),function(featurelock) {
    return featurelock.lockid;
  });
};

proto.getFeatureLocksLockIds = function(featureLocks) {
  var featureLocks = featureLocks || this._vectorLayer.getFeatureLocks();
  return _.map(featureLocks,function(featurelock) {
    return featurelock.lockid;
  });
};

proto.getFeatureLocksFeatureIds = function(featureLocks) {
  var featureLocks = featureLocks || this._vectorLayer.getFeatureLocks();
  return _.map(featureLocks,function(featurelock) {
    return featurelock.featureid;
  });
};

proto.getFeatureLockIdsForFeatureIds = function(fids) {
  var featurelocksForFids = _.filter(this._vectorLayer.getFeatureLocks(),function(featurelock) {
    return _.includes(fids,featurelock.featureid);
  });

  return this.getFeatureLocksLockIds(featurelocksForFids);
};

proto.getFeatureLockForFeatureIds = function(fids) {
  // ritorna un aray delle feature che sono state editate e che sono locckate
  //console.log(this._vectorLayer.getFeatureLocks());
  /*return _.filter(this._vectorLayer.getFeatureLocks(), function(featurelock) {
    return _.includes(fids, featurelock.featureid);
  });*/
  return this._vectorLayer.getFeatureLocks();
};
// funzione che prende le feature nuove, aggiornate e cancellate
//dall'edit buffer
proto.getEditedFeatures = function() {
  // prende gli id unici delle feature che sono state editate
  var modifiedFids = this._editBuffer.collectFeatureIds();
  var lockIds = this.getFeatureLockForFeatureIds(modifiedFids);
  return {
    add: this._editBuffer.collectFeatures('new', true),
    update: this._editBuffer.collectFeatures('updated',true),
    delete: this._editBuffer.collectFeatures('deleted',true),
    relationsedits: this.collectRelations(),
    lockids: lockIds
  }
};
// chiama la funzione collecRelations dell'edit buffer
// in modo tale da collezionare tutte le informazioni
// relative all'edit buffer sulle relazioni
proto.collectRelations = function() {
  relationsEdits = this._editBuffer.collectRelations();
  return relationsEdits;
};

// viene chamato quando si preme ad esempio Salva sul Form degli
// attributi di una feature
proto.setFieldsWithValues = function(feature, fields, relations) {
  var attributes = {};
  _.forEach(fields, function(field) {
    // mi serve nel caso delle select ch devo forzare il valore a 'null'
    //
    if (field.value == 'null') {
      field.value = null;
    }
    attributes[field.name] = field.value;
  });
  // setto i campi della feature con i valori editati nel form
  feature.setProperties(attributes);
  // vado a scrivere neln'edit buffer relativo ai campi
  // la features e le relazioni che cono state create o modificate
  this._editBuffer.updateFields(feature, relations);
  if (relations) {
    // se ci sono relazioni vado a settare i dai delle relazioni nel layervettoriale originale
    this._vectorLayer.setRelationsData(feature.getId(), relations);
  }
};

//funzione che in base alla feature passata recupera le relazioni associata ad essa
proto.getRelationsWithValues = function(feature) {
  var fid = feature.getId();
  //verifica se il layer ha relazioni
  // restituisce il valore del campo _relation (se esiste è un array) del vectorLayer
  if (this._vectorLayer.hasRelations()) {
    var fieldsPromise;
    // se non ha fid vuol dire che è nuovo e senza attributi, quindi prendo i fields vuoti
    if (!fid) {
      fieldsPromise = this._vectorLayer.getRelationsWithValues();
    }
    // se per caso ha un fid ma è un vettoriale nuovo
    else if (!this._vectorLayer.getFeatureById(fid)){
      // se questa feature, ancora non presente nel vectorLayer, ha comunque i valori delle FKs popolate, allora le estraggo
      if (this._vectorLayer.featureHasRelationsFksWithValues(feature)){
        var fks = this._vectorLayer.getRelationsFksWithValuesForFeature(feature);
        fieldsPromise = this._vectorLayer.getNewRelationsWithValuesFromFks(fks);
      }
      // altrimenti prendo i fields vuoti
      else {
        fieldsPromise = this._vectorLayer.getRelationsWithValues(fid);
      }
    }
    // se invece è una feature già presente e quindi non nuova
    // verifico se ha dati delle relazioni già  editati
    else {
      var hasEdits = this._editBuffer.hasRelationsEdits(fid);
      if (hasEdits){
        var relationsEdits = this._editBuffer.getRelationsEdits(fid);
        var relations = this._vectorLayer.getRelations();
        _.forEach(relations,function (relation) {
          relation.elements = _.cloneDeep(relationsEdits[relation.name]);
        });
        fieldsPromise = resolve(relations);
      }
      // se non ce li ha vuol dire che devo caricare i dati delle relazioni da remoto
      else {
        fieldsPromise = this._vectorLayer.getRelationsWithValues(fid);
      }
    }
  }
  else {
    // nel caso di nessuna relazione risolvo la promise
    // passando il valore null
    fieldsPromise = resolve(null);
  }
  return fieldsPromise;
};

proto.createRelationElement = function(relation) {
  var element = {};
  var fields = _.cloneDeep(this._vectorLayer.getRelationFields(relation));
  _.forEach(fields, function(field) {
      field.value = null; // DACAPIRE MEGLIO
  });
  element.fields = fields;
  element.id = this.generateId();
  element.state = 'NEW';
  return element;
};

proto.getRelationPkFieldIndex = function(relationName) {
  return this._vectorLayer.getRelationPkFieldIndex(relationName);
};
// retituisce l'oggetto field
proto.getField = function(name, fields) {
  var fields = fields || this.getVectorLayer().getFieldsWithValues();
  var field = null;
  _.forEach(fields, function(f) {
    if (f.name == name) {
      field = f;
    }
  });
  return field;
};

proto.isDirty = function() {
  return this._dirty;
};
// METODI CHE SOVRASCRIVONO ONAFTER, ONBEFORE, ONBEFOREASYNC DELL'OGGETTO G3WOBJECT
// la loro funzione è quella di settare la propriteà dell'editor
// _setterslisteners in modo corretto da poter poi essere sfruttata dal metodo
// _setToolSettersListeners  --- !!!! DA COMPLETARE LA SPIEGAZIONE !!!----

proto.onafter = function(setter, listener, priority) {
  this._onaftertoolaction(setter, listener, priority);
};

// permette di inserire un setter listener sincrono
// prima che venga effettuata una operazione da un tool (es. addfeature)
proto.onbefore = function(setter, listener, priority) {
  this._onbeforetoolaction(setter, listener, false, priority);
};

// come onbefore() ma per listener asincroni
//setter: nome del metodo
//listener: next
proto.onbeforeasync = function(setter, listener, priority) {
  this._onbeforetoolaction(setter, listener, true, priority);
};

proto._onaftertoolaction = function(setter, listener, priority) {
  priority = priority || 0;
  if (!_.get(this._setterslisteners.after, setter)) {
    this._setterslisteners.after[setter] = [];
  }
  this._setterslisteners.after[setter].push({
    fnc: listener,
    priority: priority
  });
};

proto._onbeforetoolaction = function(setter, listener, async, priority) {
  priority = priority || 0;
  //vado a verificare prima se ho come chiaave il setter
  if (!_.get(this._setterslisteners.before, setter)) {
    // se non ce l'ho aggiungo al before
    this._setterslisteners.before[setter] = [];
  }
  //vado ad aggiungere alla catena delle azioni da fare prima di quel setter
  this._setterslisteners.before[setter].push({
    fnc: listener,
    how: async ? 'async' : 'sync',
    priority: priority
  });
};

/////////////////////////////////////

// una volta istanziato il tool aggiungo a questo tutti i listener definiti a livello di editor
proto._setToolSettersListeners = function(tool) {
  // tutte le volte sarà una nuova istanza del tool (anche se attivo/clicco ripetutatemnte sul bottone del tool)
  // quindi la registarzione  dell'onbefore etc .. sarà sempre pulita

  //scorro su i setterListerns impostati dagli editor custom (GeonotesEditor ad esempio)
  // in modo da poter richiamare e settare gli onbefore o onbeefore async o on after
  // nativi dell'oggetto g3wobject sui tool
  //verifico gli on before
  _.forEach(this._setterslisteners.before, function(listeners, setter) {
    // verifico se il tool in questione ha setters
    if (_.hasIn(tool.setters, setter)) {
      // se il tool prevede setters
      _.forEach(listeners, function(listener) {
        // per ogni listener (sono tutti oggetti con
        // chiave fnc, how (vedi sopra)
        // verifico se è un onbefore or un onbeforesync
        // vado a settare la funzione listeners quando il metodo del tool setter
        // viene chiamato
        if (listener.how == 'sync') {
          tool.onbefore(setter, listener.fnc, listener.priority);
        }
        else {
          tool.onbeforeasync(setter, listener.fnc, listener.priority);
        }
      })
    }
  });
  //come sopra ma per gli onafter
  _.forEach(this._setterslisteners.after, function(listeners,setter) {
    if (_.hasIn(tool.setters, setter)) {
      _.forEach(listeners,function(listener) {
        tool.onafter(setter,listener.fnc, listener.priority);
      })
    }
  })
};

proto._transformCoordinateFeatureFromMapToLayer = function(feature) {
  // controlla prima l proiezione
  var mapProjection = this._mapService.getProjection().getCode();
  var layerProjection = this._vectorLayer.getCrs();
  var coord = feature.getGeometry().getCoordinates();
  coord = ol.proj.transform(coord, mapProjection, layerProjection);
  feature.getGeometry().setCoordinates(coord);
  return feature;
};

proto._transformCoordinateFeatureFromLayerToMap = function(feature) {

  // controlla prima la proiezione
  var mapProjection = this._mapService.getProjection().getCode();
  var layerProjection = this._vectorLayer.getCrs();
  var coord = feature.getGeometry().getCoordinates();
  coord = ol.proj.transform(coord, layerProjection, mapProjection);
  feature.getGeometry().setCoordinates(coord);
  return feature;
};

// metodo add Feature che non fa alto che aggiungere la feature al buffer
proto.addFeature = function(feature) {
  feature = this._transformCoordinateFeatureFromMapToLayer(feature);
  this._editBuffer.addFeature(feature);
};
// non fa aalctro che aggiornare la feature del buffer
proto.updateFeature = function(feature) {
  feature = this._transformCoordinateFeatureFromMapToLayer(feature);
  this._editBuffer.updateFeature(feature);
};
//edit feature
proto.pickFeature = function(feature) {
  this.updateFeature(feature)
};
//move feature
proto.moveFeature = function(feature) {
  this.updateFeature(feature);
};
// non fa altro che cancellare la feature dall'edit buffer
proto.deleteFeature = function(feature, relations, isNew) {
  this._editBuffer.deleteFeature(feature, relations);
};

proto.getVectorLayer = function() {
  return this._vectorLayer;
};

proto.getEditVectorLayer = function() {
  return this._editVectorLayer;
};

proto.generateId = function() {
  return this._newPrefix+Date.now();
};

proto.generateFormId = function(vectorName) {
  return vectorName + 'form' + Date.now();
};

proto.isNewFeature = function(fid) {
  if (fid) {
    return fid.toString().indexOf(this._newPrefix) == 0;
  }
  return true;
};
// verifico se la geometria è compatibile con quelle definite dall'editor
proto._isCompatibleType = function(geometrytype) {
  return this._geometrytypes.indexOf(geometrytype) > -1;
};
//setta i tools relativi alla geometria del layer vettoriale passato
proto._setToolsForVectorType = function(geometrytype) {
  var self = this;
  var tools = this._toolsForGeometryTypes[geometrytype];
  _.forEach(tools, function(toolClass, tool) {
    //prendo memorai dell'oggetto tools class
    self._tools[tool] = toolClass;
  })
};
// setto l'attributo started a true quando avvio l'editor
proto._setStarted = function(bool) {
  this._started = bool;
};
// funzione setDirty dell'editor che fa si che questo possa emettere
// l'evento dirty in questo modo psso fare qualcosa quando è stata fatta una modifica
// nei layers dell'editor
proto._setDirty = function(bool) {
  // se non specificato lo setto a vero
  if (_.isNil(bool)) {
    this._dirty = true;
  }
  else {
    this._dirty = bool;
  }
  // emetto l'evento dirty dell'editor
  this.emit("dirty", this._dirty);
};

proto._onSaveEditorForm = function(feature, fields, relations, next) {
  var self = this;
  var next = next;
  var feature = feature;
  return function(fields, relations) {
    self.setFieldsWithValues(feature, fields, relations);
    if (next) {
      // setto a true l'argomento di next per fare in modo che vengono eseguiti
      // se presenti i listerners do onbefore
      next(true);
    }
    GUI.setModal(false);
  };
};

proto._openEditorForm = function(isNew, feature, next) {
  var self = this;
  // viene recuperato il vectorLayer dell'editor
  var vectorLayer = this.getVectorLayer();
  // vengono recuperati i fields del vectorLayer con i valori
  var fields = vectorLayer.getFieldsWithValues(feature);
  // prende il valor pk del vectorLayer
  var pk = vectorLayer.pk;
  // verifico se il valore della chiave primaria e verifica
  // //se esiste l'oggetto field uguale alla chiave primaria
  if (pk && _.isNull(this.getField(pk))) {
    _.forEach(feature.getProperties(), function(value, attribute) {
      var field = self.getField(attribute, fields);
      if (field) {
        field.value = value;
      }
    });
  }
  var showForm  = GUI.showContentFactory('form');
  // recupero la funzione per visualizzazre il componente Form
  var relationsPromise = this.getRelationsWithValues(feature);
  //var queryResultsPanel = showQueryResults('interrogazione');
  relationsPromise
    .then(function(relations) {
      // creo un clone perchè altrimenti se faccio modifice anche temporanee
      // alle relazionimi restano e vanno ad impattare nel cancella
      var relations = _.cloneDeep(relations);
      showForm({
        provider: self,
        name: "Edita attributi "+vectorLayer.name,
        formId: self.generateFormId(vectorLayer.name),
        dataid: vectorLayer.name,
        vectorLayer: vectorLayer,
        pk: vectorLayer.pk,
        isnew: self.isNewFeature(feature.getId()),
        fields: fields,
        relations: relations,
        relationOne: self.checkOneRelation,
        tools: self._formTools,
        formComponent: self._formComponent,
        editor: self,
        buttons:[
          {
            title: "Salva",
            type: "save",
            class: "btn-danger",
            cbk: self._onSaveEditorForm(feature, fields, relations, next)
          },
          {
            title: "Cancella",
            type: "cancel",
            class: "btn-primary",
            cbk: function() {
              if (next) {
                //dico di uscire e non proseguire
                //vado a chiamare la fallback del tool
                next(false);
              }
              GUI.setModal(false);
            }
          }
        ]
      });
    })
    .fail(function() {
      if (next){
        next(false);
      }
      GUI.setModal(false);
    })
};


module.exports = Editor;
},{"./editbuffer":24,"./tools/addfeaturetool":27,"./tools/cutlinetool":28,"./tools/deletefeaturetool":29,"./tools/modifyfeaturetool":31,"./tools/movepointtool":32,"./tools/pickfeaturetool":33,"core/g3wobject":34,"core/map/layer/vectorlayer":59,"core/utils/utils":77,"gui/gui":118}],26:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');

// Oggetto RelationEditBuffer
// Utilizzato dall'editor per tenere traccia delle modifiche alle relazioni
// legate alla particolare feature del layer in editing in quel momento
function RelationEditBuffer(editorBuffer, relationName) {
  // i due parametry sono l'editor buffer a cui si lega la relazione/i
  //il nome della relazione che non è altro che il nome del layer legato al
  // layer che stiamo editando
  this._relationName = relationName;
  this._editorBuffer = editorBuffer;
  // buffer degli elementi
  this._elementsBuffer = {};
}
inherit(RelationEditBuffer, G3WObject);

module.exports = RelationEditBuffer;

var proto = RelationEditBuffer.prototype;
// clear Buffer
proto.commit = function() {
  this._clearBuffers();
};
// undoAll Relation
proto.undoAll = function(){
  this._clearBuffers();
};
// distrugge tutte le relaioni
proto.destroy = function(){
  this._clearBuffers();
};
//restituisce il nome della relazione
proto.getRelationName = function() {
  return this._relationName;
};
// generare id della relazione (utile quando si crea una nuova relazione)
proto.generateId = function(){
  return this._editorBuffer.generateId();
};

proto.getAddedElements = function() {

};

proto.getDeletedElements = function() {

};

proto.getUpdatedElements = function() {

};
//metodo che fa l'aggiornamento della relazione
proto.updateRelation = function(relation) {
  var self = this;
  // ciclo sugli emeneti della relazione
  _.forEach(relation.elements, function(element) {
    //chiama l'aggiornamento dell'elemento nel buffer
    self._editElementsBuffer(element);
  })
};
// Modifica elemento nel buffer
proto._editElementsBuffer = function(element) {
  // un elemento con tutti i campi vuoti non lo aggiungo
  var filled = _.some(element.fields, function (field) {
    // verifica se il valore è nullo o undefined
    return !_.isNil(field.value);
  });
  // se sono tutti vuoti
  if (!filled) {
    return;
  }
  // estraggo l'id dell'elemento
  var id = element.id;
  // verifico se esiste già tra le chiavi del buffer degli elementi
  if (!_.has(this._elementsBuffer, id)) {
    // se non esiste come nel caso del buffere delle feature creo l'array associandolo
    // alla chiave id dell'elemento
    this._elementsBuffer[id] = [];
  }
  // aggiungo all'array delle modifiche dell'elelemento
  this._elementsBuffer[id].push(element);
  // richiamo la funzione SetDirty
  this._setDirty(true);
};

// il filtro può essere 'ALL', 'NEW', 'OLD', 'DELETED'
proto.getRelationElements = function(filter, onlyfieldsvalues) {
  var elements = [];
  _.forEach(this._elementsBuffer, function(elementBuffer) {
    // element buffer sono gli arry ( e quindi le modifche) di ogni elemento della
    // relazione
    var element = elementBuffer.slice(-1)[0];
    if (element || (filter=='ALL')) { // lo prenso solo se non è null
      if (!filter || (filter && element.state==filter)) {
        if(onlyfieldsvalues) {
          element = _.cloneDeep(element);
          element.fields = _.map(element.fields,function(field){
            return {
              name: field.name,
              value: field.value
            }
          })
        }

        elements.push(element);
      }
    }
  });
  return elements;
};

proto.getRelationElementsOnlyFieldsValues = function(filter) {
  return this.getRelationElements(filter,true);
};

// funzione ha elementi
proto.hasRelationElements = function(){
  var hasEdits = false;
  _.forEach(this._elementsBuffer, function(elementBuffer) {
    hasEdits = hasEdits || (elementBuffer.length > 0);
  });
  return hasEdits;
};
// la funzione setDirty server per far scatenre la funzione
// _setDirtu dall 'editor delle relazioni (qui) all'editor buffer all' editor
proto._setDirty = function(bool) {
  this._editorBuffer._setDirty(bool);
};
// non fa altro che risettare gli elements buffer a oggetto vuoto
// e settare _setDirty a false
proto._clearBuffers = function(){
  this._elementsBuffer = {};
  this._setDirty(false);
};
},{"core/g3wobject":34,"core/utils/utils":77}],27:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var EditingTool = require('./editingtool');

// classe  per l'aggiuntadi feature
// eridita dalla classe padre EditingTool
function AddFeatureTool(editor, options) {

  options = options || {};
  this._running = false;
  this._busy = false;
  // source del layer di editing
  this.source = editor.getEditVectorLayer().getMapLayer().getSource();
  this.type = this.editor.getEditVectorLayer().geometrytype;
  // la drw interaction per disegnare la feature
  this.drawInteraction = null;
  this._snap = options.snap || null;
  this._snapInteraction = null;
  this._finishCondition = options.finishCondition || _.constant(true);
  this._condition = options.condition || _.constant(true);
  // qui si definiscono i metodi che vogliamo poter intercettare,
  // ed eventualmente bloccare (vedi API G3WObject)
  this.setters = {
    addFeature: {
      fnc: AddFeatureTool.prototype._addFeature,
      fallback: AddFeatureTool.prototype._fallBack
    }
  };
  
  base(this, editor);
}

inherit(AddFeatureTool, EditingTool);

module.exports = AddFeatureTool;

var proto = AddFeatureTool.prototype;

// metodo eseguito all'avvio del tool
proto.run = function() {
  var self = this;
  //definisce l'interazione che deve essere aggiunta
  // specificando il layer sul quale le feature aggiunte devono essere messe
  this.drawInteraction = new ol.interaction.Draw({
    type: this.type, // il tipo lo prende dal geometry type dell'editing vetor layer che a sua volta lo prende dal tipo si geometry del vector layer originale
    source: this.source,
    condition: this._condition,
    finishCondition: this._finishCondition // disponibile da https://github.com/openlayers/ol3/commit/d425f75bea05cb77559923e494f54156c6690c0b
  });
  var style = this.editor._editingVectorStyle ? this.editor._editingVectorStyle.add : null;
  //aggiunge l'interazione tramite il metodo generale di editor.js
  // che non fa altro che chaimare il mapservice
  this.addInteraction(this.drawInteraction);
  //setta attiva l'interazione
  this.drawInteraction.setActive(true);
  // viene settato sull'inizio del draw l'evento drawstart dell'editor
  this.drawInteraction.on('drawstart',function(e) {
    self.editor.emit('drawstart',e);
  });
  // viene settato l'evento drawend
  this.drawInteraction.on('drawend', function(e) {
    e.feature.setStyle(style);
    self.editor.emit('drawend',e);
    if (!self._busy) {
      self._busy = true;
      self.pause();
      //viene chiamato l'addFeature del che  tool (modificata da G3wobject) che
      // chiama l'addfeature del buffer
      // il metodo (essendo un "setter") scatena gli eventuali listeners
      // dati da onbefore, onafter, onbeforeasync
      self.addFeature(e.feature);
    }
  });
  //snapping
  if (this._snap) {
    this._snapInteraction = new ol.interaction.Snap({
      source: this._snap.vectorLayer.getSource()
    });
    this.addInteraction(this._snapInteraction);
  }
};

//metodo pausa
proto.pause = function(pause) {
  // se non definito o true disattiva (setActive false) le iteractions
  if (_.isUndefined(pause) || pause === true) {
    if (this._snapInteraction) {
      this._snapInteraction.setActive(false);
    }
    this.drawInteraction.setActive(false);
  } else {
    if (this._snapInteraction) {
      this._snapInteraction.setActive(true);
    }
    this.drawInteraction.setActive(true);
  }
};

// metodo eseguito alla disattivazione del tool
proto.stop = function() {
  //rimuove e setta a null la _snapInteraction
  if (this._snapInteraction) {
     this.removeInteraction(this._snapInteraction);
     this._snapInteraction = null;
  }
  //rimove l'interazione e setta a null drawInteracion
  this.removeInteraction(this.drawInteraction);
  this.drawInteraction = null;
  // rtirna semprte true
  return true;
};

proto.removeLastPoint = function() {
  if (this.drawInteraction) {
    // provo a rimuovere l'ultimo punto. Nel caso non esista la geometria gestisco silenziosamente l'errore
    try{
      this.drawInteraction.removeLastPoint();
    }
    catch (e) {
      //
    }
  }
};
// add Feature fnc setter function
proto._addFeature = function(feature) {
  // aggiungo la geometria nell'edit buffer
  //risetto allo style iniziale
  feature.setStyle(null);
  ////
  this.editor.addFeature(feature);
  this._busy = false;
  this.pause(false);
  return true;
};
// funzione di call back del setter addFeature
proto._fallBack = function(feature) {
  this._busy = false;
  // rimuovo l'ultima feature inserita, ovvero quella disegnata ma che non si vuole salvare
  if (this.source.getFeaturesCollection().getLength()){
    this.source.getFeaturesCollection().pop();
    this.pause(false);
  }
};

},{"./editingtool":30,"core/utils/utils":77}],28:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geom = require('core/geometry/geom');
var PickFeatureInteraction = require('g3w-ol3/src/interactions/pickfeatureinteraction');
var PickCoordinatesInteraction = require('g3w-ol3/src/interactions/pickcoordinatesinteraction');

var EditingTool = require('./editingtool');

function CutLineTool(editor, options){
  this.setters = {
    cutLine: CutLineTool.prototype._cutLine
  };

  base(this,editor,options);
  this.steps = new EditingTool.Steps(CutLineTool.steps);
  this._origFeature = null;
  this._origGeometry = null;
  this._newFeatures = [];
  this._linePickInteraction = null;
  this._pointPickInteraction = null;
  this._pointLayer = options.pointLayer || null;
  this._minCutPointDistance = options.minCutPointDistance || Infinity;
  this._modType = options.modType || 'MODONCUT'; // 'NEWONCUT' | 'MODONCUT'
  //selected line vecor di overlay
  this._selectedLineOverlay = new ol.layer.Vector({
    source: new ol.source.Vector(),
    style: new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: 'rgb(255,255,0)',
        width: 4
      })
    })
  });
  // vetoore della line di overlay che è matentuta
  // ha lo stile di quella originale
  this._lineToKeepOverlay = new ol.layer.Vector({
    source: new ol.source.Vector()
  });
}

inherit(CutLineTool, EditingTool);

module.exports = CutLineTool;

var proto = CutLineTool.prototype;
// funzione che viene chiamata quando viene eseguita il setTool dell'editor
proto.run = function() {
  var self = this;
  this._linePickInteraction = new PickFeatureInteraction({
    layers: [this.layer, this.editingLayer]
  });
  // aggiungo il pick feature interaction
  this.addInteraction(this._linePickInteraction);
  // vado al primo step:
  // In questo caso selzionare la linea da tagliare
  self.steps.next();
  // i metto in ascolto dell'evento picked sulla feature
  this._linePickInteraction.on('picked', function(e) {
    var cutFeature;
    // prendo la feature selzionata
    var feature = self._origFeature = e.feature;
    // clono la geometria della feature selezionata
    self._origGeometry = feature.getGeometry().clone();
    // visualizzo lo show selection
    self._showSelection(self._origGeometry, 300);
    // viene rimossa l'interazione
    self.removeInteraction(this);
    if (self._pointLayer) {
      // se è stato definto il pointLayer (il layer puntuale da utilizzare)
      self._pointPickInteraction = new PickFeatureInteraction({
        layers: [self._pointLayer]
      });
    }
    else {
      // altrimenti uso il pick layer interaction su se stesso
      self._pointPickInteraction = new PickCoordinatesInteraction();
    }
    // pesco coordinata o feature di taglio selezionata
    self.steps.next();
    // ascolto l'emssione dell'evento picked sul layer puntuale o su se stesso
    self._pointPickInteraction.on('picked',function(e) {
      // rimovo l'interazione
      self.removeInteraction(this);
      var coordinate;
      if (e.feature){
        cutFeature = e.feature;
        coordinate = cutFeature.getGeometry().getCoordinates();
      }
      else {
        coordinate = e.coordinate;
      }
      // se ci sono le coordinate del punto
      if (coordinate){
        // snappo sulla linea
        var closestCoordinate = feature.getGeometry().getClosestPoint(coordinate);
        var distance = geom.distance(coordinate,closestCoordinate);
        // se lo snap è entro la tolleranza
        if (distance < self._minCutPointDistance){
          // taglio la linea e ottengo l'array con le due nuove feature
          var slicedLines = self._cut(feature.getGeometry(),closestCoordinate);
          if (slicedLines){
            var prevLineFeature = slicedLines[0];
            var nextLineFeature = slicedLines[1];
            
            var newId = self.editor.generateId();
            prevLineFeature.setId(newId+'_1');
            nextLineFeature.setId(newId+'_2');
            
            // prendo le proprietà della feature originale (esclusa la geometria)
            var origProperties = feature.getProperties();
            delete origProperties[feature.getGeometryName()];
            
            self._showSelection(prevLineFeature.getGeometry(),300);
            setTimeout(function(){
              self._showSelection(nextLineFeature.getGeometry(),300);
            }, 300);
            
            // nel caso di modifica su taglio
            if (self._modType == 'MODONCUT') {
              // seleziono la porzione da mantenere/modificare
              // andando al prossimo next
              self.steps.next();
              self._selectLineToKeep(prevLineFeature, nextLineFeature)
              .then(function(featureToKeep) {
                // aggiorno la feature originale con la geometria della feature che si è selezionato da mantenere
                feature.setGeometry(featureToKeep.getGeometry().clone());
                var featureToAdd;
                // rimuovo una delle due nuove feature e mi tengo l'unica feature da aggiungere come nuova
                if (prevLineFeature.getId() == featureToKeep.getId()){
                  delete prevLineFeature;
                  featureToAdd = nextLineFeature;
                }
                else if (nextLineFeature.getId() == featureToKeep.getId()){
                  delete nextLineFeature;
                  featureToAdd = prevLineFeature;
                }
                self._newFeatures.push(featureToAdd);
                // tramite l'editor assegno alla nuova feature gli stessi attributi dell'altra, originale, modificata
                featureToAdd.setProperties(origProperties);
                // e la aggiungo al layer di editing, così mi viene mostrata come nuova feature sulla mappa
                //self.editor._editVectorLayer.getSource().addFeatures([featureToAdd]);
                self.editingLayer.getSource().addFeatures([featureToAdd]);
                var data = {
                  added: [featureToAdd],
                  updated: feature,
                  cutfeature:cutFeature
                };
                // a questo punto avvio il setter, che si occuperò di aggiornare l'editbuffer a seconda del tipo di modifica
                self.cutLine(data, self._modType)
                .fail(function(){
                  self._rollBack();
                  self.rerun();
                });
              })
            }
            else {
              // nel caso la modifica sia aggiungo su taglia, allora rimuovo l'originale e aggiungo le due nuove feature
              self.layer.getSource().removeFeature(feature);
              //self.editor.setAttributes(prevLineFeature,origProperties);
              //self.editor.setAttributes(nextLineFeature,origProperties);
              self._newFeatures.push(prevLineFeature);
              self._newFeatures.push(nextLineFeature);
              self.editingLayer.getSource().addFeatures([featureToAdd,prevLineFeature]);
              
              var data = {
                added: [prevLineFeature,nextLineFeature],
                removed: feature
              };
              self.cutLine(data, self._modType)
              .fail(function(){
                self._rollBack();
                self.rerun();
              })
            }
          }
          else {
            self.rerun();
          }
        }
      }
    });
    self.addInteraction(self._pointPickInteraction);
  });
};

proto.pause = function(pause){
  if (_.isUndefined(pause) || pause){
    this._linePickInteraction.setActive(false);
    this._pointPickInteraction.setActive(false);
  }
  else {
    this._linePickInteraction.setActive(true);
    this._pointPickInteraction.setActive(true);
  }
};

proto.rerun = function(){
  this.stop();
  this.run();
};

proto.stop = function(){
  this._cleanUp();
  var stop = base(this, 'stop');
  if (stop) {
    this.removeInteraction(this._linePickInteraction);
    this.removeInteraction(this._pointPickInteraction);
    this._linePickInteraction = null;
    this._pointPickInteraction = null;
  }

  return stop;
};

proto._cleanUp = function(){
  this.steps.completed();
  this._origFeature = null;
  this._origGeometry = null;
  this._newFeatures = [];
  this._lineToKeepOverlay.setMap(null);
  this._selectedLineOverlay.setMap(null);
  // evito di fare il clean up delle editing features
  //this.editingLayer.getSource().getFeaturesCollection().clear();
};

proto._rollBack = function(){
  // rimetto la vecchia geometria
  this._origFeature.setGeometry(this._origGeometry);
  // rimuovo le feature (nuove) editate dal layer di editazione
  try {
    _.forEach(this._newFeatures,function(feature){
      self.editingLayer.getSource().removeFeature(feature);
    });
  }
  catch (e) {}
};

proto._cutLine = function(data, modType) {
  // se modifico su taglio aggiorno la vecchia feature e aggiungo la nuova
  if (modType == 'MODONCUT') {
    var featureToUpdate = data.updated;
    var featureToAdd = data.added[0];
    this.editor.updateFeature(featureToUpdate);
    this.editor.addFeature(featureToAdd);
  }
  // altrimenti rimuovo la vecchia e aggiungo le nuove
  else{
    var featureToRemove = data.removed;
    var featureToAdd1 = data.added[0];
    var featureToAdd2 = data.added[1];
    this.editor.deleteFeature(featureToRemove);
    this.editor.addFeature(featureToAdd1);
    this.editor.addFeature(featureToAdd2);
  }
  this._busy = false;
  this.pause(false);
  this.rerun();
  return true;
};

proto._selectLineToKeep = function(prevLineFeature,nextLineFeature){
  var d = $.Deferred();
  var self = this;
  var layer = this._lineToKeepOverlay;
  layer.getSource().addFeatures([prevLineFeature,nextLineFeature]);
  layer.setMap(this.editor.getMapService().viewer.map);
  
  var selectLineInteraction = new PickFeatureInteraction({
    layers: [this._lineToKeepOverlay]
  });
  this.addInteraction(selectLineInteraction);
  
  selectLineInteraction.on('picked',function(e){
    layer.setMap(null);
    self.removeInteraction(this);
    d.resolve(e.feature);
  });
  
  return d.promise();
};

proto._fallBack = function(feature){
  this._busy = false;
  this.pause(false);
};

proto._cut = function(geometry,cutCoordinate){
  while (cutCoordinate.length < geometry.getLayout().length) {
    cutCoordinate.push(0);
  }

  var minDistance = Infinity;
  var closestIndex = 0;
  var index = 0;
  // cerco l'indice del segmento lineare su cui ricade la coordinata di taglio
  geometry.forEachSegment(function(v0,v1){
    var segmentPoint = geom.closestOnSegment(cutCoordinate,[v0,v1]);
    var distance = geom.distance(cutCoordinate,segmentPoint);
    if (distance < minDistance){
      minDistance = distance;
      closestIndex = index;
    }
    index += 1;
  });
  
  var coordinates = geometry.getCoordinates();
  // prendo la prima porzione di coordinate
  var prevCoords = coordinates.slice(0,closestIndex+1);
  // aggiungo la coordinata di taglio alla prima porzione
  prevCoords.splice(prevCoords.length,0,cutCoordinate);
  // prendo la seconda porzione di coordinate
  var nextCoords = coordinates.slice(closestIndex);
  // aggiungo la coordinata di taglio alla seconda porzione
  nextCoords.splice(0,1,cutCoordinate);
  
  if (prevCoords.length < 2 || nextCoords.length < 2){
    return false;
  }
  
  // creo le geometrie
  var prevLine = new ol.geom.LineString();
  prevLine.setCoordinates(prevCoords);
  var nextLine = new ol.geom.LineString();
  nextLine.setCoordinates(nextCoords);
  
  // creo le nuove feature
  var prevLineFeat = new ol.Feature({
    geometry: prevLine
  });
  var nextLineFeat = new ol.Feature({
    geometry: nextLine
  });
  
  return [prevLineFeat,nextLineFeat];
};


// TODO questo andrà spostato dentro MapService o comunque in una libreria core
// funzione show selection
proto._showSelection = function(geometry, duration){
  var self = this;
  var duration = duration || null;
  // prendo l'elemento(vettore) overlay
  var overlay = this._selectedLineOverlay;
  // creo la feature
  var feature = new ol.Feature();
  // inserisco la geometria della feature precedentemente selezionata
  feature.setGeometry(geometry);
  // l'aggiungo alla feature di overlay
  overlay.getSource().addFeatures([feature]);
  // setto la mappa del vettore di overlay
  // setMap è un metodo del layer di ol3 per far visulizzare temporaneamente un layer
  // la mappa non può interagire con esso. Il layer biene messo on top alla mappa
  overlay.setMap(this.editor.getMapService().viewer.map);
  if (duration) {
    // veridfico se è staato settato la duration
    setTimeout(function(){
      overlay.setMap(null);
      self._selectedLineOverlay.getSource().clear();
    }, duration);
  }
};

proto._isNew = function(feature){
  return (!_.isNil(this.editingLayer.getSource().getFeatureById(feature.getId())));
};

CutLineTool.steps = [
  {
    type: "selectline"
  },
  {
    type: "selectcutpoint"
  },
  {
    type: "selectparttokeep"
  }
];

},{"./editingtool":30,"core/geometry/geom":37,"core/utils/utils":77,"g3w-ol3/src/interactions/pickcoordinatesinteraction":98,"g3w-ol3/src/interactions/pickfeatureinteraction":99}],29:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DeleteInteraction = require('g3w-ol3/src/interactions/deletefeatureinteraction');
var EditingTool = require('./editingtool');

function DeleteFeatureTool(editor) {
  this.editor = editor;
  this.drawInteraction = null;
  this.layer = null;
  this.editingLayer = null;
  this.setters = {
    deleteFeature: DeleteFeatureTool.prototype._deleteFeature
  };
  
  base(this,editor);
}
inherit(DeleteFeatureTool, EditingTool);
module.exports = DeleteFeatureTool;

var proto = DeleteFeatureTool.prototype;

/* BRUTTISSIMO! Tocca ridefinire tutte le parti internet di OL3 non esposte dalle API */

ol.geom.GeometryType = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};

var styles = {};
var white = [255, 255, 255, 1];
var blue = [0, 153, 255, 1];
var red = [255, 0, 0, 1];
var width = 3;
styles[ol.geom.GeometryType.POLYGON] = [
  new ol.style.Style({
    stroke: new ol.style.Stroke({
      color: 'red',
      width: 3
    }),
    fill: new ol.style.Fill({
      color: 'rgba(255, 0, 0, 0.1)'
    })
  })
];
styles[ol.geom.GeometryType.MULTI_POLYGON] =
    styles[ol.geom.GeometryType.POLYGON];

styles[ol.geom.GeometryType.LINE_STRING] = [
  new ol.style.Style({
    stroke: new ol.style.Stroke({
      color: white,
      width: width + 2
    })
  }),
  new ol.style.Style({
    stroke: new ol.style.Stroke({
      color: red,
      width: width
    })
  })
];
styles[ol.geom.GeometryType.MULTI_LINE_STRING] =
    styles[ol.geom.GeometryType.LINE_STRING];

styles[ol.geom.GeometryType.CIRCLE] =
    styles[ol.geom.GeometryType.POLYGON].concat(
        styles[ol.geom.GeometryType.LINE_STRING]
    );


styles[ol.geom.GeometryType.POINT] = [
  new ol.style.Style({
    image: new ol.style.Circle({
      radius: width * 2,
      fill: new ol.style.Fill({
        color: red
      }),
      stroke: new ol.style.Stroke({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })
];
styles[ol.geom.GeometryType.MULTI_POINT] =
    styles[ol.geom.GeometryType.POINT];

styles[ol.geom.GeometryType.GEOMETRY_COLLECTION] =
    styles[ol.geom.GeometryType.POLYGON].concat(
        styles[ol.geom.GeometryType.LINE_STRING],
        styles[ol.geom.GeometryType.POINT]
    );


styles[ol.geom.GeometryType.POLYGON] = _.concat(styles[ol.geom.GeometryType.POLYGON],styles[ol.geom.GeometryType.LINE_STRING]);
styles[ol.geom.GeometryType.GEOMETRY_COLLECTION] = _.concat(styles[ol.geom.GeometryType.GEOMETRY_COLLECTION],styles[ol.geom.GeometryType.LINE_STRING]);
    
/* FINE BRUTTISSIMO! */
// run del tool di delete feature
proto.run = function() {
  var self = this;
  this.layer = this.editor.getVectorLayer().getMapLayer();
  this.editingLayer = this.editor.getEditVectorLayer().getMapLayer();
  this._selectInteraction = new ol.interaction.Select({
    layers: [this.layer, this.editingLayer],
    condition: ol.events.condition.click,
    style: function(feature, resolution) {
      var style = self.editor._editingVectorStyle ? self.editor._editingVectorStyle.delete : styles[feature.getGeometry().getType()];
      return style;
    }
  });
  this.addInteraction(this._selectInteraction);
  this._deleteInteraction = new DeleteInteraction({
    features: this._selectInteraction.getFeatures()
  });
  this.addInteraction(this._deleteInteraction);
  this._deleteInteraction.on('deleteend',function(e){
    var feature = e.features.getArray()[0];
    var isNew = self._isNew(feature);
    if (!self._busy){
      self._busy = true;
      self.pause(true);
      self.deleteFeature(feature, isNew)
      .always(function() {
        self._busy = false;
        self.pause(false);
      })
    }
  });

};

proto.pause = function(pause){
  if (_.isUndefined(pause) || pause){
    this._selectInteraction.setActive(false);
    this._deleteInteraction.setActive(false);
  }
  else {
    this._selectInteraction.setActive(true);
    this._deleteInteraction.setActive(true);
  }
};

proto.stop = function(){
  this._selectInteraction.getFeatures().clear();
  this.removeInteraction(this._selectInteraction);
  this._selectInteraction = null;
  this.removeInteraction(this._deleteInteraction);
  this._deleteInteraction = null;
  return true;
};

proto._deleteFeature = function(feature, isNew) {
  var relations = [];
  var relationsPromise = this.editor.getRelationsWithValues(feature);
  relationsPromise
  .then(function(relationsArray) {
    relations = relationsArray;
  });
  this.editor.deleteFeature(feature, relations, isNew);
  this._selectInteraction.getFeatures().clear();
  this._busy = false;
  this.pause(false);
  return true;
};

proto._fallBack = function(feature) {
  this._busy = false;
  this.pause(false);
};

proto._isNew = function(feature){
  return (!_.isNil(this.editingLayer.getSource().getFeatureById(feature.getId())));
};

},{"./editingtool":30,"core/utils/utils":77,"g3w-ol3/src/interactions/deletefeatureinteraction":95}],30:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

// CLASSE PADRE DI TUTTI GLI EDITING TOOL
function EditingTool(editor, options) {
  // interactions
  this._interactions = [];
  // editor padre
  this.editor = editor;
  // il layer originale su cui si fa l'editing
  this.layer = this.editor.getVectorLayer().getMapLayer();
  // il layer di editing
  this.editingLayer = this.editor.getEditVectorLayer().getMapLayer();
  // eventuali opzioni
  this.options = options || {};
  this.steps = null;
  base(this);
}

inherit(EditingTool, G3WObject);

var proto = EditingTool.prototype;
// metodo per aggiungere un'interazione
proto.addInteraction = function(interaction) {
  // recupero il mapservice
  var mapService = this.editor.getMapService();
  mapService.addInteraction(interaction);
  this._interactions.push(interaction);
};
// rimuovo un'interazione
proto.removeInteraction = function(interaction) {
  var _interactions = this._interactions;
  var mapService = this.editor.getMapService();
  _.forEach(_interactions,function(_interaction,idx) {
    if (_interaction == interaction) {
      _interactions.splice(idx,1);
    }
  });
  //vado a rimuove l'interaction e quindi tutte le feture che sono appese
  mapService.removeInteraction(interaction);
};

proto.ownsInteraction = function(interaction) {
  var owns = false;
  _.forEach(this._interactions, function(_interaction) {
    if (_interaction == interaction) {
      owns = true;
    }
  });
  return owns;
};
// metodo di fine editing
proto.stop = function() {
  if (this.steps) {
    this.steps.destroy();
  }
  return true;
};

// metodo che deve essere sovrascritto dalle
// sottoclassi
proto.run = function() {
  console.log('Se appare quasto messaggio significa che non è stato sovrascritto il metodo run() dalla sottoclasse');
};

// classe costruttore dell'istanza steps
EditingTool.Steps = function(steps) {
  // metto a -1 in quanto la prima cosa che faccio è
  // e di fare next() per vedere la prima zione che devo fare
  // quindi individuare il primo elemento dell'array steps
  var index = -1;
  //ARRAY
  var steps = steps;
  this.next = function() {
    index += 1;
    var step = steps[index];
    // emetto evento step
    this.emit('step', index, step);
  };
  
  this.currentStep = function() {
    return steps[index];
  };
  
  this.currentStepIndex = function(){
    return index;
  };
  
  this.totalSteps = function(){
    return steps.length;
  };
  
  this.reset = function(){
    index = 0;
  };
  
  this.destroy = function(){
    this.removeAllListeners();
  };
  
  this.completed = function() {
    // emetto l'evento complete
    this.emit('complete');
    // resetto porto a 0 il valore dell'index
    this.reset();
  };
  // funzione che inserisce qualcosa da fare ad un prciso momento (indice) dell'array
  this.insertStepAt = function(idx,step){
    steps.splice(idx,0,step);
  }
};

inherit(EditingTool.Steps,G3WObject);

module.exports = EditingTool;

},{"core/g3wobject":34,"core/utils/utils":77}],31:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var PickFeatureInteraction = require('g3w-ol3/src/interactions/pickfeatureinteraction');

var EditingTool = require('./editingtool');

function ModifyFeatureTool(editor,options){
  var self = this;
  options = options || {};
  this.editor = editor;
  this.isPausable = true;
  this.drawInteraction = null;
  this._deleteCondition = options.deleteCondition || undefined;
  this._snap = options.snap || null;
  this._snapInteraction = null; 

  this.setters = {
    modifyFeature: ModifyFeatureTool.prototype._modifyFeature
  };
  
  base(this,editor);
}
inherit(ModifyFeatureTool,EditingTool);
module.exports = ModifyFeatureTool;

var proto = ModifyFeatureTool.prototype;

proto.run = function() {
  var self = this;
  this.pickedFeatures = new ol.Collection;
  var layers = [this.editor.getVectorLayer().getMapLayer(),this.editor.getEditVectorLayer().getMapLayer()];
  this._pickInteraction = new PickFeatureInteraction({
    layers: layers
  });

  this.addInteraction(this._pickInteraction);

  this._pickInteraction.on('picked', function(e) {
    self.pickedFeatures.clear();
    self.pickedFeatures.push(e.feature);
  });

  this._modifyInteraction = new ol.interaction.Modify({
    features: this.pickedFeatures,
    deleteCondition: this._deleteCondition
  });
  
  this.addInteraction(this._modifyInteraction);
  var origGeometry = null;
  
  this._modifyInteraction.on('modifystart',function(e) {
    var feature = e.features.getArray()[0];
    origGeometry = feature.getGeometry().clone();
  });
  
  this._modifyInteraction.on('modifyend',function(e){
    var feature = e.features.getArray()[0];
    var isNew = self._isNew(feature);
    //try {
      if (!self._busy) {
        self._busy = true;
        self.pause(true);
        self.modifyFeature(feature, isNew)
        .fail(function(){
          feature.setGeometry(origGeometry);
        })
        .always(function(){
          self._busy = false;
          self.pause(false);
        })
      }
  });
  
  if (this._snap){
    this._snapInteraction = new ol.interaction.Snap({
      source: this._snap.vectorLayer.getSource()
    });
    this.addInteraction(this._snapInteraction);
  }
};

proto.pause = function(pause){
  if (_.isUndefined(pause) || pause){
    if (this._snapInteraction){
      this._snapInteraction.setActive(false);
    }
    this._pickInteraction.setActive(false);
    this._modifyInteraction.setActive(false);
  }
  else {
    if (this._snapInteraction){
      this._snapInteraction.setActive(true);
    }
    this._pickInteraction.setActive(true);
    this._modifyInteraction.setActive(true);
  }
};

proto.stop = function(){
  this.pickedFeatures.clear();
  if (this._snapInteraction){
     this.removeInteraction(this._snapInteraction);
     this._snapInteraction = null;
  }
  this.removeInteraction(this._pickInteraction);
  this._pickInteraction = null;
  this.removeInteraction(this._modifyInteraction);
  this._modifyInteraction = null;
  return true;
};

proto._modifyFeature = function(feature, isNew){
  // aggionro la geometria nel buffer di editing
  this.editor.updateFeature(feature, isNew);
  this._busy = false;
  this.pause(false);
  return true;
};

proto.removePoint = function(coordinate){
  if (this._modifyInteraction){
    // provo a rimuovere l'ultimo punto. Nel caso non esista la geometria gestisco silenziosamente l'errore
    try{
      this._modifyInteraction.removePoint();
    }
    catch (e){
      console.log(e);
    }
  }
};

proto._fallBack = function(feature){
  this._busy = false;
  this.pause(false);
};

proto._isNew = function(feature){
  return (!_.isNil(this.editingLayer.getSource().getFeatureById(feature.getId())));
};

},{"./editingtool":30,"core/g3wobject":34,"core/utils/utils":77,"g3w-ol3/src/interactions/pickfeatureinteraction":99}],32:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;

var EditingTool = require('./editingtool');

function MoveFeatureTool(editor){
  var self = this;
  this.editor = editor;
  this.isPausable = true;
  this.drawInteraction = null;
  this._origGeometry = null;

  this.setters = {
    moveFeature: {
      fnc: MoveFeatureTool.prototype._moveFeature,
      fallback: MoveFeatureTool.prototype._fallBack
    }
  };
  
  base(this,editor);
}
inherit(MoveFeatureTool,EditingTool);
module.exports = MoveFeatureTool;

var proto = MoveFeatureTool.prototype;

proto.run = function(){
  var self = this;
  var layers = [this.editor.getVectorLayer().getMapLayer(),this.editor.getEditVectorLayer().getMapLayer()];
  var style = this.editor._editingVectorStyle ? this.editor._editingVectorStyle.move : null;
  this._selectInteraction = new ol.interaction.Select({
    layers: layers,
    condition: ol.events.condition.click,
    style: style,
    hitTolerance: (isMobile && isMobile.any) ? 10 : 0
  });
  this.addInteraction(this._selectInteraction);
  this._translateInteraction = new ol.interaction.Translate({
    features: this._selectInteraction.getFeatures(),
    hitTolerance: (isMobile && isMobile.any) ? 10 : 0
  });
  this.addInteraction(this._translateInteraction);
  
  this._translateInteraction.on('translatestart',function(e){
    var feature = e.features.getArray()[0];
    self._origGeometry = feature.getGeometry().clone();
    self.editor.emit('movestart',feature);
  });
  
  this._translateInteraction.on('translateend',function(e){
    var feature = e.features.getArray()[0];
    //try {
      if (!self._busy){
        self._busy = true;
        self.pause();
        self.moveFeature(feature)
        .then(function(res){
          self.pause(false);
        })
        .fail(function(){
          feature.setGeometry(self._origGeometry);
        });
      }
  });

};

proto.pause = function(pause){
  if (_.isUndefined(pause) || pause){
    this._selectInteraction.setActive(false);
    this._translateInteraction.setActive(false);
  }
  else {
    this._selectInteraction.setActive(true);
    this._translateInteraction.setActive(true);
  }
};

proto.stop = function(){
  this._selectInteraction.getFeatures().clear();
  this.removeInteraction(this._selectInteraction);
  this._selectInteraction = null;
  this.removeInteraction(this._translateInteraction);
  this._translateInteraction = null;
  return true;
};

proto._moveFeature = function(feature) {
  this.editor.emit('moveend',feature);
  this.editor.moveFeature(feature);
  this._selectInteraction.getFeatures().clear();
  this._busy = false;
  this.pause(false);
  return true;
};

proto._fallBack = function(feature){
  this._busy = false;
  this.pause(false);
};

},{"./editingtool":30,"core/utils/utils":77}],33:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var noop = require('core/utils/utils').noop;
var PickFeatureInteraction = require('g3w-ol3/src/interactions/pickfeatureinteraction');

var EditingTool = require('./editingtool');

function PickFeatureTool(editor){
  var self = this;
  this.isPausable = true;
  this.pickFeatureInteraction = null;
  this._running = false;
  this._busy = false;
  this._originalFeatureStyle = null;
  // qui si definiscono i metodi che vogliamo poter intercettare, ed eventualmente bloccare (vedi API G3WObject)
  this.setters = {
    pickFeature: {
      fnc: PickFeatureTool.prototype._pickFeature,
      fallback: PickFeatureTool.prototype._fallBack
    }
  };
  base(this, editor);
}
inherit(PickFeatureTool, EditingTool);

module.exports = PickFeatureTool;

var proto = PickFeatureTool.prototype;

proto._pickFeature = function(feature) {
  this.editor.pickFeature(feature);
};

// metodo eseguito all'avvio del tool
proto.run = function() {
  var self = this;
  var defaultStyle = new ol.style.Style({
    image: new ol.style.Circle({
      radius: 5,
      fill: new ol.style.Fill({
        color: 'red'
      })
    })
  });
  var style = this.editor._editingVectorStyle ? this.editor._editingVectorStyle.edit : null;
  // vado a settare i layers su cui faccio l'interacion agisce
  var layers = [this.editor.getVectorLayer().getMapLayer(),this.editor.getEditVectorLayer().getMapLayer()];
  this.pickFeatureInteraction = new PickFeatureInteraction({
    layers: layers
  });
  this.pickFeatureInteraction.on('picked', function(e) {
    self.editor.setPickedFeature(e.feature);
    if (!self._busy) {
      e.feature.setStyle(style);
      self._busy = true;
      self.pause(true);
      self.pickFeature(e.feature)
      .then(function(res) {
        self._busy = false;
        self.pause(false);
      })
    }
  });
  
  this.addInteraction(this.pickFeatureInteraction);
};

proto.pause = function(pause){
  if (_.isUndefined(pause) || pause){
    this.pickFeatureInteraction.setActive(false);
  }
  else {
    this.pickFeatureInteraction.setActive(true);
  }
};
// metodo eseguito alla disattivazione del tool
proto.stop = function(){
  this.removeInteraction(this.pickFeatureInteraction);
  this.pickFeatureInteraction = null;
  return true;
};

proto._fallBack = function(feature){
  this._busy = false;
  this.pause(false);
};

},{"./editingtool":30,"core/utils/utils":77,"g3w-ol3/src/interactions/pickfeatureinteraction":99}],34:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var noop = require('core/utils/utils').noop;

/**
 * Un oggetto base in grado di gestire eventuali setter e relativa catena di listeners.
 * @constructor
 */
var G3WObject = function() {
  //quando istanzio l'oggetto verifico che nella sua proprietà
  // ci sia l'attributo setters. Se si vado a registare la catena di eventi
  // per poter registare azioni prima e dopo la chiamata del metodo
  if (this.setters) {
    this._setupListenersChain(this.setters);
  }
};

inherit(G3WObject, EventEmitter);

var proto = G3WObject.prototype;

/**
 * Inserisce un listener dopo che è stato eseguito il setter
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener (solo sincrona)
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onafter = function(setter, listener, priority){
  return this._onsetter('after', setter, listener, false, priority);
};

// un listener può registrarsi in modo da essere eseguito PRIMA dell'esecuzione del metodo setter. Può ritornare true/false per
// votare a favore o meno dell'esecuzione del setter. Se non ritorna nulla o undefined, non viene considerato votante
/**
 * Inserisce un listener prima che venga eseguito il setter. Se ritorna false il setter non viene eseguito
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener, a cui viene passato una funzione "next" come ultimo parametro, da usare nel caso di listener asincroni
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onbefore = function(setter, listener, priority) {
  return this._onsetter('before', setter, listener, false, priority);
};

/**
 * Inserisce un listener prima che venga eseguito il setter. Al listener viene passato una funzione "next" come ultimo parametro, da chiamare con parametro true/false per far proseguire o meno il setter
 * @param {string} setter - Il nome del metodo su cui si cuole registrare una funzione listener
 * @param {function} listener - Una funzione listener, a cui
 * @param {number} priority - Priorità di esecuzione: valore minore viene eseuito prima
 */
proto.onbeforeasync = function(setter, listener, priority) {
  return this._onsetter('before', setter, listener, true, priority);
};

proto.un = function(setter, key){
  _.forEach(this.settersListeners,function(settersListeners) {
    _.forEach(settersListeners[setter],function(setterListener, idx) {
      if(setterListener.key == key) {
        settersListeners[setter].slice(idx, 1);
      }
    })
  })
};

// funzione che si occupa di settare le funzioni legate al setter in base alla tipologia
// di evento se prima o dopo
/*
  when=before|after,
  type=sync|async
*/
proto._onsetter = function(when, setter, listener, async, priority) {
  // vado a recuperarer l'oggetto che ceh si riferifsce al when
  var settersListeners = this.settersListeners[when];
  // creo una listenerKey unica
  var listenerKey = ""+Math.floor(Math.random()*1000000)+""+Date.now();
  // verifico la priorità
  priority = priority || 0;
  // prendo tutto ciò che riguarda il setter (la funzione che dovrà essere chiamata)
  var settersListeneres = settersListeners[setter];
  // vado ad inserire l'oggetto che mi servirà a chiamare la funzione legata
  // al tipo di evento del setter
  settersListeneres.push({
    key: listenerKey,
    fnc: listener,
    async: async,
    priority: priority
  });
  // vado a riordinare l'array dei listeners del setter per quell'evento in base alla priorità
  settersListeners[setter] = _.sortBy(settersListeneres, function(setterListener) {
    return setterListener.priority;
  });
  // ritorno la chiave
  return listenerKey;
};

// trasformo un listener sincrono in modo da poter essere usato nella catena di listeners (richiamando next col valore di ritorno del listener)
/*proto._makeChainable = function(listener){
  var self = this
  return function(){
    var args = Array.prototype.slice.call(arguments);
    // rimuovo next dai parametri prima di chiamare il listener
    var next = args.pop();
    var canSet = listener.apply(self,arguments);
    var _canSet = true;
    if (_.isBoolean(canSet)){
      _canSet = canSet;
    }
    next(canSet);
  }
};*/

// funzione che viene lanciata se la sottoclasse ha come parametro setters
proto._setupListenersChain = function(setters) {
  // inizializza tutti i metodi definiti nell'oggetto "setters" della classe figlia.
  var self = this;
  this.settersListeners = {
    after: {},
    before: {}
  };
  // per ogni setter viene definito l'array dei listeners e fiene sostituito
  // il metodo originale con la funzioni che gestisce la coda di listeners
  // setterOption è la funzione
  // stters è la chiave/nome del metodo che viene assegnato all'istanza
  _.forEach(setters, function(setterOption, setter) {
    var setterFnc = noop;
    var setterFallback = noop;
    // verifico che il valore della chiave setter sia una funzione
    if (_.isFunction(setterOption)){
      setterFnc = setterOption
    } // altrimenti vado a vedere il valore dell'attributo fnc
    else {
      setterFnc = setterOption.fnc;
      setterFallback = setterOption.fallback || noop; // funzione in caso di errore nell'esecuzione della fnc
    }
    //vado a creare l'arry dei metodi/azioni/funzioni che devo essere eseguiti prima/dopo
    //la chiamata del metodo sette dell'oggetto
    self.settersListeners.after[setter] = [];
    self.settersListeners.before[setter] = [];
    // setter aggiunto come proprietà dell'istanza
    self[setter] = function() {
      // prendo gli argomenti passati alla funzione
      var args = arguments;
      var deferred = $.Deferred();
      var returnVal = null;
      var counter = 0;
      // funzione complete che serve per lanciare la funzione setter dell'istanza
      function complete() {
        // eseguo la funzione
        returnVal = setterFnc.apply(self,args);
        // e risolvo la promessa (eventualmente utilizzata da chi ha invocato il setter)
        deferred.resolve(returnVal);
        //vado a eseguire tutti i listener che sono stati settati dopo l'esecuzione del setter
        var afterListeners = self.settersListeners.after[setter];
        _.forEach(afterListeners, function(listener) {
          listener.fnc.apply(self, args);
        })
      }

      // funzione abort che mi server ad uscire dal ciclo dei listener
      // nel caso si verificasse un problema
      function abort() {
        // se non posso proseguire ...
        // chiamo l'eventuale funzione di fallback
        setterFallback.apply(self,args);
        // e rigetto la promessa
        deferred.reject();
      }

      // vado a prendere l'array delle funzioni che devo lanciare prima di lanciare il setter
      var beforeListeners = self.settersListeners['before'][setter];
      // contatore dei listener che verrà decrementato ad ogni chiamata a next()
      counter = 0;
      // funzione passata come ultimo parametro ai listeners,
      // che ***SE SONO STATI AGGIUNTI COME ASINCRONI la DEVONO*** richiamare per poter proseguire la catena
      function next(bool) {
        // inizializzo la variabile cont a true (continue) non possibile usare
        // continue perchè parola riservata di javascript
        var cont = true;
        // verifica se è stato passato un parametro boolenao alla funzione
        // e la setto alla variabile cont (continue)
        if (_.isBoolean(bool)) {
          cont = bool;
        }
        // ricavo l'array di argomenti passati alla funzione setter
        var _args = Array.prototype.slice.call(args);
        // se la catena è stata bloccata (cont==false)
        // o se siamo arrivati alla fine dei beforelisteners
        // o non non sono stati settati nessun beforelisteners
        if (cont === false || (counter == beforeListeners.length)) {
          if (cont === false) {
            // significa che si è verificato un errore oppure si è forzato a concludere
            abort.apply(self, args);
          } else {
            //vado a chiamare la funzione setter
            completed = complete.apply(self, args);
            //verifico che cosa ritorna
            if (_.isUndefined(completed) || completed === true) {
              self.emitEvent('set:'+setter,args);
            }
          }
        } else {
          // se cont è true (continua)
          if (cont) {
            // vado a prendere la funzione dall'array dei before listener
            var listenerFnc = beforeListeners[counter].fnc;
            // verifico se questa è asyncrona
            if (beforeListeners[counter].async) {
              // aggiungo next come ulyimo nel caso di onbeforeasync
              _args.push(next);
              // vado ad aggiornare il counter dei listener onbefore
              counter += 1;
              // chiamo la funzione passandogli l'argomento (modificato con next)
              // su se stesso
              listenerFnc.apply(self, _args)
            } // nel caso di onbefore(quindi non asincrona)
            else {
              // chiamo la funzione listener che mi deve ritornare un boolenano o undefined
              var _cont = listenerFnc.apply(self,_args);
              //vado ad aggiornare il counter
              counter += 1;
              next(_cont);
            }
          }
        }
      }
      // quando viene chiamato la funzione
      // viene lanciato la funzione next
      next();
      return deferred.promise();
    }
  })
};

// funzione che unregistra la chiave del listener
proto.un = function(listenerKey) {
  _.forEach(this.settersListeners, function(setterListeners) {
      _.forEach(setterListeners,function(listener,idx){
        if (listener.key == listenerKey) {
          setterListeners.splice(idx,1);
        }
      })
  })
};

module.exports = G3WObject;

},{"core/utils/utils":77}],35:[function(require,module,exports){
var GENERIC_GRID_EXTENT = [0,0,8388608,8388608];

var Projection = function(options) {
  if (!options.crs) {
    return null;
  }

  if (options.proj4def) {
    proj4.defs(epsgcode,options.proj4);
  }

  ol.proj.Projection.call(this, {
    code: options.crs,
    extent: options.extent ? options.extent : GENERIC_GRID_EXTENT
  });
};

ol.inherits(Projection, ol.proj.Projection);

module.exports = Projection;
},{}],36:[function(require,module,exports){
var Projection = require('core/geo/projection');

var STANDARD_PROJECTIONS = [3857,900913,4326];

var Projections = {
  get: function(crs,proj4,extent) {
    crs = Projections.normalizeCrs(crs);
    var cachedProjection = ol.proj.projections.get(crs);

    if (cachedProjection) {
      return cachedProjection;
    }

    var projection = new Projection({
      crs: crs,
      proj4: proj4,
      extent: extent
    });

    ol.proj.projections.add(crs,projection);

    return projection;
  },
  normalizeCrs: function(crs) {
    if (typeof crs == 'number') {
      return "EPSG:"+crs
    }
    crs = crs.replace(/[^\d\.\-]/g, "");
    if (crs != '') {
      return "EPSG:"+parseInt(crs);
    }
  }
};

module.exports = Projections;
},{"core/geo/projection":35}],37:[function(require,module,exports){
var geom = {
  distance: function(c1,c2){
    return Math.sqrt(geom.squaredDistance(c1,c2));
  },
  squaredDistance: function(c1,c2){
    var x1 = c1[0];
    var y1 = c1[1];
    var x2 = c2[0];
    var y2 = c2[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    return dx * dx + dy * dy;
  },
  closestOnSegment: function(coordinate, segment) {
    var x0 = coordinate[0];
    var y0 = coordinate[1];
    var start = segment[0];
    var end = segment[1];
    var x1 = start[0];
    var y1 = start[1];
    var x2 = end[0];
    var y2 = end[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = (dx === 0 && dy === 0) ? 0 :
        ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);
    var x, y;
    if (along <= 0) {
      x = x1;
      y = y1;
    } else if (along >= 1) {
      x = x2;
      y = y2;
    } else {
      x = x1 + along * dx;
      y = y1 + along * dy;
    }
    return [x, y];
  }
}

module.exports = geom;

},{}],38:[function(require,module,exports){
var Geometry = {};

Geometry.GeometryTypes = {
  POINT: "Point",
  MULTIPOINT: "MultiPoint",
  LINESTRING: "Line", // per seguire la definizione di QGis.GeometryType, che definisce Line invece di Linestring.
  MULTILINESTRING: "MultiLine",
  POLYGON: "Polygon",
  MULTIPOLYGON: "MultiPolygon",
  GEOMETRYCOLLECTION: "GeometryCollection"
};

Geometry.SupportedGeometryTypes = [
  Geometry.GeometryTypes.POINT,
  Geometry.GeometryTypes.MULTIPOINT,
  Geometry.GeometryTypes.LINESTRING,
  Geometry.GeometryTypes.MULTILINESTRING,
  Geometry.GeometryTypes.POLYGON,
  Geometry.GeometryTypes.MULTIPOLYGON
]

module.exports = Geometry;

},{}],39:[function(require,module,exports){
function init(config) {
  i18next
  .use(i18nextXHRBackend)
  .init({ 
      lng: 'it',
      ns: 'app',
      fallbackLng: 'it',
      resources: config.resources
  });
  
  jqueryI18next.init(i18next, $, {
    tName: 't', // --> appends $.t = i18next.t
    i18nName: 'i18n', // --> appends $.i18n = i18next
    handleName: 'localize', // --> appends $(selector).localize(opts);
    selectorAttr: 'data-i18n', // selector for translating elements
    targetAttr: 'data-i18n-target', // element attribute to grab target element to translate (if diffrent then itself)
    optionsAttr: 'data-i18n-options', // element attribute that contains options, will load/set if useOptionsAttr = true
    useOptionsAttr: false, // see optionsAttr
    parseDefaultValueFromContent: true // parses default values from content ele.val or ele.text
  });
}
    
var t = function(text){
    var trad = i18next.t(text);
    return trad;
};
    
module.exports = {
  init: init,
  t: t
};

},{}],40:[function(require,module,exports){
// Classe Feature che eridita da ol.Feature sfruttando tutti i metodi
// necessari anche alla costruzione di un layer vettoriale
// Allo stesso modo può essere un oggetto non vettoriale non settando la geometria
// ma solo le proprièta
var Feature = function(options) {
  ol.Feature.call(this, options);
  // necessario per poter interagire reattivamente con l'esterno
  this.state = {
    //attributi reattivi
  }
};

ol.inherits(Feature, ol.Feature);


module.exports = Feature;
},{}],41:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interfaccia per registare i layers
function FeaturesStore(options) {
  var self = this;
  options = options || {};
  this._features = [];
  this._dataprovider = options.dataprovider || null;
  this.setters = {
    addFeatures: function(features) {
      _.forEach(features, function(feature) {
        self._addFeature(feature);
      })
    },
    addFeature: function(feature) {
      self._addFeature(feature);
    },
    removeFeature: function(feature) {
      self._removeFeature(feature);
    },
    clearFeatures: function() {
      self._clearFeatures()
    }
  };

  base(this);
}

inherit(FeaturesStore, G3WObject);

proto = FeaturesStore.prototype;

proto.getFeatures = function(options) {
  var self = this;
  var d = $.Deferred();
  this._dataprovider.getFeatures(options)
    .then(function(features) {
      // il provider ritornerà 
      self.addFeatures(features);
      d.resolve(this._features);
    });
  return d.promise();
};

proto._addFeature = function(feature) {
  this._features.push(feature);
};

proto._removeFeature = function(feature) {
  this._features.push(feature);
};

proto._clearFeatures = function() {
  // vado a rimuovere le feature in modo reattivo (per vue) utlizzando metodi che vue
  // possa reagire allacancellazione di elementi di un array
  this._features.splice(0, this._features.length);
};

module.exports = FeaturesStore;
},{"core/g3wobject":34,"core/utils//utils":77,"core/utils/utils":77}],42:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var Layer = require('core/layers/layer');
var Projections = require('core/geo/projections');
var ProviderFactory = require('core/layers/providers/providersfactory');
var FeaturesStore = require('core/layers/features/featuresstore');
var Feature = require('core/layers/features/feature');
var Editor = require('core/editing/editor');
var GeometryTypes = require('core/geometry/geometry').GeometryTypes;

var ServerTypes = {
  OGC: "OGC",
  QGIS: "QGIS",
  Mapserver: "Mapserver",
  Geoserver: "Geoserver",
  ArcGIS: "ArcGIS",
  OSM: "OSM",
  Bing: "Bing"
};

var WMSServerTypes = [
  ServerTypes.QGIS,
  ServerTypes.Mapserver,
  ServerTypes.Geoserver,
  ServerTypes.OGC
];

function GeoLayer(config) {
  base(this, config);
  var self = this;
  _.extend(this.config,{
    bbox: config.bbox,
    projection: null,
    project: config.project,
    geometrytype: config.geometrytype,
    infoformat: config.infoformat,
    infourl: config.infourl,
    maxscale: config.maxscale,
    minscale: config.minscale,
    multilayerid: config.multilayer,
    scalebasedvisibility: config.scalebasedvisibility,
    wmsUrl: config.wmsUrl,
    cacheUrl: config.cache_url,
    baselayer: config.baselayer || false,
    wfscapabilities: config.wfscapabilities
  });

  // temporaneo
  this.state.geolayer = true;


  if (config.projection) {
    this.config.projection = config.projection;
  }
  else if (config.crs) {
    if (config.project) {
      if (config.project.getProjection().getCode() != config.crs) {
        Projections.get(config.crs,config.proj4);
      }
      else {
        this.config.projection = config.project.getProjection();
      }
    }
  }

  // in base alla tipologia di configurazione del layer
  // viene deciso quale provider deve essere instanziato
  //TEMPORANEO
  if (this.config.servertype == Layer.ServerTypes.QGIS) {
    // contiene il provider associato al layer
    this._queryprovider = ProviderFactory.build('qgis', {
      layer: this,
      layerName: this.getQueryLayerName(),
      infoFormat: this.getInfoFormat()
    });
    // vado a creare il featuresStore che si prenderà cura del recupero
    // dati (attraverso il suo provider) e salvataggio features
    this._featuresStore = new FeaturesStore({
      dataprovider: this._queryprovider //momentaneo
    });
  } else {
    // contiene il provider associato al layer
    this._queryprovider = ProviderFactory.build('qgis', {
      layer: this,
      layerName: this.getQueryLayerName(),
      infoFormat: this.getInfoFormat()
    }); //
  }
}

inherit(GeoLayer, Layer);

var proto = GeoLayer.prototype;

proto.getConfig = function() {
  return this.config;
};

proto.getState = function() {
  return this.state;
};

proto.getProject = function() {
  return this.config.getProject();
};

proto.getEditor = function() {
  return this.editor;
};

proto.setEditor = function(editor) {
  this.editor = editor;
};

proto._startEditing = function() {
  console.log('start Editing');
  //this.editor.start();
};

proto._stopEditing = function() {
  console.log('stop editing');
  // this.editor.stop()
};

// funzione per la lettura dei dati precedentemente acquisiti dal provider
proto.readFeatures = function() {
  return this._featuresStore.readFeatures();
};

proto._clearFeatures = function() {
  this._featuresStore.clearFeatures();
};


// funzione che recupera i dati da qualsisasi fonte (server, wms, etc..)
proto.getFeatures = function(options) {
  var self = this;
  var d = $.Deferred();
  this._featuresStore.getFeatures(options)
    .then(function(features) {
      return d.resolve(features);
    });
  return d.promise();
};

proto.isModified = function() {
  //medodo che stbilisce se modificato o no
  return this.state.modified;
};

proto.getDataProvider = function() {
  return this._dataprovider;
};

proto.getMultiLayerId = function() {
  return this.config.multilayerid;
};

proto.getGeometryType = function() {
  return this.config.geometrytype;
};

proto.getMultiLayerId = function() {
  return this.config.multilayerid;
};

proto.getAttributes = function() {
  return this.fields;
};

proto.changeAttribute = function(attribute, type, options) {
  _.forEach(this.fields, function(field) {
    if (field.name == attribute) {
      field.type = type;
      field.options = options;
    }
  })
};

proto.getAttributeLabel = function(name) {
  var label;
  _.forEach(this.getAttributes(),function(field){
    if (field.name == name){
      label = field.label;
    }
  });
  return label;
};

// restituisce tutte le relazioni legati a quel layer
proto.getRelations = function() {
  return this.state.relations
};

//restituisce gli attributi fields di una deterninata relazione
proto.getRelationAttributes = function(relationName) {
  var fields = [];
  _.forEach(this.state.relations, function(relation) {
    if (relation.name == relationName) {
      fields = relation.fields;
      return false
    }
  });
  return fields;
};

// retituisce un oggetto contenente nome relazione e fileds(attributi) associati
proto.getRelationsAttributes = function() {
  var fields = {};
  _.forEach(this.state.relations, function(relation) {
    fields[relation.name] = relation.fields;
  });
  return fields;
};

proto.isSelected = function() {
  return this.state.selected;
};

proto.isDisabled = function() {
  return this.state.disabled;
};

proto.isVisible = function() {
  return this.state.visible;
};

proto.isBaseLayer = function() {
  return this.config.baselayer;
};

proto.getServerType = function() {
  if (this.config.servertype && this.config.servertype != '') {
    return this.config.servertype;
  }
  else {
    return Layer.ServerTypes.QGIS;
  }
};

this.setProjection = function(crs,proj4) {
  this.config.projection = Projections.get(crs,proj4);
};

proto.getProjection = function() {
  return this.config.projection;
};

proto.getCrs = function() {
  if (this.config.projection) {
    return this.config.projection.getCode();
  }
};

proto.getProjectCrs = function() {
  if (this.config.projection) {
    return this.config.projection.getCode();
  }
};

proto.isWMS = function() {
  return WMSServerTypes.indexOf(this.config.servertype) > -1;
};

proto.isWFS = function() {
  return this.config.wfscapabilities == 1;
};

proto.isExternalWMS = function() {
  return (this.config.source && this.config.source.url);
};

proto.getWMSLayerName = function() {
  // prendo come inizio 'attributo name come nome del layer wms
  var layerName = this.config.name;
  if (this.config.source && this.config.source.layers) {
    layerName = this.config.source.layers;
  }
  return layerName;
};

proto.getWmsUrl = function() {
  var url;
  if (this.config.source && this.config.source.type == 'wms' && this.config.source.url){
    url = this.config.source.url
  }
  else {
    url = this.config.wmsUrl;
  }
  return url;
};

proto.getLegendUrl = function() {
  var url = this.getWmsUrl();
  sep = (url.indexOf('?') > -1) ? '&' : '?';
  return url+sep+'SERVICE=WMS&VERSION=1.3.0&REQUEST=GetLegendGraphic&SLD_VERSION=1.1.0&FORMAT=image/png&TRANSPARENT=true&ITEMFONTCOLOR=white&LAYERTITLE=True&ITEMFONTSIZE=10&WIDTH=300&LAYER='+this.getWMSLayerName();
};

proto.getWFSLayerName = function() {
  // prendo come inizio 'attributo name come nome del layer wms
  var layerName = this.config.origname;
  if (this.config.source && this.config.source.layers) {
    layerName = this.config.source.layers;
  }
  return layerName;
};

proto.isCached = function() {
  return this.config.cacheUrl && this.config.cacheUrl != '' ? true : false;
};

proto.getCacheUrl = function(){
  if (this.isCached()) {
    return this.config.cacheUrl;
  }
};

proto.isQueryable = function() {
  var queryEnabled = false;
  var queryableForCababilities = (this.config.capabilities && (this.config.capabilities && Layer.CAPABILITIES.QUERY)) ? true : false;
  if (queryableForCababilities) {
    // è interrogabile se visibile e non disabilitato (per scala) oppure se interrogabile comunque (forzato dalla proprietà infowhennotvisible)
    queryEnabled = (this.state.visible && !this.state.disabled);
    if (!_.isUndefined(this.config.infowhennotvisible) && (this.config.infowhennotvisible === true)) {
      queryEnabled = true;
    }
  }
  return queryEnabled;
};

proto.query = function(options) {
  var self = this;
  var d = $.Deferred();
  this._queryprovider.query(options)
    .then(function(features) {
      d.resolve(features);
    });
  return d.promise();
};

proto.getQueryUrl = function() {
  var infoUrl;
  if (this.config.infourl && this.config.infourl != '') {
    infoUrl = this.config.infourl;
  }
  else {
    infoUrl = this.config.wmsUrl;
  }
  if (this.getServerType() != 'QGIS') {
    infoUrl+='SOURCE=wms';
  }
  return infoUrl;
};

proto.setQueryUrl = function(queryUrl) {
  this.config.inforurl = queryUrl;
};

proto.getQueryLayerName = function() {
  var queryLayerName;
  if (this.config.infolayer && this.config.infolayer != '') {
    queryLayerName = this.config.infolayer;
  }
  else {
    queryLayerName = this.config.name;
  }
  return queryLayerName;
};

proto.getQueryLayerOrigName = function() {
  var queryLayerName;
  if (this.state.infolayer && this.config.infolayer != '') {
    queryLayerName = this.config.infolayer;
  }
  else {
    queryLayerName = this.config.origname;
  }
  return queryLayerName;
};

proto.getInfoFormat = function(ogcService) {
  if (this.config.infoformat && this.config.infoformat != '' && ogcService !='wfs') {
    return this.config.infoformat;
  }
  else {
    return 'application/vnd.ogc.gml';
  }
};

proto.setInfoFormat = function(infoFormat) {
  this.state.infoformat = infoFormat;
};

proto.getWfsCapabilities = function() {
  return this.config.wfscapabilities || this.config.capabilities == 1 ;
};

GeoLayer.WMSServerTypes = [
  ServerTypes.QGIS,
  ServerTypes.Mapserver,
  ServerTypes.Geoserver,
  ServerTypes.OGC
];


module.exports = GeoLayer;

},{"core/editing/editor":25,"core/g3wobject":34,"core/geo/projections":36,"core/geometry/geometry":38,"core/layers/features/feature":40,"core/layers/features/featuresstore":41,"core/layers/layer":43,"core/layers/providers/providersfactory":49,"core/utils//utils":77,"core/utils/utils":77}],43:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');


function Layer(config) {
  var self = this;
  // contiene la configurazione statica del layer
  this.config = {
    capabilities: config.capabilities,
    project: config.project,
    editops: config.editops,
    id: config.id,
    title: config.title,
    name: config.name,
    origname: config.origname,
    servertype: config.servertype,
    source: config.source,
    geolayer: false
  };

  // contiene l'editor associato al layer
  this.editor = null;
  this.provider = null;
  // contiene la parte dinamica del layer
  //this.state = config; // questo fa in modo che il catalog reagisca al mutamento
  // delle proprietà dinamiche (select, disable, visible)
  this.state = {
    id: config.id,
    title: config.name,
    visible: config.visible,
    selected: config.selected | false,
    disabled: config.disabled | false,
    editing: false,
    modified: false,
    hidden: config.hidden || false
  };
  // struttura campi del layer
  this.fields = config.fields;
  // relations
  this.relations = config.relations || null; // da vedere com gestirle
  // setters
  this.setters = {
    //funzione che segnala lo start editing
    startEditing: function() {
      self._startEditing();
    },
    // segnalazione stop editing
    stopEditing: function() {
      self._stopEditing();
    },
    // cancellazione di tutte le features del layer
    clearFeatures: function() {
      self._clearFeatures();
    }
  };
  base(this);
}

inherit(Layer, G3WObject);

var proto = Layer.prototype;

proto.getProject = function() {
  return this.config.project;
};

proto.getConfig = function() {
  return this.config;
};

proto.getState = function() {
  return this.state;
};

proto.getEditor = function() {
  return this.editor;
};

proto.setEditor = function(editor) {
  this.editor = editor;
};

proto._startEditing = function() {
  console.log('start Editing')
  //this.editor.start();
};

proto._stopEditing = function() {
  console.log('stop editing');
  // this.editor.stop()
};

// funzione per la lettura dei dati precedentemente acquisiti dal provider
proto.readFeatures = function() {
  return this._featuresStore.readFeatures();
};

proto._clearFeatures = function() {
  this._featuresStore.clearFeatures();
};


// funzione che recupera i dati da qualsisasi fonte (server, wms, etc..)
proto.getFeatures = function(options) {
  var self = this;
  var d = $.Deferred();
  this._featuresStore.getFeatures(options)
    .then(function(features) {
      return d.resolve(features);
    });
  return d.promise();
};

proto.isHidden = function() {
  return this.state.hidden;
};

proto.setHidden = function(bool) {
  this.state.hidden = _.isBoolean(bool) ? bool: true;
};

proto.isModified = function() {
  //medodo che stbilisce se modificato o no
  return this.state.modified;
};

proto.getDataProvider = function() {
  return this.dataprovider;
};

proto.getId = function() {
  return this.config.id;
};

proto.getTitle = function() {
  return this.config.title;
};

proto.getName = function() {
  return this.config.name;
};

proto.getOrigName = function() {
  return this.config.origname;
};

proto.getAttributes = function() {
  return this.fields;
};

proto.changeAttribute = function(attribute, type, options) {
  _.forEach(this.fields, function(field) {
    if (field.name == attribute) {
      field.type = type;
      field.options = options;
    }
  })
};

proto.getAttributeLabel = function(name) {
  var label;
  _.forEach(this.getAttributes(),function(field){
    if (field.name == name){
      label = field.label;
    }
  });
  return label;
};

// restituisce tutte le relazioni legati a quel layer
proto.getRelations = function() {
  return this.state.relations
};

//restituisce gli attributi fields di una deterninata relazione
proto.getRelationAttributes = function(relationName) {
  var fields = [];
  _.forEach(this.state.relations, function(relation) {
    if (relation.name == relationName) {
      fields = relation.fields;
      return false
    }
  });
  return fields;
};

// retituisce un oggetto contenente nome relazione e fileds(attributi) associati
proto.getRelationsAttributes = function() {
  var fields = {};
  _.forEach(this.state.relations, function(relation) {
    fields[relation.name] = relation.fields;
  });
  return fields;
};

proto.isSelected = function() {
  return this.state.selected;
};

proto.isDisabled = function() {
  return this.state.disabled;
};

proto.isVisible = function() {
  return this.state.visible;
};

proto.getServerType = function() {
  if (this.state.servertype && this.config.servertype != '') {
    return this.config.servertype;
  }
  else {
    return ServerTypes.QGIS;
  }
};


// SOLO GeoLayer implementa i seguenti metodi

proto.getGeometryType = function() {};

proto.getQueryLayerName = function() {};

proto.getQueryLayerOrigName = function() {};

proto.setProjection = function(crs,proj4) {};

proto.getProjection = function() {};

proto.getCrs = function() {};

proto.getProjectCrs = function() {};

proto.isWMS = function() {return false};

proto.isWFS = function() {return false};

proto.isExternalWMS = function() {};

proto.getWMSLayerName = function() {};

proto.getWFSLayerName = function() {};

proto.isCached = function() {return false};

proto.getCacheUrl = function(){};

proto.isQueryable = function() {return false};

proto.query = function(options) {};

proto.getQueryUrl = function() {};

proto.setQueryUrl = function(queryUrl) {};

proto.getInfoFormat = function(ogcService) {};

proto.setInfoFormat = function(infoFormat) {};

proto.getWfsCapabilities = function() {};

Layer.ServerTypes = {
  OGC: "OGC",
  QGIS: "QGIS",
  Mapserver: "Mapserver",
  Geoserver: "Geoserver",
  ArcGIS: "ArcGIS",
  OSM: "OSM",
  Bing: "Bing"
};

Layer.CAPABILITIES = {
  QUERY: 1,
  EDIT: 2
};

Layer.EDITOPS = {
  INSERT: 1,
  UPDATE: 2,
  DELETE: 4
};


module.exports = Layer;

},{"core/g3wobject":34,"core/utils//utils":77,"core/utils/utils":77}],44:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interfaccia per registare i layers
function LayersStore(config) {
  var self = this;
  config = config || {};

  this.config = {
    id: config.id || Date.now(),
    projection: config.projection,
    extent: config.extent,
    initextent: config.initextent,
    wmsUrl: config.wmsUrl,
    //metto caratteristica catalogabile
    catalog: _.isBoolean(config.catalog) ? config.catalog : true
  };

  this.state = {
    layerstree: []
  };

  this._layers = this.config.layers || {};

  this.setters = {
    setLayersVisible: function (layersIds, visible) {
      var self = this;
      _.forEach(layersIds, function (layerId) {
        self.getLayerById(layerId).state.visible = visible;
      })
    },
    setLayerSelected: function(layerId, selected) {
      var layers = this.getLayers();
      _.forEach(layers, function(layer) {
        layer.state.selected = ((layerId == layer.getId()) && selected) || false;
      })
    },
    addLayer: function(layer) {
      this._addLayer(layer);
    },
    removeLayer: function(layerId) {
      this._removeLayer(layerId);
    }
  };

  base(this);
}

inherit(LayersStore, G3WObject);

proto = LayersStore.prototype;

proto.showOnCatalog = function() {
  return this.config.catalog;
};

proto.setOptions = function(config) {
  this.config = config;
};

proto.getId = function() {
  return this.config.id;
};

proto._addLayer = function(layer) {
  this._layers[layer.getId()] = layer;
};

proto.addLayers = function(layers) {
  var self = this;
  _.forEach(layers, function(layer) {
    self.addLayer(layer);
  });
};

proto._removeLayer = function(layerId) {
  delete this._layers[layerId];
};

proto.removeLayers = function(layersId) {
  _.forEach(layersId, function(layerId) {
    self.removeLayer(layer)
  })
};

proto.getLayersDict = function(options) {
  if (!options) {
    return this._layers;
  }
  var options = options || {};
  var filterActive = options.ACTIVE;
  var filterQueryable = options.QUERYABLE;
  var filterVisible = options.VISIBLE;
  var filterSelected = options.SELECTED;
  var filterCached = options.CACHED;
  var filterSelectedOrAll = options.SELECTEDORALL;
  var filterAllNotSelected = options.ALLNOTSELECTED;
  var filterServerType = options.SERVERTYPE;
  var filterBaseLayer = options.BASELAYER || false;
  var filterGeoLayer = options.GEOLAYER;
  var filterHidden = options.HIDDEN;
  var filterWfs = options.WFS;
  if (filterSelectedOrAll) {
    filterSelected = null;
  }
  if (_.isUndefined(filterQueryable)
    && _.isUndefined(filterVisible)
    && _.isUndefined(filterActive)
    && _.isUndefined(filterSelected)
    && _.isUndefined(filterCached)
    && _.isUndefined(filterSelectedOrAll)
    && _.isUndefined(filterServerType)
    && _.isUndefined(filterGeoLayer)
    && _.isUndefined(filterHidden)
    && _.isUndefined(filterBaseLayer)) {
    return this._layers;
  }
  var layers = [];
  _.forEach(this._layers, function(layer, key) {
    layers.push(layer);
  });


  if (typeof filterActive == 'boolean') {
    layers = _.filter(layers, function(layer) {
      return filterActive == !layer.isDisabled();
    });
  }

  if (typeof filterQueryable == 'boolean') {
    layers = _.filter(layers, function(layer) {
      return filterQueryable == layer.isQueryable();
    });
  }

  if (typeof filterVisible == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterVisible == layer.isVisible();
    });
  }

  if (typeof filterCached == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterCached == layer.isCached();
    });
  }

  if (typeof filterSelected == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterSelected == layer.isSelected();
    });
  }

  if (typeof filterBaseLayer == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterBaseLayer == layer.isBaseLayer();
    });
  }

  if (typeof filterGeoLayer == 'boolean') {
    layers = _.filter(layers,function(layer) {
      return filterGeoLayer == layer.state.geolayer;
    });
  }

  if (typeof filterHidden == 'boolean') {
    layers = _.filter(layers,function(layer){
      return filterHidden == layer.isHidden();
    });
  }

  if (typeof filterServerType == 'string' && filterServerType!='') {
    layers = _.filter(layers,function(layer){
      return filterServerType = layer.getServerType();
    });
  }
  // filtra solo i selezionati
  if (filterSelectedOrAll) {
    var _layers = layers;
    layers = _.filter(layers,function(layer){
      return layer.isSelected();
    });
    layers = layers.length ? layers : _layers;
  }

  // filtra solo i quelli non selezionati
  if (filterAllNotSelected) {
    var _layers = layers;
    layers = _.filter(layers,function(layer){
      return !layer.isSelected();
    });
    layers = layers.length ? layers : _layers;
  }

  // filtra solo i quelli wfs
  if (filterWfs) {
    layers = _.filter(layers,function(layer) {
      // specifico che deve evare lo stesso crs del progetto
      return layer.getWfsCapabilities() && layer.config.crs == 3003;
    });
  }

  return layers;
};

// ritorna l'array dei layers (con opzioni di ricerca)
proto.getLayers = function(options) {
  var layers = this.getLayersDict(options);
  return _.values(layers);
};

proto.getBaseLayers = function() {
  return this.getLayersDict({
    BASELAYER: true
  });
};

proto.getLayerById = function(layerId) {
  return this.getLayersDict()[layerId];
};

proto.getLayerByName = function(name) {
  var layer = null;
  _.forEach(this.getLayersDict(),function(layer){
    if (layer.getName() == name){
      layer = _layer;
    }
  });
  return layer;
};

proto.getLayerAttributes = function(layerId){
  return this.getLayerById(layerId).getAttributes();
};

proto.getLayerAttributeLabel = function(layerId,name){
  return this.getLayerById(layerId).getAttributeLabel(name);
};

proto.getGeoLayers = function() {

};

proto.toggleLayer = function(layerId,visible){
  var layer = this.getLayerById(layerId);
  var visible = visible || !layer.state.visible;
  this.setLayersVisible([layerId],visible);
};

proto.toggleLayers = function(layersIds,visible){
  this.setLayersVisible(layersIds,visible);
};

proto.selectLayer = function(layerId){
  this.setLayerSelected(layerId, true);
};

proto.unselectLayer = function(layerId) {
  this.setLayerSelected(layerId, false);
};

proto.getProjection = function() {
  return this.config.projection;
};

proto.getExtent = function() {
  return this.config.extent;
};

proto.getInitExtent = function() {
  return this.config.initextent;
};

proto.getWmsUrl = function() {
  return this.config.wmsUrl;
};

// funzione che setta il layersstree deli layers del layersstore
proto.setLayersTree = function(layerstree,name) {
  var self = this;
  function traverse(obj) {
    _.forIn(obj, function (layer, key) {
      //verifica che il nodo sia un layer e non un folder
      if (!_.isNil(layer.id)) {
        obj[key] = self.getLayerById(layer.id).getState();
      }
      if (!_.isNil(layer.nodes)){
        traverse(layer.nodes);
      }
    });
  }
  traverse(layerstree);

  // questo server per raggruppare ogni albero dei layer
  // al proprio gruppo che sia un progetto, un plugin o altro
  // quando viene creato il layersstore
  this.state.layerstree.splice(0,0,{
    title: name || this.config.id,
    expanded: true,
    nodes: layerstree
  });
};

proto.removeLayersTree = function(id){
  this.state.layerstree.splice(0,this.state.layerstree.length);
};

proto.getLayersTree = function(id) {
  return this.state.layerstree;
};

module.exports = LayersStore;

},{"core/g3wobject":34,"core/utils//utils":77,"core/utils/utils":77}],45:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var LayersStore = require('core/layers/layersstore');

// Interfaccia per registare i layers
function LayersStoresRegistry() {
  var self = this;

  this.stores = {};
  this.storesArray = [];
  // questi setters mi servono per far reagire  le varie parti dell'applicazione
  // che dipendono o sono legate ai layersStores
  this.setters = {
    addLayersStore: function(layersStore, idx) {
      this._addLayersStore(layersStore, idx);
    },
    removeLayersStore: function(layerStore) {
      this._removeLayersStore(layerStore);
    }
  };

  base(this);
}

inherit(LayersStoresRegistry, G3WObject);

proto = LayersStoresRegistry.prototype;

proto.getLayersStore = function(id) {
  return this.stores[id];
};

proto.getLayersStores = function() {
  var self = this;
  var stores = [];

  _.forEach(this.storesArray,function(storeId){
    stores.push(self.stores[storeId]);
  });

  return stores;
};

// funzione che aggiunge un layersstore al registro della
proto._addLayersStore = function(layerStore, idx) {
  // usiamo un array per garantire ordine di inserimento, poi potremo gestire richieste di inserimento in una specifica posizione
  var storeId = layerStore.getId();
  this.stores[storeId] = layerStore;
  if (!_.isNil(idx)) {
    this.storesArray.splice(0,1, storeId);
  } else {
    this.storesArray.push(storeId);
  }
};

proto._removeLayersStore = function(layerStore) {
  var id = layerStore.getId();
  if (layerStore) {
    delete this.stores[id];
    this.storesArray.splice(this.storesArray.indexOf(layerStore, 1));
  }
};

module.exports = new LayersStoresRegistry();
},{"core/g3wobject":34,"core/layers/layersstore":44,"core/utils//utils":77,"core/utils/utils":77}],46:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function GEOJSONDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'geojson';
}

inherit(GEOJSONDataProvider, DataProvider);

var proto = GEOJSONDataProvider.prototype;

proto.getFearures = function() {
  var d = $.Deferred();
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
  var d = $.Deferred();
  // attravercso il layer name e il base url
  // chiedo la server di inviarmi la configurazione editing del laye
  $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
  var d = $.Deferred();
  var lock = this.getMode() == 'w' ? true : false;
  var apiUrl;
  if (lock) {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
  } else {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
  }
  $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

module.exports = GEOJSONDataProvider;


},{"core/layers/providers/provider":48,"core/utils/utils":77}],47:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function KMLDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'kml';
}

inherit(KMLDataProvider, DataProvider);

var proto = KMLDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};


module.exports = KMLDataProvider;
},{"core/layers/providers/provider":48,"core/utils/utils":77}],48:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var Feature = require('core/layers/features/feature');

function DataProvider(options) {
  options = options || {};
  this._isReady = false;
  this._name = 'provider';
  base(this);
}

inherit(DataProvider, G3WObject);

var proto = DataProvider.prototype;

proto.getFeatures = function() {
  console.log('da sovrascrivere')
};

proto.query = function(options) {
  console.log('metodo da sovrascrivere')
};

proto.setReady = function(bool) {
  this._isReady = bool;
};

proto.isReady = function() {
  return this._isReady;
};

proto.error = function() {
  //TODO
};

proto.isValid = function() {
  console.log('deve essere implementatato dai singoli provider');
};

proto.getName = function() {
  return this._name;
};


module.exports = DataProvider;
},{"core/g3wobject":34,"core/layers/features/feature":40,"core/utils/utils":77}],49:[function(require,module,exports){
var Providers = {
  geojson: require('./geojsonprovider'),
  kml: require('./kmlprovider'),
  xml: require('./xmlprovider'),
  qgis: require('./qgisprovider'),
  wms: require('./wmsprovider'),
  wfs: require('./wfsprovider')
};

function ProviderFactory() {
  this.build = function(type, options) {
    // ritorna l'sitanza del provider selezionato
    return new Providers[type](options);
  };
}

module.exports = new ProviderFactory();

},{"./geojsonprovider":46,"./kmlprovider":47,"./qgisprovider":50,"./wfsprovider":51,"./wmsprovider":52,"./xmlprovider":53}],50:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

var PIXEL_TOLERANCE = 10;
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];

function  QGISDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'qgis';
  this._layer = options.layer || null;
  this._layerName = options.layerName || null;
  this._infoFormat = options.infoFormat || 'application/vnd.ogc.gml';
}

inherit(QGISDataProvider, DataProvider);

var proto = QGISDataProvider.prototype;

proto.getFeatures = function(options) {
  options = options || {};
};

// funzione che in base ai layers e alla tipologia di servizio
// restituisce gli url per ogni layer o gruppo di layers
// che condividono lo stesso indirizzo di servizio
proto.getInfoFromLayer = function(ogcService) {
  // wfs specifica se deve essere fatta chiamata wfs o no
  // scooro sui ogni layer e catturo il queryUrl
  // se wfs prendo l'api fornite dal server
  if (ogcService == 'wfs') {
    var queryUrl = this._layer.getWmsUrl();
  } else {
    var queryUrl = this._layer.getQueryUrl();
  }
  return {
    url: queryUrl,
    infoFormat: this._layer.getInfoFormat(ogcService),
    crs: this._layer.getProjectCrs(), // dovrebbe essere comune a tutti
    serverType: this._layer.getServerType() // aggiungo anche il tipo di server
  };
};

proto._getRequestUrl = function(url, extent, size, pixelRatio, projection, params) {

  ol.asserts.assert(url !== undefined, 9); // `url` must be configured or set using `#setUrl()`

  params['CRS'] = projection.getCode();

  if (!('STYLES' in params)) {
    params['STYLES'] = '';
  }

  params['DPI'] = 90 * pixelRatio;
  params['WIDTH'] = size[0];
  params['HEIGHT'] = size[1];

  var axisOrientation = projection.getAxisOrientation();
  var bbox;
  if (axisOrientation.substr(0, 2) == 'ne') {
    bbox = [extent[1], extent[0], extent[3], extent[2]];
  } else {
    bbox = extent;
  }
  params['BBOX'] = bbox.join(',');

  return ol.uri.appendParams(/** @type {string} */ url, params);
};

// funzione che deve esserere "estratta dal mapservice"
proto._getGetFeatureInfoUrlForLayer = function(coordinates,resolution,params) {
  var url = this._layer.getQueryUrl();
  var extent = ol.extent.getForViewAndSize(
    coordinates, resolution, 0,
    GETFEATUREINFO_IMAGE_SIZE);

  var baseParams = {
    'SERVICE': 'WMS',
    'VERSION': ol.DEFAULT_WMS_VERSION,
    'REQUEST': 'GetFeatureInfo',
    'FORMAT': 'image/png',
    'TRANSPARENT': true,
    'QUERY_LAYERS': this._layer.getName()
  };

  _.merge(baseParams, params);

  var x = Math.floor((coordinates[0] - extent[0]) / resolution);
  var y = Math.floor((extent[3] - coordinates[1]) / resolution);
  baseParams[ 'I' ] = x;
  baseParams['J'] = y;

  return this._getRequestUrl(
    url, extent, GETFEATUREINFO_IMAGE_SIZE,
    1, this._layer.getProjection(), baseParams);
};

proto.query = function(options) {
  var d = $.Deferred();
  var coordinates = options.coordinates || [];
  var urlForLayer = this.getInfoFromLayer();
  var resolution = options.resolution || null;
  var queryUrlForLayer = [];
  var sourceParam = urlForLayer.url.split('SOURCE');
  urlForLayer.url = sourceParam[0];
  if (sourceParam.length > 1) {
    sourceParam = '&SOURCE' + sourceParam[1];
  } else {
    sourceParam = '';
  }
  var queryLayers = [this._layer];
  var infoFormat = this._infoFormat;
  var params = {
    LAYERS: this._layerName,
    QUERY_LAYERS: this._layerName,
    INFO_FORMAT: infoFormat,
    FEATURE_COUNT: 10,
    // PARAMETRI DI TOLLERANZA PER QGIS SERVER
    FI_POINT_TOLERANCE: PIXEL_TOLERANCE,
    FI_LINE_TOLERANCE: PIXEL_TOLERANCE,
    FI_POLYGON_TOLERANCE: PIXEL_TOLERANCE,
    G3W_TOLERANCE: PIXEL_TOLERANCE * resolution
  };
  var getFeatureInfoUrl = this._getGetFeatureInfoUrlForLayer(coordinates,resolution,params); 
  var queryString = getFeatureInfoUrl.split('?')[1];
  var url = urlForLayer.url+'?'+queryString + sourceParam;
  queryUrlForLayer.push({
    url: url,
    infoformat: infoFormat,
    queryLayers: queryLayers
  });
  this.makeQueryForLayer(queryUrlForLayer, coordinates, resolution)
    .then(function(response) {
      d.resolve(response)
    })
    .fail(function(e){
      d.reject(e);
    });
  return d.promise();
};

// da verificare generalizzazione
proto.makeQueryForLayer = function(queryUrlsForLayers, coordinates, resolution) {
  var self = this;
  var d = $.Deferred();
  var queryInfo = {
    coordinates: coordinates,
    resolution: resolution
  };
  if (queryUrlsForLayers.length > 0) {
    var queryRequests = [];
    var featuresForLayers = [];
    _.forEach(queryUrlsForLayers,function(queryUrlForLayers){
      var url = queryUrlForLayers.url;
      var queryLayers = queryUrlForLayers.queryLayers;
      var infoFormat = queryUrlForLayers.infoformat;
      var postData = queryUrlForLayers.postData;
      var request = self.doRequestAndParse({
        url: url,
        infoFormat: infoFormat,
        queryLayers: queryLayers,
        postData: postData
      });
      queryRequests.push(request);
    });
    $.when.apply(this, queryRequests).
    then(function(){
      var vectorsDataResponse = Array.prototype.slice.call(arguments);
      _.forEach(vectorsDataResponse, function(_featuresForLayers){
        if(featuresForLayers){
          featuresForLayers = _.concat(featuresForLayers,_featuresForLayers);
        }
      });
      featuresForLayers = self.handleResponseFeaturesAndRelations(featuresForLayers);
      d.resolve({
        data: featuresForLayers,
        query: queryInfo
      });
    })
      .fail(function(e){
        d.reject(e);
      });
  }
  else {
    d.resolve({
      data: null,
      query: queryInfo
    });
  }
  return d.promise()
};

proto.doRequestAndParse = function(options) {
  var options = options || {};
  var url = options.url;
  var infoFormat = options.infoFormat;
  var queryLayers = options.queryLayers;
  var postData = options.postData || null;
  var self = this;
  var d = $.Deferred();
  var request;
  if (postData) {
    request = $.post(url, postData)
  } else {
    request = $.get(url);
  }
  request
    .done(function(response) {
      var featuresForLayers = self.handleQueryResponseFromServer(response, infoFormat, queryLayers);
      d.resolve(featuresForLayers);
    })
    .fail(function(){
      d.reject();
    });
  return d;
};



proto.convertG3wRelations = function(feature) {
  var g3w_relations = feature.getProperties().g3w_relations;
  var relations = null;
  if (g3w_relations) {
    relations = [];
    _.forEach(g3w_relations, function(elements, relationName) {
      relation = {};
      if (elements.length) {
        relation.name = relationName;
        relation.elements = elements;
        relations.push(relation);
      } else {
        delete g3w_relations[relationName];
      }
    });
    if (relations.length) {
      feature.set('relations', relations);
    } else {
      feature.unset('g3w_relations');
    }
  }
};

// funzione per il recupero delle relazioni della features se ci sono
// nell'attributo g3w_relations
proto.handleResponseFeaturesAndRelations = function(layersResponse) {
  var self = this;
  _.forEach(layersResponse, function(layer) {
    _.forEach(layer.features, function(feature) {
      self.convertG3wRelations(feature);
    });
  });
  return layersResponse
};

// Messo qui generale la funzione che si prende cura della trasformazione dell'xml di risposta
// dal server così da avere una risposta coerente in termini di formato risultati da presentare
// nel componente QueryResults
proto.handleQueryResponseFromServer = function(response, infoFormat, queryLayers, ogcService) {
  var jsonresponse;
  var featuresForLayers = [];
  var parser, data;
  switch (infoFormat) {
    case 'json':
      parser = this._parseLayerGeoJSON;
      data = response.vector.data;
      break;
    default:
      // caso gml
      var x2js = new X2JS();
      try {
        if (_.isString(response)) {
          jsonresponse = x2js.xml_str2json(response);
        } else {
          jsonresponse = x2js.xml2json(response);
        }
      }
      catch (e) {
        return;
      }
      var rootNode = _.keys(jsonresponse)[0];
      switch (rootNode) {
        case 'FeatureCollection':
          parser = this._parseLayerFeatureCollection;
          data = jsonresponse;
          break;
        case "msGMLOutput":
          parser = this._parseLayermsGMLOutput;
          data = response;
          break;
      }
  }
  var nfeatures = 0;
  if (parser) {
    _.forEach(queryLayers, function(queryLayer) {
      var features = parser.call(self, queryLayer, data, ogcService);
      nfeatures += features.length;
      featuresForLayers.push({
        layer: queryLayer,
        features: features
      })
    });
  }
  return featuresForLayers;
};

// Brutto ma per ora unica soluzione trovata per dividere per layer i risultati di un doc xml wfs.FeatureCollection.
// OL3 li parserizza tutti insieme non distinguendo le features dei diversi layers
proto._parseLayerFeatureCollection = function(queryLayer, data, ogcService) {
  var layerName = (ogcService == 'wfs') ? queryLayer.getWMSLayerName().replace(/ /g,'_'): queryLayer.getWMSLayerName().replace(/ /g,''); // QGIS SERVER rimuove gli spazi dal nome del layer per creare l'elemento FeatureMember
  var layerData = _.cloneDeep(data);
  layerData.FeatureCollection.featureMember = [];
  var featureMembers = data.FeatureCollection.featureMember;
  featureMembers = _.isArray(featureMembers) ? featureMembers : [featureMembers];
  _.forEach(featureMembers,function(featureMember){
    var isLayerMember = _.get(featureMember,layerName);
    if (isLayerMember) {
      layerData.FeatureCollection.featureMember.push(featureMember);
    }
  });

  var x2js = new X2JS();
  var layerFeatureCollectionXML = x2js.json2xml_str(layerData);
  var parser = new ol.format.WMSGetFeatureInfo();
  return parser.readFeatures(layerFeatureCollectionXML);
};

// mentre con i risultati in msGLMOutput (da Mapserver) il parser può essere istruito per parserizzare in base ad un layer di filtro
proto._parseLayermsGMLOutput = function(queryLayer, data, ogcService) {
  var layers = queryLayer.getQueryLayerOrigName();
  var parser = new ol.format.WMSGetFeatureInfo({
    layers: layers
  });
  return parser.readFeatures(data);
};

proto._parseLayerGeoJSON = function(queryLayer, data) {
  var geojson = new ol.format.GeoJSON({
    defaultDataProjection: this.crs,
    geometryName: "geometry"
  });
  return geojson.readFeatures(data);
};



// METODI LOADING EDITING FEATURES //

// funzione principale, starting point, chiamata dal plugin per
// il recupero dei vettoriali (chiamata verso il server)
proto.loadLayers = function(mode, customUrlParameters) {
  // il parametro mode mi di è in scrittura, lettura etc ..
  var self = this;
  var deferred = $.Deferred();
  // tiene conto dei codici dei layer che non sono stati
  // i dati vettoriali
  var noVectorlayerCodes = [];
  // setto il mode (r/w)
  this.setMode(mode);
  //verifico che ci siano parametri custom (caso di alcuni plugin) da aggiungere alla base url
  // per fare le chiamate al server
  if (customUrlParameters) {
    this._setCustomUrlParameters(customUrlParameters)
  }
  //verifica se sono stati caricati i vettoriali dei layer
  // attraverso la proprietà vector del layer passato dal plugin
  _.forEach(this._layers, function(layer, layerCode) {
    // verifico se l'attributo vector è nullo
    if (_.isNull(layer.vector)) {
      noVectorlayerCodes.push(layerCode);
    }
  });
  // eseguo le richieste delle configurazioni e mi tengo le promesse
  var vectorLayersSetup = _.map(noVectorlayerCodes, function(layerCode) {
    return self._setupVectorLayer(layerCode);
  });
  // emetto l'evento loadingvectorlayersstart (il pluginservice è in ascolto)
  self.emit('loadingvectorlayersstart');
  // aspetto tutte le promesse del setup vector
  $.when.apply(this, vectorLayersSetup)
  // una volta che tutte le configurazioni dei layer vecor
  // sono state prese dal server e dopo aver assegnato all'attributo vector
  // del layer plugin il layer vettoriale costruito con le configurazioni
  // di sopra
    .then(function() {
      // le promesse ritornano il layerCode del layer vettoriale appena costuito
      var vectorLayersCodes = Array.prototype.slice.call(arguments);
      // emtto evento che inzia il recupero dei dati dei layer vettoriali (geojson)
      self.emit('loadingvectolayersdatastart');
      // inizio a caricare tutti i vettoriali dopo aver caricato le configurazioni
      self.loadAllVectorsData(vectorLayersCodes)
        .then(function() {
          self._vectorLayersCodes = vectorLayersCodes;
          deferred.resolve(vectorLayersCodes);
          // emtto evento che ho ricevuto i layers
          self.emit('loadingvectorlayersend');
          // ora il loader è pronto
          self.setReady(true);

        })
        .fail(function() {
          // risetto tutti i layer veetotiali a null
          _.forEach(self._layers, function(layer) {
            layer.vector = null;
          });
          deferred.reject();
          // emttto che c'è stato un errore nel loading dei dati che vengono dal server
          self.emit('errorloadingvectorlayersend');
          self.setReady(false);
        })
    })
    .fail(function() {
      self.setReady(false);
      self.emit('errorloadingvectorlayersend');
      deferred.reject();
    });
  return deferred.promise();
};

proto.setVectorLayersCodes = function(vectorLayersCodes) {
  this._vectorLayersCodes = vectorLayersCodes;
};

proto.getVectorLayersCodes = function() {
  return this._vectorLayersCodes;
};

proto.getLayers = function() {
  return this._layers;
};

// funzione che fa il reload che rihiede di nuovo il dati del vetor layer
// caso in cui si lavora con un layer vettoriale e non si usa un wms per fare la query
proto.reloadVectorData = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  var bbox = this._mapService.state.bbox;
  self._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
          self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
          vectorLayer.setData(vectorDataResponse.vector.data);
          deferred.resolve(vectorLayer);
        });
    });
  return deferred.promise();
};

//funzione che permette di ottenere tutti i dati relativi ai layer vettoriali caricati
//prima si è ottenuta la coinfigurazione, ora si ottengono i dati veri e propri
proto.loadAllVectorsData = function(layerCodes) {
  var self = this;
  var deferred = $.Deferred();
  var layers = this._layers;
  // verifico che il BBOX attuale non sia stato già  caricato
  // prondo il bbox
  var bbox = this._mapService.state.bbox;
  var loadedExtent = this._loadedExtent;
  if (loadedExtent && ol.extent.containsExtent(loadedExtent, bbox)) {
    return resolvedValue();
  }
  if (!loadedExtent) {
    this._loadedExtent = bbox;
  } else {
    this._loadedExtent = ol.extent.extend(loadedExtent, bbox);
  }
  if (layerCodes) {
    layers = [];
    _.forEach(layerCodes, function(layerCode) {
      layers.push(self._layers[layerCode]);
    });
  }
  //per ogni layer del plugin che non ha il layer vado a caricare i dati del layer vettoriale
  var vectorDataRequests = _.map(layers, function(Layer) {
    return self._loadVectorData(Layer.vector, bbox);
  });

  $.when.apply(this, vectorDataRequests)
    .then(function() {
      deferred.resolve(layerCodes);
    })
    .fail(function(){
      deferred.reject();
    });

  return deferred.promise();
};

proto._setCustomUrlParameters = function(customUrlParameters) {
  this._customUrlParameters = customUrlParameters;
};

proto._checkVectorGeometryTypeFromConfig = function(vectorConfig) {
  switch (vectorConfig.geometrytype) {
    case 'Line':
      vectorConfig.geometrytype = 'LineString';
      break;
    case 'MultiLine':
      vectorConfig.geometrytype = 'MultiLineString';
      break;
  }
  return vectorConfig;
};


proto._createVectorLayerFromConfig = function(layerCode) {
  var self = this;
  // recupero la configurazione del layer settata da plugin service
  var layerConfig = this._layers[layerCode];
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._getVectorLayerConfig(layerConfig[this._editingApiField])
    .then(function(vectorConfigResponse) {
      var vectorConfig = vectorConfigResponse.vector;
      // vado a verificare la correttezza del geometryType (caso di editing generico)
      vectorConfig = self._checkVectorGeometryTypeFromConfig(vectorConfig);
      // una volta ottenuta dal server la configurazione vettoriale,
      // provvedo alla creazione del layer vettoriale
      var crsLayer = layerConfig.crs || self._mapService.getProjection().getCode();
      var vectorLayer = self._createVectorLayer({
        geometrytype: vectorConfig.geometrytype,
        format: vectorConfig.format,
        crs: self._mapService.getProjection().getCode(),
        crsLayer : crsLayer,
        id: layerConfig.id,
        name: layerConfig.name,
        pk: vectorConfig.pk,
        editing: self._editingMode
      });
      // setto i campi del layer
      vectorLayer.setFields(vectorConfig.fields);
      vectorLayer.setCrs(crsLayer);
      // questo è la proprietà della configurazione del config layer
      // che specifica se esistono relazioni con altri layer
      // sono array di oggetti che specificano una serie di
      // informazioni su come i layer sono relazionati (nome della relazione == nome layer)
      // foreign key etc ..
      var relations = vectorConfig.relations;
      // nel caso il layer abbia relazioni (array non vuoto)
      if (relations) {
        // per dire a vectorLayer che i dati
        // delle relazioni verranno caricati solo quando
        // richiesti (es. aperture form di editing)
        vectorLayer.lazyRelations = true;
        //vado a settare le relazioni del vector layer
        vectorLayer.setRelations(relations);
      }
      // setto lo stile del layer OL
      if (layerConfig.style) {
        vectorLayer.setStyle(layerConfig.style);
      }
      // risolve con il nome del vectorLayer
      deferred.resolve(vectorLayer);
    })
    .fail(function(){
      deferred.reject();
    });
  return deferred.promise();
};

// funzione che dato la configurazione del layer fornito dal plugin (style, editor, vctor etc..)
// esegue richieste al server al fine di ottenere configurazione vettoriale del layer
proto._setupVectorLayer = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      var layerConfig = self._layers[layerCode];
      // assegno il vetorLayer appena creato all'attributo vector del layer
      layerConfig.vector = vectorLayer;
      // risolve con il nome del layerCode
      deferred.resolve(layerCode);
    })
    .fail(function() {
      deferred.reject();
    });
  return deferred.promise();
};

//in base all bbox e la layer chiedo al server di restituirmi il vettoriale (geojson) del layer
proto._loadVectorData = function(vectorLayer, bbox) {
  var self = this;
  // eseguo le richieste dei dati al server al fine di ottenere il geojson,
  // vettoriale, del layer richiesto
  return self._getVectorLayerData(vectorLayer, bbox)
    .then(function(vectorDataResponse) {
      self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
      // setto i dati vettoriali del layer vettoriale
      // e verifico se siamo in editingMode write e se ci sono featurelocks
      if (self._editingMode && vectorDataResponse.featurelocks) {
        // nel cso in cui sia in editing (mode w) e che si siano featureLocks
        // setto tale features al layervettoriale
        self.setVectorFeaturesLock(vectorLayer, vectorDataResponse.featurelocks);
      }
      //setto i dati del layer vettoriale (geojson)
      vectorLayer.setData(vectorDataResponse.vector.data);
      if (self._)
        return vectorDataResponse;
    })
    .fail(function() {
      return false;
    })
};

proto.getVectorLayerData = function(layerCode) {
  return this._vectorLayersData[layerCode];
};

proto.getVectorLayersData = function() {
  return this._vectorLayersData;
};

proto.setVectorLayerData = function(layerCode, vectorLayerData) {
  this._vectorLayersData[layerCode] = vectorLayerData;
};

//funzione che setta le features lock del layer vettoriale
proto.setVectorFeaturesLock = function(vectorLayer, featureslock) {
  //vado a pescare le fifferenze tra le featureidlock già caricati id
  var newFeaturesLockIds = _.differenceBy(featureslock, vectorLayer.getFeatureLocks(), 'featureid');
  _.forEach(newFeaturesLockIds, function(newLockId) {
    vectorLayer.addLockId(newLockId)
  });
};

proto.cleanVectorFeaturesLock = function(vectorLayer) {
  vectorLayer.cleanFeatureLocks();
};

proto.lockFeatures = function(layerName) {
  var self = this;
  var d = $.Deferred();
  var bbox = this._mapService.state.bbox;
  var vectorLayer = this._layers[layerName].vector;
  $.get(this._baseUrl+layerName+"/?lock" + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      self.setVectorFeaturesLock(vectorLayer, data.featurelocks);
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
  var d = $.Deferred();
  // attravercso il layer name e il base url
  // chiedo la server di inviarmi la configurazione editing del laye
  $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
  var d = $.Deferred();
  var lock = this.getMode() == 'w' ? true : false;
  var apiUrl;
  if (lock) {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
  } else {
    apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
  }
  $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};
// funzione per creare il layer vettoriale
proto._createVectorLayer = function(options) {
  var vector = new VectorLayer(options);
  return vector;
};
//funzione chiamata dal plugin quando si vuole fare un cleanUp dei layers
// !!! -- DA RIVEDERE -- !!!
proto.cleanUpLayers = function() {
  this._loadedExtent = null;
};


module.exports = QGISDataProvider;

},{"core/layers/providers/provider":48,"core/utils/utils":77}],51:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');


function WFSDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'wfs';
}

inherit(WFSDataProvider, DataProvider);

var proto = WFSDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};


module.exports = WFSDataProvider;
},{"core/layers/providers/provider":48,"core/utils/utils":77}],52:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function WMSDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'wms';
}

inherit(WMSDataProvider, DataProvider);

var proto = WMSDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};

module.exports = WMSDataProvider;
},{"core/layers/providers/provider":48,"core/utils/utils":77}],53:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function XMLDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'xml';
}

inherit(XMLDataProvider, DataProvider);

var proto = XMLDataProvider.prototype;

proto.getData = function() {
  var d = $.Deferred();
  return d.promise();
};

module.exports = XMLDataProvider;
},{"core/layers/providers/provider":48,"core/utils/utils":77}],54:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function BingLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(BingLayer,MapLayer);

var proto = BingLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;

  var olLayer;
  var subtype = this.layer.state.source ? this.layer.state.source.subtype : null
  switch(subtype) {
    case 'streets':
      olLayer = BaseLayers.BING.Road;
      break;
    case 'aerial':
      olLayer = BaseLayers.BING.Aerial;
      break;
    case 'aerialwithlabels':
      olLayer = BaseLayers.BING.AerialWithLabels;
      break;
    default:
      olLayer = BaseLayers.BING.Aerial;
      break;
  }
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto._updateLayer = function(mapState,extraParams){
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = BingLayer;

},{"core/map/layer/maplayer":57,"core/utils/geo":76,"core/utils/utils":77,"g3w-ol3/src/layers/bases":100}],55:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function LoaderLayerService() {
  this._layers = {};
  this._type = 'tipo di layers';
  this._isReady = false;
  base(this);
}
inherit(LoaderLayerService, G3WObject);

var proto = LoaderLayerService.prototype;

proto.getLoaderType = function() {
    return this._type;
};

proto.getLayers = function() {
  return this._layers;
};

proto.getLayer = function(layerName) {
  return this._layers[layerName];
};

proto.loadLayer = function(url, options) {
  //TODO
};
proto.loadLayers = function() {
  //TODO
};

proto.cleanUpLayers = function() {
  //TODO
};

proto.setReady = function(bool) {
  this._isReady = bool;
};

proto.isReady = function() {
  return this._isReady;
};

// setto il modo di caricare il layer
proto.setMode = function(mode) {
  switch(mode){
    case 'w':
      this._editingMode = true;
      break;
    case 'r':
      this._editingMode = false;
      break;
    default:
      mode = 'w';
      this._editingMode = true;
  }
  this._mode = mode;
  this.emit('setmode', mode);
};

proto.getMode = function() {
  return this._mode;
};



module.exports = LoaderLayerService;
},{"core/g3wobject":34,"core/utils/utils":77}],56:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var resolvedValue = require('core/utils/utils').resolve;
var VectorLayer = require('core/map/layer/vectorlayer');
var LoaderLayer = require('./loaderlayer');

function VectorLoaderLayer() {
  this._layer = {};
  this._type = 'vector';
  this._layerCodes = [];
  this._baseUrl = '';
  this._mapService = null;
  this._loadedExtent = null;
  this._editingMode = false;
  this._customUrlParameters = '';
  //mi tengo i vectorLayersCodes dei layer caricati
  this._vectorLayersCodes = [];
  this._vectorLayersData = {};
  base(this);
  //setto le proprià che mi interessano
  this.init = function(options) {
    //i layers provenienti dal plugin
    this._layers = options.layers || {};
    // il base url per poter fare richieste al server
    this._baseUrl = options.baseurl || '';
    // il map service per ineragire con la mappa
    // recuperando il bbox del layer vettoriale
    this._mapService = options.mapService || null;
    // i codice dei layers per poter recuperare le informazioni
    // dei layers passati dal plugin
    this._layerCodes = _.keys(this._layers);
    // questo mi permette di gestire e generalizzare il valore del campo del layer
    // a cui passare all'apiEditing
    this._editingApiField = options.editingApiField || 'name';
  };
}

inherit(VectorLoaderLayer, LoaderLayer);

var proto = VectorLoaderLayer.prototype;
// funzione principale, starting point, chiamata dal plugin per
// il recupero dei vettoriali (chiamata verso il server)
proto.loadLayers = function(mode, customUrlParameters) {
    // il parametro mode mi di è in scrittura, lettura etc ..
  var self = this;
  var deferred = $.Deferred();
  // tiene conto dei codici dei layer che non sono stati
  // i dati vettoriali
  var noVectorlayerCodes = [];
  // setto il mode (r/w)
  this.setMode(mode);
  //verifico che ci siano parametri custom (caso di alcuni plugin) da aggiungere alla base url
  // per fare le chiamate al server
  if (customUrlParameters) {
    this._setCustomUrlParameters(customUrlParameters)
  }
  //verifica se sono stati caricati i vettoriali dei layer
  // attraverso la proprietà vector del layer passato dal plugin
  _.forEach(this._layers, function(layer, layerCode) {
    // verifico se l'attributo vector è nullo
    if (_.isNull(layer.vector)) {
      noVectorlayerCodes.push(layerCode);
    }
  });
  // eseguo le richieste delle configurazioni e mi tengo le promesse
  var vectorLayersSetup = _.map(noVectorlayerCodes, function(layerCode) {
    return self._setupVectorLayer(layerCode);
  });
    // emetto l'evento loadingvectorlayersstart (il pluginservice è in ascolto)
  self.emit('loadingvectorlayersstart');
  // aspetto tutte le promesse del setup vector
  $.when.apply(this, vectorLayersSetup)
    // una volta che tutte le configurazioni dei layer vecor
    // sono state prese dal server e dopo aver assegnato all'attributo vector
    // del layer plugin il layer vettoriale costruito con le configurazioni
    // di sopra
    .then(function() {
      // le promesse ritornano il layerCode del layer vettoriale appena costuito
      var vectorLayersCodes = Array.prototype.slice.call(arguments);
      // emtto evento che inzia il recupero dei dati dei layer vettoriali (geojson)
      self.emit('loadingvectolayersdatastart');
      // inizio a caricare tutti i vettoriali dopo aver caricato le configurazioni
      self.loadAllVectorsData(vectorLayersCodes)
      .then(function() {
        self._vectorLayersCodes = vectorLayersCodes;
        deferred.resolve(vectorLayersCodes);
        // emtto evento che ho ricevuto i layers
        self.emit('loadingvectorlayersend');
        // ora il loader è pronto
        self.setReady(true);

      })
      .fail(function() {
        // risetto tutti i layer veetotiali a null
        _.forEach(self._layers, function(layer) {
          layer.vector = null;
        });
        deferred.reject();
        // emttto che c'è stato un errore nel loading dei dati che vengono dal server
        self.emit('errorloadingvectorlayersend');
        self.setReady(false);
      })
  })
  .fail(function() {
    self.setReady(false);
    self.emit('errorloadingvectorlayersend');
    deferred.reject();
  });
  return deferred.promise();
};

proto.setVectorLayersCodes = function(vectorLayersCodes) {
  this._vectorLayersCodes = vectorLayersCodes;
};

proto.getVectorLayersCodes = function() {
  return this._vectorLayersCodes;
};

proto.getLayers = function() {
  return this._layers;
};

// funzione che fa il reload che rihiede di nuovo il dati del vetor layer
// caso in cui si lavora con un layer vettoriale e non si usa un wms per fare la query
proto.reloadVectorData = function(layerCode) {
  var self = this;
  var deferred = $.Deferred();
  var bbox = this._mapService.state.bbox;
  self._createVectorLayerFromConfig(layerCode)
    .then(function(vectorLayer) {
      self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
          self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
          vectorLayer.setData(vectorDataResponse.vector.data);
          deferred.resolve(vectorLayer);
        });
    });
  return deferred.promise();
};

//funzione che permette di ottenere tutti i dati relativi ai layer vettoriali caricati
//prima si è ottenuta la coinfigurazione, ora si ottengono i dati veri e propri
proto.loadAllVectorsData = function(layerCodes) {
    var self = this;
    var deferred = $.Deferred();
    var layers = this._layers;
    // verifico che il BBOX attuale non sia stato già  caricato
  // prondo il bbox
    var bbox = this._mapService.state.bbox;
    var loadedExtent = this._loadedExtent;
    if (loadedExtent && ol.extent.containsExtent(loadedExtent, bbox)) {
      return resolvedValue();
    }
    if (!loadedExtent) {
      this._loadedExtent = bbox;
    } else {
      this._loadedExtent = ol.extent.extend(loadedExtent, bbox);
    }
    if (layerCodes) {
      layers = [];
      _.forEach(layerCodes, function(layerCode) {
        layers.push(self._layers[layerCode]);
      });
    }
    //per ogni layer del plugin che non ha il layer vado a caricare i dati del layer vettoriale
    var vectorDataRequests = _.map(layers, function(Layer) {
        return self._loadVectorData(Layer.vector, bbox);
    });

    $.when.apply(this, vectorDataRequests)
        .then(function() {
            deferred.resolve(layerCodes);
        })
        .fail(function(){
            deferred.reject();
        });

    return deferred.promise();
};

proto._setCustomUrlParameters = function(customUrlParameters) {
  this._customUrlParameters = customUrlParameters;
};

proto._checkVectorGeometryTypeFromConfig = function(vectorConfig) {
  switch (vectorConfig.geometrytype) {
    case 'Line':
      vectorConfig.geometrytype = 'LineString';
      break;
    case 'MultiLine':
      vectorConfig.geometrytype = 'MultiLineString';
      break;
  }
  return vectorConfig;
};


proto._createVectorLayerFromConfig = function(layerCode) {
  var self = this;
  // recupero la configurazione del layer settata da plugin service
  var layerConfig = this._layers[layerCode];
  var deferred = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._getVectorLayerConfig(layerConfig[this._editingApiField])
    .then(function(vectorConfigResponse) {
      var vectorConfig = vectorConfigResponse.vector;
      // vado a verificare la correttezza del geometryType (caso di editing generico)
      vectorConfig = self._checkVectorGeometryTypeFromConfig(vectorConfig);
      // una volta ottenuta dal server la configurazione vettoriale,
      // provvedo alla creazione del layer vettoriale
      var crsLayer = layerConfig.crs || self._mapService.getProjection().getCode();
      var vectorLayer = self._createVectorLayer({
        geometrytype: vectorConfig.geometrytype,
        format: vectorConfig.format,
        crs: self._mapService.getProjection().getCode(),
        crsLayer : crsLayer,
        id: layerConfig.id,
        name: layerConfig.name,
        pk: vectorConfig.pk,
        editing: self._editingMode
      });
      // setto i campi del layer
      vectorLayer.setFields(vectorConfig.fields);
      vectorLayer.setCrs(crsLayer);
      // questo è la proprietà della configurazione del config layer
      // che specifica se esistono relazioni con altri layer
      // sono array di oggetti che specificano una serie di
      // informazioni su come i layer sono relazionati (nome della relazione == nome layer)
      // foreign key etc ..
      var relations = vectorConfig.relations;
      // nel caso il layer abbia relazioni (array non vuoto)
      if (relations) {
        // per dire a vectorLayer che i dati
        // delle relazioni verranno caricati solo quando
        // richiesti (es. aperture form di editing)
        vectorLayer.lazyRelations = true;
        //vado a settare le relazioni del vector layer
        vectorLayer.setRelations(relations);
      }
      // setto lo stile del layer OL
      if (layerConfig.style) {
        vectorLayer.setStyle(layerConfig.style);
      }
      // risolve con il nome del vectorLayer
      deferred.resolve(vectorLayer);
    })
    .fail(function(){
      deferred.reject();
    });
  return deferred.promise();
};

// funzione che dato la configurazione del layer fornito dal plugin (style, editor, vctor etc..)
// esegue richieste al server al fine di ottenere configurazione vettoriale del layer
proto._setupVectorLayer = function(layerCode) {
    var self = this;
    var deferred = $.Deferred();
    // eseguo le richieste delle configurazioni
    this._createVectorLayerFromConfig(layerCode)
        .then(function(vectorLayer) {
            var layerConfig = self._layers[layerCode];
            // assegno il vetorLayer appena creato all'attributo vector del layer
            layerConfig.vector = vectorLayer;
            // risolve con il nome del layerCode
            deferred.resolve(layerCode);
        })
        .fail(function() {
            deferred.reject();
        });
    return deferred.promise();
};

//in base all bbox e la layer chiedo al server di restituirmi il vettoriale (geojson) del layer
proto._loadVectorData = function(vectorLayer, bbox) {
    var self = this;
    // eseguo le richieste dei dati al server al fine di ottenere il geojson,
    // vettoriale, del layer richiesto
    return self._getVectorLayerData(vectorLayer, bbox)
        .then(function(vectorDataResponse) {
            self.setVectorLayerData(vectorLayer[self._editingApiField], vectorDataResponse);
            // setto i dati vettoriali del layer vettoriale
            // e verifico se siamo in editingMode write e se ci sono featurelocks
            if (self._editingMode && vectorDataResponse.featurelocks) {
              // nel cso in cui sia in editing (mode w) e che si siano featureLocks
              // setto tale features al layervettoriale
              self.setVectorFeaturesLock(vectorLayer, vectorDataResponse.featurelocks);
            }
            //setto i dati del layer vettoriale (geojson)
            vectorLayer.setData(vectorDataResponse.vector.data);
          if (self._)
            return vectorDataResponse;
        })
      .fail(function() {
        return false;
      })
};

proto.getVectorLayerData = function(layerCode) {
  return this._vectorLayersData[layerCode];
};

proto.getVectorLayersData = function() {
  return this._vectorLayersData;
};

proto.setVectorLayerData = function(layerCode, vectorLayerData) {
  this._vectorLayersData[layerCode] = vectorLayerData;
};

//funzione che setta le features lock del layer vettoriale
proto.setVectorFeaturesLock = function(vectorLayer, featureslock) {
  //vado a pescare le fifferenze tra le featureidlock già caricati id
  var newFeaturesLockIds = _.differenceBy(featureslock, vectorLayer.getFeatureLocks(), 'featureid');
  _.forEach(newFeaturesLockIds, function(newLockId) {
    vectorLayer.addLockId(newLockId)
  });
};

proto.cleanVectorFeaturesLock = function(vectorLayer) {
  vectorLayer.cleanFeatureLocks();
};

proto.lockFeatures = function(layerName) {
  var self = this;
  var d = $.Deferred();
  var bbox = this._mapService.state.bbox;
  var vectorLayer = this._layers[layerName].vector;
  $.get(this._baseUrl+layerName+"/?lock" + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
    .done(function(data) {
      self.setVectorFeaturesLock(vectorLayer, data.featurelocks);
      d.resolve(data);
    })
    .fail(function(){
      d.reject();
    });
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function(layerApiField) {
    var d = $.Deferred();
    // attravercso il layer name e il base url
    // chiedo la server di inviarmi la configurazione editing del laye
    $.get(this._baseUrl+layerApiField+"/?config"+ this._customUrlParameters)
        .done(function(data) {
            d.resolve(data);
        })
        .fail(function(){
            d.reject();
        });
    return d.promise();
};

// ottiene il vettoriale in modalità  editing
proto._getVectorLayerData = function(vectorLayer, bbox) {
    var d = $.Deferred();
    var lock = this.getMode() == 'w' ? true : false;
    var apiUrl;
    if (lock) {
      apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?editing";
    } else {
      apiUrl = this._baseUrl+vectorLayer[this._editingApiField]+"/?"
    }
    $.get(apiUrl + this._customUrlParameters+"&in_bbox=" + bbox[0]+","+bbox[1]+","+bbox[2]+","+bbox[3])
        .done(function(data) {
            d.resolve(data);
        })
        .fail(function(){
            d.reject();
        });
    return d.promise();
};
// funzione per creare il layer vettoriale
proto._createVectorLayer = function(options) {
  var vector = new VectorLayer(options);
  return vector;
};
//funzione chiamata dal plugin quando si vuole fare un cleanUp dei layers
// !!! -- DA RIVEDERE -- !!!
proto.cleanUpLayers = function() {
    this._loadedExtent = null;
};

module.exports = VectorLoaderLayer;
},{"./loaderlayer":55,"core/map/layer/vectorlayer":59,"core/utils/utils":77}],57:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function MapLayer(config){
  this.config = config || {};
  this.id = config.id;
  this.projection = config.projection;
  this._olLayer = null;
  base(this);
}

inherit(MapLayer, G3WObject);

var proto = MapLayer.prototype;

proto.getId = function(){
  return this.id;
};

module.exports = MapLayer;

},{"core/g3wobject":34,"core/utils/utils":77}],58:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function OSMLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(OSMLayer,MapLayer);

var proto = OSMLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;

  
  var olLayer = BasesLayers.OSM;
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto._updateLayer = function(mapState,extraParams){
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = OSMLayer;

},{"core/map/layer/maplayer":57,"core/utils/geo":76,"core/utils/utils":77,"g3w-ol3/src/layers/bases":100}],59:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var truefnc = require('core/utils/utils').truefnc;
var resolve = require('core/utils/utils').resolve;
var reject = require('core/utils/utils').reject;
var G3WObject = require('core/g3wobject');

function VectorLayer(config) {
  var config = config || {};
  this.geometrytype = config.geometrytype || null;
  this.format = config.format || null;
  this.crs = config.crs  || null;
  this.crsLayer = config.crsLayer || this.crs;
  this.id = config.id || null;
  this.name = config.name || "";
  this.pk = config.pk || "id"; // TODO: il GeoJSON setta l'id della feature da sé, e nasconde il campo PK dalle properties. In altri formati va verificato, e casomai usare feature.setId()
  this._newPrefix = '_new_';
  this._olSource = new ol.source.Vector({
    features: new ol.Collection()
  });
  this._olLayer = new ol.layer.Vector({
    name: this.name,
    source: this._olSource
  });
  this._isReady = false;
  /*
   * Array di oggetti:
   * {
   *  name: Nome dell'attributo,
   *  type: integer | float | string | boolean | date | time | datetime,
   *  input: {
   *    label: Nome del campo di input,
   *    type: select | check | radio | coordspicker | boxpicker | layerpicker | fielddepend,
   *    options: {
   *      Le opzioni per lo spcifico tipo di input (es. "values" per la lista di valori di select, check e radio)
   *    }
   *  }
   * }
  */
  this._PKinAttributes = false;
  this._featuresFilter = null;
  this._fields = null;
  this._relationsDataLoaded = {};
  this.lazyRelations = true;
  this._relations = null;
  this._editingMode = config.editing || false;
  this._loadedIds = [];
  this._featureLocks = [];
  this._crs = null;
}

inherit(VectorLayer,G3WObject);

module.exports = VectorLayer;

var proto = VectorLayer.prototype;

proto.getPk = function() {
  return this.pk;
};

proto.setData = function(featuresData) {
  var self = this;
  var Ids = [];
  var features;
  if (this.format) {
    switch (this.format){
      case "GeoJSON":
        var geojson = new ol.format.GeoJSON({
          geometryName: "geometry"
        });
        features = geojson.readFeatures(featuresData, {
          dataProjection: self.crsLayer,
          featureProjection: self.crs
        });
        break;
    }
    if (this._editingMode && this._featureLocks) {
      features = _.filter(features, function(feature) {
        var hasFeatureLock = false;
        _.forEach(self._featureLocks,function(featureLock){
          if (featureLock.featureid == feature.getId()) {
            hasFeatureLock = true;
            Ids.push(feature.getId());
          }
        });
        return hasFeatureLock;
      })
    }
    
    if (features && features.length) {
      if (!_.isNull(this._featuresFilter)){
        features = _.map(features,function(feature){
          return self._featuresFilter(feature);
        });
      }
      var featuresToLoad = _.filter(features,function(feature) {
        return !_.includes(self._loadedIds,feature.getId());
      });

      this._olSource.addFeatures(featuresToLoad);
      // verifico, prendendo la prima feature, se la PK è presente o meno tra gli attributi
      var attributes = this.getSource().getFeatures()[0].getProperties();
      this._PKinAttributes = _.get(attributes,this.pk) ? true : false;
      this._loadedIds = _.union(this._loadedIds, Ids);
    }
  }
  else {
    console.log("VectorLayer format not defined");
  }
};
proto.cleanFeatureLocks = function() {
  this._featureLocks = [];
};

proto.setFeatureLocks = function(featurelocks) {
  this._featureLocks = featurelocks;
};

proto.getFeatureLocks = function() {
  return this._featureLocks;
};

proto.addLockId = function(lockId) {
  this._featureLocks.push(lockId);
};

// funzione che serve ad aggiornare o settare gli attibuti ad una feature
// viene sfruttatat al momento del salvataggio in editing di una feature
proto.setFeatureData = function(oldfid,fid,geometry,attributes) {
  var self = this;
  // vado a prende il vecchio fid (id temporaneo _new_...) oppure prendo una feature già esistente
  var feature = this.getFeatureById(oldfid) || this.getFeatureById(fid);
  // se la feature esiste vuol dire che simao nel caso di una nuoav feature
  if (feature) {
    if (oldfid && oldfid != fid) {
      feature.setId(fid);
    }
    if(geometry) {
      feature.setGeometry(geometry);
    }
    if (attributes) {
      var oldAttributes = feature.getProperties();
      var newAttributes = _.assign(oldAttributes, attributes);
      feature.setProperties(newAttributes);
    }
  }
  // vado a cambiare modificarele relazioni esistenti
  // in base alle relationi nuove Cambio id etc..)
  // NON È DETTO CHE SIA LEGATO AD UN CAMBIO DI FEATURE
  if (attributes && attributes.relations) {
    this.addRelationElements(attributes.relations);
  }

  return feature;
};

// funzione che va ada modificare la relaione/relazioni aggiunte della feature esistetnte
// si ha nel caso di un inserimento di una nuova relazione)
proto.addRelationElements = function(relations) {
  var self = this;
  var fid = relations.featureid;
  var feature = this.getFeatureById(fid);
  // scorro sulle relazioni ritornate dal server dopo un commit (new)
  // sono oggetto con chiave nome della relazione e valore gli elementi aggiunti
  _.forEach(relations, function(elements, relationName) {
    // scorro sulle relazioni di quella feature che sono state aggiunte
    _.forEach(self._relationsDataLoaded[fid], function(relationLoaded) {
      if (relationLoaded.name == relationName) {
        _.forEach(elements, function(element) {
          _.forEach(relationLoaded.elements, function(ele) {
            if (ele.id == element.clientid ) {
              ele.id = element.id;
            }
          })
        })
      }
    })
  })
};

proto.addFeature = function(feature) {
  this.getSource().addFeature(feature);
};

proto.addFeatures = function(features) {
  this.getSource().addFeatures(features);
};

proto.modifyFeatureGeometry = function(featureId, geometry) {
  var features = this.getFeatures();
  var feature = null;
  _.forEach(features, function(feature, index) {
    if (feature.getId() == featureId) {
      features[index].setGeometry(geometry);
      feature = feature[index];
      return feature
    }
  });
  return feature;
};

proto.setFeaturesFilter = function(featuresFilter){
  this._featuresFilter = featuresFilter;
};

proto.setFields = function(fields) {
  this._fields = fields;
};

proto.setCrs = function(crs) {
  this._crs = crs;
};

proto.getCrs = function() {
  return this._crs;
};

proto.setPkField = function(){
  var self = this;
  var pkfieldSet = false;
  _.forEach(this._fields,function(field){
    if (field.name == self.pk ){
      pkfieldSet = true;
    }
  });
  
  if (!pkfieldSet) {
    this._fields;
  }
};

proto.getFeatures = function() {
  return this.getSource().getFeatures();
};

proto.getFeatureIds = function(){
  var featureIds = _.map(this.getSource().getFeatures(), function(feature){
    return feature.getId();
  });
  return featureIds
};

// funzione che recurepa le feature del vector layer in base alla geometria passata
proto.getIntersectedFeatures = function(geometry) {
  var features = [];
  _.forEach(this.getFeatures(), function(feature) {
    if (geometry.intersectsExtent(feature.getGeometry().getExtent())) {
      features.push(feature);
    }
  });
  return features
};


proto.getFields = function(){
  return _.cloneDeep(this._fields);
};

// funzione che mi server per la query result nel caso di vector layer
proto.getAttributes = function() {
  return this._fields;
};

proto.getFieldsNames = function(){
  return _.map(this._fields,function(field){
    return field.name;
  });
};
// funzione che serve ad esempio all'openEditorFor per popolare
// il form con i campi della feature e i relativi valori (nel caso di editing di una feature esistente)
proto.getFieldsWithValues = function(obj) {
  var self = this;
  // clono i fields in quanto non voglio modificare i valori originali
  var fields = _.cloneDeep(this._fields);
  var feature, attributes;
  // il metodo accetta sia feature che fid
  if (obj instanceof ol.Feature){
    feature = obj;
  }
  else if (obj){
    feature = this.getFeatureById(obj);
  }
  // se c'è una feature ne prendo le proprietà
  if (feature) {
    attributes = feature.getProperties();
  }
  _.forEach(fields, function(field){
    if (feature){
      if (!this._PKinAttributes && field.name == self.pk) {
        if (self.isNewFeature(feature.getId())) {
          field.value = null;
        } else {
          field.value = feature.getId();
        }
      } else {
        
        field.value = attributes[field.name];
      }
    }
    else{
      field.value = null;
    }
  });

  return fields;
};

// funzione che setta e relazione del layer vettoriale
proto.setRelations = function(relations) {
  // assegno al valore _relations l'array relazioni
  this._relations = relations;
  // è un array contenete le relazioni con altri layers
  _.forEach(relations, function(relation) {
    // per ogni relazione scorro sull'attributo fields (array) di oggetti
    // che descrivono  i campi del layer relazione
    _.forEach(relation.fields, function(field, idx) {
      if (field.name == relation.pk) {
        // aggiung ll'atributo pkFieldIndex
        // che mi servirà per recuperare il campo
        // primary del layer relazione
        // setto indice del campo chiave primaria
        relation.pkFieldIndex = idx
      }
    })
  })
};
// resituisce le relazioni
proto.getRelations = function() {
  return this._relations;
};

// retituisce un oggetto contenente nome relazione e fileds(attributi) associati
proto.getRelationsAttributes = function() {
  var fields = {};
  _.forEach(this._relations, function(relation) {
    fields[relation.name] = relation.fields;
  });
  return fields;
};
proto.getRelation = function(relationName) {
  var relation;
  _.forEach(this._relations,function(_relation){
    if (_relation.name == relationName) {
      relation = _relation;
    }
  });
  return relation;
};

proto.hasRelations = function() {
  return !_.isNull(this._relations);
};

proto.getRelationPkFieldIndex = function(relation) {
  var pkFieldIndex;
  _.forEach(relation.fields,function(field,idx){
    if (field.name == relation.pk) {
      pkFieldIndex = idx;
    }
  });
  return pkFieldIndex;
};

proto.getRelationElementPkValue = function(relation,element) {
  var pkFieldIndex = this.getRelationPkFieldIndex(relation);
  return element.fields[pkFieldIndex].value;
};

proto.getRelationsFksKeys = function(){
  var fks = [];
  _.forEach(this._relations,function(relation){
    fks.push(relation.fk);
  });
  return fks;
};

proto.getRelationFields = function(relation) {
  return relation.fields;
};

proto.getRelationFieldsNames = function(relation){
  return _.map(relationFields,function(field){
    return field.name;
  });
};

// ottengo le relazioni a partire dal fid di una feature esistente
proto.getRelationsWithValues = function(fid) {
  var self = this;
  if (!this._relations) {
    // se non ha nessuna relazione
    // rirotno array vuoto
    resolve([]);
  }
  // altrimenti creo un clone dell'attributo relations
  var relations = _.cloneDeep(this._relations);
  // se non è stato settao l'id della feature e quindi la feature non esiste
  // vado a creare la strutture lelations element (array)
  if (!fid && !this.getFeatureById(fid)) {
    _.forEach(relations, function(relation) {
      relation.elements = [];
    });
    return resolve(relations);
  }
  else {
    if (this.lazyRelations) {
      //verifico se sono già state caricate le relazioni di quella feature
      if (!self._relationsDataLoaded[fid]) {
        var deferred = $.Deferred();
        var attributes = this.getFeatureById(fid).getProperties();
        var fks = {};
        _.forEach(relations, function(relation) {
          var keyVals = [];
          _.forEach(relation.fk, function(fkKey) {
            // verifico che la foreingkey sia la primary key del layer e a questo punto
            // prendo il fid altrimenti prendo il valore dell'attributo della feature
            if (fkKey == self.pk)  {
              fks[fkKey] = fid;
            } else {
              fks[fkKey] = attributes[fkKey];
            }
          });
        });
        this.getRelationsWithValuesFromFks(fks)
          .then(function(relationsResponse){
            self._relationsDataLoaded[fid] = relationsResponse;
            deferred.resolve(relationsResponse);
          })
          .fail(function(){
            deferred.reject();
          });
        return deferred.promise();
      }
      else {
        return resolve(this._relationsDataLoaded[fid]);
      }
    }
    else {
      return resolve(this._relations); // vuol dire che gli elementi delle relazioni sono stati già inseriti in fase di creazione del vettoriale
    }
  }
};

// ottengo le relazioni valorizzate a partire da un oggetto con le chiavi FK come keys e i loro valori come values
proto.getRelationsWithValuesFromFks = function(fks, newRelation) {
  var self = this;
  var relations = _.cloneDeep(this._relations);
  var relationsRequests = [];

  _.forEach(relations,function(relation){
    relation.elements = []; // creo la proprietà che accoglierà gli elementi della relazione ( e che quindi li cacherà)
    var url = relation.url;
    var keyVals = [];
    _.forEach(relation.fk,function(fkKey){
      var fkValue = fks[fkKey];
      keyVals.push(fkKey+"="+fkValue);
    });
    var fkParams = _.join(keyVals,"&");
    url += "?"+fkParams;
    relationsRequests.push($.get(url)
      .then(function(relationsElements){
        if (relationsElements.length) {
          _.forEach(relationsElements,function(relationElement){
            var element = {};
            element.fields = _.cloneDeep(relation.fields); // i campi li metto anche in ogni elemento, in modo da poterne assegnarne i valori
            _.forEach(element.fields,function(field){ // assegno i valori ai campi
              field.value = relationElement[field.name];
              if (field.name == relation.pk) {
                element.id = field.value; // aggiungo element.id dandogli il valore della chiave primaria della relazione
                var state = newRelation ? 'NEW' : 'OLD';
                element.state = state; // flag usato per identificare elemento: 'NEW', 'OLD', 'DELETED'
              }
            });
            relation.elements.push(element);
          })
        }
      })
    )
  });
  
  return $.when.apply(this,relationsRequests)
  .then(function(){
    return relations; // le relazioni e i loro elementi sono immutabili; le modifiche vanno nei RelationEditBuffer
  });
};

proto.getNewRelationsWithValuesFromFks = function(fks){
  return this.getRelationsWithValuesFromFks(fks, true)
};

// data una feature verifico se ha tra gli attributi i valori delle FK delle (eventuali) relazioni
proto.featureHasRelationsFksWithValues = function(feature){
  var attributes = feature.getProperties();
  var fksKeys = this.getRelationsFksKeys();
  return _.every(fksKeys,function(fkKey){
    var value = attributes[fkKey];
    return (!_.isNil(value) && value != '');
  })
};

// data una feature popolo un oggetto con chiavi/valori delle FK delle (eventuali) relazione
proto.getRelationsFksWithValuesForFeature = function(feature){
  var attributes = feature.getProperties();
  var fks = {};
  var fksKeys = this.getRelationsFksKeys();
  _.forEach(fksKeys,function(fkKey){
    fks[fkKey] = attributes[fkKey];
  });
  return fks;
};

//vado a settare le nuove relaioni dopo che ho fatto save del form
proto.setRelationsData = function (fid, relationsData) {
  this._relationsDataLoaded[fid] = relationsData;
};

proto.setStyle = function(style){
  this._olLayer.setStyle(style);
};

proto.getMapLayer = function(){
  return this._olLayer;
};

proto.getSource = function(){
  return this._olLayer.getSource();
};

proto.getFeatureById = function(fid){
  if (fid) {
    return this._olLayer.getSource().getFeatureById(fid);
  }
};

proto.isVisible = function() {
  return this._olLayer.getVisible();
};

proto.setVisible = function(bool) {
  this._olLayer.setVisible(bool);
};

proto.clear = function(){
  this.getSource().clear();
};

proto.addToMap = function(map){
  map.addLayer(this._olLayer);
};

proto.isNewFeature = function(fid){
  if (fid) {
    return fid.toString().indexOf(this._newPrefix) == 0;
  }
  return true;
};


},{"core/g3wobject":34,"core/utils/utils":77}],60:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

function WMSLayer(options,extraParams){
  var self = this;
  this.LAYERTYPE = {
    LAYER: 'layer',
    MULTILAYER: 'multilayer'
  };

  this.extraParams = extraParams;
  this.layers = [];
  
  base(this,options);
}

inherit(WMSLayer,MapLayer);

var proto = WMSLayer.prototype;

proto.getOLLayer = function(withLayers){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer(withLayers);
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getInfoFormat = function() {
  return 'application/vnd.ogc.gml';
};

proto.getGetFeatureInfoUrl = function(coordinate,resolution,epsg,params){
  return this.getOLLayer().getSource().getGetFeatureInfoUrl(coordinate,resolution,epsg,params);
};

proto.getLayerConfigs = function(){
  return this.layers;
};

proto.addLayer = function(layer){
  this.layers.push(layer);
};

proto.toggleLayer = function(layer){
  _.forEach(this.layers,function(_layer){
    if (_layer.id == layer.id){
      _layer.visible = layer.visible;
    }
  });
  this._updateLayers();
};
  
proto.update = function(mapState, extraParams) {
  this._updateLayers(mapState, extraParams);
};

proto.isVisible = function(){
  return this._getVisibleLayers().length > 0;
};

proto.getQueryUrl = function(){
  var layer = this.layers[0];
  if (layer.infourl && layer.infourl != '') {
    return layer.infourl;
  }
  return this.config.url;
};

proto.getQueryableLayers = function(){ 
  return _.filter(this.layers,function(layer){
    return layer.isQueryable();
  });
};

proto._getVisibleLayers = function(mapState){
  var self = this;
  var visibleLayers = [];
  _.forEach(this.layers,function(layer){
    var resolutionBasedVisibility = layer.state.maxresolution ? (layer.state.maxresolution && layer.state.maxresolution > mapState.resolution) : true;
    if (layer.state.visible && resolutionBasedVisibility) {
      visibleLayers.push(layer);
    }    
  });
  return visibleLayers;
};

proto._makeOlLayer = function(withLayers){
  var self = this;
  var wmsConfig = {
    url: this.config.url,
    id: this.config.id
  };
  
  if (withLayers) {
    wmsConfig.layers = _.map(this.layers,function(layer){
      return layer.getWMSLayerName();
    });
  }
  
  var representativeLayer = this.layers[0]; //BRUTTO, DEVO PRENDERE UN LAYER A CASO (IL PRIMO) PER VEDERE SE PUNTA AD UN SOURCE DIVERSO (dovrebbe accadere solo per i layer singoli, WMS esterni)
  
  if (representativeLayer.state.source && representativeLayer.state.source.type == 'wms' && representativeLayer.state.source.url){
    wmsConfig.url = representativeLayer.state.source.url;
  }
  
  var olLayer = new RasterLayers.WMSLayer(wmsConfig,this.extraParams);
  
  olLayer.getSource().on('imageloadstart', function() {
        self.emit("loadstart");
      });
  olLayer.getSource().on('imageloadend', function() {
      self.emit("loadend");
  });
  
  return olLayer
};

proto.checkLayerDisabled = function(layer,resolution) {
  var scale = geo.resToScale(resolution);
  var enabled = true;
  if (layer.state.maxresolution){
    enabled = enabled && (layer.state.maxresolution > resolution);
  }
  if (layer.state.minresolution){
    enabled = enabled && (layer.state.minresolution < resolution);
  }
  if (layer.state.minscale) {
    enabled = enabled && (layer.state.minscale > scale);
  }
  if (layer.state.maxscale) {
    enabled = enabled && (layer.state.maxscale < scale);
  }
  layer.state.disabled = !enabled;
};

proto.checkLayersDisabled = function(resolution){
  var self = this;
  _.forEach(this.layers,function(layer){
    self.checkLayerDisabled(layer,resolution);
  });
};

proto._updateLayers = function(mapState,extraParams){
  this.checkLayersDisabled(mapState.resolution);
  var visibleLayers = this._getVisibleLayers(mapState);
  if (visibleLayers.length > 0) {
    var params = {
      LAYERS: _.join(_.map(visibleLayers, function(layer) {
        return layer.getWMSLayerName();
      }),',')
    };
    if (extraParams) {
      params = _.assign(params,extraParams);
    }
    this._olLayer.setVisible(true);
    this._olLayer.getSource().updateParams(params);
  }
  else {
    this._olLayer.setVisible(false);
  }
};

module.exports = WMSLayer;

},{"core/map/layer/maplayer":57,"core/utils/geo":76,"core/utils/utils":77,"g3w-ol3/src/layers/rasters":101}],61:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geo = require('core/utils/geo');
var MapLayer = require('core/map/layer/maplayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

var GENERCI_GRID_EXTENT = [0,0,8388608,8388608];
var STANDARD_PROJECTIONS = [3857,900913,4326];

function XYZLayer(options,extraParams){
  var self = this;
  base(this,options);
  this.layer = null;
}

inherit(XYZLayer,MapLayer);

var proto = XYZLayer.prototype;

proto.getOLLayer = function(){
  var olLayer = this._olLayer;
  if (!olLayer){
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function(){
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function(){
  return this.layer;
};

proto.addLayer = function(layer){
  this.layer = layer;
};

proto.toggleLayer = function(layer){
  this._updateLayers();
};

proto.update = function(mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function(){
  return layer.state.visible;
};

proto._makeOlLayer = function(){
  var self = this;
  var crs = this.layer.getProjectCrs();

  var projection = this.projection ? this.projection : this.layer.getProjection();

  var layerOptions = {
    url: this.layer.getCacheUrl()+"/{z}/{x}/{y}.png",
    maxZoom: 20
  };

  /*if (STANDARD_PROJECTIONS.indexOf(crs) < 0) {
    layerOptions.projection = new ol.proj.Projection({
      code: "EPSG:"+crs,
      extent: GENERIC_GRID_EXTENT
    })
  }*/

  layerOptions.projection = projection;

  var olLayer = RasterLayers.XYZLayer(layerOptions);

  olLayer.getSource().on('imageloadstart', function() {
    self.emit("loadstart");
  });
  olLayer.getSource().on('imageloadend', function() {
    self.emit("loadend");
  });

  return olLayer
};

proto._updateLayer = function(mapState, extraParams) {
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = XYZLayer;

},{"core/map/layer/maplayer":57,"core/utils/geo":76,"core/utils/utils":77,"g3w-ol3/src/layers/rasters":101}],62:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('./pluginsregistry');

var Plugin = function() {

  base(this);
  this.name = '(no name)';
  this.config = null;
  this.service = null;

};

inherit(Plugin,G3WObject);

var proto = Plugin.prototype;

//recuperare il servizio associato al plugin
proto.getService = function() {
  return this.service
};

//settare un servizio
proto.setService = function(service) {
  this.service = service;
};

//recupero il nome
proto.getName = function() {
  return this.name;
};

//setto il nome
proto.setName = function(name) {
  this.name = name;
};

//recupero la configurazione del plugin dal registro dei plugins
proto.getConfig = function(name) {
  name = name || this.name;
  return PluginsRegistry.getPluginConfig(name);
};

proto.setConfig = function(config) {
  this.config = config;
};

//verifica la compatibilià con il progetto corrente
proto.isCurrentProjectCompatible = function(projectId) {
  var project = ProjectsRegistry.getCurrentProject();
  return projectId == project.getGid();
};

//registrazione plugin se compatibile con il progetto corrente
proto.registerPlugin = function(projectId) {
  if (this.isCurrentProjectCompatible(projectId)) {
    PluginsRegistry.registerPlugin(this);
    return true;
  }
  return false;
};

// setup dell'interfaccia
proto.setupGui = function() {
  //al momento niente non so se verrà usata
};

module.exports = Plugin;

},{"./pluginsregistry":64,"core/g3wobject":34,"core/project/projectsregistry":69,"core/utils/utils":77}],63:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

// classe utilizzata dai plugin per il servizo
// al momento inizilaizza il config
function PluginService(options) {
  var options = options || {};
  base(this, options);
  this.init = function(config) {
    this.config = config;
    //TODO
  }
}

inherit(PluginService, G3WObject);

var proto = PluginService.prototype;

proto.getConfig = function() {
  return this.config;
};

proto.setConfig = function(config) {
  this.config = config;
};



module.exports = PluginService;
},{"core/g3wobject":34,"core/utils/utils":77}],64:[function(require,module,exports){
var base = require('core/utils/utils').base;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function PluginsRegistry() {
  var self = this;
  this.config = null;
  // un domani questo sarà dinamico
  this._plugins = {};
  this._loadedPluginUrls = [];
  this.setters = {
    //setters che server per registrare il plugin
    registerPlugin: function(plugin) {
      if (!self._plugins[plugin.name]) {
        self._plugins[plugin.name] = plugin;
      }
    }
  };

  base(this);

  this.init = function(options) {
    var self = this;
    this.pluginsBaseUrl = options.pluginsBaseUrl;
    this.pluginsConfigs = options.pluginsConfigs;
    this.otherPluginsConfig = options.otherPluginsConfig;
    this.setOtherPlugins();
        //ciclo sull'oggetto plugins per fare il setup dei vari plugin legati al progetto
    _.forEach(this.pluginsConfigs, function(pluginConfig, name) {
      self._setup(name, pluginConfig);
    })
  };

  this.setOtherPlugins = function() {
    //da vedere poi come cutomizzare il law plugin
    if (this.otherPluginsConfig && this.otherPluginsConfig.law && this.otherPluginsConfig.law.length) {
      this.pluginsConfigs['law'] =  this.otherPluginsConfig.law;
    }
  };

  // funzione che serve per fare il reload dei plugins
  this.reloadPlugins = function(project) {
    var self = this;
    var ApplicationService = require('core/applicationservice');
    //forzo la varibile globale initConfig a null affinche venga ricaricato
    // la configurazione iniziale
    window.initConfig = null;
    //vado a riottenere l'initConfig
    ApplicationService.obtainInitConfig()
      .then(function(initConfig) {
        // prendo vado a rimuovere i tools
        GUI.getComponent('tools').getService().removeTools();
        // setto il pluginsConfig
        self.setPluginsConfig(initConfig.group.plugins);
        // devo ricaricare quelli con custom
        self.setOtherPlugins();
        // cliclo sugli scripte vado a togliere gli script che contengono plugin
        _.forEach($('script'), function(scr) {
          _.forEach(self._loadedPluginUrls, function(pluginUrl) {
            if (scr.getAttribute('src') == pluginUrl) {
              scr.parentNode.removeChild( scr );
              return false;
            }
          })
        });
        //vado a cancellare a risettare a vuoto l'array degli url
        self._loadedPluginUrls = [];
        // vado a ricarcicare i plugin
        _.forEach(self.pluginsConfigs, function(pluginConfig, pluginName) {
          self._setup(pluginName, pluginConfig);
        })
      });
  };

  this.setPluginsConfig = function(config) {
    this.pluginsConfigs = config;
  };

  this._setup = function(name, pluginConfig) {
    if (pluginConfig) {
      var url = this.pluginsBaseUrl+name+'/js/plugin.js?'+Date.now();
      $script(url);
      this._loadedPluginUrls.push(url);
    }
  };
  
  this.getPluginConfig = function(pluginName) {
    return this.pluginsConfigs[pluginName];
  };

}

inherit(PluginsRegistry,G3WObject);

module.exports = new PluginsRegistry;

},{"core/applicationservice":22,"core/g3wobject":34,"core/utils/utils":77,"gui/gui":118}],65:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var PrinterProvider = require('./providers/printerprovider');

function PrintService() {
  base(this);
  // funzione generica nel caso volessi lanciare il print
  // senza ottenere il printer
  this.print = function(options) {
    /* options è un oggetto che contiene:
     type: tipo di printer server
     url: url a cui effettuare la richiesta
     params : oggetto contenete i parametri necessari alla creazione della richiesta
              come ad esempio filter etc ..
    */
    var options = options || {};
    var type = options.type || 'QGIS';
    var provider = new PrinterProvider(type);
    var url = provider.print(options);
    return $.get(url)
  };
}

inherit(PrintService, G3WObject);

module.exports = new PrintService;

},{"./providers/printerprovider":66,"core/g3wobject":34,"core/utils/utils":77}],66:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
// providers

var PrinterQGISProvider = require('./qgis/printerQGISProvider');

var Providers = {
  'QGIS': PrinterQGISProvider
};

// classe costruttore che permette a seconda delle caratteristiche dei layers
// ogcservice etc... di chiamare il proprio providers per effettuare le chiamte al server
function PrinterProvider(options) {
  var options = options || {};
  var serverType = options.serverType || 'QGIS';
  this._provider = Providers[serverType];
  this.print = function(options) {
    return this._provider.print(options);
  };
  base(this);
}

inherit(PrinterProvider, G3WObject);

module.exports =  PrinterProvider;


},{"./qgis/printerQGISProvider":67,"core/g3wobject":34,"core/utils/utils":77}],67:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var resolve = require('core/utils/utils').resolve;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');


function PrinterQGISProvider() {
  base(this);

  this._getPrintUrl = function(options) {
    var options = options || {};
    var layersStore =   ProjectsRegistry.getCurrentProject().getLayersStore();
    var templateMap = options.map || 'map0';
    var url = layersStore.getWmsUrl();
    // devo fare il reverse perchè l'odine conta sulla visualizzazione del print
    var layers = _.reverse(layersStore.getLayers({
      ACTIVE: true,
      VISIBLE: true,
      SERVERTYPE: 'QGIS'
    }));
    layers = _.map(layers,function(layer){
      return layer.getQueryLayerName()
    });
    var params = {
      SERVICE: 'WMS',
      VERSION: '1.3.0',
      REQUEST: 'GetPrint',
      TEMPLATE: options.template,
      DPI: options.dpi,
      FORMAT: 'pdf',
      CRS:layersStore.getProjection().getCode(),
      LAYERS: layers.join()
    };
    // AL comento commento
    params[templateMap+':SCALE'] = options.scale;
    params[templateMap+':EXTENT'] = options.extent;
    params[templateMap+':ROTATION'] = options.rotation;
    url = url + '?' + $.param(params);
    return url;
  };

  this.print = function(options) {
    /* options è un oggetto che contiene:
     type: tipo di printer server
     url: url a cui effettuare la richiesta
     params : oggetto contenete i parametri necessari alla creazione della richiesta
     come ad esempio filter etc ..
     */
    var options = options || {};
    return this._getPrintUrl(options);
  };
}

inherit(PrinterQGISProvider, G3WObject);

module.exports = new PrinterQGISProvider;


/*
 http://localhost/fcgi-bin/qgis_mapserver/qgis_mapserv.fcgi?MAP=/home/marco/geodaten/projekte/composertest.qgs&SERVICE=WMS&VERSION=1.3.0
 &REQUEST=GetPrint&TEMPLATE=Composer 1&
 map0:extent=693457.466131,227122.338236,700476.845177,230609.807051&
 BBOX=693457.466131,227122.338236,700476.845177,230609.807051&
 CRS=EPSG:21781&WIDTH=1467&HEIGHT=729&LAYERS=layer0,layer1&
 STYLES=,&FORMAT=pdf&DPI=300&TRANSPARENT=true

 In detail, the following parameters can be used to set properties for composer maps:

 <mapname>:EXTENT=<xmin,ymin,xmax, ymax> //mandatory
 <mapname>:ROTATION=<double> //optional, defaults to 0
 <mapname>:SCALE=<double> //optional. Forces scale denominator as server and client may have different scale calculations
 <mapname>:LAYERS=<comma separated list with layer names> //optional. Defaults to all layer in the WMS request
 <mapname>:STYLES=<comma separated list with style names> //optional
 <mapname>:GRID_INTERVAL_X=<double> //set the grid interval in x-direction for composer grids
 <mapname>:GRID_INTERVAL_Y=<double> //set the grid interval in x-direction for composer grids
 */
},{"core/g3wobject":34,"core/project/projectsregistry":69,"core/utils/utils":77}],68:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var GeoLayer = require('core/layers/geolayer');
var LayersStore = require('core/layers/layersstore');
var LayersStoresRegistry = require('core/layers/layersstoresregistry');
var Projections = require('core/geo/projections');

function Project(projectConfig) {
  var self = this;
  /* struttura oggetto 'project'
  {
    id,
    type,
    gid,
    name,
    crs,
    proj4,
    extent,
    initextent,
    layers,
    layerstree,
    overviewprojectgid,
    baselayers,
    initbaselayer
  }
  */
  this.state = projectConfig;

  this._processLayers();

  this._projection = Projections.get(this.state.crs,this.state.proj4);
  this._layersStore = this._buildLayersStore();

  this.setters = {
    setBaseLayer: function(id) {
      _.forEach(self.state.baselayers, function(baseLayer) {
        baseLayer.visible = (baseLayer.id == id || (baseLayer.fixed === true));
      })
    }
  };

  base(this);
}

inherit(Project, G3WObject);

var proto = Project.prototype;

proto._processLayers = function() {
  var self = this;
  function traverse(obj) {
    _.forIn(obj, function (layer, key) {
      //verifica che il nodo sia un layer e non un folder
      if (!_.isNil(layer.id)) {
        var fulllayer;
        _.forEach(self.state.layers, function(lyr) {
          if (layer.id == lyr.id) {
            lyr.wmsUrl = self.getWmsUrl();
            lyr.project = self;
            fulllayer = _.merge(lyr, layer);
            return false
          }
        });
        obj[parseInt(key)] = fulllayer;
      }
      if (!_.isNil(layer.nodes)){
        // aggiungo proprietà title per l'albero
        layer.title = layer.name;
        traverse(layer.nodes);
      }
    });
  }
  traverse(this.state.layerstree);

  _.forEach(this.state.baselayers, function(layerConfig) {
    var visible = false;

    if (self.state.initbaselayer) {
      visible = (layerConfig.id == (self.state.initbaselayer));
    }

    if (layerConfig.fixed) {
      visible = layerConfig.fixed;
    }

    layerConfig.visible = visible;
    layerConfig.baselayer = true;
  });
};

// funzione che fa il buil del layers store
// lo istanzia  crea il layersstree
proto._buildLayersStore = function() {
  var self = this;
  var layersStore = new LayersStore();
  var overviewprojectgid = this.state.overviewprojectgid ? this.state.overviewprojectgid.gid : null;

  layersStore.setOptions({
    id: this.state.gid,
    projection: this._projection,
    extent: this.state.extent,
    initextent: this.state.initextent,
    wmsUrl: this.state.WMSUrl,
    catalog: this.state.gid != overviewprojectgid
  });

  _.forEach(this.getLayers(), function(layerConfig) {
    // aggiungo la proiezione
    layerConfig.projection = self._projection;
    var layer = new GeoLayer(layerConfig);
    layersStore.addLayer(layer);
  });

  layersStore.setLayersTree(this.getLayersTree(),this.state.name);

  return layersStore;
};

proto.getLayers = function() {
  return _.concat(this.state.layers,this.state.baselayers);
};

proto.getState = function() {
  return this.state;
};

// funzione che ritorna id
proto.getId = function() {
  return this.state.id;
};

//funzione che ritorna il tipo
proto.getType = function() {
  return this.state.type;
};

proto.getGid = function() {
  return this.state.gid;
};

proto.getName = function() {
  return this.state.name;
};

proto.getOverviewProjectGid = function() {
  return this.state.overviewprojectgid ? this.state.overviewprojectgid.gid : null;
};

proto.getCrs = function() {
  return this._projection.getCode();
};

proto.getProjection = function() {
  return this._projection;
};

proto.getWmsUrl = function() {
  return this.state.WMSUrl;
};

proto.getInfoFormat = function() {
  return 'application/vnd.ogc.gml';
};

proto.getLayersTree = function(full) {
  if (full === true) {
    return this.state.layerstree;
  }
  else {
    var layerstree = [];
    function traverse(obj,newobj) {
      _.forIn(obj, function (layer) {
        var lightlayer = {};
        if (!_.isNil(layer.id)) {
          lightlayer.id = layer.id;
        }
        if (!_.isNil(layer.nodes)){
          lightlayer.title = layer.name;
          lightlayer.expanded = layer.expanded;
          lightlayer.nodes = [];
          traverse(layer.nodes,lightlayer.nodes)
        }
        newobj.push(lightlayer);
      });
    }
    traverse(this.state.layerstree,layerstree);
    return layerstree;
  }

};

proto.getLayersStore = function() {
  return this._layersStore;
};

module.exports = Project;

},{"core/g3wobject":34,"core/geo/projections":36,"core/layers/geolayer":42,"core/layers/layersstore":44,"core/layers/layersstoresregistry":45,"core/utils//utils":77,"core/utils/utils":77}],69:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var reject = require('core/utils/utils').reject;
var G3WObject = require('core/g3wobject');
var Project = require('core/project/project');
var LayersStoresRegistry = require('core/layers/layersstoresregistry');

/* service
Funzione costruttore contentente tre proprieta':
    setup: metodo di inizializzazione
    getLayersState: ritorna l'oggetto LayersState
    getLayersTree: ritorna l'array layersTree dall'oggetto LayersState
*/

// Public interface
function ProjectsRegistry() {
  var self = this;
  this.config = null;
  this.initialized = false;
  //tipo di progetto
  this.projectType = null;
  this.setters = {
    setCurrentProject: function(project) {
      if (this.state.currentProject) {
        LayersStoresRegistry.removeLayersStore(this.state.currentProject.getLayersStore());
      }
      self.state.currentProject = project;
      //aggiunto tipo progetto
      self.setProjectType(project.state.type);
      // lo mette sempre in prima posizione mi serve per la mappa
      LayersStoresRegistry.addLayersStore(project.getLayersStore(), 0);
    }
  };
  //stato del registro progetti
  this.state = {
    baseLayers: {},
    minScale: null,
    maxscale: null,
    currentProject: null
  };
  
  // tutte le configurazioni di base dei progetti, ma di cui non è detto che
  // sia ancora disponibile l'istanza (lazy loading)
  this._pendingProjects = [];
  this._projects = {};
  
  base(this);
}

inherit(ProjectsRegistry, G3WObject);

var proto = ProjectsRegistry.prototype;

proto.init = function(config) {
  var self = this;
  var deferred = $.Deferred();
  //verifico se è già stato inizilizzato
  if (!this.initialized) {
    this.initialized = true;
    //salva la configurazione
    this.config = config;
    // salvo l'overviewproject
    this.overviewproject = config.overviewproject;
    //setta lo state
    this.setupState();
    // vado a prendere la configurazione del progetto corrente
    this.getProject(config.initproject)
    .then(function(project) {
      // vado a settare il progetto corrente
      self.setCurrentProject(project);
      deferred.resolve(project);
    })
    .fail(function() {
      deferred.reject();
    })
  }
  return deferred.promise();
};

proto.setProjectType = function(projectType) {
   this.projectType = projectType;
};

proto.getConfig = function() {
  return this.config;
};


proto.getState = function() {
  return this.state;
};

proto.setupState = function() {
  var self = this;
  self.state.baseLayers = self.config.baselayers;
  self.state.minScale = self.config.minscale;
  self.state.maxScale = self.config.maxscale;
  self.state.crs = self.config.crs;
  self.state.proj4 = self.config.proj4;
  // setto  quale progetto deve essere impostato come overview
  //questo è settato da django-admin
  var overViewProject = (self.config.overviewproject && self.config.overviewproject.gid) ? self.config.overviewproject : null;
  //per ogni progetto ciclo e setto tutti gli attributi comuni
  // come i base layers etc ..
  self.config.projects.forEach(function(project) {
    project.baselayers = _.cloneDeep(self.config.baselayers);
    project.minscale = self.config.minscale;
    project.maxscale = self.config.maxscale;
    project.crs = self.config.crs;
    project.proj4 = self.config.proj4;
    project.overviewprojectgid = overViewProject;
    //aggiungo tutti i progetti ai pending project
    self._pendingProjects.push(project);
  });
};

proto.getProjectType = function() {
  return this.projectType;
};

proto.getPendingProjects = function() {
  return this._pendingProjects;
};

proto.getProjects = function() {
  return this._pendingProjects;
};

proto.getListableProjects = function() {
  var currentProjectId = this.getCurrentProject().getId();
  return _.filter(this.getProjects(), function(project) {
    if (!_.isNil(project.listable)) {
      return project.listable;
    }
    //resituisce solo quelli diversi da overviewprojetc
    // nel caso si stato settato
    if ((project.overviewprojectgid && project.gid != project.overviewprojectgid.gid && project.id != currentProjectId) || (project.id != currentProjectId)) {
      return project;
    }
  })
};

proto.getCurrentProject = function(){
  return this.state.currentProject;
};

// ottengo il progetto dal suo gid;
// ritorna una promise nel caso non fosse stato ancora scaricato
// il config completo (e quindi non sia ancora istanziato Project)
proto.getProject = function(projectGid) {
  var self = this;
  var d = $.Deferred();
  var pendingProject;
  var project = null;
  // scorro atraverso i pending project che contengono oggetti
  // di configurazione dei progetti del gruppo
  this._pendingProjects.forEach(function(_pendingProject) {
    if (_pendingProject.gid == projectGid) {
      pendingProject = _pendingProject;
      project = self._projects[projectGid];
    }
  });
  if (!pendingProject) {
    return reject("Project doesn't exist");
  }

  if (project) {
    return d.resolve(project);
  } else {
    return this._getProjectFullConfig(pendingProject)
    .then(function(projectFullConfig){
      var projectConfig = _.merge(pendingProject,projectFullConfig);
      projectConfig.WMSUrl = self.config.getWmsUrl(projectConfig);
      var project = new Project(projectConfig);
      // aggiungo/ registro il progetto
      self._projects[projectConfig.gid] = project;
      return d.resolve(project);
    })
    .fail(function() {
      return d.reject();
    })
  }
};
  
//ritorna una promises che verrà risolta con la
// configuarzione del progetto corrente
proto._getProjectFullConfig = function(projectBaseConfig) {
  var deferred = $.Deferred();
  var url = this.config.getProjectConfigUrl(projectBaseConfig);
  $.get(url)
    .done(function(projectFullConfig) {
      deferred.resolve(projectFullConfig);
    })
    .fail(function() {
      deferred.reject();
    });
  return deferred.promise();
};


module.exports = new ProjectsRegistry();

},{"core/g3wobject":34,"core/layers/layersstoresregistry":45,"core/project/project":68,"core/utils/utils":77}],70:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var resolve = require('core/utils/utils').resolve;
//definisco il filtro ol3
var ol3OGCFilter = ol.format.filter;

//oggetto che viene passato per effetturare il la search
var ol3GetFeatureRequestObject = {
  srsName: 'EPSG:',
  featureNS: '',
  featurePrefix: '',
  featureTypes: [],
  outputFormat: 'application/json',
  filter: null // esempio filtro composto ol3OGCFilter.and(ol3OGCFilter.bbox('the_geom', [1, 2, 3, 4], 'urn:ogc:def:crs:EPSG::4326'),ol3OGCFilter.like('name', 'New*'))
};

// FILTRI OL3
var ol3Filters = {
  eq: ol3OGCFilter.equalTo,
  gt: ol3OGCFilter.greaterThan,
  gte: ol3OGCFilter.greaterThanOrEqualTo,
  lt: ol3OGCFilter.lessThan,
  lte: ol3OGCFilter.lessThanOrEqualTo,
  like: ol3OGCFilter.like,
  ilike: "",
  bbox: ol3OGCFilter.bbox,
  AND: ol3OGCFilter.and,
  OR: ol3OGCFilter.or,
  NOT: ol3OGCFilter.not
};


// CREATO UN FILTRO DI ESEMPIO PER VERIFICARE LA CORRETTEZZA DELLA FUNZIONE CREAZIONE FILTRO
var testFilter = {
  'AND':
    [
      {
        eq:
          {
            gid : 10
          }
      },
      {
        'OR':
          [
            {
              eq: {
                pippo : 'lallo'
              }
            },
            {
              gt: {
                id : 5
              }
            }

          ]
      }
   ]
};
//////////////

///FILTRI CUSTOM
var standardFilterTemplates = function() {
  var common = {
    propertyName:
          "<PropertyName>" +
            "[PROP]" +
          "</PropertyName>",
    literal:
          "<Literal>" +
            "[VALUE]" +
          "</Literal>"
  };
  return {
    eq: "<PropertyIsEqualTo>" +
            common.propertyName +
            common.literal +
        "</PropertyIsEqualTo>",
    gt: "<PropertyIsGreaterThan>" +
            common.propertyName +
            common.literal +
         "</PropertyIsGreaterThan>",
    gte:"",
    lt: "",
    lte: "",
    like: "",
    ilike: "",
    AND: "<And>[AND]</And>",
    OR: "<Or>[OR]</Or>"
  }
}();

/////
var qgisFilterTemplates = {
  // codice qui
};

var mapserverFilterTemplates = {
  // codice qui
};

var geoserverFilterTemplates = {
  // codice qui
};

function QueryWFSProvider(){
  var self = this;
  var d = $.Deferred();
  var results = {
    headers:[],
    values:[]
  };

  this.doSearch = function(queryFilterObject){
    var querylayer = queryFilterObject.queryLayer;
    var url = querylayer.getQueryUrl();
    var crs = querylayer.getCrs();
    var filterObject = queryFilterObject.filterObject;
    //setto il srs
    ol3GetFeatureRequestObject.srsName+=crs || '4326';
    var response, filter;
    switch (ogcservertype) {
      case 'OGC':
        filter = this.createStandardFilter(filterObject, querylayer);
        response = this.standardSearch(url, filter);
        return resolve(response);
        break;
      case 'qgis':
        filter = this.createQgisFilter(filterObject);
        response = this.qgisSearch(querylayer, url, filter);
        return resolve(response);
        break;
      case 'mapserver':
        filter = this.createMapserverFilter(filterObject);
        response = this.mapserverSearch(querylayer, url, filter);
        return resolve(response);
        break;
      case 'geoserver':
        filter = this.createGeoserverFilter(filterObject);
        response = this.geoserverSearch(querylayer, url, filter);
        return resolve(response);
        break;
      default:
        return false
    }
  };

  this.standardSearch = function(url, filter){
  };
  this.createStandardFilter = function(filterObject, querylayer) {
    /////inserisco il nome del layer (typename) ///
    ol3GetFeatureRequestObject.featureTypes.push(querylayer.getQueryLayerName);
    var filter = [];
    function createSingleFilter(booleanObject) {
      var filterElements = [];
      var filterElement = '';
      var rootFilter;
      _.forEach(booleanObject, function(v, k, obj) {
        //creo il filtro root che sarà AND OR
        rootFilter = ol3Filters[k];
        //qui c'è array degli elementi di un booleano
        _.forEach(v, function(input){
          //scorro su oggetto operatore
          _.forEach(input, function(v, k, obj) {
          //è un array e quindi è altro oggetto padre booleano
            if (_.isArray(v)) {
              filterElement = createSingleFilter(obj);
            } else {
              filterElement = ol3Filters[k];
              _.forEach(input, function(v, k, obj) {
                _.forEach(v, function(v, k, obj) {
                  filterElement = filterElement(k, v);
                });
              });
            }
            filterElements.push(filterElement);
          });
        });
        //verifico che ci siano almeno due condizione nel filtro AND. Nel caso di una sola condizione (esempio : un solo input)
        //estraggo solo l'elemento filtro altrimenti da errore -- DA VERIFICARE SE CAMBIARLO
        if (filterElements.length > 1) {
          rootFilter = rootFilter.apply(this, filterElements);
        } else {
          rootFilter = filterElements[0];
        }
      });
      return rootFilter;
    }
    //assegno il filtro creato
    ol3GetFeatureRequestObject.filter = createSingleFilter(filterObject);
    //creo il filtro utilizzando ol3
    filter = new ol.format.WFS().writeGetFeature(ol3GetFeatureRequestObject);
    return filter;
  };

  this.qgisSearch = function(urls, filter){
    $.get(searchUrl).then(function(result){
      self.emit("searchdone",result);
    });
    return d.promise();
  };
  this.createQGisFilter = function(filterObject) {
    var filter;
    return filter
  };
  this.mapserverSearch = function(querylayer, url, filter){
    return d.promise();
  };
  this.createMapserverFilter = function(filterObject) {
    var filter;
    return filter
  };
  this.geoserverSearch = function(querylayer, url, filter){
    return d.promise();
  };
  this.createGeoserverFilter = function(filterObject) {
    var filter;
    return filter
  };
  base(this);
}
inherit(QueryWFSProvider,G3WObject);

module.exports =  new QueryWFSProvider;


},{"core/g3wobject":34,"core/utils/utils":77}],71:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function QueryQGISWFSProvider() {
  base(this);
  self = this;
  // post request
  this._post = function(url, params) {
    url = url + '/';
    return request = $.post(url, params)

  };

  // get request
  this._get = function(url, params) {
    var urlParams = $.param(params);
    url = url + '?' + urlParams;
    return $.get(url)
  };

  this._doRequest = function(options) {
    var options = options || {};
    var url = options.url;
    var crs = options.crs;
    var filter = options.filter;
    var infoFormat = options.infoFormat;
    var layers = options.layers;
    var layers = _.map(layers,function(layer){
      return layer.getQueryLayerName().replace(/ /g,'_');
    });

    var params = {
      SERVICE: 'WFS',
      VERSION: '1.3.0',
      REQUEST: 'GetFeature',
      TYPENAME: layers.join(),
      OUTPUTFORMAT: infoFormat,
      SRSNAME: 'EPSG:' + crs
    };
    if (filter.bbox) {
      params.BBOX = '' + filter.bbox;
      request = this._get(url, params)

    } else {
      var geometry = filter.geometry;
      var f = ol.format.filter;
      var featureRequest = new ol.format.WFS().writeGetFeature({
        featureTypes: layers,
        filter: f.intersects('the_geom', geometry)
      });
      filter = featureRequest.children[0].innerHTML;
      params.FILTER = filter;
      request = this._post(url, params)

    }
    return request
  };
  //funzione che fa la ricerca
  this.doSearch = function(options) {
   return this._doRequest(options);
  };
}

inherit(QueryQGISWFSProvider, G3WObject);

module.exports =  new QueryQGISWFSProvider;

},{"core/g3wobject":34,"core/utils/utils":77}],72:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var resolve = require('core/utils/utils').resolve;
var ProjectsRegistry = require('core/project/projectsregistry');

// FILTRI
var Filters = {
  eq: '=',
  gt: '>',
  gte: '>=',
  lt: '<',
  lte: '=<',
  LIKE: 'LIKE',
  ILIKE: 'ILIKE',
  AND: 'AND',
  OR: 'OR',
  NOT: '!='
};

function QueryQGISWMSProvider() {

  self = this;
  //funzione che fa la richiesta vera e propria al server qgis
  this._submitGetFeatureInfo = function(options) {
    var url = options.url || '';
    var layername = options.layername || null;
    var filter = options.filter || null;
    var bbox = options.bbox || ProjectsRegistry.getCurrentProject().state.extent.join(',');
    var simpleWmsSearchMaxResults = options.simpleWmsSearchMaxResults || null;
    var crs = options.crs || '4326;';
    return $.get( url, {
        'SERVICE': 'WMS',
        'VERSION': '1.3.0',
        'REQUEST': 'GetFeatureInfo',
        'LAYERS': layername,
        'QUERY_LAYERS': layername,
        'FEATURE_COUNT': simpleWmsSearchMaxResults ||  200,
        'INFO_FORMAT': 'application/vnd.ogc.gml',
        'CRS': 'EPSG:'+ crs,
        'FILTER': filter
        // Temporary fix for https://hub.qgis.org/issues/8656 (fixed in QGIS master)
        //'BBOX': bbox // QUI CI VA IL BBOX DELLA MAPPA
      }
    );
   };

  //funzione che fa la ricerca
  this.doSearch = function(options) {
    var options = options || {};
    var d = $.Deferred();
    var layers = options.layers;
    var url = options.url;
    var crs = options.crs;
    var filterObject = options.filter;
    //creo il filtro
    // DA MIGLIORARE CASO FILTRO WMS SINGOLO LAYER / MULTIPLE LAYER
    var filter = this._createFilter(filterObject, layers[0].getQueryLayerName());
    // nel caso in cui il filtro è vuoto
    if (!filter) {
      return d.reject().promise();
    }
    //eseguo la richiesta e restituisco come risposta la promise del $.get
    var request = this._submitGetFeatureInfo({
      url: url,
      crs: crs,
      filter: filter,
      layername: layers[0].getQueryLayerName()
    });
    return request;
  };

  this._createFilter = function(filterObject, layername) {
    /////inserisco il nome del layer (typename) ///
    var filter = [];
    function createSingleFilter(booleanObject) {
      var filterElements = [];
      var filterElement = '';
      var valueExtra = "";
      var valueQuotes = "'";
      var rootFilter;
      _.forEach(booleanObject, function(v, k, obj) {
        //creo il filtro root che sarà AND OR
        rootFilter = Filters[k];
        //qui c'è array degli elementi di un booleano
        _.forEach(v, function(input){
          //scorro su oggetto
          valueExtra = "";
          _.forEach(input, function(v, k, obj) {
          //verifico se il valore dell'oggetto è array e quindi è altro oggetto padre booleano
            if (_.isArray(v)) {
              filterElement = createSingleFilter(obj);
            } else { // è un oggetto operatore
              if (k == 'LIKE' || k == 'ILIKE') {
                valueExtra = "%";
              }
              filterOp = Filters[k];
              var value;
              _.forEach(input, function(v, k, obj) {
                _.forEach(v, function(v, k, obj) {
                  //verifico se il valore non è un numero e quindi aggiungo singolo apice
                  if (!(_.isNull(v) || (_.isNaN(v) || _.trim(v) == ''))) {
                    filterElement = "\"" + k + "\" "+ filterOp +" " + valueQuotes + valueExtra + v + valueExtra + valueQuotes;
                    filterElements.push(filterElement);
                  }
                });
              });
            }
          });
        });
        rootFilter = (filterElements.length > 0) ? filterElements.join(" "+ rootFilter + " ") : false;
      });
      return rootFilter;
    }
    //assegno il filtro creato
    if (createSingleFilter(filterObject)) {
      return  layername + ":" + createSingleFilter(filterObject);
    } else {
      return false
    }
  };
}

inherit(QueryQGISWMSProvider, G3WObject);

module.exports =  new QueryQGISWMSProvider;

},{"core/g3wobject":34,"core/project/projectsregistry":69,"core/utils/utils":77}],73:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
// providers
var QueryWFSProvider = require('./ogc/queryWFSProvider');
var QueryWMSProvider = require('./ogc/queryWFSProvider');
var QueryQGISWMSProvider = require('./qgis/queryQGISWMSProvider');
var QueryQGISWFSProvider = require('./qgis/queryQGISWFSProvider');

var Providers = {
  'QGIS': {
    'wms': QueryQGISWMSProvider,
    'wfs': QueryQGISWFSProvider
  },
  'OGC': {
    'wms':QueryWMSProvider,
    'wfs': QueryWFSProvider
  }
};

// classe costruttore che permette a seconda delle caratteristiche dei layers
// ogcservice etc... di chiamare il proprio providers per effettuare le chiamte al server
function QueryProvider(options) {
  var options = options || {};
  var serverType = options.serverType || 'QGIS';
  var ogcService = options.ogcService || 'wms';
  this._provider = Providers[serverType][ogcService];
  this.doSearch = function() {
    return this._provider.doSearch(options);
  };
  base(this);
}

inherit(QueryProvider, G3WObject);

module.exports =  QueryProvider;


},{"./ogc/queryWFSProvider":70,"./qgis/queryQGISWFSProvider":71,"./qgis/queryQGISWMSProvider":72,"core/g3wobject":34,"core/utils/utils":77}],74:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var QueryProvider = require('./providers/queryprovider');

/*var PickToleranceParams = {};
PickToleranceParams[ProjectTypes.QDJANGO] = {};
PickToleranceParams[ProjectTypes.QDJANGO][GeometryTypes.POINT] = "FI_POINT_TOLERANCE";
PickToleranceParams[ProjectTypes.QDJANGO][GeometryTypes.LINESTRING] = "FI_LINE_TOLERANCE";
PickToleranceParams[ProjectTypes.QDJANGO][GeometryTypes.POLYGON] = "FI_POLYGON_TOLERANCE";

var PickToleranceValues = {}
PickToleranceValues[GeometryTypes.POINT] = 5;
PickToleranceValues[GeometryTypes.LINESTRING] = 5;
PickToleranceValues[GeometryTypes.POLYGON] = 5;*/

var PIXEL_TOLERANCE = 10;

//oggetto query service
function QueryService(){
  var self = this;
  this.url = "";
  this.filterObject = {};
  this.queryFilterObject = {};
  //me lo porto da mapqueryservice ma vediamo cosa succede
  this.setMapService = function(mapService){
    this._mapService = mapService;
  };

  this.setFilterObject = function(filterObject){
    this.filterObject = filterObject;
  };

  this.getFilterObject = function() {
    return this.filterObject;
  };

  //dato l'oggetto filter restituito dal server ricostruisco la struttura del filterObject
  //interpretato da queryWMSProvider
  this.createQueryFilterFromConfig = function(filter) {
    var queryFilter = {};
    var operator;
    var field;
    var booleanObject = {};
    //funzione che costruisce l'oggetto operatore es. {'=':{'nomecampo':null}}
    function createOperatorObject(obj) {
      //rinizializzo a oggetto vuoto
      evalObject = {};
      //verifico che l'oggetto passato non sia a sua volta un oggetto 'BOOLEANO'
      _.forEach(obj, function(v,k) {
        if (_.isArray(v)) {
          return createBooleanObject(k,v);
        }
      });
      field = obj.attribute;
      operator = obj.op;
      evalObject[operator] = {};
      evalObject[operator][field] = null;
      return evalObject;
    }
    //functione che costruisce oggetti BOOLEANI caso AND OR contenente array di oggetti fornit dalla funzione createOperatorObject
    function createBooleanObject(booleanOperator, operations) {
      booleanObject = {};
      booleanObject[booleanOperator] = [];
      _.forEach(operations, function(operation){
        booleanObject[booleanOperator].push(createOperatorObject(operation));
      });
      return booleanObject;
    }
    /*
    // vado a creare l'oggetto filtro principale. Questo è un oggetto che contiene l'operatore booleano come root (chiave)
    // come valore un array di oggetti operatori che contengono il tipo di operatore come chiave e come valore un oggetto contenete
    // nome campo e valore passato
    */
    _.forEach(filter, function(v,k,obj) {
      queryFilter = createBooleanObject(k,v);
    });
    return queryFilter;
  };
  // funzione che in base ai layer coinvolti nella chaita del filtro,
  // creerà un'array di oggetti a seconda del tipo di layer
  this.createQueryFilterObject = function(options) {
    var options = options || {};
    var queryLayers = options.queryLayers || [];
    var ogcService = options.ogcService || 'wms';
    var filter =  options.filter || {};
    var queryFilters = [];
    var infoFromLayers = this.getInfoFromLayers(queryLayers, ogcService);
    _.forEach(infoFromLayers, function(info) {
      // vado a creare un oggetto/array di oggetti con informazioni rigurdanti layers in comune
      queryFilters.push(_.merge(info, {
        // Servizio ogc: wfs, wms etc..
        ogcService: ogcService,
        filter : filter // oggetto che descrive come dovrà essere composto il filtro dal provider
      }));
    });
    return queryFilters
  };

  /////PARSERS //////////////////

  // Brutto ma per ora unica soluzione trovata per dividere per layer i risultati di un doc xml wfs.FeatureCollection.
  // OL3 li parserizza tutti insieme non distinguendo le features dei diversi layers
  this._parseLayerFeatureCollection = function(queryLayer, data, ogcService) {
    var layerName = (ogcService == 'wfs') ? queryLayer.getWMSLayerName().replace(/ /g,'_'): queryLayer.getWMSLayerName().replace(/ /g,''); // QGIS SERVER rimuove gli spazi dal nome del layer per creare l'elemento FeatureMember
    var layerData = _.cloneDeep(data);
    layerData.FeatureCollection.featureMember = [];
    var featureMembers = data.FeatureCollection.featureMember;
    featureMembers = _.isArray(featureMembers) ? featureMembers : [featureMembers];
    _.forEach(featureMembers,function(featureMember){
      var isLayerMember = _.get(featureMember,layerName);
      if (isLayerMember) {
        layerData.FeatureCollection.featureMember.push(featureMember);
      }
    });

    var x2js = new X2JS();
    var layerFeatureCollectionXML = x2js.json2xml_str(layerData);
    var parser = new ol.format.WMSGetFeatureInfo();
    return parser.readFeatures(layerFeatureCollectionXML);
  };

  // mentre con i risultati in msGLMOutput (da Mapserver) il parser può essere istruito per parserizzare in base ad un layer di filtro
  this._parseLayermsGMLOutput = function(queryLayer, data, ogcService) {
    var layers = queryLayer.getQueryLayerOrigName();
    var parser = new ol.format.WMSGetFeatureInfo({
      layers: layers
    });
    return parser.readFeatures(data);
  };
  
  this._parseLayerGeoJSON = function(queryLayer, data) {
    var geojson = new ol.format.GeoJSON({
      defaultDataProjection: this.crs,
      geometryName: "geometry"
    });
    return geojson.readFeatures(data);
  };

  //// FINE PARSER ///

  //INIZO SEZIONE QUERIES ///

  // funzione per convertire le g3w_relations in relations

  this.convertG3wRelations = function(feature) {
    var g3w_relations = feature.getProperties().g3w_relations;
    var relations = null;
    if (g3w_relations) {
      relations = [];
      _.forEach(g3w_relations, function(elements, relationName) {
        relation = {};
        if (elements.length) {
          relation.name = relationName;
          relation.elements = elements;
          relations.push(relation);
        } else {
          delete g3w_relations[relationName];
        }
      });
      if (relations.length) {
        feature.set('relations', relations);
      } else {
        feature.unset('g3w_relations');
      }
    }
  };

  // funzione per il recupero delle relazioni della features se ci sono
  // nell'attributo g3w_relations
  this.handleResponseFeaturesAndRelations = function(layersResponse) {
    var self = this;
    _.forEach(layersResponse, function(layer) {
      _.forEach(layer.features, function(feature) {
        self.convertG3wRelations(feature);
      });
    });
    return layersResponse
  };

  // Messo qui generale la funzione che si prende cura della trasformazione dell'xml di risposta
  // dal server così da avere una risposta coerente in termini di formato risultati da presentare
  // nel componente QueryResults
  this.handleQueryResponseFromServer = function(response, infoFormat, queryLayers, ogcService) {
    var jsonresponse;
    var featuresForLayers = [];
    var parser, data;
    switch (infoFormat) {
      case 'json':
        parser = this._parseLayerGeoJSON;
        data = response.vector.data;
        break;
      default:
        // caso gml
        var x2js = new X2JS();
        try {
          if (_.isString(response)) {
            jsonresponse = x2js.xml_str2json(response);
          } else {
            jsonresponse = x2js.xml2json(response);
          }
        }
        catch (e) {
          return;
        }
        var rootNode = _.keys(jsonresponse)[0];
        switch (rootNode) {
          case 'FeatureCollection':
            parser = this._parseLayerFeatureCollection;
            data = jsonresponse;
            break;
          case "msGMLOutput":
            parser = this._parseLayermsGMLOutput;
            data = response;
            break;
        }
    }
    var nfeatures = 0;
    if (parser) {
      _.forEach(queryLayers, function(queryLayer) {
        var features = parser.call(self, queryLayer, data, ogcService);
        nfeatures += features.length;
        featuresForLayers.push({
          layer: queryLayer,
          features: features
        })
      });
    }
    return featuresForLayers;
  };

  /* query basato sul filtro
     tale funzione prende in considerazione casi come:
     1- search: Ogni layer ha campie attributi su cui viene fatto il filtro
     2- bbox: filtro per bbox
     3- polygon/geometry: filtro per geometria
     In pratica si specifica il tipo di servizion ogc wfs, wms il tipo di server
     a cui fare la richiesta (qgis, mapserver etc..)
     Il parametro filters è un array che contiene layer e attributi
  */
  this.queryByFilter = function(filters) {
    var self = this;
    var d = $.Deferred();
    // creo l'array di promises chiamate get post per efftuare multiple chimate a seconda
    // del provider e del ogcservice
    var doSearches = [];
    /// cliclo sul query filter objects
    _.forEach(filters, function(filter) {
      // si crea il provider
      var provider = new QueryProvider(filter);
      //ritorna una promise poi gestita da che la chiede
      doSearches.push(provider.doSearch(filter))
    });
    $.when.apply(this, doSearches)
      .done(function(response) {
       var allFeaturesFoLayers = [];
        _.forEach(filters, function(filter) {
          var featuresForLayers = self.handleQueryResponseFromServer(response, filter.infoFormat, filter.layers, filter.ogcService);
          allFeaturesFoLayers = _.union(allFeaturesFoLayers, self.handleResponseFeaturesAndRelations(featuresForLayers));
        });
        d.resolve({
          data: allFeaturesFoLayers
        });
      })
      .fail(function(e){
            d.reject(e);
      });
    return d.promise();
  };

  // queryByLocation
  this.queryByLocation = function(coordinates, layers) {
    var d = $.Deferred();
    var mapService = GUI.getComponent('map').getService();
    var urlsForLayers = this.getInfoFromLayers(layers);
    var resolution = mapService.getResolution();
    var epsg = mapService.getEpsg();
    var queryUrlsForLayers = [];
    _.forEach(urlsForLayers,function(urlForLayers) {
      var sourceParam = urlForLayers.url.split('SOURCE');
      urlForLayers.url = sourceParam[0];
      if (sourceParam.length > 1) {
        sourceParam = '&SOURCE' + sourceParam[1];
      } else {
        sourceParam = '';
      }
      var queryLayers = urlForLayers.layers;
      var infoFormat = queryLayers[0].getInfoFormat();
      var params = {
        LAYERS: _.map(queryLayers,function(layer){ return layer.getQueryLayerName(); }),
        QUERY_LAYERS: _.map(queryLayers,function(layer){ return layer.getQueryLayerName(); }),
        INFO_FORMAT: infoFormat,
        FEATURE_COUNT: 10,
        // PARAMETRI DI TOLLERANZA PER QGIS SERVER
        FI_POINT_TOLERANCE: PIXEL_TOLERANCE,
        FI_LINE_TOLERANCE: PIXEL_TOLERANCE,
        FI_POLYGON_TOLERANCE: PIXEL_TOLERANCE,
        G3W_TOLERANCE: PIXEL_TOLERANCE * resolution
      };

      var getFeatureInfoUrl = mapService.getGetFeatureInfoUrlForLayer(queryLayers[0],coordinates,resolution,epsg,params);
      var queryString = getFeatureInfoUrl.split('?')[1];
      var url = urlForLayers.url+'?'+queryString + sourceParam;
      queryUrlsForLayers.push({
        url: url,
        infoformat: infoFormat,
        queryLayers: queryLayers
      });
    });
    this.makeQueryForLayers(queryUrlsForLayers, coordinates, resolution)
      .then(function(response) {
        d.resolve(response)
      })
      .fail(function(e){
        d.reject(e);
      });
    return d.promise();
  };

  // da verificare generalizzazione
  this.makeQueryForLayers = function(queryUrlsForLayers, coordinates, resolution) {
    var self = this;
    var d = $.Deferred();
    var queryInfo = {
      coordinates: coordinates,
      resolution: resolution
    };
    if (queryUrlsForLayers.length > 0) {
      var queryRequests = [];
      var featuresForLayers = [];
      _.forEach(queryUrlsForLayers,function(queryUrlForLayers){
        var url = queryUrlForLayers.url;
        var queryLayers = queryUrlForLayers.queryLayers;
        var infoFormat = queryUrlForLayers.infoformat;
        var postData = queryUrlForLayers.postData;
        var request = self.doRequestAndParse({
          url: url,
          infoFormat: infoFormat,
          queryLayers: queryLayers,
          postData: postData
        });
        queryRequests.push(request);
      });
      $.when.apply(this, queryRequests).
      then(function(){
        var vectorsDataResponse = Array.prototype.slice.call(arguments);
        _.forEach(vectorsDataResponse, function(_featuresForLayers){
          if(featuresForLayers){
            featuresForLayers = _.concat(featuresForLayers,_featuresForLayers);
          }
        });
        featuresForLayers = self.handleResponseFeaturesAndRelations(featuresForLayers);
        d.resolve({
          data: featuresForLayers,
          query: queryInfo
        });
      })
      .fail(function(e){
        d.reject(e);
      });
    }
    else {
      d.resolve({
        data: null,
        query: queryInfo
      });
    }
    return d.promise()
  };
  // funzione che in base ai layers e alla tipologia di servizio
  // restituisce gli url per ogni layer o gruppo di layers
  // che condividono lo stesso indirizzo di servizio
  this.getInfoFromLayers = function(layers, ogcService) {
    // wfs specifica se deve essere fatta chiamata wfs o no
    var urlsForLayers = {};
    // scooro sui ogni layer e catturo il queryUrl
    _.forEach(layers, function(layer) {
      // se wfs prendo l'api fornite dal server
      if (ogcService == 'wfs') {
        var queryUrl = layer.getProject().getWmsUrl();
      } else {
        var queryUrl = layer.getQueryUrl();
      }
      var urlHash = queryUrl.hashCode().toString();
      if (_.keys(urlsForLayers).indexOf(urlHash) == -1) {
        urlsForLayers[urlHash] = {
          url: queryUrl,
          layers: [],
          infoFormat: layer.getInfoFormat(ogcService),
          crs: layer.getCrs(), // dovrebbe essere comune a tutti
          serverType: layer.getServerType() // aggiungo anche il tipo di server
        };
      }
      urlsForLayers[urlHash].layers.push(layer);
    });
    // restituisce un oggetto contente oggetti avente l'url condiviso da più layers
    return urlsForLayers;
  };

  this.doRequestAndParse = function(options) {
    var options = options || {};
    var url = options.url;
    var infoFormat = options.infoFormat;
    var queryLayers = options.queryLayers;
    var postData = options.postData || null;
    var self = this;
    var d = $.Deferred();
    var request;
    if (postData) {
      request = $.post(url, postData)
    } else {
      request = $.get(url);
    }
    request
    .done(function(response) {
      var featuresForLayers = self.handleQueryResponseFromServer(response, infoFormat, queryLayers);
      d.resolve(featuresForLayers);
    })
    .fail(function(){
      d.reject();
    });
    return d;
  };

  base(this);
}
inherit(QueryService, G3WObject);

module.exports =  new QueryService;


},{"./providers/queryprovider":73,"core/g3wobject":34,"core/utils/utils":77,"gui/gui":118}],75:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Base64 = require('core/utils/utils').Base64;
var G3WObject = require('core/g3wobject');

/*
 * RouterService basato su History.js (https://github.com/browserstate/history.js) e Crossroads (https://github.com/millermedeiros/crossroads.js)
 * Il concetto di base è una RouteQuery, del tipo "map?point=21.2,42.1&zoom=12", 
 * che viene inserito nello stato dell'history del browser e nella URL come parametro querystring in forma codificata (q=map@point!21.2,41.1|zoom!12).
 * Per invocare una RouteQuery:
 * 
 * RouterService.goto("map?point=21.2,42.1&zoom=12");
 * 
 * Chiunque voglia rispondere ad una RouteQuery deve aggiungere una route con RouterService.addRoute(pattern, callback). Es.:
 * 
 * var route = RouterService.addRoute('map/{?query}',function(query){
 *  console.log(query.point);
 *  console.log(query.zoom);
 * });
 * 
 * Patterns:
 *  "map/{foo}": la porzione "foo" è richiesta, ed viene passata come parametro alla callback
 *  "map/:foo:": la porzione "foo" è opzionale, ed eventualmente viene passata come parametro alla callback
 *  "map/:foo*: tutto quello che viene dopo "map/"
 *  "map/{?querystring}": obbligatoria querystring, passata alla callback come oggetto dei parametri
 *  "map/:?querystring:": eventuale querystring, passata alla callback come oggetto dei parametri
 * 
 * Per rimuovere una route:
 * RouterService.removeRoute(route);
*/

// altrimenti due chiamate successive alla stessa route verrebbero ignorate
// e può capitare di tornare a chiamare la stessa route senza averne chiamate prima (perché non tutta la GUI è comandata tramite Router)
crossroads.ignoreState = true;
// tutte le route vengono innescate da un url, invece di feramrsi alla prima (com'è di default)
crossroads.greedy = true;

var RouterService = function(){
  var self = this;
  this._initialLocationQuery;
  this._routeQuery = '';
  this.setters = {
    setRouteQuery: function(routeQuery){
      this._routeQuery = routeQuery;
      crossroads.parse(routeQuery);
    }
  };
  
  base(this);
};
inherit(RouterService,G3WObject);

var proto = RouterService.prototype;

proto.init = function(){
  var query = window.location.search;
  this._setRouteQueryFromLocationQuery(query);
};

proto.addRoute = function(pattern,handler,priority) {
  return crossroads.addRoute(pattern,handler,priority);
};

proto.removeRoute = function(route) {
  return crossroads.removeRoute(route);
};

proto.removeAllRoutes = function() {
  return crossroads.removeAllRoutes();
};

proto.parse = function(request,defaultArgs) {
  return crossroads.parse(request,defaultArgs);
};

proto.goto = function(routeQuery){
  if (!this._initialQuery) {
    this._initialLocationQuery = this._stripInitialQuery(location.search.substring(1));
  }
  if (routeQuery) {
    this.setRouteQuery(routeQuery);
  }
};

proto.makePermalink = function(routeQuery) {
  if (!this._initialQuery) {
    this._initialLocationQuery = this._stripInitialQuery(location.search.substring(1));
  }
  var encodedRouteQuery = this._encodeRouteQuery(routeQuery);
  //encodedRouteQuery = Base64.encode(encodedRouteQuery);
  return '?'+this._initialLocationQuery + '&q='+this._encodeRouteQuery(routeQuery);
};

proto.makeQueryString = function(queryParams){};

proto.slicePath = function(path){
  return path.split('?')[0].split('/');
};
  
proto.sliceFirst = function(path){
  var pathAndQuery = path.split('?');
  var queryString = pathAndQuery[1];
  var pathArr = pathAndQuery[0].split('/');
  var firstPath = pathArr[0];
  path = pathArr.slice(1).join('/');
  path = [path,queryString].join('?');
  return [firstPath,path];
};
  
proto.getQueryParams = function(query){
  query = query.replace('?','');
  var queryParams = {};
  var queryPairs = [];
  if (query != "" && query.indexOf("&") == -1) {
    queryPairs = [query];
  }
  else {
    queryPairs = query.split('&');
  }
  try {
    _.forEach(queryPairs,function(queryPair){
      var pair = queryPair.split('=');
      var key = pair[0];
      var value = pair[1];
      queryParams[key] = value;
    });
  }
  catch (e) {}
  return queryParams;
};

proto.getQueryString = function(path){
  return path.split('?')[1];
};

proto._getQueryPortion = function(query,queryKey){
  var queryPortion;
  try {
    var queryPairs = query.split('&');
    var queryParams = {};
    _.forEach(queryPairs,function(queryPair){
      var pair = queryPair.split('=');
      var key = pair[0];
      if (key == queryKey) {
        queryPortion = queryPair;
      }
    });
  }
  catch (e) {}
  return queryPortion;
};

proto._encodeRouteQuery = function(routeQuery) {
  routeQuery = routeQuery.replace('?','@');
  routeQuery = routeQuery.replace('&','|');
  routeQuery = routeQuery.replace('=','!');
  return routeQuery;
};

proto._decodeRouteQuery = function(routeQuery) {
  routeQuery = routeQuery.replace('@','?');
  routeQuery = routeQuery.replace('|','&');
  routeQuery = routeQuery.replace('!','=');
  return routeQuery;
};

proto._setRouteQueryFromLocationQuery = function(locationQuery) {
  var encodedRouteQuery = this._getRouteQueryFromLocationQuery(locationQuery);
  //encodedRouteQuery = Base64.decode(encodedRouteQuery);
  if (encodedRouteQuery) {
    var routeQuery = this._decodeRouteQuery(encodedRouteQuery);
    this.setRouteQuery(routeQuery);
  }
};

proto._getRouteQueryFromLocationQuery = function(locationQuery) {
  return this.getQueryParams(locationQuery)['q'];
};

proto._stripInitialQuery = function(locationQuery) {
  var previousQuery = this._getQueryPortion(locationQuery,'q');
  if (previousQuery) {
    var previousQueryLength = previousQuery.length;
    var previousQueryPosition = locationQuery.indexOf(previousQuery);
    queryPrefix = _.trimEnd(locationQuery.substring(0,previousQueryPosition),"&");
    querySuffix = locationQuery.substring(previousQueryPosition+previousQueryLength);
    querySuffix = (queryPrefix != "") ? querySuffix : _.trimStart(querySuffix,"&");
    locationQuery = queryPrefix + querySuffix;
  }
  return locationQuery;
};

module.exports = new RouterService;

},{"core/g3wobject":34,"core/utils/utils":77}],76:[function(require,module,exports){
var OGC_PIXEL_WIDTH = 0.28;
var OGC_DPI = 25.4/OGC_PIXEL_WIDTH;

module.exports = {
  resToScale: function(res, metric) {
    var metric = metric || 'm';
    var scale;
    switch (metric) {
      case 'm':
        var scale = (res*1000) / OGC_PIXEL_WIDTH;
        break
    }
    return scale;
  },
  scaleToRes: function(scale, metric) {
    var metric = metric || 'm';
    var resolution;
    switch (metric) {
      case 'm':
        var resolution = (scale * OGC_PIXEL_WIDTH) / 1000;
        break
    }
    return resolution;

  }
};

},{}],77:[function(require,module,exports){

/**
 * Decimal adjustment of a number.
 *
 * @param {String}  type  The type of adjustment.
 * @param {Number}  value The number.
 * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).
 * @returns {Number} The adjusted value.
 */
function decimalAdjust(type, value, exp) {
  // If the exp is undefined or zero...
  if (typeof exp === 'undefined' || +exp === 0) {
    return Math[type](value);
  }
  value = +value;
  exp = +exp;
  // If the value is not a number or the exp is not an integer...
  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
    return NaN;
  }
  // Shift
  value = value.toString().split('e');
  value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
  // Shift back
  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
}

// Decimal round
if (!Math.round10) {
  Math.round10 = function(value, exp) {
    return decimalAdjust('round', value, exp);
  };
}
// Decimal floor
if (!Math.floor10) {
  Math.floor10 = function(value, exp) {
    return decimalAdjust('floor', value, exp);
  };
}
// Decimal ceil
if (!Math.ceil10) {
  Math.ceil10 = function(value, exp) {
    return decimalAdjust('ceil', value, exp);
  };
}

String.prototype.hashCode = function() {
  var hash = 0, i, chr, len;
  if (this.length === 0) return hash;
  for (i = 0, len = this.length; i < len; i++) {
    chr   = this.charCodeAt(i);
    hash  = ((hash << 5) - hash) + chr;
    hash |= 0;
  }
  return hash;
};

var Base64 = {_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",encode:function(e){var t="";var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f<e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t="";var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,"");while(f<e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s<<2|o>>4;r=(o&15)<<4|u>>2;i=(u&3)<<6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,"n");var t="";for(var n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r)}else if(r>127&&r<2048){t+=String.fromCharCode(r>>6|192);t+=String.fromCharCode(r&63|128)}else{t+=String.fromCharCode(r>>12|224);t+=String.fromCharCode(r>>6&63|128);t+=String.fromCharCode(r&63|128)}}return t},_utf8_decode:function(e){var t="";var n=0;var r=c1=c2=0;while(n<e.length){r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r);n++}else if(r>191&&r<224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&31)<<6|c2&63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&15)<<12|(c2&63)<<6|c3&63);n+=3}}return t}};


var utils = {
  mixin: function mixin(destination, source) {
      return utils.merge(destination.prototype, source);
  },
  
  mixininstance: function mixininstance(destination,source){
      var sourceInstance = new source;
      utils.merge(destination, sourceInstance);
      utils.merge(destination.prototype, source.prototype);
  },


  merge: function merge(destination, source) {
      var key;
      for (key in source) {
          if (utils.hasOwn(source, key)) {
              destination[key] = source[key];
          }
      }
  },

  hasOwn: function hasOwn(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
  },
  
  inherit:function(childCtor, parentCtor) {
    function tempCtor() {};
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    childCtor.prototype.constructor = childCtor;
  },
  
  base: function(me, opt_methodName, var_args) {
    var caller = arguments.callee.caller;
    if (caller.superClass_) {
      // This is a constructor. Call the superclass constructor.
      return caller.superClass_.constructor.apply(
          me, Array.prototype.slice.call(arguments, 1));
    }
    var args = Array.prototype.slice.call(arguments, 2);
    var foundCaller = false;
    for (var ctor = me.constructor;
         ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
      if (ctor.prototype[opt_methodName] === caller) {
        foundCaller = true;
      } else if (foundCaller) {
        return ctor.prototype[opt_methodName].apply(me, args);
      }
    }

    // If we did not find the caller in the prototype chain,
    // then one of two things happened:
    // 1) The caller is an instance method.
    // 2) This method was not called by the right caller.
    if (me[opt_methodName] === caller) {
      return me.constructor.prototype[opt_methodName].apply(me, args);
    } else {
      throw Error(
          'base called from a method of one name ' +
          'to a method of a different name');
    }
  },
  
  noop: function(){},
  
  truefnc: function(){return true},
  
  falsefnc: function(){return true},
  
  resolve: function(value){
    var deferred = $.Deferred();
    deferred.resolve(value);
    return deferred.promise();
  },
  
  reject: function(value){
    var deferred = $.Deferred();
    deferred.reject(value);
    return deferred.promise();
  },
  
  Base64: Base64
};

module.exports = utils;

},{}],78:[function(require,module,exports){
var Control = require('./control');
function AddLayersControl() {
  var options = {
    name: "addlayer",
    tipLabel: "AddLayer",
    label: "\ue907"
  };
  Control.call(this, options);
}

ol.inherits(AddLayersControl, Control);

var proto = AddLayersControl.prototype;

proto.setMap = function(map) {
  var self = this;
  Control.prototype.setMap.call(this,map);
  $(this.element).on('click', function() {
    self.dispatchEvent('addlayer');
  })
};

proto.layout = function(map) {
  Control.prototype.layout.call(this, map);
};


module.exports = AddLayersControl;

},{"./control":80}],79:[function(require,module,exports){
var utils = require('../utils');
var AreaIteraction = require('../interactions/areainteraction');
var MeasureControl = require('./measurecontrol');

var AreaControl = function(options) {
  var _options = {
    name: "Area",
    label: "\ue909",
    interactionClass: AreaIteraction
  };
  options = utils.merge(options,_options);
  MeasureControl.call(this, options);
};

ol.inherits(AreaControl, MeasureControl);


module.exports = AreaControl;

},{"../interactions/areainteraction":94,"../utils":103,"./measurecontrol":84}],80:[function(require,module,exports){
var Control = function(options) {
  var name = options.name || "?";
  this.name = name.split(' ').join('-').toLowerCase();
  this.id = this.name+'_'+(Math.floor(Math.random() * 1000000));
  this.positionCode = options.position || 'tl';
  this.priority = options.priority || 0;
  if (!options.element) {
    var className = "ol-"+this.name.split(' ').join('-').toLowerCase();
    var tipLabel = options.tipLabel || this.name;
    var label = options.label || "?";
    options.element = $('<div class="'+className+' ol-unselectable ol-control"><button type="button" title="'+tipLabel+'">'+label+'</button></div>')[0];
  }
  $(options.element).addClass("ol-control-"+this.positionCode);
  var buttonClickHandler = options.buttonClickHandler || Control.prototype._handleClick.bind(this);
  $(options.element).on('click',buttonClickHandler);
  ol.control.Control.call(this,options);
  this._postRender();

};

// sotto classse della classe Control di OL3
ol.inherits(Control, ol.control.Control);

var proto = Control.prototype;

proto.getPosition = function(positionCode) {
  var positionCode = positionCode || this.positionCode;
  var position = {};
  position['top'] = (positionCode.indexOf('t') > -1) ? true : false;
  position['left'] = (positionCode.indexOf('l') > -1) ? true : false;
  return position;
};

proto._handleClick = function(event) {
  event.preventDefault();
  var self = this;
  var map = this.getMap();
  var resetControl = null;
  // remove all the other, eventually toggled, interactioncontrols
  var controls = map.getControls();
  controls.forEach(function(control){
    if(control.id && control.toggle && (control.id != self.id)) {
      control.toggle(false);
      if (control.name == 'reset') {
        resetControl = control;
      }
    }
  });
  if (!self._toggled && resetControl) {
    resetControl.toggle(true);
  }
  this.dispatchEvent('controlclick');
};

//funzione che fa lo shift della posizione
proto.shiftPosition = function(position) {
  $(this.element).css(hWhere, position+'px');
};

// funzione che gestisce il layout
proto.layout = function(map) {
  if (map) {
    var position =  this.getPosition();
    var viewPort = map.getViewport();
    // vado a verificare se trovo elementi con lo stessa classe .ol-control-t o .ol-control-tl(che sono i default di ol3)
    var previusControls = $(viewPort).find('.ol-control-'+this.positionCode+':visible');
    if (previusControls.length) {
      previusControl = previusControls.last();
      var previousOffset = position.left ? previusControl.position().left : previusControl.position().top;
      var hWhere = position.left ? 'left' : 'top';
      var previousWidth = previusControl[0].offsetWidth;
      var hOffset = $(this.element).position()[hWhere] + previousOffset + previousWidth;
      $(this.element).css(hWhere,hOffset+'px');
    }
  }
};

// funzione che viene chiamata al momento che il controllo viene
// aggiunto alla mappa
proto.setMap = function(map) {
  if (map) {
    this.layout(map);
    ol.control.Control.prototype.setMap.call(this, map);
  }
};

// funzione che nasconde il controllo e sposta tutti i controlli a destra
// senza lasciare il buco
proto.hideControl = function() {
  var position = $(this.element).position().left
  var controlWidth = $(this.element).outerWidth();
  var newPosition = position;
  var controls = $(this.element).siblings('.ol-control-tl');
  controls.each(function() {
    if ($(this).position().left > position) {
      newPosition = $(this).position().left;
      if (controlWidth > $(this).outerWidth()) {
        position = position + (controlWidth - $(this).outerWidth())
      } 
      $(this).css('left', position+'px');
      position = newPosition;
      controlWidth = $(this).outerWidth();
    }
  });
  $(this.element).hide();
};

proto._postRender = function() {};

module.exports = Control;

},{}],81:[function(require,module,exports){
var Control = require('./control');
function GeolocationControl() {
  var options = {
    name: "geolocation",
    tipLabel: "Geolocation",
    label: "\ue904"
  };
  Control.call(this, options);
}

ol.inherits(GeolocationControl, Control);

var proto = GeolocationControl.prototype;

proto.setMap = function(map) {
  var self = this;
  Control.prototype.setMap.call(this,map);
  // faccio la gestione tutta interna alla rimozione del controllo
  var geolocation = new ol.Geolocation({
    projection: map.getView().getProjection(),
    tracking: true
  });
  //mi metto in ascolto del proprety change in particolare quando viene settato allow o block
  geolocation.once('change:position', function(e) {
    if (this.getPosition()) {
      $(self.element).removeClass('g3w-ol-disabled');
      $(self.element).on('click', function() {
        var map = self.getMap();
        var view = map.getView();
        coordinates = geolocation.getPosition();
        view.setCenter(coordinates);
        self.dispatchEvent({
          type: 'click',
          coordinates: coordinates
        })
      });
    } else {
      self.hideControl();
    }
  });
  geolocation.once('error', function(e) {
    self.hideControl();
    if (e.code != 1) {
      self.dispatchEvent('error');
    }
  });
};

proto.layout = function(map) {
  Control.prototype.layout.call(this, map);
  $(this.element).addClass('g3w-ol-disabled');
};


module.exports = GeolocationControl;
},{"./control":80}],82:[function(require,module,exports){
var Control = require('./control');

var InteractionControl = function(options) {
  this._toggled = this._toggled || false;
  this._interactionClass = options.interactionClass || null;
  this._interaction = null;
  this._autountoggle = options.autountoggle || false;
  this._geometryTypes = options.geometryTypes || []; // array con tipologie di geometria layer
  this._onSelectLayer = options.onselectlayer || false;
  this._enabled = (options.enabled === false) ? false : true;
  this._onhover = options.onhover || false;
  this._help = options.help  || null;
  this._modalHelp = this._help ? (options.modalHelp || toastr) : null;
  options.buttonClickHandler = InteractionControl.prototype._handleClick.bind(this);
  Control.call(this, options);
  // vado a creare il modal help se esiste un messaggio
  if (this._help) {
    this._createModalHelp();
  }
};

ol.inherits(InteractionControl, Control);

var proto = InteractionControl.prototype;

proto._clearModalHelp = function(id) {
  var self = this;
  $('body').delegate('#'+id,'change', function() {
    self._modalHelp = null;
  });
};

//funzione che si occupa di  visualizzazre la modeal dell'help
proto._showModalHelp = function() {
  var previousToastPositionClass = toastr.options.positionClass;
  // qui c'è una dipendenza con l'app template
  var contentDiv = $('#g3w-view-content');
  if (this._modalHelp) {
    toastr.options.positionClass = 'toast-top-right';
    // se già presente un modale lo chiudo
    this._modalHelp.clear();
    var helpElement = this._modalHelp.info(this._help);
    if (contentDiv) {
      var right = contentDiv.css('width');
      $(helpElement).css('right', right);
    }
    toastr.options.positionClass = previousToastPositionClass;
  }
};

// funzione che crea la help modal
proto._createModalHelp = function() {
  var self = this;
  var id = "close_button"+Math.floor(Math.random()*1000000)+""+Date.now();
  this._help += '<label for="'+id+'" style="float:right">Non mostrare più</label><input type="checkbox" id="'+id+'" class="pull-right"/>';
  // verifico se abilitato e se settato proprietà onhover
  if (this._onhover) {
    $(this.element).on('mouseenter', function() {
      if (!self._enabled) {
        self._showModalHelp();
      }
    });
  }
  this._clearModalHelp(id);
};

proto.getGeometryTypes = function() {
  return this._geometryTypes;
};

proto.getInteraction = function() {
  return this._interaction;
};

proto.isToggled = function() {
  return this._toggled;
};

// funzione per la gestione premuto non premuto
proto.toggle = function(toggle) {
  var toggle = toggle !== undefined ? toggle : !this._toggled;
  //stato del toogle;
  this._toggled = toggle;
  var controlButton = $(this.element).find('button').first();
  if (toggle) {
    this._showModalHelp();
    if (this._interaction) {
      this._interaction.setActive(true);
    }
    controlButton.addClass('g3w-ol-toggled');
  }
  else {
    if (this._interaction) {
      this._interaction.setActive(false);
    }
    controlButton.removeClass('g3w-ol-toggled');
  }
};

// funzione che abilita e disabilita il controllo
proto.setEnable = function(bool) {
  var controlButton = $(this.element).find('button').first();
  if (bool)  {
    controlButton.removeClass('g3w-ol-disabled');
  } else {
    controlButton.addClass('g3w-ol-disabled');
    controlButton.removeClass('g3w-ol-toggled');
    if (this._interaction) {
      this._interaction.setActive(false);
    }
  }
  this._enabled = bool;
};

proto.getEnable = function() {
  return this._enabled;
};

proto.getGeometryTypes = function() {
  return this._geometryTypes;
};

proto.setGeometryTypes = function(types) {
  this._geometryTypes = types;
};

proto.onSelectLayer = function() {
  return this._onSelectLayer;
};

proto.setMap = function(map) {
  if (!this._interaction && this._interactionClass) {
    this._interaction = new this._interactionClass;
    map.addInteraction(this._interaction);
    this._interaction.setActive(false);
  }
  Control.prototype.setMap.call(this,map);
};

proto._handleClick = function(e) {
  if (this._enabled) {
    this.toggle();
    Control.prototype._handleClick.call(this,e);
  }
};

proto.getIteraction = function() {
  return this._interaction;
};


module.exports = InteractionControl;

},{"./control":80}],83:[function(require,module,exports){
var utils = require('../utils');
var LenghtIteraction = require('../interactions/lengthinteraction');
var MeasureControl = require('./measurecontrol');

var LengthControl = function(options) {
  var _options = {
    name: "Lunghezza",
    label: "\ue908",
    interactionClass: LenghtIteraction
  };

  options = utils.merge(options,_options);
  MeasureControl.call(this, options);
};

ol.inherits(LengthControl, MeasureControl);


module.exports = LengthControl;

},{"../interactions/lengthinteraction":96,"../utils":103,"./measurecontrol":84}],84:[function(require,module,exports){
var InteractionControl = require('./interactioncontrol');

var MeasureControl = function(options) {
  this._map = null;
  this._projection = null;
  InteractionControl.call(this, options);
};

ol.inherits(MeasureControl, InteractionControl);

var proto = MeasureControl.prototype;

proto.setMap = function(map) {
  InteractionControl.prototype.setMap.call(this, map);
};

proto.toggle = function(toggle) {
  InteractionControl.prototype.toggle.call(this, toggle);
  if (!this.isToggled()) {
    //vado a fare il clen del measure control che erara stato eventualmente acceso
    // esempio area se attivo su lenght e viceversa
    this.getIteraction().clear();
  }
};

module.exports = MeasureControl;

},{"./interactioncontrol":82}],85:[function(require,module,exports){
var Control = require('./control');
function NominatimControl() {
  var self = this;
  this.options = {
    provider: 'osm',
    placeholder: 'Città, indirizzo ... ',
    targetType: 'text-input',
    lang: 'it-IT',
    limit: 5,
    keepOpen: true,
    preventDefault: false,
    autoComplete: false,
    autoCompleteMinLength: 4,
    debug: false
  };

  var inputQueryId = "gcd-input-query";
  var inputResetId = "gcd-input-reset";
  var cssClasses = {
    "namespace": "ol-geocoder",
    "spin": "gcd-pseudo-rotate",
    "hidden": "gcd-hidden",
    "country": "gcd-country",
    "city": "gcd-city",
    "road": "gcd-road",
    "olControl": "ol-control",
    "glass": {
      "container": "gcd-gl-container",
      "control": "gcd-gl-control",
      "button": "gcd-gl-btn",
      "input": "gcd-gl-input",
      "expanded": "gcd-gl-expanded",
      "reset": "gcd-gl-reset",
      "result": "gcd-gl-result"
    },
    "inputText": {
      "container": "gcd-txt-container",
      "control": "gcd-txt-control",
      "input": "gcd-txt-input",
      "reset": "gcd-txt-reset",
      "icon": "gcd-txt-glass",
      "result": "gcd-txt-result"
    }
  };

  var targetType = {
    GLASS: 'glass-button',
    INPUT: 'text-input'
  };
  var vars = Object.freeze({
    inputQueryId: inputQueryId,
    inputResetId: inputResetId,
    cssClasses: cssClasses,
    default: {
      inputQueryId: inputQueryId,
      inputResetId: inputResetId,
      cssClasses: cssClasses
    }
  });

  var utils = {
    toQueryString: function toQueryString(obj) {
      var this$1 = this;
      return Object.keys(obj).reduce(function (a, k) {
        a.push(
          typeof obj[k] === 'object' ?
            this$1.toQueryString(obj[k]) :
            encodeURIComponent(k) + '=' + encodeURIComponent(obj[k])
        );
        return a;
      }, []).join('&');
    },
    encodeUrlXhr: function encodeUrlXhr(url, data) {
      if(data && typeof data === 'object') {
        var str_data = this.toQueryString(data);
        url += (/\?/.test(url) ? '&' : '?') + str_data;
      }
      return url;
    },
    json: function json(url, data) {
      return $.get(url, data)
      },
    jsonp: function jsonp(url, key, callback) {
        // https://github.com/Fresheyeball/micro-jsonp/blob/master/src/jsonp.js
        var head = document.head,
          script = document.createElement('script'),
          // generate minimally unique name for callback function
          callbackName = 'f' + Math.round(Math.random() * Date.now());

        // set request url
        script.setAttribute('src',
          /*  add callback parameter to the url
           where key is the parameter key supplied
           and callbackName is the parameter value */
          (url + (url.indexOf('?') > 0 ? '&' : '?') + key + '=' + callbackName));

        /*  place jsonp callback on window,
         the script sent by the server should call this
         function as it was passed as a url parameter */
        window[callbackName] = function (json) {
          window[callbackName] = undefined;

          // clean up script tag created for request
          setTimeout(function () {
            head.removeChild(script);
          }, 0);

          // hand data back to the user
          callback(json);
        };

        // actually make the request
        head.appendChild(script);
      },
      now: function now() {
        // Polyfill for window.performance.now()
        // @license http://opensource.org/licenses/MIT
        // copyright Paul Irish 2015
        // https://gist.github.com/paulirish/5438650
        if('performance' in window === false) {
          window.performance = {};
        }

        Date.now = (Date.now || function () {  // thanks IE8
          return new Date().getTime();
        });

        if('now' in window.performance === false) {

          var nowOffset = Date.now();

          if(performance.timing && performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart;
          }

          window.performance.now = function now() {
            return Date.now() - nowOffset;
          };
        }
        return window.performance.now();
      },

      flyTo: function flyTo(map, coord, duration, resolution) {
        resolution = resolution || 2.388657133911758;
        duration = duration || 500;
        var view = map.getView();
        view.animate({duration: duration, resolution: resolution},
          {duration: duration, center: coord});
      },
      randomId: function randomId(prefix) {
        var id = this.now().toString(36);
        return prefix ? prefix + id : id;
      },
      isNumeric: function isNumeric(str) {
        return /^\d+$/.test(str);
      },
      classRegex: function classRegex(classname) {
        return new RegExp(("(^|\\s+) " + classname + " (\\s+|$)"));
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String|Array<String>} classname Class or array of classes.
       * For example: 'class1 class2' or ['class1', 'class2']
       * @param {Number|undefined} timeout Timeout to remove a class.
       */
      addClass: function addClass(element, classname, timeout) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.addClass(each, classname);
          });
          return;
        }

        var array = (Array.isArray(classname))
          ? classname
          : classname.split(/\s+/);
        var i = array.length;

        while (i--) {
          if(!this$1.hasClass(element, array[i])) {
            this$1._addClass(element, array[i], timeout);
          }
        }
      },
      _addClass: function _addClass(el, klass, timeout) {
        var this$1 = this;

        // use native if available
        if(el.classList) {
          el.classList.add(klass);
        } else {
          el.className = (el.className + ' ' + klass).trim();
        }

        if(timeout && this.isNumeric(timeout)) {
          window.setTimeout(function () {
            this$1._removeClass(el, klass);
          }, timeout);
        }
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String|Array<String>} classname Class or array of classes.
       * For example: 'class1 class2' or ['class1', 'class2']
       * @param {Number|undefined} timeout Timeout to add a class.
       */
      removeClass: function removeClass(element, classname, timeout) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.removeClass(each, classname, timeout);
          });
          return;
        }

        var array = (Array.isArray(classname))
          ? classname
          : classname.split(/\s+/);
        var i = array.length;

        while (i--) {
          if(this$1.hasClass(element, array[i])) {
            this$1._removeClass(element, array[i], timeout);
          }
        }
      },
      _removeClass: function _removeClass(el, klass, timeout) {
        var this$1 = this;

        if(el.classList) {
          el.classList.remove(klass);
        } else {
          el.className = (el.className.replace(this.classRegex(klass), ' ')).trim();
        }
        if(timeout && this.isNumeric(timeout)) {
          window.setTimeout(function () {
            this$1._addClass(el, klass);
          }, timeout);
        }
      },
      /**
       * @param {Element} element DOM node.
       * @param {String} classname Classname.
       * @return {Boolean}
       */
      hasClass: function hasClass(element, c) {
        // use native if available
        return element.classList
          ? element.classList.contains(c)
          : this.classRegex(c).test(element.className);
      },
      /**
       * @param {Element|Array<Element>} element DOM node or array of nodes.
       * @param {String} classname Classe.
       */
      toggleClass: function toggleClass(element, classname) {
        var this$1 = this;

        if(Array.isArray(element)) {
          element.forEach(function (each) {
            this$1.toggleClass(each, classname);
          });
          return;
        }

        // use native if available
        if(element.classList) {
          element.classList.toggle(classname);
        } else {
          if(this.hasClass(element, classname)) {
            this._removeClass(element, classname);
          } else {
            this._addClass(element, classname);
          }
        }
      },
      /**
       * Abstraction to querySelectorAll for increased
       * performance and greater usability
       * @param {String} selector
       * @param {Element} context (optional)
       * @param {Boolean} find_all (optional)
       * @return (find_all) {Element} : {Array}
       */
      find: function find(selector, context, find_all) {
        if(context === void 0) context = window.document;
        var simpleRe = /^(#?[\w-]+|\.[\w-.]+)$/,
          periodRe = /\./g,
          slice = Array.prototype.slice,
          matches = [];

        // Redirect call to the more performant function
        // if it's a simple selector and return an array
        // for easier usage
        if(simpleRe.test(selector)) {
          switch (selector[0]) {
            case '#':
              matches = [this.$(selector.substr(1))];
              break;
            case '.':
              matches = slice.call(context.getElementsByClassName(
                selector.substr(1).replace(periodRe, ' ')));
              break;
            default:
              matches = slice.call(context.getElementsByTagName(selector));
          }
        } else {
          // If not a simple selector, query the DOM as usual
          // and return an array for easier usage
          matches = slice.call(context.querySelectorAll(selector));
        }
        return (find_all) ? matches : matches[0];
      },
      $: function $(id) {
        id = (id[0] === '#') ? id.substr(1, id.length) : id;
        return document.getElementById(id);
      },
      isElement: function isElement(obj) {
        // DOM, Level2
        if('HTMLElement' in window) {
          return (!!obj && obj instanceof HTMLElement);
        }
        // Older browsers
        return (!!obj && typeof obj === 'object' && obj.nodeType === 1 &&
        !!obj.nodeName);
      },
      getAllChildren: function getAllChildren(node, tag) {
        return [].slice.call(node.getElementsByTagName(tag));
      },
      isEmpty: function isEmpty(str) {
        return (!str || 0 === str.length);
      },
      emptyArray: function emptyArray(array) {
        while (array.length) {
          array.pop();
        }
      },
      anyMatchInArray: function anyMatchInArray(source, target) {
        return source.some(function (each) {
          return target.indexOf(each) >= 0;
        });
      },
      everyMatchInArray: function everyMatchInArray(arr1, arr2) {
        return arr2.every(function (each) {
          return arr1.indexOf(each) >= 0;
        });
      },
      anyItemHasValue: function anyItemHasValue(obj, has) {
        var this$1 = this;
        if(has === void 0) has = false;

        var keys = Object.keys(obj);
        keys.forEach(function (key) {
          if(!this$1.isEmpty(obj[key])) {
            has = true;
          }
        });
        return has;
      },
      removeAllChildren: function removeAllChildren(node) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      },
      removeAll: function removeAll(collection) {
        var node;
        while ((node = collection[0])) {
          node.parentNode.removeChild(node);
        }
      },
      getChildren: function getChildren(node, tag) {
        return [].filter.call(
          node.childNodes, function (el) {
            return tag
              ? el.nodeType === 1 && el.tagName.toLowerCase() === tag
              : el.nodeType === 1;
          }
        );
      },
      template: function template(html, row) {
        var this$1 = this;

        return html.replace(/\{ *([\w_-]+) *\}/g, function (htm, key) {
          var value = (row[key] === undefined) ? '' : row[key];
          return this$1.htmlEscape(value);
        });
      },
      htmlEscape: function htmlEscape(str) {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      },
      /**
       * Overwrites obj1's values with obj2's and adds
       * obj2's if non existent in obj1
       * @returns obj3 a new object based on obj1 and obj2
       */
      mergeOptions: function mergeOptions(obj1, obj2) {
        var obj3 = {};
        for (var attr1 in obj1) {
          obj3[attr1] = obj1[attr1];
        }
        for (var attr2 in obj2) {
          obj3[attr2] = obj2[attr2];
        }
        return obj3;
      },
      createElement: function createElement(node, html) {
        var elem;
        if(Array.isArray(node)) {
          elem = document.createElement(node[0]);

          if(node[1].id) {
            elem.id = node[1].id;
          }
          if(node[1].classname) {
            elem.className = node[1].classname;
          }

          if(node[1].attr) {
            var attr = node[1].attr;
            if(Array.isArray(attr)) {
              var i = -1;
              while (++i < attr.length) {
                elem.setAttribute(attr[i].name, attr[i].value);
              }
            } else {
              elem.setAttribute(attr.name, attr.value);
            }
          }
        } else {
          elem = document.createElement(node);
        }
        elem.innerHTML = html;
        var frag = document.createDocumentFragment();

        while (elem.childNodes[0]) {
          frag.appendChild(elem.childNodes[0]);
        }
        elem.appendChild(frag);
        return elem;
      },
      assert: function assert(condition, message) {
        if(message === void 0) message = 'Assertion failed';

        if(!condition) {
          if(typeof Error !== 'undefined') {
            throw new Error(message);
          }
          throw message; // Fallback
        }
      }
    };

    var klasses = vars.cssClasses;
    var klasses$1 = vars.cssClasses;

  // classe Html //
  var Html = function Html(base) {
    this.options = base.options;
    this.els = this.createControl();
  };

  Html.prototype.createControl = function createControl () {
    var container, containerClass, elements;

    if (this.options.targetType === targetType.INPUT) {
      containerClass = klasses.namespace + ' ' + klasses.inputText.container;
      container = utils.createElement(
        ['div', { classname: containerClass }], Html.input);
      elements = {
        container: container,
        control: utils.find('.' + klasses.inputText.control, container),
        input: utils.find('.' + klasses.inputText.input, container),
        reset: utils.find('.' + klasses.inputText.reset, container),
        result: utils.find('.' + klasses.inputText.result, container)
      };
    } else {
      containerClass = klasses.namespace + ' ' + klasses.glass.container;
      container = utils.createElement(
        ['div', { classname: containerClass }], Html.glass);
      elements = {
        container: container,
        control: utils.find('.' + klasses.glass.control, container),
        button: utils.find('.' + klasses.glass.button, container),
        input: utils.find('.' + klasses.glass.input, container),
        reset: utils.find('.' + klasses.glass.reset, container),
        result: utils.find('.' + klasses.glass.result, container)
      };
    }
    //set placeholder from options
    elements.input.placeholder = this.options.placeholder;
    return elements;
  };

  /* eslint-disable indent */
  Html.glass = [
    '<div class="', klasses.glass.control, ' ', klasses.olControl, '">',
    '<button type="button" class="', klasses.glass.button, '"></button>',
    '<input type="text"',
    ' id="', vars.inputQueryId, '"',
    ' class="', klasses.glass.input, '"',
    ' autocomplete="off" placeholder="Search ...">',
    '<a',
    ' id="', vars.inputResetId, '"',
    ' class="', klasses.glass.reset, ' ', klasses.hidden, '"',
    '></a>',
    '</div>',
    '<ul class="', klasses.glass.result, '"></ul>'
  ].join('');

  Html.input = [
    '<div class="', klasses.inputText.control, '">',
    '<input type="text"',
    ' id="', vars.inputQueryId, '"',
    ' class="', klasses.inputText.input, '"',
    ' autocomplete="off" placeholder="Search ...">',
    '<button type="button" class="btn btn-primary" id="search_nominatim"><i class="fa fa-search" aria-hidden="true"></i></button>',
    '<button type="button"',
    ' id="', vars.inputResetId, '"',
    ' class="', klasses.inputText.reset, ' ', klasses.hidden, '"',
    '></button>',
    '</div>',
    '<ul class="', klasses.inputText.result, '"></ul>'
  ].join('');

  // classe Html fine //

  // classe OpenStreet //

  var OpenStreet = function OpenStreet() {

    this.settings = {
      url: '//nominatim.openstreetmap.org/search/',
      params: {
        q: '',
        format: 'json',
        addressdetails: 1,
        limit: 10,
        countrycodes: 'IT',
        'accept-language': 'it-IT'
      }
    };
  };


  OpenStreet.prototype.getParameters = function getParameters(options) {
    return {
      url: this.settings.url,
      params: {
        q: options.query,
        format: 'json',
        addressdetails: 1,
        limit: options.limit || this.settings.params.limit,
        countrycodes: options.countrycodes || this.settings.params.countrycodes,
        'accept-language': options.lang || this.settings.params['accept-language']
      }
    };
  };

  OpenStreet.prototype.handleResponse = function handleResponse(results) {
    return results.map(function (result) {
      return ({
        lon: result.lon,
        lat: result.lat,
        address: {
          name: result.address.neighbourhood || '',
          road: result.address.road || '',
          postcode: result.address.postcode,
          city: result.address.city || result.address.town,
          state: result.address.state,
          country: result.address.country
        },
        original: {
          formatted: result.display_name,
          details: result.address
        }
      });
    });
  };

  // classe OpenStreet fine //

  // classe Nomitatim //

  var Nominatim = function Nominatim(base, els) {
    this.Base = base;
    this.options = base.options;
    this.options.provider = this.options.provider.toLowerCase();
    this.els = els;
    this.lastQuery = '';
    this.container = this.els.container;
    this.registeredListeners = { mapClick: false };
    this.setListeners();
    this.OpenStreet = new OpenStreet();

  };

  Nominatim.prototype.setListeners = function setListeners () {
    var this$1 = this;
    var timeout, lastQuery;
    var openSearch = function () {
      utils.hasClass(this$1.els.control, klasses$1.glass.expanded) ?
        this$1.collapse() : this$1.expand();
    };
    var query = function (evt) {
      var value = evt.target.value.trim();
      var hit = evt.key ? evt.key === 'Enter' :
        evt.which ? evt.which === 13 :
          evt.keyCode ? evt.keyCode === 13 : false;

      if (hit) {
        evt.preventDefault();
        this$1.query(value);
      }
    };
    var reset = function (evt) {
      this$1.els.input.focus();
      this$1.els.input.value = '';
      this$1.lastQuery = '';
      utils.addClass(this$1.els.reset, klasses$1.hidden);
      this$1.clearResults();
    };
    var handleValue = function (evt) {
      var value = evt.target.value.trim();

      value.length
        ? utils.removeClass(this$1.els.reset, klasses$1.hidden)
        : utils.addClass(this$1.els.reset, klasses$1.hidden);

      if (this$1.options.autoComplete && value !== lastQuery) {
        lastQuery = value;
        timeout && clearTimeout(timeout);
        timeout = setTimeout(function () {
          if (value.length >= this$1.options.autoCompleteMinLength) {
            this$1.query(value);
          }
        }, 200);
      }
    };
    this.els.input.addEventListener('keyup', query, false);
    this.els.input.addEventListener('input', handleValue, false);
    this.els.reset.addEventListener('click', reset, false);
    if (this.options.targetType === targetType.GLASS) {
      this.els.button.addEventListener('click', openSearch, false);
    }
  };

  Nominatim.prototype.query = function query (q) {
    var this$1 = this;
    var ajax = {}, options = this.options;
    var provider = this.getProvider({
      query: q,
      provider: options.provider,
      key: options.key,
      lang: options.lang,
      countrycodes: options.countrycodes,
      limit: options.limit
    });
    if (this.lastQuery === q && this.els.result.firstChild) { return; }
    this.lastQuery = q;
    this.clearResults();
    utils.addClass(this.els.reset, klasses$1.spin);
    ajax.url = document.location.protocol + provider.url;
    ajax.data = provider.params;
    utils.json(ajax)
      .done(function(res) {
        utils.removeClass(this$1.els.reset, klasses$1.spin);
            //will be fullfiled according to provider
            var res_= res.length ? this$1.OpenStreet.handleResponse(res) : undefined;
            this$1.createList(res_);
            if (res_) {
              this$1.listenMapClick();
            }

      })
      .fail(function(error){
        utils.removeClass(this$1.els.reset, klasses$1.spin);
            var li = utils.createElement(
              'li', '<h5>  Il server non risponde</h5>');
            this$1.els.result.appendChild(li);
      })

  };

  Nominatim.prototype.createList = function createList (response) {
    var this$1 = this;
    var ul = this.els.result;
    if (response) {
      response.forEach(function (row) {
        var addressHtml = this$1.addressTemplate(row.address),
          html = ['<a href="#">', addressHtml, '</a>'].join(''),
          li = utils.createElement('li', html);
        li.addEventListener('click', function (evt) {
          evt.preventDefault();
          this$1.chosen(row, addressHtml, row.address, row.original);
        }, false);
        ul.appendChild(li);
      });
    } else {
      li = utils.createElement('li', 'Nessun Risultato');
      ul.appendChild(li);
    }

  };

  Nominatim.prototype.chosen = function chosen(place, addressHtml, addressObj, addressOriginal) {
    var map = this.Base.getMap();
    var coord_ = [parseFloat(place.lon), parseFloat(place.lat)];
    var projection = map.getView().getProjection();
    var coord = ol.proj.transform(coord_, 'EPSG:4326', projection);
    var address = {
      formatted: addressHtml,
      details: addressObj,
      original: addressOriginal
    };
    this.options.keepOpen === false && this.clearResults(true);
    this.Base.dispatchEvent({
      type: 'addresschosen',
      address: address,
      coordinate: coord
    });
  };

  Nominatim.prototype.addressTemplate = function addressTemplate (address) {
    var html = [];
    if (address.name) {
      html.push(['<div class="', klasses$1.road, '">{name}</div>'].join(''));
    }
    if (address.road || address.building || address.house_number) {
      html.push([
        '<div class="', klasses$1.road,
        '">{building} {road} {house_number}</div>'
      ].join(''));
    }
    if (address.city || address.town || address.village) {
      html.push([
        '<div class="', klasses$1.city,
        '">{postcode} {city} {town} {village}</div>'
      ].join(''));
    }
    if (address.state || address.country) {
      html.push([
        '<div class="', klasses$1.country, '">{state} {country}</div>'
      ].join(''));
    }
    return utils.template(html.join('<br>'), address);
  };

  Nominatim.prototype.getProvider = function getProvider (options) {
    return this.OpenStreet.getParameters(options);
  };

  Nominatim.prototype.expand = function expand () {
    var this$1 = this;

    utils.removeClass(this.els.input, klasses$1.spin);
    utils.addClass(this.els.control, klasses$1.glass.expanded);
    window.setTimeout(function () { return this$1.els.input.focus(); }, 100);
    this.listenMapClick();
  };

  Nominatim.prototype.collapse = function collapse () {
    this.els.input.value = '';
    this.els.input.blur();
    utils.addClass(this.els.reset, klasses$1.hidden);
    utils.removeClass(this.els.control, klasses$1.glass.expanded);
    this.clearResults();
  };

  Nominatim.prototype.listenMapClick = function listenMapClick () {
    // already registered
    if (this.registeredListeners.mapClick) { return; }

    var this_ = this;
    var mapElement = this.Base.getMap().getTargetElement();
    this.registeredListeners.mapClick = true;

    //one-time fire click
    mapElement.addEventListener('click', {
      handleEvent: function (evt) {
        this_.clearResults(true);
        mapElement.removeEventListener(evt.type, this, false);
        this_.registeredListeners.mapClick = false;
      }
    }, false);
  };

  Nominatim.prototype.clearResults = function clearResults (collapse) {
    collapse && this.options.targetType === targetType.GLASS ?
      this.collapse() : utils.removeAllChildren(this.els.result);
  };

  Nominatim.prototype.getSource = function getSource () {
    return this.layer.getSource();
  };

  Nominatim.prototype.addLayer = function addLayer () {
    var this$1 = this;

    var found = false;
    var map = this.Base.getMap();

    map.getLayers().forEach(function (layer) {
      if (layer === this$1.layer) { found = true; }
    });
    if (!found) { map.addLayer(this.layer); }
  };

  // classe Nomitatim fine //

  var $html = new Html(this);
  this.container = $html.els.container;
  this.nominatim = new Nominatim(this, $html.els);
  this.layer = this.nominatim.layer;
  Control.call(this, {
    element: this.container,
    name: "nominatim"
  });
}

ol.inherits(NominatimControl, Control);

proto = NominatimControl.prototype;


module.exports = NominatimControl;

},{"./control":80}],86:[function(require,module,exports){
var OLControl = function(options){
  this._control = null;
  this.positionCode = options.position || 'tl';
  
  switch (options.type) {
    case 'zoom':
      this._control = new ol.control.Zoom(options);
      break;
    case 'zoomtoextent':
      this._control = new ol.control.ZoomToExtent(options);
      break;
    case 'scaleline':
      this._control = new ol.control.ScaleLine(options);
      break;
    case 'overview':
      this._control = new ol.control.OverviewMap(options);
  }
  
  $(this._control.element).addClass("ol-control-"+this.positionCode);
  
  ol.control.Control.call(this,{
    element: this._control.element
  });
};

// sotto classe della classe control di OL3
ol.inherits(OLControl, ol.control.Control);
module.exports = OLControl;

var proto = OLControl.prototype;

proto.getPosition = function(positionCode) {
  var positionCode = positionCode || this.positionCode;
  var position = {};
  position['top'] = (positionCode.indexOf('t') > -1) ? true : false;
  position['left'] = (positionCode.indexOf('l') > -1) ? true : false;
  return position;
};

proto.layout = function(map) {
  if (map) {
    var position =  this.getPosition();
    var viewPort = map.getViewport();
    var previusControls = $(viewPort).find('.ol-control-'+this.positionCode);
    if (previusControls.length) {
      previusControl = previusControls.last();
      var previousOffset = position.left ? previusControl.position().left : previusControl.position().right;
      var hWhere = position.left ? 'left' : 'right';
      var previousWidth = previusControl[0].offsetWidth;
      var hOffset = $(this.element).position()[hWhere] + previousOffset + previousWidth + 2;
      $(this.element).css(hWhere,hOffset+'px');
    }
  }
};

proto.setMap = function(map){
  this.layout(map);
  this._control.setMap(map);
};

},{}],87:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var QueryBBoxControl = function(options){
  this._startCoordinate = null;
  var _options = {
    name: "querybbox",
    tipLabel: "Query BBox layer",
    label: "\ue902",
    interactionClass: ol.interaction.DragBox,
    help: '<h4>Guida - Query BBox layer</h4><ul><li>Disegna un rettangolo per interrogare gli strati evidenziati in giallo</li></ul>'
  };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(QueryBBoxControl, InteractionControl);

var proto = QueryBBoxControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });
  this._interaction.on('boxend',function(e){
    var start_coordinate = self._startCoordinate;
    var end_coordinate = e.coordinate;
    var extent = ol.extent.boundingExtent([start_coordinate,end_coordinate]);
    self.dispatchEvent({
      type: 'bboxend',
      extent: extent
    });
    self._startCoordinate = null;
    if (self._autountoggle) {
      self.toggle();
    }
  })
};

module.exports = QueryBBoxControl;

},{"../utils":103,"./interactioncontrol":82}],88:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');

var QueryByPolygonControl = function(options){
  var _options = {
    name: "querybypolygon",
    tipLabel: "Query By Polygon",
    label: "\ue903",
    geometryTypes: ['Polygon', 'MultiPolygon'],
    onselectlayer: true,
    interactionClass: PickCoordinatesInteraction,
    help: '<h4>Guida - Query By Polygon</h4><ul><li>Seleziona uno strato poligonale</li><li>Clicca su una feature dello strato selezionato per lanciare la selezione</li></ul>',
    onhover: true
  };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(QueryByPolygonControl, InteractionControl);

var proto = QueryByPolygonControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });

  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
  this.setEnable(false);
};

module.exports = QueryByPolygonControl;

},{"../interactions/pickcoordinatesinteraction":98,"../utils":103,"./interactioncontrol":82}],89:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');

var QueryControl = function(options){
  var _options = {
    name: "querylayer",
    tipLabel: "Query layer",
    label: "\uea0f",
    interactionClass: PickCoordinatesInteraction
  };
  options = utils.merge(options, _options);
  InteractionControl.call(this, options);
};

ol.inherits(QueryControl, InteractionControl);

var proto = QueryControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });

  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
};

module.exports = QueryControl;

},{"../interactions/pickcoordinatesinteraction":98,"../utils":103,"./interactioncontrol":82}],90:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var ResetControl = function(options){
  this._toggled = true;
  this._startCoordinate = null;
  var _options = {
      name: "reset",
      tipLabel: "Pan",
      label: "\ue901"
    };
  
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);

};

ol.inherits(ResetControl, InteractionControl);

module.exports = ResetControl;

var proto = ResetControl.prototype;

proto._postRender = function(){
  this.toggle(true);
};

},{"../utils":103,"./interactioncontrol":82}],91:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');


var StreetViewControl = function(options) {
  var _options = {
    name: "streetview",
    tipLabel: "StreetView",
    label: "\ue905",
    interactionClass: PickCoordinatesInteraction
  };
  this._sv = null;
  this._panorama = null;
  this._map = null;
  this._projection = null;
  this._streetViewFeature = new ol.Feature();
  this._streetViewFeature.setStyle(style = new ol.style.Style({
    text: new ol.style.Text({
      text: '\ue905',
      font: 'bold 30px icomoon',
      textBaseline: 'Bottom',
      fill: new ol.style.Fill({
        color: '#3c8dbc'
      })
    })
  }));
  var streetVectorSource = new ol.source.Vector({
    features: []
  });

  this._layer = new ol.layer.Vector({
    source: streetVectorSource
  });
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);
};

ol.inherits(StreetViewControl, InteractionControl);

var proto = StreetViewControl.prototype;


proto.getLayer = function() {
  return this._layer;
};

proto.setProjection = function(projection) {
  this._projection = projection;
};

proto.setPosition = function(position) {
  var self = this;
  var lnglat;
  var pixel;
  if (!this._sv) {
    this._sv = new google.maps.StreetViewService();
  }
  this._sv.getPanorama({location: position}, function (data) {
    self._panorama = new google.maps.StreetViewPanorama(
      document.getElementById('streetview')
    );
    self._panorama.addListener('position_changed', function() {
      if (self.isToggled()) {
        lnglat = ol.proj.transform([this.getPosition().lng(), this.getPosition().lat()], 'EPSG:4326', self._projection.getCode());
        self._layer.getSource().getFeatures()[0].setGeometry(
          new ol.geom.Point(lnglat)
        );
        pixel = self._map.getPixelFromCoordinate(lnglat);
        if ((pixel[0] + 15) > self._map.getSize()[0] || (pixel[1] + 15) > self._map.getSize()[1] || pixel[0] < 15 || pixel [1] < 15 ) {
          self._map.getView().setCenter(lnglat);
        }
      }
    });
    if (data && data.location) {
      self._panorama.setPov({
        pitch: 0,
        heading: 0
      });
      self._panorama.setPosition(data.location.latLng);
    }
  })
};

proto.setMap = function(map) {
  var self = this;
  this._map = map;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('picked',function(e){
    self.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (self._autountoggle) {
      self.toggle();
    }
  });
};

proto.clear = function() {
  this._layer.getSource().clear();
  this._streetViewFeature.setGeometry(null);
};

proto.toggle = function(toggle) {
  InteractionControl.prototype.toggle.call(this, toggle);
  if (!this.isToggled()) {
    this.clear()
  } else {
    this._layer.getSource().addFeatures([this._streetViewFeature]);
  }
};

module.exports = StreetViewControl;

},{"../interactions/pickcoordinatesinteraction":98,"../utils":103,"./interactioncontrol":82}],92:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var ZoomBoxControl = function(options){
  var self = this;
  this._startCoordinate = null;
  var _options = {
      name: "zoombox",
      tipLabel: "Zoom to box",
      label: "\ue901",
      interactionClass: ol.interaction.DragBox
    };
  options = utils.merge(options,_options);
  InteractionControl.call(this,options);

};
ol.inherits(ZoomBoxControl, InteractionControl);
module.exports = ZoomBoxControl;

var proto = ZoomBoxControl.prototype;

proto.setMap = function(map) {
  var self = this;
  InteractionControl.prototype.setMap.call(this,map);
  this._interaction.on('boxstart',function(e){
    self._startCoordinate = e.coordinate;
  });
  
  this._interaction.on('boxend',function(e){
    var start_coordinate = self._startCoordinate;
    var end_coordinate = e.coordinate;
    var extent = ol.extent.boundingExtent([start_coordinate,end_coordinate]);
    self.dispatchEvent({
      type: 'zoomend',
      extent: extent
    });
    self._startCoordinate = null;
    if (self._autountoggle) {
      self.toggle();
    }
  });
};


},{"../utils":103,"./interactioncontrol":82}],93:[function(require,module,exports){
var utils = require('./utils');
var maphelpers = require('./map/maphelpers');

(function (name, root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  }
  else if (typeof exports === 'object') {
    module.exports = factory();
  }
  else {
    root[name] = factory();
  }
})('g3wol3', this, function () {
  'use strict';
  
  var helpers = utils.merge({},maphelpers);
  
  return {
    helpers: helpers
  }
});

},{"./map/maphelpers":102,"./utils":103}],94:[function(require,module,exports){
var MeasureInteraction = require('./measureinteraction');

// Area

var AreaIteraction = function() {
  var options = {};
  options.geometryType = "Polygon";
  MeasureInteraction.call(this, options);
};

ol.inherits(AreaIteraction, MeasureInteraction);

module.exports = AreaIteraction;
},{"./measureinteraction":97}],95:[function(require,module,exports){
var DeleteInteractionEvent = function(type, features, coordinate) {
  this.type = type;
  this.features = features;
  this.coordinate = coordinate;
};

var DeleteInteraction = function(options) {
  ol.interaction.Pointer.call(this, {
    handleDownEvent: DeleteInteraction.handleDownEvent_,
    handleMoveEvent: DeleteInteraction.handleMoveEvent_,
    handleUpEvent: DeleteInteraction.handleUpEvent_,
    handleEvent: DeleteInteraction.handleEvent_,
  });

  this.previousCursor_ = undefined;
  this.lastCoordinate_ = null;
  this.features_ = options.features !== undefined ? options.features : null;
};
ol.inherits(DeleteInteraction, ol.interaction.Pointer);

DeleteInteraction.handleEvent_ = function(mapBrowserEvent) {
  if (mapBrowserEvent.type == 'keydown'){
    if(this.features_.getArray().length && mapBrowserEvent.originalEvent.keyCode == 46){
      this.dispatchEvent(
          new DeleteInteractionEvent(
              'deleteend', this.features_,
              event.coordinate));
      return true;
    }
  }
  else{
    return ol.interaction.Pointer.handleEvent.call(this,mapBrowserEvent);
  }
};

DeleteInteraction.handleDownEvent_ = function(event) {
  this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  if (this.lastFeature_) {
    DeleteInteraction.handleMoveEvent_.call(this, event);
    this.dispatchEvent(
            new DeleteInteractionEvent(
                'deleteend', this.features_,
                event.coordinate));
    return true;
  }
  return false;
};

DeleteInteraction.handleMoveEvent_ = function(event) {
  var elem = event.map.getTargetElement();
  var intersectingFeature = event.map.forEachFeatureAtPixel(event.pixel,
      function(feature) {
        return feature;
      });

  if (intersectingFeature) {
    this.previousCursor_ = elem.style.cursor;

    elem.style.cursor =  'pointer';

  } else {
    elem.style.cursor = this.previousCursor_ !== undefined ?
        this.previousCursor_ : '';
    this.previousCursor_ = undefined;
  }
};

DeleteInteraction.prototype.featuresAtPixel_ = function(pixel, map) {
  var found = null;

  var intersectingFeature = map.forEachFeatureAtPixel(pixel,
      function(feature) {
        return feature;
      });

  if (this.features_ &&
     _.includes(this.features_.getArray(), intersectingFeature)) {
    found = intersectingFeature;
  }

  return found;
};

module.exports = DeleteInteraction;

},{}],96:[function(require,module,exports){
var MeasureInteraction = require('./measureinteraction');

// LenghtInteracion
var LengthIteraction = function() {
  var options = {};
  options.geometryType = "LineString";
  MeasureInteraction.call(this, options)
};

ol.inherits(LengthIteraction, MeasureInteraction);


module.exports = LengthIteraction;
},{"./measureinteraction":97}],97:[function(require,module,exports){
// MeasureInteracion

var MeasureIteraction = function(options) {
  this._helpTooltip;
  this._measureTooltipElement;
  this._measureTooltip;
  this._featureGeometryChangelistener;
  this._poinOnMapMoveListener;

  var measureStyle = new ol.style.Style({
    fill: new ol.style.Fill({
      color: 'rgba(255, 255, 255, 0.2)'
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(0, 0, 0, 0.5)',
      lineDash: [10, 10],
      width: 3
    }),
    image: new ol.style.Circle({
      radius: 5,
      stroke: new ol.style.Stroke({
        color: 'rgba(0, 0, 0, 0.7)'
      }),
      fill: new ol.style.Fill({
        color: 'rgba(255, 255, 255, 0.2)'
      })
    })
  });
  var geometryType = options.geometryType || 'LineString';
  this._formatMeasure = null;
  this._helpMsg = null;
  // funzione che serve per gestire il keydow della cancellazione ultimo vertice disegnato
  this._keyDownEventHandler = null;
  switch (geometryType) {
    case 'LineString':
     this._formatMeasure = function(feature) {
        var length;
        length = Math.round(feature.getLength() * 100) / 100;
        var output;
        if (length > 1000) {
          output = (Math.round(length / 1000 * 1000) / 1000) +
            ' ' + 'km';
        } else {
          output = (Math.round(length * 100) / 100) +
            ' ' + 'm';
        }
        return output;
      };
      this._helpMsg = "Clicca sulla mappa per continuare a disegnare la linea.<br>CANC se si vuole cancellare l'ultimo vertice inserito";
      break;
    case 'Polygon':
      this._formatMeasure = function(feature) {
        var area;
        area = Math.round(feature.getArea() * 100) / 100;
        var output;
        if (area > 1000) {
          output = (Math.round(area / 1000 * 1000) / 1000) +
            ' ' + 'km<sup>2</sup>';
        } else {
          output = (Math.round(area * 100) / 100) +
            ' ' + 'm<sup>2</sup>';
        }
        return output;
      };
      this._helpMsg = "Click per continuare a disegnare il poligono.<br>CANC se si vuole cancellare l'ultimo vertice inserito";
      break;
  }
  var source = new ol.source.Vector();
  this._helpTooltipElement;
  this._map = null;
  this._feature = null;
  this._layer = new ol.layer.Vector({
    source: source,
    style: function(feature) {
      var styles = [
        // linestring
        new ol.style.Style({
          stroke: new ol.style.Stroke({
            lineDash: [10, 10],
            width: 3
          }),
          fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
          })
        })
      ];
      return styles;
    }
  });
  ol.interaction.Draw.call(this, {
    source: source,
    type: geometryType,
    style: measureStyle
  });

  this.set('beforeRemove', this.clear);
  this.set('layer', this._layer);

  // registro gli eventi sulle due interaction
  this.on('drawstart', this._drawStart);
  this.on('drawend', this._drawEnd);

};

ol.inherits(MeasureIteraction, ol.interaction.Draw);


var proto = MeasureIteraction.prototype;

proto.clear = function() {
  this._layer.getSource().clear();
  this._clearMessagesAndListeners();
  if (this._map) {
    this._map.removeOverlay(this._measureTooltip);
    this._map.removeLayer(this._layer);
  }
};

proto._clearMessagesAndListeners = function() {
  this._feature = null;
  // unset tooltip so that a new one can be created
  if (this._map) {
    this._measureTooltipElement = null;
    this._helpTooltipElement.innerHTML = '';
    this._helpTooltipElement.classList.add('hidden');
    ol.Observable.unByKey(this._featureGeometryChangelistener);
    ol.Observable.unByKey(this._poinOnMapMoveListener);
    $(document).off('keydown', this._keyDownEventHandler);
  }
};

proto._removeLastPoint = function(event) {
  var geom = this._feature.getGeometry();
  if (event.keyCode === 46) {
    if( geom instanceof ol.geom.Polygon && geom.getCoordinates()[0].length > 2) {
      this.removeLastPoint();
    } else if(geom instanceof ol.geom.LineString && geom.getCoordinates().length > 1) {
      this.removeLastPoint();
    }
  }
};

//funzione drawStart
proto._drawStart = function(evt) {
  var self = this;
  this._map = this.getMap();
  this._createMeasureTooltip();
  this._createHelpTooltip();
  this._feature = evt.feature;
  this._keyDownEventHandler = _.bind(this._removeLastPoint, this);
  $(document).on('keydown', this._keyDownEventHandler);
  // vado a ripulire tutte le features
  this._layer.getSource().clear();
  this._poinOnMapMoveListener = this._map.on('pointermove', function(evt) {
    if (evt.dragging) {
      return;
    }
    if (self._feature) {
      helpMsg = self._helpMsg;
    }
    self._helpTooltipElement.innerHTML = helpMsg;
    self._helpTooltip.setPosition(evt.coordinate);
    self._helpTooltipElement.classList.remove('hidden');
  });
  var tooltipCoord = evt.coordinate;
  this._featureGeometryChangelistener = this._feature.getGeometry().on('change', function(evt) {
    var geom = evt.target;
    var output;
    if (geom instanceof ol.geom.Polygon) {
      tooltipCoord = geom.getInteriorPoint().getCoordinates();
    } else if (geom instanceof ol.geom.LineString) {
      tooltipCoord = geom.getLastCoordinate();
    }
    output = self._formatMeasure(geom);
    self._measureTooltipElement.innerHTML = output;
    self._measureTooltip.setPosition(tooltipCoord);
  });
};

//funzione drawEnd
proto._drawEnd = function() {
  this._measureTooltipElement.className = 'mtooltip mtooltip-static';
  this._measureTooltip.setOffset([0, -7]);
  this._clearMessagesAndListeners();
  this._map.addLayer(this._layer);
};

/**
 * Creates a new help tooltip
 */
proto._createHelpTooltip = function() {
  if (this._helpTooltipElement) {
    this._helpTooltipElement.parentNode.removeChild(this._helpTooltipElement);
  }
  if (this._helpTooltip) {
    this._map.removeOverlay(this._helpTooltip);
  }
  this._helpTooltipElement = document.createElement('div');
  this._helpTooltipElement.className = 'mtooltip hidden';
  this._helpTooltip = new ol.Overlay({
    element: this._helpTooltipElement,
    offset: [15, 0],
    positioning: 'center-left'
  });
  this._map.addOverlay(this._helpTooltip);
};


/**
 * Creates a new measure tooltip
 */
proto._createMeasureTooltip = function() {
  if (this._measureTooltipElement) {
    this._measureTooltipElement.parentNode.removeChild(this._measureTooltipElement);
  }
  if (this._measureTooltip) {
    this._map.removeOverlay(this._measureTooltip);
  }
  this._measureTooltipElement = document.createElement('div');
  this._measureTooltipElement.className = 'mtooltip mtooltip-measure';
  this._measureTooltip = new ol.Overlay({
    element: this._measureTooltipElement,
    offset: [0, -15],
    positioning: 'bottom-center'
  });
  this._map.addOverlay(this._measureTooltip);
};
// END MEASURE CONTROLS //

module.exports = MeasureIteraction;
},{}],98:[function(require,module,exports){
var PickCoordinatesEventType = {
  PICKED: 'picked'
};

var PickCoordinatesEvent = function(type, coordinate) {
  this.type = type;
  this.coordinate = coordinate;
};

var PickCoordinatesInteraction = function(options) {
  this.previousCursor_ = null;
  
  ol.interaction.Pointer.call(this, {
    handleDownEvent: PickCoordinatesInteraction.handleDownEvent_,
    handleUpEvent: PickCoordinatesInteraction.handleUpEvent_,
    handleMoveEvent: PickCoordinatesInteraction.handleMoveEvent_,
  });
};
ol.inherits(PickCoordinatesInteraction, ol.interaction.Pointer);

PickCoordinatesInteraction.handleDownEvent_ = function(event) {
  return true;
};

PickCoordinatesInteraction.handleUpEvent_ = function(event) {
  this.dispatchEvent(
          new PickCoordinatesEvent(
              PickCoordinatesEventType.PICKED,
              event.coordinate));
  return true;
};

PickCoordinatesInteraction.handleMoveEvent_ = function(event) {
  var elem = event.map.getTargetElement();
  elem.style.cursor =  'pointer';
};

PickCoordinatesInteraction.prototype.shouldStopEvent = function(){
  return false;
};

PickCoordinatesInteraction.prototype.setActive = function(active){
  var map = this.getMap();
  if (map) {
    var elem = map.getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setActive.call(this,active);
};

PickCoordinatesInteraction.prototype.setMap = function(map){
  if (!map) {
    var elem = this.getMap().getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setMap.call(this,map);
};

module.exports = PickCoordinatesInteraction;

},{}],99:[function(require,module,exports){
var PickFeatureEventType = {
  PICKED: 'picked'
};

var PickFeatureEvent = function(type, coordinate, feature) {
  this.type = type;
  this.feature = feature;
  this.coordinate = coordinate;
};

var PickFeatureInteraction = function(options) {

  var self = this;
  ol.interaction.Pointer.call(this, {
    handleDownEvent: PickFeatureInteraction.handleDownEvent_,
    handleUpEvent: PickFeatureInteraction.handleUpEvent_,
    handleMoveEvent: PickFeatureInteraction.handleMoveEvent_
  });
  this.features_ = options.features || null;
  this.layers_ = options.layers || null;
  this.pickedFeature_ = null;
  this.layerFilter_ = function(layer) {
    return _.includes(self.layers_, layer);
  };
};
ol.inherits(PickFeatureInteraction, ol.interaction.Pointer);

PickFeatureInteraction.handleDownEvent_ = function(event) {
  this.pickedFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  return true;
};

PickFeatureInteraction.handleUpEvent_ = function(event) {
  if(this.pickedFeature_){
    this.dispatchEvent(
            new PickFeatureEvent(
                PickFeatureEventType.PICKED,
                event.coordinate,
                this.pickedFeature_));
  }
  return true;
};

PickFeatureInteraction.handleMoveEvent_ = function(event) {
  var elem = event.map.getTargetElement();
  var intersectingFeature = this.featuresAtPixel_(event.pixel, event.map);
  if (intersectingFeature) {
    elem.style.cursor =  'pointer';
  } else {
    elem.style.cursor = '';
  }
};

PickFeatureInteraction.prototype.featuresAtPixel_ = function(pixel, map) {
  var featureFound = null;
  var self = this;
  var intersectingFeature = map.forEachFeatureAtPixel(pixel,
      function(feature) {
        if (self.features_) {
          if (self.features_.indexOf(feature) > -1){
            return feature
          }
          else{
            return null;
          }
        }
        return feature;
      }, {
        layerFilter: self.layerFilter_,
        hitTolerance: (isMobile && isMobile.any) ? 10 : 0
      });
  if (intersectingFeature) {
    featureFound = intersectingFeature;
  }
  return featureFound;
};

PickFeatureInteraction.prototype.shouldStopEvent = function(){
  return false;
};

PickFeatureInteraction.prototype.setMap = function(map){
  if (!map) {
    var elem = this.getMap().getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setMap.call(this,map);
};

module.exports = PickFeatureInteraction;

},{}],100:[function(require,module,exports){
var BaseLayers = {};

BaseLayers.OSM = new ol.layer.Tile({
  source: new ol.source.OSM({
    attributions: [
      new ol.Attribution({
        html: 'All maps &copy; ' +
            '<a href="http://www.openstreetmap.org/">OpenStreetMap</a>'
      }),
      ol.source.OSM.ATTRIBUTION
    ],
    url: 'http://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    crossOrigin: null
  }),
  id: 'osm',
  title: 'OSM',
  basemap: true
});

BaseLayers.BING = {};

BaseLayers.BING.Road = new ol.layer.Tile({
  name:'Road',
  visible: false,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'Road'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

BaseLayers.BING.AerialWithLabels = new ol.layer.Tile({
  name: 'AerialWithLabels',
  visible: true,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'AerialWithLabels'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

BaseLayers.BING.Aerial = new ol.layer.Tile({
  name: 'Aerial',
  visible: false,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn',
    imagerySet: 'Aerial'
      // use maxZoom 19 to see stretched tiles instead of the BingMaps
      // "no photos at this zoom level" tiles
      // maxZoom: 19
  }),
  basemap: true
});

module.exports = BaseLayers;

},{}],101:[function(require,module,exports){
var utils = require('../utils');
var RasterLayers = {};

RasterLayers.TiledWMSLayer = function(layerObj,extraParams){
  var options = {
    layerObj: layerObj,
    extraParams: extraParams || {},
    tiled: true
  };
  return RasterLayers._WMSLayer(options);
};

RasterLayers.WMSLayer = function(layerObj,extraParams){
  var options = {
    layerObj: layerObj,
    extraParams: extraParams || {}
  };
  return RasterLayers._WMSLayer(options);
};

RasterLayers._WMSLayer = function(options){
  var layerObj = options.layerObj;
  var extraParams = options.extraParams;
  var tiled = options.tiled || false;
  
  var params = {
    LAYERS: layerObj.layers || '',
    VERSION: '1.3.0',
    TRANSPARENT: true,
    SLD_VERSION: '1.1.0'
  };
  
  params = utils.merge(params,extraParams);
  
  var sourceOptions = {
    url: layerObj.url,
    params: params,
    ratio: 1
  };
  
  var imageOptions = {
    id: layerObj.id,
    name: layerObj.name,
    opacity: layerObj.opacity || 1.0,
    visible:layerObj.visible,
    maxResolution: layerObj.maxResolution
  };
  
  var imageClass;
  var source;
  if (tiled) {
    source = new ol.source.TileWMS(sourceOptions);
    imageClass = ol.layer.Tile;
    //imageOptions.extent = [1134867,3873002,2505964,5596944];
  }
  else {
    source = new ol.source.ImageWMS(sourceOptions);
    imageClass = ol.layer.Image;
  }
  
  imageOptions.source = source;
  
  return new imageClass(imageOptions);
};

RasterLayers.XYZLayer = function(options){
  if (!options.url){
    return;
  }

  var sourceOptions = {
    url: options.url
  };

  if (options.projection){
    sourceOptions.projection = options.projection;
  }
  if (options.maxZoom) {
    sourceOptions.maxZoom = options.maxZoom;
  }
  if (options.minZoom) {
    sourceOptions.minZoom = options.minZoom;
  }

  return new ol.layer.Tile({
    source: new ol.source.XYZ(sourceOptions)
  });
};

/*RasterLayers.TiledWMSLayer = function(layerObj){
  var layer = new ol.layer.Tile({
    name: layerObj.name,
    opacity: 1.0,
    source: new ol.source.TileWMS({
      url: layerObj.url,
      params: {
        LAYERS: layerObj.layers || '',
        VERSION: '1.3.0',
        TRANSPARENT: true
      }
    }),
    visible: layerObj.visible
  });
  
  return layer;
};*/

module.exports = RasterLayers;


},{"../utils":103}],102:[function(require,module,exports){
BaseLayers = require('../layers/bases');

var MapHelpers = {
  createViewer: function(opts){
    return new _Viewer(opts);
  }
};

var _Viewer = function(opts){
  var controls = ol.control.defaults({
    attributionOptions: {
      collapsible: false
    },
    zoom: false,
    attribution: false
  });//.extend([new ol.control.Zoom()]);
  
  var interactions = ol.interaction.defaults()
    .extend([
      new ol.interaction.DragRotate()
    ]);
  interactions.removeAt(1);// rimuovo douclickzoom
  
  var view;
  if (opts.view instanceof ol.View) {
    view = opts.view;
  }
  else {
    view = new ol.View(opts.view);
  }
  var options = {
    controls: controls,
    interactions: interactions,
    ol3Logo: false,
    view: view,
    keyboardEventTarget: document
  };
  if (opts.id){
    options.target = opts.id;
  }
  var map  = new ol.Map(options);
  this.map = map;
};

_Viewer.prototype.destroy = function(){
  if (this.map) {
    this.map.dispose();
    this.map = null
  }
};

_Viewer.prototype.getView = function() {
  return this.map.getView();
};

_Viewer.prototype.updateMap = function(mapObject){};

_Viewer.prototype.updateView = function(){};

_Viewer.prototype.getMap = function(){
  return this.map;
};

_Viewer.prototype.setTarget = function(id){
  this.map.setTarget(id);
};

_Viewer.prototype.goTo = function(coordinates, options) {
  var options = options || {};
  var animate = options.animate || true;
  var zoom = options.zoom || false;
  var view = this.map.getView();
  if (animate) {
    var panAnimation = {
      duration: 500,
      center: coordinates
    };
    if (zoom) {
      var zoomAnimation = {
        duration: 500,
        zoom: zoom
      };
    } else {
      var zoomAnimation = {
        duration: 500,
        resolution: view.getResolution()
      };
    }
    view.animate(panAnimation,zoomAnimation);
  } else {
    view.setCenter(coordinates);
    if (zoom) {
      view.setZoom(zoom);
    }
  }
};

_Viewer.prototype.goToRes = function(coordinates, options){
  var options = options || {};
  var animate = options.animate || true;
  var view = this.map.getView();
  var resolution = options.resolution || view.getResolution();
  
  if (animate) {
    var panAnimation = {
      duration: 300,
      center: coordinates
    };
    var zoomAnimation = {
      duration: 300,
      resolution: resolution
    };
    view.animate(panAnimation,zoomAnimation);
  } else {
    view.setCenter(coordinates);
    view.setResolution(resolution);
  }
};

_Viewer.prototype.fit = function(geometry, options){
  var view = this.map.getView();
  
  var options = options || {};
  var animate = options.animate || true;
  
  if (animate) {
    var panAnimation = view.animate({
      duration: 300,
      center: view.getCenter()
    });
    var zoomAnimation = view.animate({
      duration: 300,
      resolution: view.getResolution()
    });
    //this.map.getView().animate(panAnimation,zoomAnimation);
  }
  
  if (options.animate) {
    delete options.animate; // non lo passo al metodo di OL3 perché è un'opzione interna
  }
  options.constrainResolution = options.constrainResolution || true;
  
  view.fit(geometry,this.map.getSize(),options);
};

_Viewer.prototype.getZoom = function(){
  var view = this.map.getView();
  return view.getZoom();
};

_Viewer.prototype.getResolution = function(){
  var view = this.map.getView();
  return view.getResolution();
};

_Viewer.prototype.getCenter = function(){
  var view = this.map.getView();
  return view.getCenter();
};

_Viewer.prototype.getBBOX = function(){
  return this.map.getView().calculateExtent(this.map.getSize());
};

_Viewer.prototype.getLayerByName = function(layerName) {
  var layers = this.map.getLayers();
  var length = layers.getLength();
  for (var i = 0; i < length; i++) {
    if (layerName === layers.item(i).get('name')) {
      return layers.item(i);
    }
  }
  return null;
};

_Viewer.prototype.removeLayerByName = function(layerName){
  var layer = this.getLayerByName(layerName);
  if (layer){
    this.map.removeLayer(layer);
    delete layer;
  }
};

_Viewer.prototype.getActiveLayers = function(){
  var activelayers = [];
  this.map.getLayers().forEach(function(layer) {
    var props = layer.getProperties();
    if (props.basemap != true && props.visible){
       activelayers.push(layer);
    }
  });
  
  return activelayers;
};

_Viewer.prototype.removeLayers = function(){
  this.map.getLayers().clear();
};

_Viewer.prototype.getLayersNoBase = function(){
  var layers = [];
  this.map.getLayers().forEach(function(layer) {
    var props = layer.getProperties();
    if (props.basemap != true){
      layers.push(layer);
    }
  });
  
  return layers;
};

_Viewer.prototype.addBaseLayer = function(type){
  var layer;
  type ? layer = BaseLayers[type]:  layer = BaseLayers.BING.Aerial;
  this.map.addLayer(layer);
};

_Viewer.prototype.changeBaseLayer = function(layerName){
  var baseLayer = this.getLayerByName(layername);
  var layers = this.map.getLayers();
  layers.insertAt(0, baseLayer);
};

module.exports = MapHelpers;

},{"../layers/bases":100}],103:[function(require,module,exports){
var utils = {
  merge: function(obj1,obj2){
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }
}

module.exports = utils;

},{}],104:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var LayersStoresRegistry = require('core/layers/layersstoresregistry');

function CatalogService() {
  var self = this;
  this.state = {
    prstate: ProjectsRegistry.state,
    highlightlayers: false,
    externallayers:[],
    layerstrees: []
  };
  this.setters = {};
  this.addExternalLayer = function(layer) {
    this.state.externallayers.push(layer);
  };
  this.removeExternalLayer = function(name) {
    var self = this;
    _.forEach(this.state.externallayers, function(layer, index) {
      if (layer.name == name) {
        self.state.externallayers.splice(index, 1);
        return false
      }
    });
  };

  // funzione che verifica se il layerssore aggiunto è addatttao per essere aggiunto
  // al layerstrees del catalogo e quindi visibile come albero dei layer
  this.addLayersStoreToLayersTrees = function(layersStore) {
    this.state.layerstrees.push({
      tree: layersStore.getLayersTree(),
      storeid: layersStore.getId()
    });
  };

  base(this);
  // vado a popolare cosa c'è già
  var layersStores = LayersStoresRegistry.getLayersStores();
  _.forEach(layersStores, function(layersStore) {
    self.addLayersStoreToLayersTrees(layersStore);
  });

  // resto in ascolto di eventuali layersStore aggiunti
  LayersStoresRegistry.onafter('addLayersStore', function(layersStore) {
    self.addLayersStoreToLayersTrees(layersStore);
  });

  //registro l'eventuale rimozione del layersSore dal LayersRegistryStore
  LayersStoresRegistry.onafter('removeLayersStore', function(layersStore) {
    self.state.layerstrees.splice(self.state.layerstrees.indexOf(layersStore), 1);
  });
}

inherit(CatalogService, G3WObject);

module.exports = CatalogService;

},{"core/g3wobject":34,"core/layers/layersstoresregistry":45,"core/project/projectsregistry":69,"core/utils/utils":77}],105:[function(require,module,exports){
module.exports = "<!-- item template -->\n<div id=\"catalog\" @contextmenu.prevent.stop=\"\" class=\"tabbable-panel catalog\">\n  <!--<div class=\"title\">{{ title }}</div>-->\n  <div class=\"tabbable-line\">\n    <ul class=\"nav nav-tabs\" role=\"tablist\">\n      <li role=\"presentation\" class=\"active\" :style=\"{width: hasBaseLayers ? '32%' : '48%'}\"><a href=\"#tree\" aria-controls=\"tree\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"tree\">Data</a></li>\n      <li v-if=\"hasBaseLayers\" role=\"presentation\" style=\"width: 32%\"><a href=\"#baselayers\" aria-controls=\"baselayers\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"baselayers\">Layer Base</a></li>\n      <li role=\"presentation\" :style=\"{width: hasBaseLayers ? '32%' : '48%'}\"><a href=\"#legend\" aria-controls=\"legend\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"legend\">Legenda</a></li>\n    </ul>\n    <div  class=\"tab-content\">\n      <div role=\"tabpanel\" class=\"tab-pane active tree\" id=\"tree\">\n        <ul class=\"tree-root\" v-for=\"_layerstree in state.layerstrees\">\n          <tristate-tree  :highlightlayers=\"state.highlightlayers\" :layerstree=\"layerstree\" class=\"item\" v-for=\"layerstree in _layerstree.tree\" :storeid=\"_layerstree.storeid\" :key=\"layerstree.id\">\n          </tristate-tree>\n        </ul>\n        <!--<ul>\n          <tristate-tree  :externallayers=\"state.externallayers\" :layerstree=\"layerstree\" class=\"item\" v-for=\"layerstree in state.externallayers\" :key=\"layerstree.id\">\n          </tristate-tree>\n        </ul>-->\n      </div>\n      <div v-if=\"hasBaseLayers\" role=\"tabpanel\" class=\"tab-pane baselayers\" id=\"baselayers\">\n        <form>\n          <ul>\n            <li v-if=\"!baselayer.fixed\" v-for=\"baselayer in baselayers\">\n              <div class=\"radio\">\n                <label><input type=\"radio\" name=\"baselayer\" v-checked=\"baselayer.visible\" @click=\"setBaseLayer(baselayer.id)\">{{ baselayer.title }}</label>\n              </div>\n            </li>\n          </ul>\n        </form>\n      </div>\n      <layerslegend v-for=\"_layerstree in state.layerstrees\" :layerstree=\"_layerstree\"></layerslegend>\n    </div>\n  </div>\n  <ul id=\"layer-menu\" v-click-outside-layer-menu=\"closeLayerMenu\"  tabindex=\"-1\" v-if=\"layerMenu.show\"  :style=\"{top: layerMenu.top + 'px', left: layerMenu.left + 'px' }\">\n    <li @click.prevent.stop=\"zoomToLayer\"> Zoom to Layer</li>\n    <li @click.prevent.stop=\"\" v-if=\"layerMenu.layer.external\" @mouseleave.self=\"showColorMenu(false,$event)\" @mouseover.self=\"showColorMenu(true,$event)\"> Setta/Cambia Colore <i class=\"fa fa-chevron-right\" style=\"padding-left:10px;\" aria-hidden=\"true\"></i>\n      <ul v-if=\"layerMenu.colorMenu.show\" style=\"position:fixed\" :style=\"{ top: layerMenu.colorMenu.top + 'px', left: layerMenu.colorMenu.left +   'px' }\">\n        <li style=\"padding:0;\">\n          <chrome-picker @click.prevent.stop=\"\" v-model=\"layerMenu.colorMenu.color\" @change-color=\"onChangeColor\" style=\"width: 100%\"></chrome-picker>\n        </li>\n      </ul>\n    </li>\n  </ul>\n</div>\n";

},{}],106:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ComponentsRegistry = require('gui/componentsregistry');
var GUI = require('gui/gui');
var ControlsRegistry = require('gui/map/control/registry');
var LayersStoresRegistry = require('core/layers/layersstoresregistry');
var Service = require('../catalogservice');
var ChromeComponent = VueColor.Chrome;
var CatalogEventHub = new Vue();

var vueComponentOptions = {
  template: require('./catalog.html'),
  data: function() {
    return {
      state: null,
      //oggetto per la visualizzazione del contextmenu
      // tasto destro
      layerMenu: {
        show: false,
        top:0,
        left:0,
        name: '',
        layer: null,
        //oggetto colorMenu
        colorMenu: {
          show: false,
          top:0,
          left: 0,
          color: null
        }
      }

    }
  },
  directives: {
    //creo la direttiva per il click fuori dal contextmenu
    'click-outside-layer-menu': {
      bind: function (el, binding, vnode) {
        this.event = function (event) {
          if(!(el == event.target || el.contains(event.target))) {
            vnode.context[binding.expression](event);
          }
        };
        //aggiungo event listener click
        document.body.addEventListener('click', this.event)
      },
      unbind: function (el) {
        document.body.removeEventListener('click', this.event)
      }
    }
  },
  components: {
    'chrome-picker': ChromeComponent
  },
  computed: {
    project: function() {
      return this.state.prstate.currentProject
    },
    title: function() {
      return this.project.state.name;
    },
    baselayers: function(){
      return this.project.state.baselayers;
    },
    hasBaseLayers: function(){
      return this.project.state.baselayers.length>0;
    }
  },
  methods: {
    setBaseLayer: function(id) {
      this.project.setBaseLayer(id);
    },
    zoomToLayer: function() {
      var bbox;
      if (this.layerMenu.layer.bbox) {
        bbox = [this.layerMenu.layer.bbox.minx, this.layerMenu.layer.bbox.miny, this.layerMenu.layer.bbox.maxx, this.layerMenu.layer.bbox.maxy] ;
      }
      var mapService = GUI.getComponent('map').getService();
      mapService.goToBBox(bbox);
      this.layerMenu.show = false;
    },
    closeLayerMenu: function() {
      this.layerMenu.show = false;
      this.showColorMenu(false);
    },
    onChangeColor: function(val) {
      var mapService = GUI.getComponent('map').getService();
      this.layerMenu.colorMenu.color = val;
      var layer = mapService.getLayerByName(this.layerMenu.name);
      layer.setStyle(mapService.setExternalLayerColor(val));
    },
    showColorMenu: function(bool, evt) {
      if(bool) {
        var elem = $(evt.target);
        this.layerMenu.colorMenu.top = elem.offset().top;
        this.layerMenu.colorMenu.left = elem.offset().left + elem.width() + ((elem.outerWidth() - elem.width()) /2);
      }
      this.layerMenu.colorMenu.show = bool;
    }
  },
  mounted: function() {
    var self = this;
    CatalogEventHub.$on('treenodetoogled',function(storeid, node) {
      if (node.external) {
        var mapService = GUI.getComponent('map').getService();
        var layer;
        layer = mapService.getLayerByName(node.name);
        layer.setVisible(!layer.getVisible());
        node.visible = !node.visible;
      } else {
        LayersStoresRegistry.getLayersStore(storeid).toggleLayer(node.id);
      }
    });

    CatalogEventHub.$on('treenodestoogled',function(storeid, nodes,parentChecked) {
      var layersIds = [];
      function checkNodes(obj) {
        if (obj.nodes) {
          _.forEach(obj.nodes, function(node) {
            checkNodes(node);
          });
        } else {
          layersIds.push(obj.id);
        }
      }
      _.map(nodes,checkNodes);
      LayersStoresRegistry.getLayersStore(storeid).toggleLayers(layersIds, parentChecked);
    });

    CatalogEventHub.$on('treenodeselected',function(storeid,node) {
      var mapservice = GUI.getComponent('map').getService();
      var layer = LayersStoresRegistry.getLayersStore(storeid).getLayerById(node.id);
      if (!layer.isSelected()) {
        LayersStoresRegistry.getLayersStore(storeid).selectLayer(node.id);
        // emetto il segnale layer selezionato dal catalogo
        mapservice.emit('cataloglayerselected', layer);
      } else {
        LayersStoresRegistry.getLayersStore(storeid).unselectLayer(node.id);
        mapservice.emit('cataloglayerunselected', layer);
      }
    });

    CatalogEventHub.$on('showmenulayer', function(layerstree, evt) {
      self.layerMenu.top = evt.y;
      self.layerMenu.left = evt.x;
      self.layerMenu.name = layerstree.name;
      self.layerMenu.layer = layerstree;
      self.layerMenu.show = true;
      self.layerMenu.colorMenu.color = layerstree.color;
    });

    ControlsRegistry.onafter('registerControl', function(id, control) {
      if (id == 'querybbox') {
        control.getInteraction().on('propertychange', function(evt) {
          if (evt.key == 'active') {
            self.state.highlightlayers=!evt.oldValue;
          }
        })
      }
    });
    $('input:file').filestyle({
      buttonText: "",
      input: false,
      buttonName: "btn-primary",
      iconName: "glyphicon glyphicon-plus"
    });
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);

// se lo voglio usare come componente come elemento html
Vue.component('g3w-catalog', vueComponentOptions);


/* COMPONENTI FIGLI */

// tree component


Vue.component('tristate-tree', {
  template: require('./tristate-tree.html'),
  props: {
    layerstree: {},
    storeid: null,
    //eredito il numero di childs dal parent
    checked: false,
    //highlightlayers: false,
    parentFolder: false,
    externallayers: null
  },
  data: function () {
    return {
      expanded: this.layerstree.expanded,
      parentChecked: !this.checked,
      controltoggled: false,
      n_childs: null
    }
  },
  watch: {
    'checked': function(val) {
      this.layerstree.visible = val;
    }
  },
  computed: {
    isFolder: function () {
      var _visibleChilds = 0;
      var _childsLength = 0;
      (function countLayersVisible(layerstree) {
        _.forEach(layerstree.nodes, function(layer) {
          if (!layer.nodes) _childsLength+=1;
          if (layer.visible) {
            _visibleChilds += 1;
          } else if (layer.nodes) {
            countLayersVisible(layer);
          }
        });
      })(this.layerstree);
      // lo metto qui n_childs perchè nel caso del reload ltiene quello precedente
      this.n_childs = _childsLength;//this.layerstree.nodes ? this.layerstree.nodes.length : 0;
      var isFolder = this.n_childs ? true : false;
      if (isFolder) {
        this.n_parentChilds = this.n_childs - _visibleChilds;
      } 
      return isFolder
    },
    isHidden: function() {
      return this.layerstree.hidden && (this.layerstree.hidden === true);
    },
    selected: function() {
      var isSelected = this.layerstree.selected ? "SI" : "NO";
      return isSelected;
    },
    isHighLight: function() {
      if (this.layerstree.id) {
        // da sostituire con una proprietà precalcolata nello state del layer
        //this.layer = LayersStoresRegistry.getLayersStore().getLayerById(this.layerstree.id);
        //return this.highlightlayers && layer.isWFS() && layer.getProject() && layer.getProject().getProjection() == layer.getProjection();
        //
      }
      return false;
    }

  },
  methods: {
    toggle: function (checkAllLayers) {
      var checkAll = checkAllLayers == 'true' ? true : false;
      if (this.isFolder && !checkAll) {
        this.layerstree.expanded = !this.layerstree.expanded;

      }
      else if (checkAll) {
        if (this.parentChecked && !this.n_parentChilds){
          this.parentChecked = false;
        } else if (this.parentChecked && this.n_parentChilds) {
          this.parentChecked = true;
        }
        else {
          this.parentChecked = !this.parentChecked;
        }
        CatalogEventHub.$emit('treenodestoogled',this.storeid, this.layerstree.nodes, this.parentChecked);
      }
      else {
        CatalogEventHub.$emit('treenodetoogled',this.storeid,this.layerstree);
      }
    },
    select: function () {
      if (!this.isFolder && !this.layerstree.external) {
        CatalogEventHub.$emit('treenodeselected',this.storeid,this.layerstree);
      }
    },
    triClass: function () {
      if (!this.n_parentChilds) {
        return 'fa-check-square-o';
      } else if ((this.n_parentChilds > 0) && (this.n_parentChilds < this.n_childs)) {
        return 'fa-square';
      } else {
        return 'fa-square-o';
      }
    },
    removeExternalLayer: function(name) {
      var mapService = GUI.getComponent('map').getService();
      var layer = mapService.getLayerByName(name);
      mapService.removeExternalLayer(name);
    },
    showLayerMenu: function(layerstree, evt) {
      if (!this.isFolder) {
        CatalogEventHub.$emit('showmenulayer', storeid, layerstree, evt);
      }
    }
  }
});

Vue.component('layerslegend',{
    template: require('./legend.html'),
    props: ['layerstree'],
    data: function() {
      return {
        //data qui
      }
    },
    computed: {
      visiblelayers: function(){
        var _visiblelayers = [];
        var layerstree = this.layerstree.tree;
        function traverse(obj){
        _.forIn(obj, function (layer, key) {
              //verifica che il valore dell'id non sia nullo
              if (!_.isNil(layer.id) && layer.visible) {
                  _visiblelayers.push(layer);
              }
              if (!_.isNil(layer.nodes)) {
                  traverse(layer.nodes);
              }
          });
        }
        traverse(layerstree);
        return _visiblelayers;
      }
    },
    watch: {
      'layerstree': {
        handler: function(val, old){
          //codice qui
        },
        deep: true
      }
    },
    mounted: function() {
      Vue.nextTick(function() {
        $('.legend-item').perfectScrollbar();
      });
    }
});

Vue.component('layerslegend-item',{
  template: require('./legend_item.html'),
  props: ['layer'],
  computed: {
    legendurl: function(){
      var self = this;
      var _legendurl;
      _.forEach(LayersStoresRegistry.getLayersStores(), function(layerStore) {
        if (layerStore.getLayerById(self.layer.id)){
          _legendurl = layerStore.getLayerById(self.layer.id).getLegendUrl();
          return false
        }
      });
      return _legendurl;
    }
  },
  methods: {
    updateLegendScroll: function(evt) {
      $(evt.target).perfectScrollbar('update');
    }
  }
});

/* FINE COMPONENTI FIGLI */

/* INTERFACCIA PUBBLICA */
function CatalogComponent(options) {
  base(this);
  var self = this;
  this.id = "catalog-component";
  this.title = "catalog";
  this.mapComponentId = options.mapcomponentid;
  var service = options.service || new Service;
  this.setService(service);
  this.setInternalComponent(new InternalComponent({
    service: service
  }));
  this.internalComponent.state = this.getService().state;
  function listenToMapVisibility(map) {
    var mapService = map.getService();
    self.state.visible = !mapService.state.hidden;
    mapService.onafter('setHidden',function(hidden) {
      self.state.visible = !mapService.state.hidden;
      self.state.expanded = true;
    })
  }
  if (this.mapComponentId) {
    var map = GUI.getComponent(this.mapComponentId);
    if (!map) {
      ComponentsRegistry.on('componentregistered',function(component){
        if (component.getId() == self.mapComponentId) {
          listenToMapVisibility(component);
        }
      })
    }
    else {
      listenToMapVisibility(map)
    }
  }
  //mergio opzioni con proprità di default del componente
  merge(this, options);
}

inherit(CatalogComponent, Component);

module.exports = CatalogComponent;

},{"../catalogservice":104,"./catalog.html":105,"./legend.html":107,"./legend_item.html":108,"./tristate-tree.html":109,"core/layers/layersstoresregistry":45,"core/utils/utils":77,"gui/componentsregistry":111,"gui/gui":118,"gui/map/control/registry":122,"gui/vue/component":156}],107:[function(require,module,exports){
module.exports = "<div role=\"tabpanel\" class=\"tab-pane\" id=\"legend\">\n  <layerslegend-item :layer=\"layer\" v-for=\"layer in visiblelayers\" :key=\"layer.id\"></layerslegend-item>\n</div>\n";

},{}],108:[function(require,module,exports){
module.exports = "  <div class=\"legend-item\" @mouseenter=\"updateLegendScroll($event)\">\n    <img :src=\"legendurl\">\n    <span class=\"divider\"></span>\n  </div>\n";

},{}],109:[function(require,module,exports){
module.exports = "<li class=\"tree-item\" @contextmenu.prevent.stop=\"showLayerMenu(layerstree, $event)\" @click=\"select()\" :class=\"{selected: !isFolder ? layerstree.selected : false, itemmarginbottom: !isFolder }\">\n  <span :class=\"{bold: isFolder, 'fa-chevron-down': layerstree.expanded, 'fa-chevron-right': !layerstree.expanded}\" @click=\"toggle\" v-if=\"isFolder\" class=\"root fa\"></span>\n  <span v-if=\"isFolder\" @click.stop=\"toggle('true')\" :class=\"[triClass()]\" class=\"fa\"></span>\n  <span v-show=\"!layerstree.hidden\" v-else @click.stop=\"toggle\" :class=\"[layerstree.visible  ? 'fa-check-square-o': 'fa-square-o',layerstree.disabled  ? 'disabled': '',  parentFolder ? 'child' : 'root' ]\" class=\"fa checkbox-layer\"></span>\n  <span v-show=\"!layerstree.hidden || isFolder\" class=\"tree-node-title\" :class=\"{bold: isFolder, disabled: layerstree.disabled, highlightlayer: isHighLight }\">{{ layerstree.title }}</span><i v-if=\"layerstree.external\" class=\"glyphicon glyphicon glyphicon-trash link trash pull-right\" @click=\"removeExternalLayer(layerstree.name)\"></i>\n  <ul v-show=\"layerstree.expanded\" v-if=\"isFolder\">\n    <tristate-tree :parentFolder=\"isFolder\" :n_parent-childs=\"n_parentChilds\" :layerstree=\"layerstree\" :storeid=\"storeid\" v-for=\"layerstree in layerstree.nodes\" :key=\"layerstree.id\">\n    </tristate-tree>\n  </ul>\n</li>";

},{}],110:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var merge = require('core/utils/utils').merge;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var VUECOMPONENTSATTRIBUTES = ['methods', 'computed', 'data', 'components'];

var Component = function(options) {

  options = options || {};
  this.internalComponent = null;
  this.id = options.id || Math.random() * 1000;
  this.title = options.title || '';
  this.state = {
    visible: options.visible || true,
    open: options.open || false
  };
  //setters
  this.setters = {
    setOpen: function(bool) {
      this.state.open = bool;
      this._setOpen();
    },
    setVisible: function(bool) {
      this.state.visible = bool;
      this._setVisible();
    },
    reload: function() {
      this._reload();
    }
  };
  base(this);
};

inherit(Component, G3WObject);

var proto = Component.prototype;

// restituisce id del componente
proto.getId = function() {
  return this.id;
};

// setta id del component
proto.setId = function(id) {
  this.id = id;
};

proto.getOpen = function() {
  return this.state.open;
};

proto.getVisible = function() {
  return this.state.visible;
};

// restituice il titolo del componente
proto.getTitle = function() {
  return this.state.title;
};

//setta il titolo del componente
proto.setTitle = function(title) {
  this.state.title = title;
};

//implementati due metodi per poter unificare il metodo di recupero del servizio
//legato al componente
// resituisce il service del componente
proto.getService = function() {
  return this._service;
};

// setta il service del componente
proto.setService = function(service) {
  this._service = service;
};

// restituisce il componente vue interno
proto.getInternalComponent = function() {
  return this.internalComponent;
};

// setta il nuovo internalcomponent
proto.setInternalComponent = function(internalComponent) {
  if (!internalComponent && this.internalComponentClass) {
    this.internalComponent = new this.internalComponentClass;
  }
  else {
    // internal component è un'istanza e non una classe
    this.internalComponent = internalComponent;
  }
};

proto.createVueComponent = function (vueObjOptions) {
  return _.cloneDeep(vueObjOptions);
};

// aggiunge dati all'internalComponent
proto.addInternalComponentData = function(data) {
  _.merge(this.internalComponent, data)
};

// sovrascrive il metodo del service originale con uno nuovo
proto.overwriteServiceMethod = function(methodName, method) {
  this._service[methodName] = method;
};

// sovrascrive i metodi che hanno chiave uguale a quelli presenti nel servizio
proto.overwriteServiceMethods = function(methodsOptions) {
  var self = this;
  _.forEach(methodsOptions, function(method, methodName) {
    self.overwriteServiceMethod(methodName, method);
  })
};

// estendo il servizio con nuovi metodi
proto.extendService = function(serviceOptions) {
  if (this._service) {
    merge(this._service, serviceOptions);
  }
};

// estende in modo generico il vue component
proto.extendInternalComponent = function(internalComponentOptions) {
  var self = this;
  if (this.vueComponent) {
    // faccio il clone altrimenti ho problem con i components
    _.forEach(internalComponentOptions, function(value, key) {
      if (VUECOMPONENTSATTRIBUTES.indexOf(key) > -1) {
        switch (key) {
          case 'methods':
            self.extendInternalComponentMethods(value);
            break;
          case 'components':
            self.extendInternalComponentComponents(value);
            break;
          default:
            merge(self.vueComponent[key], value);
        }
      }
    });
  } else {
    this.vueComponent = internalComponentOptions;
  }
};

//funzione che estende l'attributo components dell'oggetto vue Component
proto.extendInternalComponentComponents = function(components) {
  if (components) {
    merge(this.vueComponent.components, components);
  }
};

// estende i methods il vue component
proto.extendInternalComponentMethods = function(methods) {
  if (methods) {
    // ciclo sulle chiavi dell'oggetto per verificare che sia una funzione
    _.forEach(methods, function (value, key) {
      if (!(value instanceof Function)){
        delete methods[key];
      }
    });
    merge(this.vueComponent.methods, methods);
  }
};

// estende i computed del vue component
proto.extendInternalComponentComputed = function(computed) {
  if (computed) {
    // ciclo sulle chiavi dell'oggetto per verificare che sia una funzione
    _.forEach(computed, function (value, key) {
      if (!(value instanceof Function)){
        delete computed[key];
      }
    });
    merge(this.vueComponent.computed, computed);
  }
};

//setto il template del componente vue
proto.setInternalComponentTemplate = function(template) {
  // dovrò poi aggiungere regole per verificare se il
  // tenplate è compatibile ad un template o no
  if (template) {
    this.vueComponent.template = template;
  }
};

proto.getInternalTemplate = function() {
  return this.vueComponent.template;
};

////////// fine metodi Service Components //////////
/* HOOKS */
/* 
 * Il metodo permette al componente di montarsi nel DOM
 * parentEl: elemento DOM padre, su cui inserirsi; 
 * ritorna una promise, risolta nel momento in cui sarà terminato il montaggio
*/
proto.mount = function(parent) {};

/*
 * Metodo richiamato quando si vuole rimuovere il componente.
 * Ritorna una promessa che sarà risolta nel momento in cui il componente avrà completato la propria rimozione (ed eventuale rilascio di risorse dipendenti)
*/
proto.unmount = function() {};

proto.ismount = function() {
  return true;
};

// se si vuole usare il componete lo deve ridefinire
proto._setOpen = function() {
};


// se si vuole usare il componete lo deve ridefinire
proto._setVisible = function() {};


//funzione che dovrà essere sovrascritta dai singoli componenti
proto._reload = function() {

};

/*
 * Metodo (opzionale) che offre l'opportunità di ricalcolare proprietà dipendenti dalle dimensioni del padre
 * parentHeight: nuova altezza del parent
 * parentWidth: nuova larghezza del parent
 * richiamato ogni volta che il parent subisce un ridimensionamento
*/
proto.layout = function(parentWidth, parentHeight) {};


module.exports = Component;

},{"core/g3wobject":34,"core/utils/utils":77}],111:[function(require,module,exports){
var G3WObject = require('core/g3wobject');
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;

//classe Componet Registry (singleton)
// ha lo scopo di salvare tutti i componenti aggiunti
function ComponentsRegistry() {
  // attributo componets che tiene traccia
  // dei componenti registrati
  this.components = {};
  // funzione per refgistrare il componente
  this.registerComponent = function(component) {
    // recupera l'id del componente
    var id = component.getId();
    // se non è stato precedentemente registrato
    if (!this.components[id]) {
      this.components[id] = component;
      this.emit('componentregistered', component);
    }
  }; 
  //funzione che retituisce il componente in base all'id
  this.getComponent = function(id) {
    return this.components[id];
  };

  this.getComponents = function() {
    return this.components;
  };

  // toglie dal registro dei componenti il componete che si vuole eliminare
  this.unregisterComponent = function(id) {
    var component = this._components[id];
    // verifica che sia presente il componete con l'id passato
    if (component) {
      //verifico che estista la funzione destroy dell'oggetto componente
      if (_.isFunction(component.destroy)) {
        // nel caso lo ditruggo (togliendolo anche visivamente)
        component.destroy();
      }
      //elimino il componente e lo setto a null per evitare
      // che se in un secondo momento lo registro di nuovo
      // questa venga ignorato
      delete component;
      this._components[id] = null;
    }
  };
  base(this);
}
inherit(ComponentsRegistry,G3WObject);

module.exports = new ComponentsRegistry;

},{"core/g3wobject":34,"core/utils/utils":77}],112:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var VectorLoaderLayer = require('core/map/layer/loader/vectorloaderlayer');
var FormClass = require('gui/form/vue/form');

function EditingService(options) {
  var options = options || {};
  var self = this;
  //qui vado  a settare il mapservice
  this._mapService = options.mapService || GUI.getComponent('map').getService();
  //definisco i codici layer
  this._layerCodes = options.layerCodes || {};
  // classi editor
  this._editorClass = options.editorClass || {};
  //definisco layer del plugin come oggetto
  this._layers = options.layers || {};
  //definisco il loader del plugin
  this._loader = options.loader || new VectorLoaderLayer;
  var editingConstraints = options.editingConstraints || {
    resolution: 1 // vincolo di risoluzione massima
  };
  this._editingApiField = options.editingApiField || 'name';
  this._formClass = options.formClass || FormClass;
  //messaggi per gli steps del tool
  this._toolStepsMessages = options.toolStepsMessages || {};
  this._loadDataOnMapViewChangeListener = null;
  this._currentEditingLayer = null;
  this.state = {
    editing: {
      on: false,
      enabled: false,
      layerCode: null,
      toolType: null,
      startingEditingTool: false,
      toolstep: {
        n: null,
        total: null,
        message: null
      },
      error: false
    },
    retrievingData: false,
    hasEdits: false
  };
  this.init = function(config) {
    var self = this;
    this.config = config;
    //inizializzo il loader
    // passandogli:
    // 1 - layers del plugin (style etc..)
    // 2 - la baseurl che mi server per interagire con il server per fare tutte le modifiche
    var options_loader = {
      'layers': this._layers,
      'baseurl': this.config.baseurl,
      'mapService': this._mapService,
      'editingApiField': this._editingApiField
    };
    //inizializzo il loader
    this._loader.init(options_loader);
    //caso di loading data
    this._loader.on('loadingvectorlayersstart', function() {
      self.state.retrievingData = true;
    });
    this._loader.on('loadingvectorlayersend', function() {
      self.state.retrievingData = false;
    });
    //in caso di errore
    this._loader.on('errorloadingvectorlayersend', function() {
      self.state.retrievingData = false;
      self.state.editing.error = true;
    });
    // disabilito l'eventuale tool attivo se viene attivata
    // un'interazione di tipo pointerInteractionSet sulla mappa
    this._mapService.on('pointerInteractionSet', function(interaction) {
      var currentEditingLayer = self._getCurrentEditingLayer();
      if (currentEditingLayer) {
        var activeTool = currentEditingLayer.editor.getActiveTool().instance;
        // devo verificare che non sia un'interazione attivata da uno dei tool di editing del plugin
        if (activeTool && !activeTool.ownsInteraction(interaction)) {
          self._stopEditingTool();
        }
      }
    });
    //  abilito o meno l'editing in base alla risoluzione della mappa
    this._mapService.onafter('setMapView',function(bbox, resolution) {
      self.state.editing.enabled = (resolution < editingConstraints.resolution) ? true : false;
    });
    // attributo dello stato del srevizio che mi permette di accendere o spengere l'editing
    // serve anche per poter in fase di toggleEditing(bottone di avvio editing) di vedere se posso inziare o meno
    // caricare i vettoriali etc..
    this.state.editing.enabled = (this._mapService.getResolution() < editingConstraints.resolution) ? true : false;
    // per ogni layer definiti nel plugin setto name e id
    // recuperati grazie al mapservice
    _.forEach(this._layers, function(Layer, layerCode) {
      //recupero l'id dalla configurazione del plugin
      // i layers nella configurazione passata i layers hanno due attributi: id e name
      var layerId = config.layers[layerCode].id;
      // recupera il layer dal mapservice
      var layer = self._mapService.layersstore.getLayerById(layerId);
      // recupero l'origin name dal projectlayer
      Layer.name = layer.getOrigName();
      Layer.id = layerId;
    });
  };
  // fine del metodo INIT
  // metodi GETTERS and SETTERS
  //LOADER
  this.setLoader = function(loader) {
    this._loader = loader;
  };

  //get loader service
  this.getLoader = function() {
    return this._loader;
  };

  //LAYERS
  this.setLayers = function(layers) {
    this._layers = layers;
  };

  this.getLayers = function(layers) {
    return this._layers;
  };

  // layer By layerCode
  this.getLayer = function(layerCode) {
    return this._layers[layerCode];
  };

  // LAYERS CODE
  this.setLayersCode = function(layerCodes) {
    this._layerCodes = layerCodes;
  };

  this.getLayerCodes = function() {
    return this._layerCodes;
  };

  // FORM CLASS
  this.setFormClass = function(formClass) {
    this._formClass = formClass;
  };

  this.getFormClass = function() {
    return this._formClass;
  };
  // FINE METODI GETTERS SETTERS

  //stop
  this.stop = function() {
    var deferred = $.Deferred();
    if (this.state.editing.on) {
      this._cancelOrSave()
      .then(function() {
        self._stopEditing();
        deferred.resolve();
      })
      .fail(function(){
        deferred.reject();
      })
      .always(function() {
        GUI.closeForm();
      })
    } else {
      deferred.resolve();
    }
    return deferred.promise();
  };

  // avvio o termino la sessione di editing generale
  // unto di partenza dell'avvio dell'editing
  this.toggleEditing = function() {
    // creo oggetto deferred per restituire una promise
    var deferred = $.Deferred();
    // qui dice che se nel caso la risoluzione della mappa va bene (state.editing.enabled)
    // e non è ancora stato attivato l'editing
    // quindi caso prima volta
    if (this.state.editing.enabled && !this.state.editing.on) {
      // faccio partire editing
      this._startEditing();
    }
    // altrimenti se è già in editing chiamo lo stop del plugin
    // che non è altro che lo stop dell'editing
    else if (this.state.editing.on) {
      return this.stop();
    }
    // restituisco una promessa
    return deferred.promise();
  };

  this.saveEdits = function(){
    this._cancelOrSave(2);
  };

  // avvia uno dei tool di editing tra quelli supportati da Editor (addfeature, ecc.)
  // funzione dell'elemento panel vue
  this.toggleEditTool = function(layerCode, toolType) {
    var self = this;
    //prendo il layer in base al codice passato dall componente vue
    var layer = this._layers[layerCode];
    if (layer) {
      //recuprero il current layer in editing
      var currentEditingLayer = this._getCurrentEditingLayer();
      // se si sta usando un tool che prevede lo stesso layer in editazione
      if (currentEditingLayer && layerCode == currentEditingLayer.layerCode) {
        // e lo stesso tool allora disattivo il tool (in quanto è
        // premuto sullo stesso bottone)
        if (toolType == currentEditingLayer.editor.getActiveTool().getType()) {
          // stesso tipo di tool quindi si è verificato un toggle nel bottone
          // allora stippo l'editing Tool
          this._stopEditingTool();
        }
        // altrimenti attivo il tool richiesto
        else {
          //stoppo preventivamente l'editing tool attivo
          this._stopEditingTool();
          //faccio partire l'editng tool passando current Editing Layer e il tipo di tool
          this._startEditingTool(currentEditingLayer, toolType);
        }
      } else {
        // altrimenti caso in cui non è stato settato il current editing layer o
        // il layer che si sta cercando di editare è diverso da quello in editing in precedenza
        // nel caso sia già  attivo un editor verifico di poterlo stoppare
        if (currentEditingLayer && currentEditingLayer.editor.isStarted()) {
          // se la terminazione dell'editing sarà  andata a buon fine, setto il tool
          // provo a stoppare
          this._cancelOrSave(2)
          .then(function(){
            if (self._stopEditor()) {
              self._startEditingTool(layer, toolType);
            }
          })
        } else {
          //nel caso sia la prima volta che interagisco con un tool
          // e quindi non è stato settato nessun layer in editing
          this._startEditingTool(layer, toolType);
        }
      }
    }
  };

  /* METODI PRIVATI */
  // funzione per settare il vectorlayer alla prorietà vector del layer
  this._setUpVectorLayer = function(layerCode, vectorLayer) {
    this._layers[layerCode].vector = vectorLayer;
  };

  //funzione che permette di fare il setup dell'editor e asseganrlo al layer
  this._setUpEditor = function(layerCode) {
    var self = this;
    //option editor
    var options_editor = {
      'mapService': self._mapService,
      'formClass': this._formClass
    };
    // prendo il vector layer del layer
    var vectorLayer = this._layers[layerCode].vector;
    //GESTIONE E INIZIALIZZAZIONE DELL'EDITOR RELATIVO AL LAYER VETTORIALE
    //creo l'istanza dell'editor che gestirà il layer
    var editor = new self._editorClass[layerCode](options_editor);
    //setto il layer vettoriale associato all'editor
    // e i tipi di tools associati ad esso
    editor.setVectorLayer(vectorLayer);
    //emette evento che è stata generata una modifica la layer
    editor.on("dirty", function (dirty) {
      self.state.hasEdits = dirty;
    });
    //assegno l'istanza editor al layer tramite la proprietà editor
    this._layers[layerCode].editor = editor;
    //// FINE GESTIONE EDITOR
  };

  //fa partire l'editing
  this._startEditing = function() {
    // mi assicuro che se per qualsisi motivo
    // faccio uno starediting di un editing già avviato
    // ritorno perchè ho già tutto (lo faccio per sicurennza non si sa mai)
    if (this.state.editing.on || this.state.retrievingData) {
      return;
    }
    var self = this;
    var layer;

    // vado a ciclare sui layer e faccio lo start editing
    _.forEach(this._layers, function(value, layerId) {
      layer = self._mapService.getLayersStore().getLayerById(layerId);
      // var provider_options = {
      //   'baseurl': self.config.baseurl,
      //   'mapService': self._mapService,
      //   'editingApiField': self._editingApiField
      // };
      layer.startEditing();
    });
    // chiedo al loader di caricare i dati
    this._loader.loadLayers('w') // carico i layer in modalità editing (scrittura)
    .then(function(vectorLayersLoaded) {
      //una volta che il loader ha finito di caricare i layer vettoriali
      //questo mi restituisce i codice dei layer che sono stati caricati(array)
      _.forEach(vectorLayersLoaded, function(layerCode) {
        // per ogni layer faccio il setup dell'editor
        self._setUpEditor(layerCode);
      });
      // se tutto  è andato a buon fine aggiungo i VectorLayer alla mappa
      self._addToMap();
      self.state.editing.on = true;
      self.emit("editingstarted");
      if (!self._loadDataOnMapViewChangeListener) {
        //viene ritornata la listener key
        self._loadDataOnMapViewChangeListener = self._mapService.onafter('setMapView', function() {
          if (self.state.editing.on && self.state.editing.enabled) {
            self._loader.loadAllVectorsData();
          }
        });
      }
    })
    .fail(function() {
      // errore nel server
      self.state.editing.error = true;
      GUI.notify.error(t('could_not_load_vector_layers'));
    })
  };

  this._stopEditing = function(reset){
    // se posso stoppare tutti gli editor...
    if (this._stopEditor(reset)){
      _.forEach(this._layers, function(layer, layerCode){
        var vector = layer.vector;
        self._mapService.viewer.removeLayerByName(vector.name);
        layer.vector = null;
        layer.editor.destroy();
        layer.editor = null;
        self._unlockLayer(self._layers[layerCode]);
      });
      this._updateEditingState();
      self.state.editing.on = false;
      self._cleanUp();
      self.emit("editingstopped");
    }
  };

  this._cleanUp = function() {
    //vado ad annulare l'estenzione del loader per poter ricaricare i dati vetttoriali
    //da rivedere;
    this._loader.cleanUpLayers();
  };

  //se non è ancora partito faccio partire lo start editor
  this._startEditor = function(layer) {
    // avvio l'editor
    // passandoli il service che lo accetta
    if (layer.editor.start(this)) {
      // registro il current layer in editing
      this._setCurrentEditingLayer(layer);
      return true;
    }
    return false;
  };

  //funzione che viene chiamata al click su un tool dell'editing e se
  //non è stato assegnato ancora nessun layer come current layer editing
  this._startEditingTool = function(layer, toolType, options) {
    //assegno true allo startEditingTool attributo delllo state
    this.state.startingEditingTool = true;
    var canStartTool = true;
    //verifico se l'editor è partito o meno
    if (!layer.editor.isStarted()) {
      //se non è ancora partito lo faccio partire e ne prendo il risultato
      // true o false
      canStartTool = this._startEditor(layer);
    }
    // verifica se il tool può essere attivato
    // l'editor verifica se il tool richiesto è compatibile
    // con i tools previsti dall'editor. Crea istanza di tool e avvia il tool
    // attraverso il metodo run
    if (canStartTool && layer.editor.setTool(toolType, options)) {
      this._updateEditingState();
      this.state.startingEditingTool = false;
      return true;
    }
    this.state.startingEditingTool = false;
    return false;
  };

  // funzione che lancia lo stop sull'editor corrente
  this._stopEditor = function(reset) {
    var ret = true;
    var layer = this._getCurrentEditingLayer();
    if (layer) {
      ret = layer.editor.stop(reset);
      if (ret){
        this._setCurrentEditingLayer();
      }
    }
    return ret;
  };

  // funzione che si occupa di interromepere l'edting tool
  this._stopEditingTool = function() {
    var ret = true;
    // recupere il layer in current editing
    var layer = this._getCurrentEditingLayer();
    // se esiste ed era stato settato
    if (layer) {
      // se andato bene ritorna true
      ret = layer.editor.stopTool();
      if (ret) {
        this._updateEditingState();
      }
    }
    return ret;
  };

  // funzione che accetta come parametro il tipo di
  // operazione da fare a seconda dicosa è avvenuto
  this._cancelOrSave = function(type){
    var deferred = $.Deferred();
    // per sicurezza tengo tutto dentro un grosso try/catch,
    // per non rischiare di provocare inconsistenze nei dati durante il salvataggio
    try {
      var _askType = 1;
      if (type) {
        _askType = type
      }
      var self = this;
      var dirtyEditors = {};
      // verifico per ogni layer se l'edito associato è Dirty
      _.forEach(this._layers, function(layer, layerCode) {
        if (layer.editor.isDirty()) {
          dirtyEditors[layerCode] = layer.editor;
        }
      });
      // verifico se ci sono o meno editor sporchi
      if(_.keys(dirtyEditors).length) {
        this._askCancelOrSave(_askType)
        .then(function(action) {// ritorna il tipo di azione da fare
          // save, cancel, nosave
          if (action === 'save') {
            // passo gli editor spochi alla funzione _saveEdits
            self._saveEdits(dirtyEditors)
            .then(function(result){
               deferred.resolve();
             }).fail(function(result){
               deferred.reject();
             })
          } else if (action == 'nosave') {
            deferred.resolve();
          } else if (action == 'cancel') {
            deferred.reject();
          }
        })
      } else {
        deferred.resolve();
      }
    }
    catch (e) {
      deferred.reject();
    }
    return deferred.promise();
  };

    // funzione che in base al tipo di askType
    // visualizza il modale a cui rispondere, salva etc ..
  this._askCancelOrSave = function(type){
    var deferred = $.Deferred();
    var buttonTypes = {
      SAVE: {
        label: "Salva",
        className: "btn-success",
        callback: function(){
          deferred.resolve('save');
        }
      },
      NOSAVE: {
        label: "Termina senza salvare",
        className: "btn-danger",
        callback: function(){
          deferred.resolve('nosave');
        }
      },
      CANCEL: {
        label: "Annulla",
        className: "btn-primary",
        callback: function(){
          deferred.resolve('cancel');
        }
      }
    };
    switch (type){
      case 1:
        buttons = {
          save: buttonTypes.SAVE,
          nosave: buttonTypes.NOSAVE,
          cancel: buttonTypes.CANCEL
        };
        break;
      case 2:
        buttons = {
          save: buttonTypes.SAVE,
          cancel: buttonTypes.CANCEL
        };
        break;
    }
    GUI.dialog.dialog({
      message: "Vuoi salvare definitivamente le modifiche?",
      title: "Salvataggio modifica",
      buttons: buttons
    });
    return deferred.promise();
  };

  // funzione che salva i dati relativi al layer vettoriale
  // del dirtyEditor
  this._saveEdits = function(dirtyEditors) {
    var error_message;
    var deferred = $.Deferred();
    function traverseErrorMessage(obj) {
      _.forIn(obj, function (val, key) {
        if (_.isArray(val)) {
          error_message = val[0];
        }
        if (_.isObject(val)) {
          traverseErrorMessage(obj[key]);
        }
        if (error_message) {
          return false;
        }
      });
    }
    this._sendEdits(dirtyEditors)
    .then(function(response) {
      GUI.notify.success("I dati sono stati salvati correttamente");
      self._commitEdits(dirtyEditors, response);
      //funzione che fa il referesh dei wms layer così da essere allineati con
      // il layer vettoriale
      self._mapService.refreshMap();
      deferred.resolve();
    })
    .fail(function(errorResponse) {
      if (errorResponse) {
        traverseErrorMessage(errorResponse.error.data);
        GUI.notify.error("<h4>Errore nel salvataggio sul server</h4>" +
          "<h5>" + error_message + "</h5>");
      } else {
        GUI.notify.error("Errore nel salvataggio sul server");
      }
      deferred.resolve();
    });
    return deferred.promise();
  };

  // funzione che prende come ingresso gli editor sporchi
  this._sendEdits = function(dirtyEditors) {
    var self = this;
    var deferred = $.Deferred();
    var editsToPush = _.map(dirtyEditors, function(editor) {
      return {
        layername: editor.getVectorLayer()[self._editingApiField],
        edits: editor.getEditedFeatures()
      }
    });

      // esegue il post dei dati
    this._postData(editsToPush)
    .then(function(returned) {
      if (returned.result){
        deferred.resolve(returned.response);
      } else {
        deferred.reject(returned.response);
      }
    })
    .fail(function(returned){
      deferred.reject(returned.response);
    });
    return deferred.promise();
  };

  this._commitEdits = function(editors, response) {
    // un dubbio gli editors possono essere uno alla volta
    var layer;
    _.forEach(editors, function(editor) {
      if (response && response.new.length > 0) {
        // scorro array dei nuovi feature/relations
        _.forEach(response.new, function(updatedFeatureAttributes) {
          var oldfid = updatedFeatureAttributes.clientid;
          var fid = updatedFeatureAttributes.id;
          // verfico se oldfid è diverso da fid (in questo caso si ha a che fare con una nuova feature)
          if (oldfid != fid) {
            layer = editor.getEditVectorLayer();
          } else {
            // vecchia feature e quindi devo aggiornare le proprietà e relazioni senza cambiare l'id
            layer = editor.getVectorLayer()
          }
          // funzione che setta e va a cambiare l'id e gli attributi ma lo scopo principale
          // l'id della feature new (nuova)
          layer.setFeatureData(oldfid,fid,null,updatedFeatureAttributes);
          editor.commit(updatedFeatureAttributes)
        });
        _.forEach(response.new_lockids, function(newlockId) {
          editor.getVectorLayer().addLockId(newlockId);
        });
      } else {
        // nel caso di nessuna new (update e delete)
        editor.commit();
      }
    });
  };

  this._undoEdits = function(dirtyEditors){
    var currentEditingLayerCode = this._getCurrentEditingLayer().layerCode;
    var editor = dirtyEditors[currentEditingLayerCode];
    this._stopEditing(true);
  };

    // esegue l'update dello state nel caso ad esempio di un toggle del bottone tool
  this._updateEditingState = function() {
    // prende il layer in Editing
    var layer = this._getCurrentEditingLayer();
    if (layer) {
      this.state.editing.layerCode = layer.layerCode;
      this.state.editing.toolType = layer.editor.getActiveTool().getType();
    } else {
      this.state.editing.layerCode = null;
      this.state.editing.toolType = null;
    }
    this._updateToolStepsState();
  };

  this._updateToolStepsState = function() {
    var self = this;
    var layer = this._getCurrentEditingLayer();
    var activeTool;
    if (layer) {
      activeTool = layer.editor.getActiveTool();
    }
    if (activeTool && activeTool.getTool()) {
      var toolInstance = activeTool.getTool();
      if (toolInstance.steps){
        this._setToolStepState(activeTool);
        toolInstance.steps.on('step', function(index,step) {
          self._setToolStepState(activeTool);
        });
        toolInstance.steps.on('complete', function(){
          self._setToolStepState();
        })
      }
    } else {
      self._setToolStepState();
    }
  };

  this._setToolStepState = function(activeTool){
    var index, total, message;
    if (_.isUndefined(activeTool)){
      index = null;
      total = null;
      message = null;
    } else {
      var tool = activeTool.getTool();
      var messages = this._toolStepsMessages[activeTool.getType()];
      index = tool.steps.currentStepIndex();
      total = tool.steps.totalSteps();
      message = messages[index];
      if (_.isUndefined(message)) {
        index = null;
        total = null;
        message = null;
      }
    }
    this.state.editing.toolstep.n = index + 1;
    this.state.editing.toolstep.total = total;
    this.state.editing.toolstep.message = message;
  };

  this._getCurrentEditingLayer = function() {
    return this._currentEditingLayer;
  };

  this._setCurrentEditingLayer = function(layer){
    if (!layer){
      this._currentEditingLayer = null;
    } else {
      this._currentEditingLayer = layer;
    }
  };

  this._addToMap = function() {
    //recupero l'elemento map ol3
    var map = this._mapService.viewer.map;
    var layerCodes = this.getLayerCodes();
    //ogni layer lo aggiungo alla mappa
    //con il metodo addToMap di vectorLayer
    _.forEach(layerCodes, function(layerCode) {
      self._layers[layerCode].vector.addToMap(map);
    })
  };

  this._postData = function(editsToPush) {
    // mando un oggetto come nel caso del batch,
    // ma in questo caso devo prendere solo il primo, e unico, elemento
    if (editsToPush.length > 1) {
      return this._postBatchData(editsToPush);
    }
    var layerName = editsToPush[0].layername;
    var edits = editsToPush[0].edits;
    var jsonData = JSON.stringify(edits);
    return $.post({
      url: this.config.baseurl+layerName+"/",
      data: jsonData,
      contentType: "application/json"
    });
  };

  this._postBatchData = function(multiEditsToPush){
    var edits = {};
    _.forEach(multiEditsToPush, function(editsToPush) {
      edits[editsToPush.layername] = editsToPush.edits;
    });
    var jsonData = JSON.stringify(edits);
    return $.post({
      url: this.config.baseurl,
      data: jsonData,
      contentType: "application/json"
    });
  };

  this._unlock = function(){
    var layerCodes = this.getLayerCodes();
    // eseguo le richieste delle configurazioni e mi tengo le promesse
    var unlockRequests = _.map(layerCodes,function(layerCode){
      return self._unlockLayer(self._layers[layerCode]);
    });
  };

  this._unlockLayer = function(layerConfig){
    $.get(this.config.baseurl+layerConfig[this._editingApiField]+"/?unlock");
  };
}

inherit(EditingService, G3WObject);

module.exports = EditingService;

},{"core/g3wobject":34,"core/i18n/i18n.service":39,"core/map/layer/loader/vectorloaderlayer":56,"core/utils/utils":77,"gui/form/vue/form":116,"gui/gui":118}],113:[function(require,module,exports){
module.exports = "<div class=\"g3w-editing-panel\">\n  <template v-for=\"toolbar in editorstoolbars\">\n    <div class=\"panel panel-primary\">\n      <div class=\"panel-heading\">\n        <h3 class=\"panel-title\">{{ toolbar.name }}</h3>\n      </div>\n      <div class=\"panel-body\">\n        <template v-for=\"tool in toolbar.tools\">\n          <div class=\"editbtn\" :class=\"{'enabled' : (state.editing.on && editingtoolbtnEnabled(tool)), 'toggled' : editingtoolbtnToggled(toolbar.layercode,tool.tooltype)}\">\n            <img height=\"30px\" width=\"30px\" @click=\"toggleEditTool(toolbar.layercode,tool.tooltype)\" :alt=\"tool.title\" :title=\"tool.title\" :src=\"resourcesurl+'images/'+tool.icon\"/>\n          </div>\n        </template>\n      </div>\n    </div>\n  </template>\n  <div>\n    <button class=\"btn btn-primary\" v-disabled=\"editingbtnEnabled\" :class=\"{'btn-success' : state.editingOn}\" @click=\"toggleEditing\">{{ editingbtnlabel }}</button>\n    <button class=\"btn btn-danger\" v-disabled=\"!state.hasEdits\" @click=\"saveEdits\">{{ savebtnlabel }}</button>\n    <img v-show=\"state.retrievingData\" :src=\"resourcesurl +'images/loader.svg'\">\n  </div>\n  <div class=\"message\" v-html=\"message\"></div>\n</div>\n";

},{}],114:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var Component = require('gui/vue/component');
var EditingService = require('gui/editing/editingservice');
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var EditingTemplate = require('./editing.html');

var vueComponentOptions = {
  template: null,
  data: null,
  transitions: {'addremovetransition': 'showhide'},
  methods: {
    toggleEditing: function() {
      //si ha quando viene avviata o terminata una sessione di editing
      this.$options.service.toggleEditing();
    },
    saveEdits: function() {
      //chaiamata quando si preme su salva edits
      this.$options.service.saveEdits();
    },
    toggleEditTool: function(layerCode, toolType) {
      //chiamato quando si clicca su un tool dell'editor
      if (toolType == '') {
        return;
      }
      if (this.state.editing.on) {
        this.$options.service.toggleEditTool(layerCode, toolType);
      }
    },
    editingtoolbtnToggled: function(layerCode, toolType) {
      return (this.state.editing.layerCode == layerCode && this.state.editing.toolType == toolType);
    },
    editingtoolbtnEnabled: function(tool) {
      return tool.tooltype != '';
    },
    onClose: function() {
      this.$options.service.stop();
    }
  },
  computed: {
    editingbtnlabel: function() {
      return this.state.editing.on ? "Termina editing" : "Avvia editing";
    },
    editingbtnEnabled: function() {
      return (!this.state.editing.error && (this.state.editing.enabled || this.state.editing.on)) ? "" : "disabled";
    },
    message: function() {
      var message = "";
      if (!this.state.editing.enabled) {
        message = '<span style="color: red">Aumentare il livello di zoom per abilitare l\'editing';
      }
      else if (this.state.editing.toolstep.message) {
        var n = this.state.editing.toolstep.n;
        var total = this.state.editing.toolstep.total;
        var stepmessage = this.state.editing.toolstep.message;
        message = '<div style="margin-top:20px">GUIDA STRUMENTO:</div>' +
          '<div><span>['+n+'/'+total+'] </span><span style="color: yellow">'+stepmessage+'</span></div>';
      }
      return message;
    }
  }
};


function PanelComponent(options) {
  var self = this;
  // proprietà necessarie. In futuro le mettermo in una classe Panel
  // da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  base(this, options);
  // qui vado a tenere traccia delle due cose che mi permettono di customizzare
  // vue component e service
  this.vueComponent = vueComponentOptions;
  this.name = options.name || 'Gestione dati';
  merge(this, options);
  // dichiaro l'internal Component
  this.internalComponent = null;
  //template from component
  this._template = options.template || EditingTemplate;
  // edittoolbar
  this._editorsToolbars = options.editorsToolBars || [];
  // save buttons
  this._saveBtnLabel = options.saveBtnLabel || "Salva";
  // resource urls
  this._resourcesUrl = options.resourcesUrl || GUI.getResourcesUrl();
  // settor il service del component settando le relative opzioni
  var serviceOptions = options.serviceOptions || {};
  this._service = options.service || new EditingService(serviceOptions);
  // setto il componente interno
  this.setInternalComponent = function () {
    var InternalComponent = Vue.extend(this.vueComponent);
    this.internalComponent = new InternalComponent({
      service: this._service,
      template: this._template,
      data: function() {
        return {
          //lo state è quello del servizio in quanto è lui che va a modificare operare sui dati
          state: self._service.state,
          resourcesurl: self._resourcesUrl,
          editorstoolbars: self._editorsToolbars,
          savebtnlabel: self._saveBtnLabel
        }
      }
    });
    return this.internalComponent;
  };

  // sovrascrivo richiamando il padre in append
  this.mount = function(parent) {
    return base(this, 'mount', parent, true)
  };

  this.unmount = function() {
    // faccio in modo che venga disattivato l'eventuale tool attivo al momento del
    // click sulla x
    this._service.stop();
    return base(this, 'unmount');
  }
}

inherit(PanelComponent, Component);

module.exports = PanelComponent;



},{"./editing.html":113,"core/utils/utils":77,"gui/editing/editingservice":112,"gui/gui":118,"gui/vue/component":156}],115:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var PickCoordinatesInteraction = require('g3w-ol3/src/interactions/pickcoordinatesinteraction');
var ClipBoard = require('core/clipboardservice');
var QueryService = require('core/query/queryservice');
var ProjectsRegistry = require('core/project/projectsregistry');

var Inputs = {};
Inputs.STRING = 'string';
Inputs.INTEGER = 'integer';
Inputs.FLOAT = 'float';
Inputs.BOOLEAN = 'boolean';

Inputs.defaults = {};
Inputs.defaults[Inputs.STRING] = "";
Inputs.defaults[Inputs.INTEGER] = 0;
Inputs.defaults[Inputs.FLOAT] = 0.0;
Inputs.simpleFieldTypes = [Inputs.STRING,Inputs.INTEGER,Inputs.FLOAT];

Inputs.TEXTAREA = 'textarea';
Inputs.SELECT = 'select';
Inputs.RADIO = 'radio';
Inputs.CHECKBOX = 'checkbox';
Inputs.LAYERPICKER = 'layerpicker';
Inputs.IMAGE = 'image';

Inputs.specialInputs = [Inputs.TEXTAREA, Inputs.SELECT, Inputs.RADIO, Inputs.CHECKBOX, Inputs.LAYERPICKER, Inputs.IMAGE];

function FormService() {
  this._actions = {};
  this.state = null;
  this._pickInteraction = null;
  this.setters = {
    setInitForm: function(options) {
      this._setInitForm(options);
    },
    // setter sul cambio dellle relazioni del form
    setFormRelations: function (relations) {
      this.state.relations = relations;
    },
    // setter sul cambio dei campi
    setFormFields: function (fields) {
      this.state.fields = fields;
    },
    setupFields: function() {
      this._setupFields();
    },
    setupRelationsFields: function() {
      this._setupRelationsFields();
    },
    // setter sull'inserimento dei dati del form
    setFormData: function(fields, relations) {
      this.setFormFields(fields);
      this.setFormRelations(relations);
    },
    // setter del singolo field
    setField: function(field) {
    },
    // settere dello state
    setState: function(state) {
      this._setState(state);
    },
    // setter sull'aggiunta di un'azione sul form
    addActionsForForm: function (actions) {
      // un opportunità per i listener per aggiungere azioni a form
    },
    postRender: function (element) {
      // un opportunità per i listener di intervenire sul DOM
    }
  };
  // inizializzo il form con l'opzioni passate dall'editor al momento del'apertura del form
  this._setInitForm = function(options) {
    this.provider = options.provider || null; // è l' editor che lo chiama
    this.formId = options.formId;
    this.name = options.name; // nome del form
    this.dataid = options.dataid; // "accessi", "giunzioni", ecc.
    this.editor = options.editor || {};
    this.relationOne = options.relationOne || null;
    this.pk = options.pk || null; // eventuale chiave primaria (non tutti i form potrebbero avercela o averne bisogno
    this.tools = options.tools || [];
    this.isnew = (!_.isNil(options.isnew) && _.isBoolean(options.isnew)) ? options.isnew : true;
    this._defaults = options.defaults || Inputs.defaults;
    this.buttons = options.buttons;
    // clipboard
    this._clipBoard = ClipBoard;
    //mi server per estrarre il nome del layer dall'id del form
    // in quanto l'id è creato univoco ma riposrta al suo interno
    // il nome del layer
    var formLayer = this.formId.split('form')[0];
    this._pickedPromise = null;
    // setto lo stato
    this.state = {
      fields: null,
      relations: null,
      editor: this.editor,
      isnew: this.isnew,
      buttons: this.buttons,
      tools: {},
      relationOne: this.relationOne,
      canpaste: _.has(this._clipBoard._data, formLayer)
    };
    //chiamo i setter
    this.setFormFields(options.fields);
    this.setFormRelations(options.relations);
    var elementsBoxes = this.getUniqueRelationsElementId();
    this.state.elementsBoxes = elementsBoxes;
    // qui associo lo state del pannello allo ste del form
    this._setFormTools(this.tools);
    this.editor.setFormService(this);
  };

  //vado a ripulire lo state del form dopo che è stato effettuaro un commit sul server
  this.cleanStateAfterCommit = function(newRelationIds) {
    // verifico che ci sia stato un aggiunta di relazioni
    var addedRelations = (newRelationIds && newRelationIds.length > 0) ? newRelationIds[0].relations :  {}
    var relationsToDelete = [];
    // cliclo sulle relazioni e faccio "pulizia"
    _.forEach(this.state.relations, function (relation) {
      var addedRelation = addedRelations[relation.name];
      // uso forEachRight invece di forEach in quando lo splice shifta gli element e
      // quindi si avrebbe un elemento finale undefined
      _.forEachRight(relation.elements, function (element, index) {
        // verifico gli elementi che sono stati cancellati e cancello
        if(element.state.indexOf('DELETE') > -1) {
          relation.elements.splice(index, 1);
        }
        // nela caso di elementi nuovi inseriti
        if (element.state == 'NEW') {
          _.forEach(addedRelation, function(newElement){
            if (element.id == newElement.clientid) {
              element.id = newElement.id;
              return false
            }
          });
          // assegno lo stato OLD
          element.state = 'OLD';
        }
      });
    });
  };

  this.createPickInteraction = function() {
    this._pickInteraction = new PickCoordinatesInteraction;
    return this._pickInteraction;
  };
  this.getState = function () {
    return this.state;
  };

  this._setState = function(state) {
    this.state = state;
  };
  // funzione che supporta la validazione dei campi obbigatori al fine di abliltare o meno il Salva
  this._checkFieldsValidation = function(fields) {
    var self = this;
    var valid = true;
    var fieldValid = true;
    _.forEach(fields, function(field) {
      if (self._isEditable(field) && self._isVisible(field) && field.validate && field.validate.required) {
        if (_.isNil(field.value) || !_.trim(field.value)) {
          if (!self._isSelect(field)) {
            fieldValid = false;
          }
        }
        valid = valid && fieldValid;
      }
    });
    return valid;
  };
  //funzione che retituisce i fields
  this.getFields = function() {
    return this._fields;
  };
  // funzione che restituisce se nella feture(nel layer) è prevista una relazione ONE
  this._getRelationsOne = function() {
    // overwrite from plugin
    var self = this;
    var relationsOne = [];
    _.forEach(this.state.relations, function(relation, index) {
      if (relation.type == 'ONE') {
        relationsOne.push(self.state.relations[index]);
      }
    });
    return relationsOne;
  };
  //funzione che mi server per estrarre il layer name dall'id del form
  // utile per il clipboard al fine del copia e incolla
  this._getLayerFormFromId = function() {
    return this.formId.split('form')[0];
  };
  //funzione che clona i dati del form per il copia e incolla
  this._copyFormToClipBoard = function() {
    var formData = _.cloneDeep(this.state);
    this._clipBoard.set(this.formId, formData);
    this.state.canpaste = true;
    return true;
  };

  this._setFieldValueLayerFromToRelationField = function(relation, name) {
     ('questa funzione deve essere sovrascritta dal plugin al momento');
  };

  this._checkIfFieldIsOverwritable = function(fieldName, fieldsdArray) {
    var check = null;
    _.forEach(fieldsdArray, function(field) {
      if (!_.isNil(field[fieldName])) {
        check = field[fieldName]
      }
    });
    return check;
  };
  // funzione utlizzazta al fine di copiare i dati di un altra feature seleziona
  // evitando di scrivere i campi non sovrascrivibili. Rimasta con il nome vecchio riferita solo alla primary key
  this._pasteStateWithoutPk = function(fields, relations) {
    //prendo vector layer
    var self = this;
    var layerFields = [];
    var copyAndPasteFieldsNotOverwritable = self.editor.getcopyAndPasteFieldsNotOverwritable();
    var relationFields = {};
    // verifico se sono stati settati campi che non devono essere sovrascitti dal copia e incolla
    // è settato dall'editor specifico
    if (!_.isNil(copyAndPasteFieldsNotOverwritable.layer)) {
      layerFields = copyAndPasteFieldsNotOverwritable.layer;
    }
    if (!_.isNil(copyAndPasteFieldsNotOverwritable.relations)) {
      relationFields = copyAndPasteFieldsNotOverwritable.relations;
    }
    // verifico i fields da non modificare sul layer
    var orginalField;
    _.forEach(fields, function(field, index) {
      orginalField = self._checkIfFieldIsOverwritable(field.name, layerFields);
      //verifico se è una chiave prmaria il campo
      if (self.pk == field.name) {
        fields[index].value = self.isnew ? null : self.state.fields[index].value;
      } else if (!_.isNull(orginalField)) { // caso in cui non è la chiave primaria
        fields[index].value = (orginalField && self.isnew) ? undefined : self.state.fields[index].value;
      }
    });
    // verifico i fileds delle relazioni da non sovrascrivere
    _.forEach(relations, function(relation, relationIndex) {
      _.forEach(relation.elements, function(element, elementIndex) {
        /// aggiungo allo stato della relazione copiata NEW
        relations[relationIndex].elements[elementIndex].state = 'NEW';
        _.forEach(element.fields, function(field, fieldIndex) {
          _.forEach(relationFields[relation.name], function(relationField) {
            if (field.name == relationField) {
              relations[relationIndex].elements[elementIndex].fields[fieldIndex].value = undefined;
            }
          });
        });
      })
    });
    // setto i nuovi fields e relations lasciando quelli vecchi
    this.setFormData(fields, relations);
    var elementsBoxes = this.getUniqueRelationsElementId(false);
    this.state.elementsBoxes = elementsBoxes;
    return true;
  };
  // funzione che server per incollare i dati dalla clipboard nel form
  this._pasteClipBoardToForm = function(layerForm) {
    var formData = this._clipBoard.get(layerForm);
    this._pasteStateWithoutPk(formData.fields, formData.relations);
    this.state.canpaste = false;
  };

  // funzione che verifica se la featuare su cui stiamo lavorando
  // è nuova o vecchia
  this._isNew = function(){
    return this.isnew;
  };
  // funzione che verifa se il campo è obbligatorio o no
  this._hasFieldsRequired = function() {
    var someFieldsRequired = _.some(this.state.fields, function(field){
      return field.validate && field.validate.required;
    });
    var someRelationsRequired = _.some(this.state.relations,function(relation){
      return relation.validate && relation.validate.required;
    });
    return someFieldsRequired || someRelationsRequired;
  };

  // VERIFICA CAMPI

  // funzione che restituisce true/false a seconda se il campo è visibile o no
  this._isVisible = function(field) {
    return !(!field.editable && (field.value == "" || _.isNull(field.value))) && field.name !=this.pk;
  };
  //verifica se il campo è editabile o no
  this._isEditable = function(field) {
    return field.editable;
  };
  // verifica se il campo è considerato tra i seimple(es text)
  this._isSimple = function(field) {

    if (_.includes(Inputs.specialInputs, field.input.type)){
      return false;
    }
    return _.includes(Inputs.simpleFieldTypes, field.type)
  };
  // verifica se l'input è una textarea
  this._isTextarea = function(field) {
    return (field.input.type == Inputs.TEXTAREA);
  };
  // verifica se è una select
  this._isSelect = function(field) {
    return (_.includes(Inputs.specialInputs,field.input.type) && field.input.type == Inputs.SELECT);
  };
  // verifica se è tipo radio button
  this._isRadio = function(field) {
    return (_.includes(Inputs.specialInputs, field.input.type) && field.input.type == Inputs.RADIO);
  };
  // verifica se è tipo checkbox
  this._isCheckbox = function(field) {
    return (_.includes(Inputs.specialInputs,field.input.type) && field.input.type == Inputs.CHECKBOX);
  };
  // verifica se il campo è un picklayer
  this._isLayerPicker = function(field) {
    return (_.includes(Inputs.specialInputs,field.input.type) && field.input.type == Inputs.LAYERPICKER);
  };
  // verifica se il campo è di tipo file
  this._isImage = function(field) {
    return (field.input.type == Inputs.IMAGE);
  };

  // FINE VERIFICA CAMPI

  //una volta cliccato sulla mappa dopo un picklayer ripulisce
  this._cleanUpPickLayer = function() {
    var mapService = GUI.getComponent('map').getService();
    mapService.removeInteraction(this._pickInteraction);
    this._pickInteraction = null;
    GUI.setModal(true);
  };
  this._pickLayerInputFieldChange = function(field, relation) {
    console.log('funzione che deve essere sovrascritta dal plugin');
  };
  // funzione chiata nel caso pick layer
  this._pickLayer = function(field, relation) {
    // ritorno una promessa, se qualcun altro volesse usare
    // il risultato (es. per settare altri campi in base alla feature selezionata)
    var d = $.Deferred();
    GUI.notify.info("Seleziona un'elemento dalla mappa per ottenere il valore di "+ field.label + " o scrivilo direttamentene");
    var self = this;
    // disabilito temporanemante lo strato modale per permettere l'interazione con la mappa
    GUI.setModal(false);
    var mapService = GUI.getComponent('map').getService();
    var layer = mapService.getLayersStore.getLayerById(field.input.options.layerid);
    var relFieldName = field.input.options.field;
    var relFieldLabel = layer.getAttributeLabel(field.input.options.field);
    mapService.addInteraction(this.createPickInteraction());
    this._pickInteraction.on('picked',function(e){
      QueryService.queryByLocation(e.coordinate, [layer])
        .then(function(response){
          var featuresForLayers = response.data;
          if (featuresForLayers.length && featuresForLayers[0].features.length) {
            var attributes = featuresForLayers[0].features[0].getProperties(); // prendo la prima feature del primo (e unico) layer
            var value = attributes[relFieldName] ? attributes[relFieldName] : attributes[relFieldLabel];
            field.value = value;
            d.resolve(attributes);
          }
          else {
            d.reject();
          }
        })
        .fail(function(){
          d.reject();
        })
        .always(function() {
          self._cleanUpPickLayer();
        })
    });
    return d.promise();
  };
  //funzione che server per poter copiare lo state di una feature identificata
  // sul form attuale di un'altra feature
  this._pickLayerToClipBoard = function() {
    //TODO
    var self = this;
    // ritorno una promessa, se qualcun altro volesse
    // usare il risultato (es. per settare altri campi in base alla feature selezionata)
    var d = $.Deferred();
    if (this._pickedPromise) {
      return this._pickedPromise
    }
    // disabilito temporanemante lo strato modale per permettere l'interazione con la mappa
    GUI.setModal(false);
    // recupero mapservice perchè mi permette di ineteragire con la mappa
    var mapService = GUI.getComponent('map').getService();
    var vectorLayer = this.editor.getVectorLayer();
    var layer = mapService.getLayersStore().getLayerById(vectorLayer.id);
    // l'aggiungo alla mappa
    mapService.addInteraction(this.createPickInteraction());
    // on picked
    this._pickInteraction.on('picked', function(e) {
      // qui passo lo stessso layer su cui sto agendo
      QueryService.queryByLocation(e.coordinate, [layer])
        .then(function(response) {
          var featuresForLayers = response.data;
          // verifico se ci sono features selezionate
          if (featuresForLayers.length && featuresForLayers[0].features.length) {
            // rpendo la prima feature
            var featureLayer = featuresForLayers[0].features[0];
            var pk = vectorLayer.getPk();
            var feature = vectorLayer.getFeatureById(featureLayer.get(pk));
            // prendo dal vectorLayer la feature basato sull'id della richiesta
            if (!feature) {
              feature = vectorLayer.getFeatureById(featureLayer.getId());
            }
            var fields = vectorLayer.getFieldsWithValues(feature);
            var relationsPromise = self.editor.getRelationsWithValues(feature);
            relationsPromise
              .then(function(relations) {
                self._pasteStateWithoutPk(fields, relations);
                d.resolve();
              });
          }
        })
        .fail(function() {
          d.reject();
        })
        .always(function() {
          self._cleanUpPickLayer();
        })
    });
    return d.promise();
  };
  // funzione che ritorna il valore di default del campo
  this._getDefaultValue = function(field) {
    if (field.input && field.input.options && field.input.options.default) {
      return field.input.options.default;
    } else if (this._isSelect(field)) {
      return field.input.options.values[0].key;
    }
    return '';
  };
  // restituisce il nome del layer che si è appena cliccato con il picklayer
  this._getlayerPickerLayerName = function(layerId){
    var layer = ProjectsRegistry.getCurrentProject().getLayersStore().getLayerById(layerId);
    if (layer){
      return layer.getName();
    }
    return "";
  };
  // da cancellare?
  this._shouldShowRelation = function(relation) {
    return true;
  };

  // per definire i valori di default nel caso si tratta di un nuovo inserimento
  this._setupFields = function() {
    var self = this;
    var fields = _.filter(this.state.fields,function(field){
      // tutti i campi eccetto la PK (se non nulla)
      if (self.pk && field.value==null){
        return ((field.name != self.pk));
      }
      return true;
    });
    _.forEach(fields,function(field){
      if(_.isNil(field.value)){
        var defaultValue = self._getDefaultValue(field);
        if (defaultValue){
          field.value = defaultValue;
        }
      }
    });
  };
// funzione che setta i campi della relazione
  this._setupRelationsFields = function(relations) {
    var self = this;
    relations = relations || this.state.relations;
    if (relations) {
      _.forEach(relations, function(relation) {
        _.forEach(relation.elements, function(element) {
          self._setupRelationElementFields(element);
        })
      });
    }
  };

  this._setupRelationElementFields = function(element) {
    var self = this;
    _.forEach(element.fields,function(field){
      if(_.isNil(field.value)){
        field.value = self._getDefaultValue(field);
      }
    })
  };

  this._setupPanel = function(){
    var panel = this.internalComponent = new this._formPanel({
      form: this
    });
    if (this.options.buttons) {
      panel.buttons = this.options.buttons;
    }
    var elementsBoxes = this.getUniqueRelationsElementId();
    this.state.elementsBoxes = elementsBoxes;
    // qui associo lo state del pannello allo ste del form
    panel.state = this.state;
    this._setFormTools(this.tools);
    return panel;
  };

  this._setFormTools = function(tools) {
    var self = this;
    _.forEach(tools, function(tool) {
      self.state.tools[tool] = true;
    })
  };

  this.getUniqueRelationsElementId = function(bool) {
    var self = this;
    var elementsBoxes = {};
    var collapsed = _.isNil(bool) ? true : bool;
    _.forEach(this.state.relations, function(relation){
      _.forEach(relation.elements, function(element){
        var boxid = self.getUniqueRelationElementId(relation,element);
        elementsBoxes[boxid] = {
          collapsed: collapsed
        }
      })
    });
    return elementsBoxes;
  };

  this.getUniqueRelationElementId = function(relation, element){
    return relation.name+'_'+element.id;
  };

  this._getField = function(fieldName){
    var field = null;
    _.forEach(this.state.fields,function(f){
      if (f.name == fieldName){
        field = f;
      }
    });
    return field;
  };

  this._setImageStyleInput = function() {
    $('input:file').filestyle({
      buttonText: " Foto",
      buttonName: "btn-primary",
      iconName: "glyphicon glyphicon-camera"
    })
  };

  this._addRelationElement = function(relation) {
    var self = this;
    // chama la funzione editor che crea una relazione
    var element = this.provider.createRelationElement(relation);
    var elementBoxId = this.getUniqueRelationElementId(relation, element);
    Vue.set(this.state.elementsBoxes, elementBoxId,{collapsed:false});
    this._setupRelationElementFields(element);
    relation.elements.push(element);
    _.forEach(element.fields, function(field) {
      if (self._isImage(field)) {
        Vue.nextTick(function() {
          self._setImageStyleInput();
        })
      }
    })
  };

  this._removeRelationElement = function(relation, element){
    var self = this;
    _.forEach(relation.elements,function(_element, idxToRemove){
      if (_element.id == element.id) {
        //relation.elements.splice(idxToRemove,1);
        element.state = element.state+'_DELETED'; // lo marco come elminato
        delete self.state.elementsBoxes.elmentBoxId;
      }
    })
  };

  this._removeRelationElements = function(relation) {
    var self = this;
    _.forEach(relation.elements, function(element){
      self._removeRelationElement(relation, element);
    })
  };

  this._getRelationField = function(fieldName, relationName){
    var field = null;
    _.forEach(this.state.relations,function(relation){
      if (relationName == relation.name){
        _.forEach(relation.fields,function(f){
          if (f.name == fieldName){
            field = f;
          }
        })
      }
    });
    return field;
  };

  this._getRelationElementField = function(fieldName, element) {
    var field;
    _.forEach(element.fields,function(_field){
      if (_field.name == fieldName) {
        field = _field;
      }
    });
    return field;
  };

  base(this);
}

// Make the public service en Event Emitter
inherit(FormService, G3WObject);

module.exports = FormService;
},{"core/clipboardservice":23,"core/g3wobject":34,"core/project/projectsregistry":69,"core/query/queryservice":74,"core/utils/utils":77,"g3w-ol3/src/interactions/pickcoordinatesinteraction":98,"gui/gui":118}],116:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var Component = require('gui/vue/component');
var Service = require('gui/form/formservice');
var base = require('core/utils/utils').base;
var Template = require('./templateform.html');

// FILTRI VUE

Vue.filter('startcase', function (value) {
  return _.startCase(value);
});

Vue.filter('lowerCase', function (value) {
  return _.lowerCase(value);
});

Vue.filter('relationplural', function (relation) {
  return (relation.plural) ? relation.plural : _.startCase(relation.name);
});

//FINE FILTRI VUE

//VUE VALIDATOR
// li manteniamo come commenti giusto per riprendere le Regex nel futuro validatore
/*Vue.validator('email', function (val) {
  return /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(val)
});

Vue.validator('integer', function (val) {
  return /^(-?[1-9]\d*|0)$/.test(val);
});*/

//FINE VUE VALIDATOR

//Definisco l'oggetto che contiene i dati necessari per instanziare un vue component
var vueComponentOptions = {
  template: null,
  data: function() {
    return {
      state: null,
      tools : {
        copypaste: false
      }
    }
  },
  components: {
    //è possibile inserire componenti custom dai vari plugin,
  },
  transitions: {'addremovetransition': 'showhide'},
  methods: {
    exec: function(cbk) {
      var relations = this.state.relations || null;
      cbk(this.state.fields, relations);
      if (this.state.editor.getPickedFeature()) {
        this.state.editor.cleanUpPickedFeature();
      }
      GUI.closeForm();
    },
    btnEnabled: function(button) {
      return button.type != 'save' || (button.type == 'save' && this.isValidForm());
    },
    hasFieldsRequired: function() {
      return this.$options.formService._hasFieldsRequired();
    },
    isEditable: function(field){
      return this.$options.formService._isEditable(field);
    },
    isSimple: function(field) {
      return this.$options.formService._isSimple(field);
    },
    isTextarea: function(field) {
      return this.$options.formService._isTextarea(field);
    },
    isSelectOptionsNull : function(value) {
      if (_.isNil(value)) {
        return 'null';
      } else {
        return value;
      }
    },
    isSelect: function(field){
      return this.$options.formService._isSelect(field);
    },
    isRadio: function(field) {
      return this.$options.formService._isRadio(field);
    },
    isCheckbox: function(field) {
      return this.$options.formService._isCheckbox(field);
    },
    multiCheckBoxValue: function(evt, field) {
      if (!field.value) {
        filed.value = [];
      }
      if (evt.target.checked) {
        field.push(evt.target.value);
      } else {
        _.remove(field, function(n) {
          return n == evt.target.value;
        });
      }
    },
    isLayerPicker: function(field){
      return this.$options.formService._isLayerPicker(field);
    },
    removeImage: function(field) {
      field.value = null;
    },
    isImage: function(field) {
      return this.$options.formService._isImage(field);
    },
    layerPickerPlaceHolder: function(field) {
      return this.$options.formService._getlayerPickerLayerName(field.input.options.layerid);
    },
    pickLayer: function(field, relation) {
      this.checkPickLayer();
      this.$options.formService._pickLayer(field, relation);
    },
    pickLayerInputFieldChange: function(field, relation) {
      this.$options.formService._pickLayerInputFieldChange(field, relation);
    },
    pickLayerToClipBoard: function() {
      this.checkPickLayer();
      this.$options.formService._pickLayerToClipBoard()
      .then(function() {
        //TODO
      })
    },
    isValidForm: function() {
      var self = this;
      var valid = this.$options.formService._checkFieldsValidation(this.state.fields);
      _.forEach(this.state.relations, function(relation) {
        if (self.showRelation(relation)) {
          _.forEach(relation.elements, function (element) {
            // non tengo conto dell'elementi della relazione eliminati
            if (element.state.indexOf('DELETE') > -1) {return true}
            valid = valid && self.$options.formService._checkFieldsValidation(element.fields);
          })
        }
      });
      return valid;
    },
    pickLayerInputChange: function() {
      this.$options.formService._cleanUpPickLayer();
    },
    checkPickLayer: function() {
      if (this.$options.formService._pickInteraction) {
        this.$options.formService._cleanUpPickLayer();
      }
    },
    isVisible: function(field) {
      return this.$options.formService._isVisible(field);
    },
    visibleElements: function(relation) {
      return _.filter(relation.elements,function(element){
        return (element.state != 'NEW_DELETED' && element.state != 'OLD_DELETED');
      });
    },
    visibleElementsLength: function(relation) {
      return this.visibleElements(relation).length;
    },
    showRelation: function(relation) {
      return this.$options.formService._shouldShowRelation(relation);
    },
    relationPkFieldName: function(relation) {
      return relation.pk;
    },
    isRelationElementDeletable: function(relation,element) {
      if (element.new) {
        return true;
      }
      var min;
      if (relation.type == 'ONE') {
        min = 1;
      }
      else {
        min = Number.NEGATIVE_INFINITY;
      }
      if (relation.min) {
        min = Math.min(min.relation.min);
      }
      return min < relation.elements.length;
    },
    canAddRelationElements: function(relation) {
      var canAdd = true;
      if (relation.type == 'ONE') {
        canAdd = (relation.elements.length) ? false : true; // se è una relazione 1:1 e non ho elementi, lo posso aggiungere, altrimenti no
      }
      else {
        var max = relation.max ? relation.max : Number.POSITIVE_INFINITY;
        canAdd = relation.elements.length < max; 
      }
      return canAdd;
    },
    addRelationElement: function(relation) {
      this.$options.formService._addRelationElement(relation);
    },
    removeRelationElement: function(relation, element){
      this.$options.formService._removeRelationElement(relation, element);
    },
    visibleElementFields: function(fields) {
      var self = this;
      return _.filter(fields, function (field) {
        return self.isVisible(field);
      })
    },
    fieldsSubset: function(fields) {
      var attributes = _.filter(fields, function(attribute) {
        return attribute.type != 'image';
      });
      var end = Math.min(3, attributes.length);
      return attributes.slice(0, end);
    },
    fieldsSubsetLength: function(fields) {
      return this.fieldsSubset(fields).length;
    },
    collapseElementBox: function(relation,element) {
      var boxid = this.getUniqueRelationElementId(relation,element);
      if (this.state.elementsBoxes[boxid]) {
        return this.state.elementsBoxes[boxid].collapsed;
      }
    },
    toggleElementBox: function(relation, element) {
      var boxid = this.getUniqueRelationElementId(relation, element);
      this.state.elementsBoxes[boxid].collapsed = !this.state.elementsBoxes[boxid].collapsed;
    },
    getUniqueRelationElementId: function(relation, element) {
      return this.$options.formService.getUniqueRelationElementId(relation, element);
    },
    pasteClipBoardToForm : function() {
      var layerForm = this.$options.formService._getLayerFormFromId();
      this.$options.formService._pasteClipBoardToForm(layerForm);
      this.$validate();
      this.$validate(this.state.relations);
      this.$resetValidation()
    },
    copyToClipBoard : function() {
      this.$options.formService._copyFormToClipBoard();
    },
    onSelectChange: function(field, evt) {
      field.value = evt.target.value;
    },
    onFileChange: function(field, relationIndex, e) {
      var formData = {};
      var spinnerContainer;
      // verifico se esiste il token di django
      var csrftoken = this.$cookie.get('csrftoken');
      if (csrftoken) {
        formData.csrfmiddlewaretoken = csrftoken;
      }
      if (relationIndex) {
        spinnerContainer = $('#foto-spinner'+relationIndex);
      } else {
        spinnerContainer = $('#foto-spinner');
      }
      GUI.showSpinner({
        container: spinnerContainer,
        id: 'fotoloadspinner',
        style: 'white',
        center: true
      });
      $(e.target).fileupload({
        dataType: 'json',
        formData : formData,
        done: function (e, data) {
          $.each(data.result, function (key, value) {
            field.value = value.filename
          });
        },
        fail: function() {
         $(this).siblings('.bootstrap-filestyle').find('input').val(field.value);
         GUI.notify.error('Si è verificato un errore nel caricamento')
        },
        always: function() {
          GUI.hideSpinner('fotoloadspinner');
        }
      });
      //verifico se è stato caricato un file
      var files = e.target.files || e.dataTransfer.files;
      if (!files.length) {
        return;
      }
    },
    createImage: function(file, field) {
      var reader = new FileReader();
      reader.onload = function(e) {
        field.value = e.target.result;
      };
      reader.readAsDataURL(file);
    },
    checkFileSrc: function(value) {
      var value = value;
      if (_.isNil(value)) {
        value = ''
      }
      return value
    },
    setImageStyleInput: function() {
      this.$options.formService._setImageStyleInput();
    }
  },
  computed: {
    isValid: function(field) {
      return this.$validate(field.name);
    },
    hasRelations: function() {
      return this.state.relations.length;
    },
    fields: function() {
      return this.state.fields;
    }
  },
  //aggiunta per  permettere al copia e incolla
  // di aggiornare stile upload image input
  watch: {
    'state.fields': function() {
      this.setImageStyleInput();
    }
  },
  mounted: function() {
    var self = this;
    if (this.state.relationOne && this.state.isnew) {
      var relationsOne = this.$options.formService._getRelationsOne();
      _.forEach(relationsOne, function(relationOne) {
        if (!relationOne.elements.length) {
          self.addRelationElement(relationOne);
        }
      });
    }
    this.$nextTick(function(){
      self.setImageStyleInput();
      self.$options.formService.postRender();
    });
  },
  beforeDestroy: function() {
    // prima di distruggerlo mi assicuro che venga rimosso l'eventuale picklayer interaction
    this.$options.formService._cleanUpPickLayer();
  }
};

function FormComponent(options) {
  var options = options || {};
  options.id = options.id || 'form';
  // qui vado a tenere traccia delle tre cose che mi permettono di customizzare
  // vue component, service e template
  // proprietà necessarie. In futuro le mettermo in una classe Panel
  // da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  base(this, options);
  //settor il service del component (lo istanzio tutte le volte che inizializzo un componente
  var service = options.service ?  new options.service : new Service;
  var vueComponent = options.vueComponentOptions || vueComponentOptions;
  // lo devo fare per problemi con compoents
  this.vueComponent = this.createVueComponent(vueComponent);
  this.setService(service);
  var template = options.template || Template;
  this.setInternalComponentTemplate(template);
  // funzione che permette di settare il componente interno
  this.setInternalComponent = function() {
    var InternalComponent = Vue.extend(this.vueComponent);
    this.internalComponent = new InternalComponent({
      formService: this.getService(),
      template: this.getInternalTemplate()
    });
    // associo lo state del componente interno a quello del service
    // perchè le funzioni che maipolano lo stato del componente sono delegate al service nella
    // maggior parte dei casi
    this.internalComponent.state = this.getService().state;
  };
  // Sovrascrivo il metodo mount padre. Viene richiamato dalla toolbar quando
  // il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
  this.mount = function(parent, append) {
    var self = this;
    // richiama il mont padre
    return base(this, 'mount', parent, append)
      // una volta footo il mount
    .then(function() {
      self.getService().setupFields();
      self.getService().setupRelationsFields();
      // setto il modale a true
      GUI.setModal(true);
    });
  };

  this.layout = function(width,height) {
    var headerHeight = $(this.internalComponent.$el).find(".g3w-form-component_header").height();
    var bodyHeight = height - headerHeight;
    $(this.internalComponent.$el).find(".g3w-form-component_body").height(bodyHeight);
    $(".nano").nanoScroller();
  }
}

inherit(FormComponent, Component);

module.exports = FormComponent;


},{"./templateform.html":117,"core/utils/utils":77,"gui/form/formservice":115,"gui/gui":118,"gui/vue/component":156}],117:[function(require,module,exports){
module.exports = "<div>\n  <div class=\"g3w-form-component_header\">\n    <div class=\"quick-actions-menu\">\n      <div v-if=\"state.tools.copypaste\" class=\"pull-right\">\n        <button v-if='state.isnew' class=\"btn btn-default glyphicon glyphicon-screenshot\" data-placement=\"bottom\" @click=\"pickLayerToClipBoard\"  data-i18n=\"[title]copy_form_data_from_feature\"></button>\n        <button v-if='!state.isnew' class=\"btn btn-default glyphicon glyphicon-copy\" data-placement=\"bottom\" @click=\"copyToClipBoard\"  data-i18n=\"[title]copy_form_data\"></button>\n        <button v-if='state.isnew' class=\"btn btn-default glyphicon glyphicon-paste\" data-placement=\"bottom\" @click=\"pasteClipBoardToForm\" v-disabled=\"!state.canpaste\" data-i18n=\"[title]paste_form_data\"></button>\n      </div>\n    </div>\n  </div>\n  <div class=\"g3w-form-component_body nano\">\n    <form name=\"validation\" novalidate class=\"form-horizontal g3w-form nano-content\">\n        <div class=\"box box-primary\">\n          <div class=\"box-header with-border\">\n            <h3 class=\"box-title\">Attributi elemento</h3>\n            <div class=\"box-tools pull-right\">\n            </div>\n          </div>\n          <div class=\"box-body\">\n            <template v-for=\"field in fields\">\n              <div v-if=\"isVisible(field)\" class=\"form-group has-feedback\">\n                <label :for=\"field.name\" class=\"col-sm-4 control-label\">{{ field.label }}<span v-if=\"field.validate && field.validate.required\">*</span></label>\n                <div class=\"col-sm-8\">\n                  <input v-if=\"isSimple(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                  <textarea v-if=\"isTextarea(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                  </textarea>\n                  <select v-if=\"isSelect(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" @change=\"onSelectChange(field, $event)\" :value=\"isSelectOptionsNull(field.value)\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                    <option v-for=\"value in field.input.options.values\"  :value=\"isSelectOptionsNull(value.key)\" >{{ value.value }}</option>\n                  </select>\n                  <div v-if=\"isLayerPicker(field)\">\n                    <input class=\"form-control picklayerinput\" @click=\"pickLayer(field)\" @change=\"pickLayerInputChange\" :field=\"field.name\" data-toggle=\"tooltip\" :title=\"'Ottieni il dato da un elemento del layer \\'' + layerPickerPlaceHolder(field) + '\\' o scrivilo direttamente qui'\" v-disabled=\"!isEditable(field)\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"'['+layerPickerPlaceHolder(field)+']'\">\n                    <i class=\"glyphicon glyphicon-screenshot form-control-feedback\" ></i>\n                  </div>\n                  <div v-if=\"isRadio(field)\">\n                    <template v-for=\"(value,index) in field.input.options.values\">\n                      <input class=\"magic-radio\" type=\"radio\" :value=\"value.value\" v-model=\"field.value\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" :id=\"field.name + value.value\" :placeholder=\"value.key\">\n                      <label :for=\"field.name + value.value\">{{ value.key }}</label>\n                    </template>\n                  </div>\n                  <div v-if=\"isImage(field)\">\n                    <i v-if=\"checkFileSrc(field.value)\" class=\"glyphicon glyphicon glyphicon-trash pull-right link trash\" @click=\"removeImage(field)\"></i>\n                    <img v-if=\"checkFileSrc(field.value)\" class=\"photo-preview img-responsive img-thumbnail rounded\"  :src=\"field.value\" />\n                    <div id=\"foto-spinner\"></div>\n                    <input type=\"file\" :name=\"field.name\" :data-url=\"field.uploadurl\" :field=\"field.name\" title=\"Foto\" accept=\"image/*;capture=camera\" class=\"filestyle\" @change=\"onFileChange(field, null, $event)\">\n                  </div>\n                </div>\n              </div>\n            </template>\n          </div>\n        </div>\n        <div v-for=\"relation, relationIndex in state.relations\" style=\"margin-top:10px\">\n          <transition name=\"expand\">\n          <div v-if=\"showRelation(relation)\">\n            <div class=\"box box-default\">\n              <div class=\"box-header with-border\">\n                <h3 class=\"box-title\">{{ relation | relationplural }}</h3>\n              </div>\n              <div class=\"box-body\">\n                <table v-if=\"visibleElementsLength(relation)\" class=\"table table-striped\">\n                  <thead>\n                  <tr>\n                    <th v-for=\"field in fieldsSubset(relation.fields)\">{{field.label}}</th>\n                  </tr>\n                  </thead>\n                  <tbody>\n                  <template v-for=\"element in visibleElements(relation)\">\n                    <tr class=\"attributes-preview\" @click=\"toggleElementBox(relation, element)\">\n                      <td v-for=\"relfield in fieldsSubset(element.fields)\">\n                        <span>{{relfield.value}}</span>\n                      </td>\n                      <td class=\"pull-right\">\n                        <i v-if=\"isRelationElementDeletable(relation,element)\" class=\"glyphicon glyphicon glyphicon-trash link trash\" @click.stop.prevent=\"removeRelationElement(relation,element)\"></i>\n                        <i class=\"glyphicon glyphicon-option-horizontal link morelink\"></i>\n                      </td>\n                    </tr>\n                    <tr v-show=\"!collapseElementBox(relation,element)\" class=\"queryresults-featurebox\">\n                      <td :colspan=\"fieldsSubsetLength(element.fields)+1\">\n                        <template v-for=\"field in element.fields\">\n                          <div v-if=\"isVisible(field)\" class=\"form-group has-feedback\">\n                            <label :for=\"field.name\" class=\"col-sm-4 control-label\">{{ field.label }}<span v-if=\"field.validate && field.validate.required\">*</span></label>\n                            <div class=\"col-sm-8\">\n                              <input v-if=\"isSimple(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                              <textarea v-if=\"isTextarea(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"field.input.label\"></textarea>\n                              <select v-if=\"isSelect(field)\" @focus=\"checkPickLayer\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" class=\"form-control\" @change=\"onSelectChange(field, $event)\" :value=\"isSelectOptionsNull(field.value)\" :id=\"field.name\" :placeholder=\"field.input.label\">\n                                <option v-for=\"value in field.input.options.values\"  :value=\"isSelectOptionsNull(value.key)\" >{{ value.value }}</option>\n                              </select>\n                              <div v-if=\"isRadio(field)\">\n                                <template v-for=\"(value, index) in field.input.options.values\">\n                                  <input class=\"magic-radio\" type=\"radio\" :value=\"value.value\" v-model=\"field.value\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" :id=\"field.name + value.value\" :placeholder=\"value.key\">\n                                  <label :for=\"field.name + value.value\">{{ value.key }} </label>\n                                </template>\n                              </div>\n                              <div v-if=\"isCheckbox(field)\">\n                                <template v-for=\"(value, index) in field.input.options.values\">\n                                  <label :for=\"field.name + value.value\">{{ value.key }} </label>\n                                  <input type=\"radio\" :value=\"value.value\" v-model=\"field.value\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" :id=\"field.name + value.value\" :placeholder=\"value.key\">\n                                </template>\n                              </div>\n                              <div v-if=\"isLayerPicker(field)\">\n                                <input class=\"form-control picklayerinput\" @click=\"pickLayer(field, relation)\" @input=\"pickLayerInputFieldChange(field, relation)\"  :field=\"field.name\" data-toggle=\"tooltip\" :title=\"'Ottieni il dato da un elemento del layer \\'' + layerPickerPlaceHolder(field) + '\\' o scrivilo direttamente qui'\" v-disabled=\"!isEditable(field)\" v-model=\"field.value\" :id=\"field.name\" :placeholder=\"'['+layerPickerPlaceHolder(field)+']'\">\n                                <i class=\"glyphicon glyphicon-screenshot form-control-feedback\" ></i>\n                              </div>\n                              <div v-if=\"isRadio(field)\">\n                                <template v-for=\"(value,index) in field.input.options.values\">\n                                  <input class=\"magic-radio\" type=\"radio\" :value=\"value.value\" v-model=\"field.value\" :field=\"field.name\" v-disabled=\"!isEditable(field)\" :id=\"field.name + value.value\" :placeholder=\"value.key\">\n                                  <label :for=\"field.name + value.value\">{{ value.key }}</label>\n                                </template>\n                              </div>\n                              <div v-if=\"isImage(field)\" style=\"position:relative;\">\n                                <i v-if=\"checkFileSrc(field.value)\" class=\"glyphicon glyphicon glyphicon-trash pull-right link trash\" @click=\"removeImage(field)\"></i>\n                                <i v-if=\"checkFileSrc(field.value)\" class=\"glyphicon glyphicon glyphicon-trash pull-right link trash\" @click=\"removeImage(field)\"></i>\n                                <img v-if=\"checkFileSrc(field.value)\" class=\"photo-preview img-responsive img-thumbnail rounded\" :src=\"field.value\" />\n                                <div :id=\"'foto-spinner'+relationIndex\"></div>\n                                <input type=\"file\" :name=\"field.name\" :data-url=\"field.uploadurl\" :field=\"field.name\" title=\"Foto\" accept=\"image/*;capture=camera\" class=\"filestyle\" @change=\"onFileChange(field, relationIndex, $event)\">\n                              </div>\n                            </div>\n                          </div>\n                        </template>\n                      </td>\n                    </tr>\n                  </template>\n                  </tbody>\n                </table>\n                <div v-if=\"canAddRelationElements(relation)\" class=\"row\" style=\"margin:0px\"><i class=\"glyphicon glyphicon-plus-sign pull-right btn-add\" @click=\"addRelationElement(relation)\"></i></div>\n              </div>\n            </div>\n          </div>\n          </transition>\n        </div>\n        <div class=\"form-group\">\n          <div class=\"col-sm-offset-4 col-sm-8\">\n            <div v-if=\"hasFieldsRequired\" style=\"margin-bottom:10px\">\n              <span>* Campi richiesti</span>\n            </div>\n            <span v-for=\"button in state.buttons\">\n              <button class=\"btn \" :class=\"[button.class]\" @click.stop.prevent=\"exec(button.cbk)\" v-disabled=\"!btnEnabled(button)\">{{ button.title }}</button>\n            </span>\n          </div>\n        </div>\n    </form>\n  </div>\n</div>";

},{}],118:[function(require,module,exports){
var noop = require('core/utils/utils').noop;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var RouterService = require('core/router');
var ComponentsRegistry = require('gui/componentsregistry');

// rappresenta l'interfaccia globale dell'API della GUI. 
// metodi devono essere implementati (definiti) dall'applicazione ospite
// l'app ospite dovrebbe chiamare anche la funzione GUI.ready() quando la UI è pronta
function GUI() {
  this.ready = false;
  // url delle risorse (immagini, ecc.)
  this.getResourcesUrl = noop;
  // show a Vue form
  this.showForm = noop;
  this.closeForm = noop;
  // mostra una lista di oggetti (es. lista di risultati)
  this.showListing = noop;
  this.closeListing = noop;
  this.hideListing = noop;
  // options conterrà i vari dati sui risultati. Sicuramente avrà la prprietà options.features
  // nel caso di queryByLocation avrà anche options.coordinate
  this.showQueryResults = function(options) {};
  this.hideQueryResults = noop;
  /* editing */
  this.showPanel = noop;
  this.hidePanel = noop;
  //metodi componente
  // aggiunge (e registra) un componente in un placeholder del template - Metodo implementato dal template
  this.addComponent = function(component, placeholder) {};
  this.removeComponent = function(id) {};
  // registra globalmente un componente (non legato ad uno specifico placeholder. Es. componente per mostrare risultati interrogazion)
  this.setComponent = function(component) {
    ComponentsRegistry.registerComponent(component);
  };
  // funzione che mi permette di prendere il componente
  // registrato in base al suo id
  this.getComponent = function(id) {
    return ComponentsRegistry.getComponent(id);
  };
  // funzione che prende tutti i componenti registrati
  this.getComponents = function() {
    return ComponentsRegistry.getComponents();
  };
  //fine metodi componente

  this.goto = function(url) {
    RouterService.goto(url);
  };

  this.ready = function(){
    this.emit('ready');
    this.ready = true;
  };
  
  this.guiResized = function() {
    this.emit('guiresized');
  };

  /* spinner */
  this.showSpinner = function(options){};

  this.hideSpinner = function(id){};

  
  this.notify = noop;
  this.dialog = noop;
}

inherit(GUI,G3WObject);

module.exports = new GUI;

},{"core/g3wobject":34,"core/router":75,"core/utils/utils":77,"gui/componentsregistry":111}],119:[function(require,module,exports){
module.exports = "<div>\n  Lista di oggetti\n</div>\n";

},{}],120:[function(require,module,exports){
var resolve = require('core/utils/utils').resolve;
var reject = require('core/utils/utils').reject;
var GUI = require('gui/gui');
//var MapService = require('core/map/mapservice');

var ListPanelComponent = Vue.extend({
  template: require('./listpanel.html'),
  methods: {
    exec: function(cbk){
      var relations = this.state.relations || null;
      cbk(this.state.fields,relations);
      GUI.closeForm();
    }
  }
});


function ListPanel(options){
  // proprietà necessarie. In futuro le mettermo in una classe Panel da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  this.panelComponent = null;
  this.options =  options || {};
  this.id = options.id || null; // id del form
  this.name = options.name || null; // nome del form
  
  this.state = {
    list: options.list || []
  };
  
  this._listPanelComponent = options.listPanelComponent || ListPanelComponent;
}

var proto = ListPanel.prototype;

// viene richiamato dalla toolbar quando il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
proto.onShow = function(container){
  var panel = this._setupPanel();
  this._mountPanel(panel,container);
  return resolve(true);
};

// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso
proto.onClose = function(){
  this.panelComponent.$destroy(true);
  this.panelComponent = null;
  return resolve(true);
};

proto._setupPanel = function(){
  var panel = this.panelComponent = new this._listPanelComponent({
    panel: this
  });
  panel.state = this.state;
  return panel
};

proto._mountPanel = function(panel,container){
  panel.$mount().$appendTo(container);
};

module.exports = {
  ListPanelComponent: ListPanelComponent,
  ListPanel: ListPanel
};

},{"./listpanel.html":119,"core/utils/utils":77,"gui/gui":118}],121:[function(require,module,exports){
var ResetControl = require('g3w-ol3/src/controls/resetcontrol');
var QueryControl = require('g3w-ol3/src/controls/querycontrol');
var ZoomBoxControl = require('g3w-ol3/src/controls/zoomboxcontrol');
var QueryBBoxControl = require('g3w-ol3/src/controls/querybboxcontrol');
var QueryByPolygonControl = require('g3w-ol3/src/controls/querybypolygoncontrol');
var GeolocationControl = require('g3w-ol3/src/controls/geolocationcontrol');
var StreetViewControl = require('g3w-ol3/src/controls/streetviewcontrol');
var AddLayersControl = require('g3w-ol3/src/controls/addlayers');
var LengthControl = require('g3w-ol3/src/controls/lengthcontrol');
var AreaControl = require('g3w-ol3/src/controls/areacontrol');
var Control = require('g3w-ol3/src/controls/control');
var OLControl = require('g3w-ol3/src/controls/olcontrol');
var NominatimControl = require('g3w-ol3/src/controls/nominatimcontrol');

var ControlsFactory = {
  create: function(options) {
    var control;
    var ControlClass = ControlsFactory.CONTROLS[options.type];
    var layers = options.layers; // opzione che mi server per far visualizzare o meno il controllo
    if (ControlClass) {
      // istanzio il controllo
      control = new ControlClass(options);
    }
    // nel caso siano stati specificati i layers del progetto su cui interrogare
    if (layers && control instanceof Control) {
      // nel caso l'array dei layer è vuoto non visualizzo il controllo
      if (!layers.length) {
        return null
      }
      // ricavo le geometry su cui deve essere fatto i layer
      var controlGeometryTypes = control.getGeometryTypes();
      // imposto il valore iniziale di visible se è un array vuoto vuol dire che non ho specificato nessuna
      // geometria rilevante e quindi deve essere visible
      var visible = (controlGeometryTypes.length) ? false : true;
      _.forEach(layers, function (layer) {
        if (controlGeometryTypes.indexOf(layer.getGeometryType()) > -1) {
          visible = true;
          return false;
        }
      });
      // se visibile allora restituisco il controllo altrimenti null
      if (visible) {
        return control;
      } else {
        return null;
      }
    } else {
      return control;
    }
  }
};

ControlsFactory.CONTROLS = {
  'reset': ResetControl,
  'zoombox': ZoomBoxControl,
  'zoomtoextent': OLControl,
  'query': QueryControl,
  'querybbox': QueryBBoxControl,
  'querybypolygon': QueryByPolygonControl,
  'geolocation': GeolocationControl,
  'streetview': StreetViewControl,
  'zoom': OLControl,
  'scaleline': OLControl,
  'overview': OLControl,
  'nominatim': NominatimControl,
  'addlayers': AddLayersControl,
  'length': LengthControl,
  'area': AreaControl
};

module.exports = ControlsFactory;

},{"g3w-ol3/src/controls/addlayers":78,"g3w-ol3/src/controls/areacontrol":79,"g3w-ol3/src/controls/control":80,"g3w-ol3/src/controls/geolocationcontrol":81,"g3w-ol3/src/controls/lengthcontrol":83,"g3w-ol3/src/controls/nominatimcontrol":85,"g3w-ol3/src/controls/olcontrol":86,"g3w-ol3/src/controls/querybboxcontrol":87,"g3w-ol3/src/controls/querybypolygoncontrol":88,"g3w-ol3/src/controls/querycontrol":89,"g3w-ol3/src/controls/resetcontrol":90,"g3w-ol3/src/controls/streetviewcontrol":91,"g3w-ol3/src/controls/zoomboxcontrol":92}],122:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function ControlsRegistry() {

  this._controls = {};
  this.setters = {
    registerControl : function(id, control) {
      this._registerControl(id, control)
    }
  };

  this._registerControl = function(id, control) {
    this._controls[id] = control;
  };

  this.getControl = function(id) {
    return this._controls[id];
  };

  this.getControls = function() {
    return this._controls;
  };

  this.unregisterControl = function(id) {
    var control = this.getControl(id);
    var mapService = GUI.getComponet('map').getService();
    var map = mapService.getMap();
    if (control) {
      map.removeControl(control);
      delete this._controls[id];
      return true
    }
    return false
  };
  base(this);
}

inherit(ControlsRegistry, G3WObject);

module.exports = new ControlsRegistry;

},{"core/g3wobject":34,"core/utils/utils":77,"gui/gui":118}],123:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var ApplicationService = require('core/applicationservice');
var ProjectsRegistry = require('core/project/projectsregistry');
var Layer = require('core/layers/layer');
var LayersStoreRegistry = require('core/layers/layersstoresregistry');
var ol3helpers = require('g3w-ol3/src/g3w.ol3').helpers;
var WMSLayer = require('core/map/layer/wmslayer');
var XYZLayer = require('core/map/layer/xyzlayer');
var VectorLayer = require('core/map/layer/vectorlayer');
var ControlsFactory = require('gui/map/control/factory');
var QueryService = require('core/query/queryservice');
var StreetViewService = require('gui/streetview/streetviewservice');
var ControlsRegistry = require('gui/map/control/registry');


function MapService(options) {
  var self = this;
  this.viewer = null;
  this.target = null;
  this._layersStoresEventKeys = {};
  this.project   = null;
  this._mapControls = [];
  this._mapLayers = [];
  this.mapBaseLayers = {};
  this.layersExtraParams = {};
  this.state = {
      bbox: [],
      resolution: null,
      center: null,
      loading: false,
      hidden: true
  };

  this._greyListenerKey = null;
  this._drawShadow = {
    type: 'coordinate',
    outer: [],
    inner: [],
    scale: null,
    rotation: null
  };
  this.config = options.config || ApplicationService.getConfig();
  this._howManyAreLoading = 0;
  this._incrementLoaders = function(){
    if (this._howManyAreLoading == 0){
      this.emit('loadstart');
      GUI.showSpinner({
        container: $('#map-spinner'),
        id: 'maploadspinner',
        style: 'blue'
      });
    }
    this._howManyAreLoading += 1;
  };
  
  this._decrementLoaders = function(){
    this._howManyAreLoading -= 1;
    if (this._howManyAreLoading == 0){
      this.emit('loadend');
      GUI.hideSpinner('maploadspinner');
    }
  };

  if(!_.isNil(options.project)) {
    this.project = options.project;
  } else {
    this.project = ProjectsRegistry.getCurrentProject();
    ProjectsRegistry.onafter('setCurrentProject',function(project){
      self._removeListeners();
      self.project = project;
      self._setupLayers();
      self._resetView();
    })
  }
  this._setupListeners();
  this._marker = null;

  this.setters = {
    setMapView: function(bbox, resolution, center) {
      this.state.bbox = bbox;
      this.state.resolution = resolution;
      this.state.center = center;
      this.updateMapLayers(this._mapLayers);
    },
    setHidden: function(bool) {
      this.state.hidden = bool;
    },
    setupViewer: function(width,height){
      if (width == 0 || height == 0) {
        return
      }
      if (self.viewer) {
        self.viewer.destroy();
        self.viewer = null;
      }
      self._setupViewer(width, height);
      self.state.bbox = this.viewer.getBBOX();
      self.state.resolution = this.viewer.getResolution();
      self.state.center = this.viewer.getCenter();
      self.setupControls();
      self._setupLayers();
      self.emit('viewerset');
    },
    controlClick: function() {}
  };
  
  this.on('cataloglayerselected', function(layer) {
   if (layer) {
     _.forEach(this._mapControls, function(mapcontrol) {
       if (_.indexOf(_.keysIn(mapcontrol.control), 'onSelectLayer') > -1 && mapcontrol.control.onSelectLayer()) {
         if (mapcontrol.control.getGeometryTypes().indexOf(layer.getGeometryType()) > -1 ) {
           mapcontrol.control.setEnable(true);
         } else {
           mapcontrol.control.setEnable(false);
         }
       }
     })
   }
  });

  this.on('cataloglayerunselected', function(layer) {
    _.forEach(this._mapControls, function(mapcontrol) {
      if (_.indexOf(_.keysIn(mapcontrol.control),'onSelectLayer') > -1 && mapcontrol.control.onSelectLayer()) {
        mapcontrol.control.setEnable(false);
      }
    })
  });

  // vado a registrare gli eventi sui layerstores esistesenti nel registro
  _.forEach(LayersStoreRegistry.getLayersStores(), function(layerStore) {
    self._setUpEventsKeysToLayersStore(layerStore);
  });

  // sto in ascolto di evantuali aggiunte di layersStore per poter eventualmente
  // aggiungere i suoi layers alla mappa
  LayersStoreRegistry.onafter('addLayersStore', function(layerStore) {
    self._setUpEventsKeysToLayersStore(layerStore);
  });
  // sto in ascolto di evantuali aggiunte di layersStore per poter eventualmente
  // aggiungere i suoi layers alla mappa
  LayersStoreRegistry.onafter('removeLayersStore', function(layerStore) {
    self._removeEventsKeysToLayersStore(layerStore);
  });
  
  base(this);
}


inherit(MapService, G3WObject);

var proto = MapService.prototype;

// rende questo mapservice slave di un altro MapService
proto.slaveOf = function(mapService, sameLayers){
  // se impostare i layer iniziali uguali a quelli del mapService master
  var sameLayers = sameLayers || false;
};

proto.setLayersExtraParams = function(params,update){
  this.layersExtraParams = _.assign(this.layersExtraParams,params);
  this.emit('extraParamsSet',params,update);
};

proto.getProject = function() {
  return this.project;
};

proto.getMap = function() {
  return this.viewer.map;
};

// funzione che server per definire una proiezione non standard
proto.defineProjection = function(crs) {
  switch(crs) {
    case '3003':
      proj4.defs("EPSG:" + crs, "+proj=tmerc +lat_0=0 +lon_0=9 +k=0.9996 +x_0=1500000 +y_0=0 +ellps=intl +units=m +no_defs");
      break;
  }
};

proto.getProjection = function() {
  return this.project.getProjection();
};

proto.getCrs = function() {
  return this.getProjection().getCode();
};

proto.getViewerElement = function(){
  return this.viewer.map.getTargetElement();
};

proto.getViewport = function(){
  return this.viewer.map.getViewport();
};

proto.getResolution = function() {
  return this.viewer.map.getView().getResolution();
};

proto.getEpsg = function() {
  return this.viewer.map.getView().getProjection().getCode();
};

proto.getGetFeatureInfoUrlForLayer = function(layer,coordinates,resolution,epsg,params) {
  var mapLayer = this.getMapLayerForLayer(layer);
  return mapLayer.getGetFeatureInfoUrl(coordinates,resolution,epsg,params);
};

proto.showMarker = function(coordinates, duration) {
  duration = duration || 1000;
  var self = this;
  this._marker.setPosition(coordinates);
  setTimeout(function(){
    self._marker.setPosition();
  }, duration)
};

// ritorna il layer nella mappa in base al name
proto.getLayerByName = function(name) {
  var map = this.viewer.map;
  var layer = null;
  map.getLayers().forEach(function(lyr) {
    if (lyr.get('name') == name) {
      layer = lyr;
      return false
    }
  });
  return layer;
};

// ritorna il layer della mappa in base all'id
proto.getLayerById = function(id) {
  var map = this.viewer.map;
  map.getLayers().forEach(function(lyr) {
    if (lyr.get('id') == id) {
      layer = lyr;
      return false
    }
  });
  return layer;
};


proto.setupControls = function(){
  var self = this;
  if (this.config && this.config.mapcontrols) {
    _.forEach(this.config.mapcontrols, function(controlType) {
      var control;
      switch (controlType) {
        case 'reset':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
          }
          self.addControl(controlType,control);
          break;
        case 'zoom':
          control = ControlsFactory.create({
            type: controlType,
            zoomInLabel: "\ue98a",
            zoomOutLabel: "\ue98b"
          });
          self.addControl(controlType,control);
          break;
        case 'zoombox':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('zoomend', function (e) {
              self.viewer.fit(e.extent);
            });
            self.addControl(controlType,control);
          }
          break;
        case 'zoomtoextent':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType,
              label: "\ue98c",
              extent: self.project.state.initextent
            });
            self.addControl(controlType,control);
          }
          break;
        case 'query':
          control = ControlsFactory.create({
            type: controlType
          });
          control.on('picked', function(e) {
            var coordinates = e.coordinates;
            self.showMarker(coordinates);
            var showQueryResults = GUI.showContentFactory('query');
            var layers = self.getLayers({
              QUERYABLE: true,
              SELECTEDORALL: true
            });
            var queryPromises = [];// raccoglie tutte le promises dei provider del layer
            _.forEach(layers, function(layer) {
              queryPromises.push(layer.query({
                  coordinates: coordinates,
                  resolution: self.getResolution()
              }))
            });
            //faccio query by location su i layers selezionati o tutti
            var queryResultsPanel = showQueryResults('interrogazione');
            $.when.apply(this, queryPromises)
              .then(function() {
                results = arguments;
                // vado ad unificare i rusltati delle promises
                results.query = results[0].query;
                var data = [];
                _.forEach(results, function(result) {
                  data.push(result.data);
                });
                results.data = data;
                queryResultsPanel.setQueryResponse(results, coordinates, self.state.resolution);
                })
              .fail(function() {
                GUI.notify.error('Si è verificato un errore nella richiesta al server');
                GUI.closeContent();
              })
            // QueryService.queryByLocation(coordinates, layers)
            // .then(function(results) {
            //   queryResultsPanel.setQueryResponse(results,coordinates,self.state.resolution);
            // })
            // .fail(function() {
            //   GUI.notify.error('Si è verificato un errore nella richiesta al server');
            //   GUI.closeContent();
            // })
          });
          self.addControl(controlType,control);
          break;
        case 'querybypolygon':
          var controlLayers = self.getLayers({
            QUERYABLE: true,
            SELECTEDORALL: true
          });
          control = ControlsFactory.create({
            type: controlType,
            layers: controlLayers
          });
          if (control) {
            control.on('picked', function (e) {
              var coordinates = e.coordinates;
              var showQueryResults = GUI.showContentFactory('query');
              //faccio query by location su i layers selezionati o tutti
              var queryResultsPanel = showQueryResults('interrogazione');
              var layers = self.getLayers({
                QUERYABLE: true,
                SELECTED: true
              });
              QueryService.queryByLocation(coordinates, layers)
                .then(function (results) {
                  if (results && results.data && results.data[0].features.length) {
                    var geometry = results.data[0].features[0].getGeometry();
                    var queryLayers = self.getLayers({
                      QUERYABLE: true,
                      ALLNOTSELECTED: true,
                      WFS: true
                    });
                    self.highlightGeometry(geometry);
                    var filterObject = QueryService.createQueryFilterObject({
                      queryLayers: queryLayers,
                      ogcService: 'wfs',
                      filter: {
                        geometry: geometry
                      }
                    });
                    QueryService.queryByFilter(filterObject)
                      .then(function (results) {
                        queryResultsPanel.setQueryResponse(results, geometry, self.state.resolution);
                      })
                      .fail(function() {
                        GUI.notify.error('Si è verificato un errore nella richiesta al server');
                        GUI.closeContent();
                      })
                      .always(function () {
                        self.clearHighlightGeometry();
                      });
                  }
                })
                .fail(function() {
                  GUI.notify.error('Si è verificato un errore nella richiesta al server');
                  GUI.closeContent();
                })
            });
            self.addControl(controlType, control);
          }
          break;
        case 'querybbox':
          if (!isMobile.any && self.checkWFSLayers()) {
            var controlLayers = self.getLayers({
              QUERYABLE: true,
              SELECTEDORALL: true,
              WFS: true
            });
            control = ControlsFactory.create({
              type: controlType,
              layers: controlLayers
            });
            if (control) {
              control.on('bboxend', function (e) {
                var bbox = e.extent;
                var layers = self.getLayers({
                  QUERYABLE: true,
                  SELECTEDORALL: true,
                  WFS: true
                });
                var showQueryResults = GUI.showContentFactory('query');
                //faccio query by location su i layers selezionati o tutti
                var queryResultsPanel = showQueryResults('interrogazione');
                var filterObject = QueryService.createQueryFilterObject({
                  queryLayers: layers,
                  ogcService: 'wfs',
                  filter: {
                    bbox: bbox
                  }
                });
                QueryService.queryByFilter(filterObject)
                  .then(function (results) {
                    queryResultsPanel.setQueryResponse(results, bbox, self.state.resolution);
                  })
                  .fail(function() {
                    GUI.notify.error('Si è verificato un errore nella richiesta al server');
                    GUI.closeContent();
                  })
              });
              self.addControl(controlType, control);
            }
          }
          break;
        case 'streetview':
          // streetview
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.setProjection(self.getProjection());
            self.addControl(controlType, control);
            self.on('viewerset', function() {
              self.viewer.map.addLayer(control.getLayer());
            });
            $script("https://maps.googleapis.com/maps/api/js?key=AIzaSyBCHtKGx3yXWZZ7_gwtJKG8a_6hArEFefs",
              function() {
                var position = {
                  lat: null,
                  lng: null
                };
                var streetViewService = new StreetViewService();
                streetViewService.onafter('postRender', function(position) {
                  control.setPosition(position);
                });
                if (control) {
                  control.on('picked', function(e) {
                    var coordinates = e.coordinates;
                    var lonlat = ol.proj.transform(coordinates, self.getProjection().getCode(), 'EPSG:4326');
                    position.lat = lonlat[1];
                    position.lng = lonlat[0];
                    streetViewService.showStreetView(position);
                  });
                  control.on('disabled', function() {
                    if (panorama) {
                      panorama = null;
                    }
                  })
                }
              }
            )
          }
          break;
        case 'scaleline':
          control = ControlsFactory.create({
            type: controlType,
            position: 'br'
          });
          self.addControl(controlType,control);
          break;
        case 'overview':
          if (!isMobile.any) {
            var overviewProjectGid = self.config.overviewproject.gid;
            if (overviewProjectGid) {
              ProjectsRegistry.getProject(overviewProjectGid)
              .then(function(project) {
                var overViewMapLayers = self.getOverviewMapLayers(project);
                control = ControlsFactory.create({
                  type: controlType,
                  position: 'bl',
                  className: 'ol-overviewmap ol-custom-overviewmap',
                  collapseLabel: $('<span class="glyphicon glyphicon-menu-left"></span>')[0],
                  label: $('<span class="glyphicon glyphicon-menu-right"></span>')[0],
                  collapsed: false,
                  layers: overViewMapLayers,
                  view: new ol.View({
                    projection: self.getProjection()
                  })
                });
                self.addControl(controlType,control);
              });
            }
          }
          break;
        case 'nominatim':
          control = ControlsFactory.create({
            type: controlType
          });
          control.on('addresschosen', function (evt) {
            var coordinate = evt.coordinate;
            var geometry =  new ol.geom.Point(coordinate);
            self.highlightGeometry(geometry);
          });
          self.addControl(controlType,control);
          $('#search_nominatim').click(function() {
            control.nominatim.query($('input.gcd-txt-input').val());
          });
          $('.gcd-txt-result').perfectScrollbar();
          break;
        case 'geolocation':
          // nel caso in cui esista il geolocation control o siamo sul mobile
          if (!isMobile.any) {
            // creo il controllo
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('click', function(evt) {
              self.showMarker(evt.coordinates);
            });
            control.on('error', function(e) {
              GUI.notify.error('Non è possibile calcolare la tua posizione. Si è verificato un errore di connessione al server')
            });
            self.addControl(controlType, control);
          }
          break;
        case 'addlayers':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            control.on('addlayer', function() {
              self.emit('addexternallayer');
            });
            self.addControl(controlType, control);
          }
          break;
        case 'length':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            self.addControl(controlType, control);
          }
          break;
        case 'area':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
            self.addControl(controlType, control);
          }
          break;
      }
    });
  }
};

// funzione che recupera i layers dagli stores
proto.getLayers = function(filter) {
  filter = filter || {};
  var mapFilter = {
    GEOLAYER: true,
    HIDDEN: false
  };
  filter = _.merge(filter, mapFilter);
  var layers = [];
  _.forEach(LayersStoreRegistry.getLayersStores(), function(layerStore) {
    _.merge(layers, layerStore.getLayers(filter));
  });
  return layers;
};

// verifica se esistono layer querabili che hanno wfs capabilities
proto.checkWFSLayers = function() {
  var iswfs = false;
  var layers = this.getLayers({
    QUERYABLE: true,
    SELECTEDORALL: true
  });
  _.forEach(layers, function(layer) {
    if (layer.getWfsCapabilities()) {
      iswfs = true;
      return false
    }
  });
  return iswfs
};

proto.addControl = function(type, control) {
  var self = this;
  this.viewer.map.addControl(control);
  this._mapControls.push({
    type: type,
    control: control,
    visible: true
  });
  control.on('controlclick', function() {
    self.controlClick();
  });
  // vado a registrare il controllo aggiunto
  ControlsRegistry.registerControl(type, control);
};

// mostra uno dei controlli disponibili (ovvero già istanziati in base alla configurazione)
proto.showControl = function(type) {
  this.showControls([type]);
};

// nasconde uno dei controlli disponibili (ovvero già istanziati in base alla configurazione)
proto.hideControl = function(type) {
  this.hideControls([type]);
};

// come sopra ma per un array di tipi di controlli. Es. mapService.showControls(['zoombox','query'])
proto.showControls = function(types) {
  this.toggleControls(true,types);
};

// come sopra ma per un array di tipi di controlli. Es. mapService.hideControls(['zoombox','query'])
proto.hideControls = function(types) {
 this.toggleControls(false,types);
};

// riattiva tutti i controlli disponibili
proto.showAllControls = function() {
  this.toggleControls(true);
};

// rimuove tutti i controlli
proto.hideAllControls = function() {
  this.toggleControls(false);
};

proto.toggleControls = function(toggle, types) {
  var self = this;
  this._removeControls();
  _.forEach(this._mapControls,function(controlObj){
    if (types) {
      if (types.indexOf(controlObj.type) > -1) {
        controlObj.visible = toggle;
      }
    }
    else {
      controlObj.visible = toggle;
    }
  });
  this._layoutControls();
};

proto._layoutControls = function() {
  var self = this;
  _.forEach(this._mapControls,function(controlObj){
    if (controlObj.visible) {
      self.viewer.map.addControl(controlObj.control);
    }
  })
};

proto.removeControl = function(type) {
  var self = this;
  _.forEach(this._mapControls,function(controlObj, ctrlIdx) {
    if (type == controlObj.type) {
      self._mapControls.splice(ctrlIdx,1);
      self.viewer.map.removeControl(controlObj.control);
      return false;
    }
  })
};

proto._removeControls = function() {
  var self = this;
  _.forEach(this._mapControls,function(controlObj){
    self.viewer.map.removeControl(controlObj.control);
  })
};

proto._unToggleControls = function() {
  _.forEach(this._mapControls,function(controlObj){
    if (controlObj.control.toggle) {
      controlObj.control.toggle(false);
    }
  })
};

proto.addMapLayer = function(mapLayer) {
  this._mapLayers.push(mapLayer);
};

proto.getMapLayers = function() {
  return this._mapLayers;
};

proto.getMapLayerForLayer = function(layer) {
  var mapLayer;
  var multilayerId = 'layer_'+layer.getMultiLayerId();
  _.forEach(this.getMapLayers(), function(_mapLayer) {
    if (_mapLayer.getId() == multilayerId) {
      mapLayer = _mapLayer;
      return false;
    }
  });
  return mapLayer;
};

proto.getProjectLayer = function(layerId) {
  return this.layersstore.getLayerById(layerId);
};

proto._resetView = function() {
  var width = this.viewer.map.getSize()[0];
  var height = this.viewer.map.getSize()[1];
  var extent = this.project.state.extent;
  var maxxRes = ol.extent.getWidth(extent) / width;
  var minyRes = ol.extent.getHeight(extent) / height;
  var maxResolution = Math.max(maxxRes,minyRes) > this.viewer.map.getView().getMaxResolution() ? Math.max(maxxRes,minyRes): this.viewer.map.getView().getMaxResolution();
  var view = new ol.View({
    extent: extent,
    projection: this.viewer.map.getView().getProjection(),
    center: this.viewer.map.getView().getCenter(),
    resolution: this.viewer.map.getView().getResolution(),
    maxResolution: maxResolution
  });
  this.viewer.map.setView(view);
};

// funzione che setta la view basata sulle informazioni del progetto
proto._setupViewer = function(width,height) {
  var self = this;
  var projection = this.getProjection();
  // ricavo l'estensione iniziale del progetto)
  var initextent = self.project.state.initextent;
  // ricavo l'estensione del progetto
  var extent = self.project.state.extent;

  var maxxRes = ol.extent.getWidth(extent) / width;
  var minyRes = ol.extent.getHeight(extent) / height;
  // calcolo la massima risoluzione
  var maxResolution = Math.max(maxxRes,minyRes);

  var initxRes = ol.extent.getWidth(initextent) / width;
  var inityRes = ol.extent.getHeight(initextent) / height;
  var initResolution = Math.max(initxRes,inityRes);

  this.viewer = ol3helpers.createViewer({
    id: this.target,
    view: {
      projection: projection,
      /*center: this.config.initcenter || ol.extent.getCenter(extent),
       zoom: this.config.initzoom || 0,
       extent: this.config.constraintextent || extent,
       minZoom: this.config.minzoom || 0, // default di OL3 3.16.0
       maxZoom: this.config.maxzoom || 28 // default di OL3 3.16.0*/
      center: ol.extent.getCenter(initextent),
      extent: extent,
      //minZoom: 0, // default di OL3 3.16.0
      //maxZoom: 28 // default di OL3 3.16.0
      maxResolution: maxResolution
    }
  });

  if (this.config.background_color) {
    $('#' + this.target).css('background-color', this.config.background_color);
  }

  $(this.viewer.map.getViewport()).prepend('<div id="map-spinner" style="position:absolute;right:0px;"></div>');

  this.viewer.map.getInteractions().forEach(function(interaction){
    self._watchInteraction(interaction);
  });

  this.viewer.map.getInteractions().on('add',function(interaction){
    self._watchInteraction(interaction.element);
  });

  this.viewer.map.getInteractions().on('remove',function(interaction){
    //self._onRemoveInteraction(interaction);
  });

  this.viewer.map.getView().setResolution(initResolution);

  this.viewer.map.on('moveend',function(e) {
    self._setMapView();
  });

  this._marker = new ol.Overlay({
    position: undefined,
    positioning: 'center-center',
    element: document.getElementById('marker'),
    stopEvent: false
  });

  this.viewer.map.addOverlay(this._marker);

  this.emit('ready');
};

proto._removeListeners = function() {

  if (this._setBaseLayerListenerKey) {
    this.project.un('setBaseLayer',this._setBaseLayerListenerKey);
  }
};

// vado a registrare tuti gli ebventi del layersStore
proto._removeEventsKeysToLayersStore = function(layerStore) {
  var self = this;
  var layerStoreId = layerStore.getId();
  if (self._layersStoresEventKeys[layerStoreId]) {
    _.forEach(self._layersStoresEventKeys[layerStoreId], function(eventObj) {
      _.forEach(eventObj, function(eventKey, event) {
        layerStore.un(event, eventKey);
      })
    })
  }
};

// vado a registrare tuti gli eventi del layersStore
proto._setUpEventsKeysToLayersStore = function(layerStore) {
  var self = this;
  var layerStoreId = layerStore.getId();
  if (!this._layersStoresEventKeys[layerStoreId]) {
    this._layersStoresEventKeys[layerStoreId] = [];
    var layerVisibleKey = layerStore.onafter('setLayersVisible', function (layersIds) {
      var mapLayers = _.map(layersIds, function(layerId) {
        var layer = layerStore.getLayerById(layerId);
        return self.getMapLayerForLayer(layer);
      });
      self.updateMapLayers(mapLayers);
    });
    this._layersStoresEventKeys[layerStore.getId()].push({
      setLayersVisible:layerVisibleKey
    });
  }
};

proto._setupListeners = function(){

  this._setBaseLayerListenerKey = this.project.onafter('setBaseLayer',function(){
    self.updateMapLayers(self.mapBaseLayers);
  });
};

proto._setupBaseLayers = function(){
  var self = this;
  var baseLayers = self.getLayers({
    BASELAYER: true
  });
  if (!baseLayers.length){
    return;
  }
  this.mapBaseLayers = {};
  _.forEach(baseLayers,function(layer){

    if (layer.isWMS()) {
      var config = {
        url: layer.getWmsUrl(),
        id: layer.state.id,
        tiled: layer.state.tiled
      };
      var mapLayer = new WMSLayer(config);
    }

    else {
      switch(layer.getServerType()){
        case 'OSM':
          var OSMLayer = require('core/map/layer/osmlayer');
          var mapLayer = new OSMLayer({
            id: layer.state.id
          });
          break;
        case 'Bing':
          var BingLayer = require('core/map/layer/binglayer');
          var mapLayer = new BingLayer({
            id: layer.state.id
          });
          break;
      }
    }

    self.addMapLayer(mapLayer);
    self.registerListeners(mapLayer);
    mapLayer.addLayer(layer);
    self.mapBaseLayers[layer.getId()] = mapLayer;
  });

  _.forEach(_.values(this.mapBaseLayers).reverse(),function(mapLayer){
    self.viewer.map.addLayer(mapLayer.getOLLayer());
    mapLayer.update(self.state);
  });
};

proto._setupLayers = function(){
  var self = this;
  this.viewer.removeLayers();
  this._setupBaseLayers();
  this._reset();
  // recupero i layers dai vari layerstore mettendo coem condizione HIDDEN e GEOLAYER
  var layers = this.getLayers();
  //raggruppo per valore del multilayer con chiave valore multilayer
  // e valore array
  var multiLayers = _.groupBy(layers, function(layer){
    return layer.getMultiLayerId();
  });
  //una volta raggruppati per multilayer dove la chiave è il valore del multilayer
  // e il valore è un array di uno o più Layers, distinguo tra layers singoli o multipli e tra layer cachati o non
  _.forEach(multiLayers, function(layers, id) {
    var multilayerId = 'layer_'+id;
    var mapLayer;
    var layer = layers[0];
    if (layers.length == 1 && layer.isCached()) {
      mapLayer = new XYZLayer({
        id: multilayerId,
        projection: self.getProjection()
      });
      self.addMapLayer(mapLayer);
      self.registerListeners(mapLayer);
      mapLayer.addLayer(layer);
    }
    // in casi di multilayers
    else {
      // creo configurazione per costruire il layer wms
      //creo il wms layer
      mapLayer = new WMSLayer({
        // getWMSUrl funzione creata in fase di inizializzazione dell'applicazione
        url: layer.getWmsUrl(),
        id: multilayerId
      }, self.layersExtraParams);
      self.addMapLayer(mapLayer);
      self.registerListeners(mapLayer);
      // lo aggiungo alla lista dei mapLayers
      _.forEach(layers.reverse(), function(sub_layer) {
        // per ogni layer appartenete allo stesso multilayer (è un array)
        // viene aggiunto al mapLayer (WMSLayer) perecedentemente creato
        mapLayer.addLayer(sub_layer);
      });
    }
  });

  // una volta creati tutti i mapLayer apparteneti alla mappa
  _.forEach(this.getMapLayers().reverse(), function(mapLayer) {
    // scorro sui mapLayer (reverse) e aggiungo alla mappa
    self.viewer.map.addLayer(mapLayer.getOLLayer());
    mapLayer.update(self.state, self.layersExtraParams);
  });
  return this.mapLayers;
};

proto.getOverviewMapLayers = function(project) {
  var projectLayers = project.getLayersStore().getLayers({
    VISIBLE: true,
    GEOLAYER: true,
    HIDDEN: false
  });
  

  var multiLayers = _.groupBy(projectLayers,function(layer){
    return layer.getMultiLayerId();
  });
  
  var overviewMapLayers = [];
  _.forEach(multiLayers,function(layers,id){
    var multilayerId = 'overview_layer_'+id;
    var tiled = layers[0].state.tiled;
    var config = {
      url: project.getWmsUrl(),
      id: multilayerId,
      tiled: tiled
    };
    var mapLayer = new WMSLayer(config);
    _.forEach(layers.reverse(),function(layer){
      mapLayer.addLayer(layer);
    });
    overviewMapLayers.push(mapLayer.getOLLayer(true));
  });
  
  return overviewMapLayers.reverse();
};

proto.updateMapLayers = function(mapLayers) {
  var self = this;
  _.forEach(mapLayers, function(mapLayer) {
    mapLayer.update(self.state, self.layersExtraParams);
  })
};
// funzione che registra i listeners sulla creazione del mapLayers
proto.registerListeners = function(mapLayer) {

  var self = this;
  mapLayer.on('loadstart',function(){
    self._incrementLoaders();
  });
  mapLayer.on('loadend',function(){
    self._decrementLoaders(false);
  });
  
  this.on('extraParamsSet',function(extraParams,update){
    if (update) {
      mapLayer.update(this.state,extraParams);
    }
  })
};

proto.setTarget = function(elId){
  this.target = elId;
};

proto.addInteraction = function(interaction) {
  this._unToggleControls();
  this.viewer.map.addInteraction(interaction);
  interaction.setActive(true);
};

proto.removeInteraction = function(interaction){
  this.viewer.map.removeInteraction(interaction);

};

// emetto evento quando viene attivata un interazione di tipo Pointer
// (utile ad es. per disattivare/riattivare i tool di editing)
proto._watchInteraction = function(interaction) {
  var self = this;
  interaction.on('change:active',function(e) {
    if ((e.target instanceof ol.interaction.Pointer) && e.target.getActive()) {
      self.emit('pointerInteractionSet',e.target);
    }
  })
};

proto.goTo = function(coordinates,zoom) {
  var options = {
    zoom: zoom || 6
  };
  this.viewer.goTo(coordinates,options);
};

proto.goToRes = function(coordinates,resolution){
  var options = {
    resolution: resolution
  };
  this.viewer.goToRes(coordinates,options);
};

proto.goToBBox = function(bbox) {
  this.viewer.fit(bbox);
};


proto.goToWGS84 = function(coordinates,zoom){
  var coordinates = ol.proj.transform(coordinates,'EPSG:4326','EPSG:'+this.project.state.crs);
  this.goTo(coordinates,zoom);
};

proto.extentToWGS84 = function(extent){
  return ol.proj.transformExtent(extent,'EPSG:'+this.project.state.crs,'EPSG:4326');
};

proto.getResolutionForMeters = function(meters) {
  var viewport = this.viewer.map.getViewport();
  return meters / Math.max(viewport.clientWidth,viewport.clientHeight);
};

var highlightLayer = null;
var animatingHighlight = false;

proto.highlightGeometry = function(geometryObj,options) {
  var self = this;
  this.clearHighlightGeometry();
  var options = options || {};
  var zoom = (typeof options.zoom == 'boolean') ? options.zoom : true;
  var highlight = (typeof options.highlight == 'boolean') ? options.highlight : true;
  var duration = options.duration || 2000;
  var view = this.viewer.map.getView();
  
  var geometry;
  if (geometryObj instanceof ol.geom.Geometry){
    geometry = geometryObj;
  }
  else {
    var format = new ol.format.GeoJSON;
    geometry = format.readGeometry(geometryObj);
  }

  if (options.fromWGS84) {
    geometry.transform('EPSG:4326','EPSG:'+ProjectService.state.project.crs);
  }
  
  var geometryType = geometry.getType();
  if (zoom) {
    if (geometryType == 'Point' || (geometryType == 'MultiPoint' && geometry.getPoints().length == 1)) {
      var coordinates = geometryType == 'Point' ? geometry.getCoordinates() : geometry.getPoint(0).getCoordinates();
      if (this.project.state.crs != 4326 && this.project.state.crs != 3857) {
        // zoom ad una risoluzione in cui la mappa copra 100m
        var res = this.getResolutionForMeters(100);
        self.goToRes(coordinates,res);
      }
      else {
        zoom = self.viewer.map.getView().getZoom() > 6 ? self.viewer.map.getView().getZoom() : 6;
        self.goTo(coordinates, zoom);
      }
    }
    else {
      this.viewer.fit(geometry,options);
    }
  }

  if (highlight) {
    var feature = new ol.Feature({
      geometry: geometry
    });

    if (!highlightLayer) {
      highlightLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: function(feature){
          var styles = [];
          var geometryType = feature.getGeometry().getType();
          if (geometryType == 'LineString' || geometryType == 'MultiLineString') {
            var style = new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'rgb(255,255,0)',
                width: 4
              })
            });
            styles.push(style);
          }
          else if (geometryType == 'Point' || geometryType == 'MultiPoint') {
            var style = new ol.style.Style({
              image: new ol.style.Circle({
                radius: 6,
                fill: new ol.style.Fill({
                  color: 'rgb(255,255,0)'
                })
              }),
              zIndex: Infinity
            });
            styles.push(style);
          } else if (geometryType == 'MultiPolygon' || geometryType == 'Polygon') {
            var style = new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'rgb(255,255,0)',
                width: 4
              }),
              fill: new ol.style.Fill({
                color: 'rgba(255, 255, 0, 0.5)'
              })
            });
            styles.push(style);
          }
          return styles;
        }
      });
      highlightLayer.setMap(this.viewer.map);
    }

    highlightLayer.getSource().clear();
    highlightLayer.getSource().addFeature(feature);

    if (duration) {
      animatingHighlight = true;
      setTimeout(function(){
        highlightLayer.getSource().clear();
        animatingHighlight = false;
      },duration);
    }
  }
};

proto.clearHighlightGeometry = function() {
  if (highlightLayer && ! animatingHighlight) {
    highlightLayer.getSource().clear();
  }
};

proto.refreshMap = function() {
  _.forEach(this._mapLayers, function(wmsLayer) {
    wmsLayer.getOLLayer().getSource().updateParams({"time": Date.now()});
  });
};

// funzione mi server per poter in pratica
// fare l'updatesize della mappa qundo il div che la contine cambia
// in questo modo la mappa non si streccia (chimata dalla viewport)
proto.layout = function(width, height) {
  if (!this.viewer) {
    this.setupViewer(width,height);
  }
  if (this.viewer) {
    this.setHidden((width == 0 || height == 0));
    this.getMap().updateSize();
    this._setMapView();
  }
};

proto._reset = function() {
  this._mapLayers = [];
};

proto._setMapView = function() {
  var bbox = this.viewer.getBBOX();
  var resolution = this.viewer.getResolution();
  var center = this.viewer.getCenter();
  this.setMapView(bbox, resolution, center);
};

proto.getMapSize = function() {
  var map = this.viewer.map;
  return map.getSize();
};

proto.setInnerGreyCoverScale = function(scale) {
  this._drawShadow.scale = scale;
};

proto._resetDrawShadowInner = function() {
  this._drawShadow = {
    type: 'coordinate',
    outer: [],
    inner: [],
    scale: null,
    rotation: null
  };
};

proto.setInnerGreyCoverBBox = function(options) {
  var options = options || {};
  var map = this.viewer.map;
  var type = options.type || 'coordinate'; // di solito sollo coordinate
  var inner = options.inner || null;
  var rotation = options.rotation;
  var scale = options.scale;
  var lowerLeftInner;
  var upperRightInner;
  if (inner) {
    switch (type) {
      case 'coordinate':
        lowerLeftInner = map.getPixelFromCoordinate([inner[0], inner[1]]);
        upperRightInner = map.getPixelFromCoordinate([inner[2], inner[3]]);
        break;
      case 'pixel':
        lowerLeftInner = [inner[0], inner[1]];
        upperRightInner = [inner[2], inner[3]];
        break
    }
    var y_min = lowerLeftInner[1] * ol.has.DEVICE_PIXEL_RATIO;
    var x_min = lowerLeftInner[0] * ol.has.DEVICE_PIXEL_RATIO;
    var y_max = upperRightInner[1] * ol.has.DEVICE_PIXEL_RATIO;
    var x_max = upperRightInner[0] * ol.has.DEVICE_PIXEL_RATIO;
    this._drawShadow.inner[0] = x_min;
    this._drawShadow.inner[1] = y_min;
    this._drawShadow.inner[2] = x_max;
    this._drawShadow.inner[3] = y_max;
  }
  if (_.isNil(scale)) {
    this._drawShadow.scale = this._drawShadow.scale || 1;
  } else {
    this._drawShadow.scale = scale;
  }
  if (_.isNil(rotation)) {
    this._drawShadow.rotation = this._drawShadow.rotation || 0;
  } else {
    this._drawShadow.rotation = rotation;
  }
  if (this._drawShadow.outer) {
    map.render();
  }
};

// funzione grigio mappa precompose mapcompose
proto.startDrawGreyCover = function() {
  var self = this;
    // after rendering the layer, restore the canvas context
  var map = this.viewer.map;
  var x_min, x_max, y_min, y_max, rotation, scale;
  //verifico che non ci sia già un greyListener
  if (this._greyListenerKey) {
      this.stopDrawGreyCover();
  }

  function postcompose(evt) {
    var ctx = evt.context;
    var size = this.getSize();
    // Inner polygon,must be counter-clockwise
    var height = size[1] * ol.has.DEVICE_PIXEL_RATIO;
    var width = size[0] * ol.has.DEVICE_PIXEL_RATIO;
    self._drawShadow.outer = [0,0,width, height];
    ctx.restore();
    ctx.beginPath();
    // Outside polygon, must be clockwise
    ctx.moveTo(0, 0);
    ctx.lineTo(width, 0);
    ctx.lineTo(width, height);
    ctx.lineTo(0, height);
    ctx.lineTo(0, 0);
    ctx.closePath();
    // fine bbox esterno (tutta la mappa-)
    if (self._drawShadow.inner.length) {
      ctx.save();
      x_min = self._drawShadow.inner[0];
      y_min = self._drawShadow.inner[3];
      x_max = self._drawShadow.inner[2];
      y_max = self._drawShadow.inner[1];
      rotation = self._drawShadow.rotation;
      scale = self._drawShadow.scale;
      // Inner polygon,must be counter-clockwise antiorario
      ctx.translate((x_max+x_min)/2, (y_max+y_min)/2);
      ctx.rotate(rotation*Math.PI / 180);
      ctx.moveTo(-((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.lineTo(((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.lineTo(((x_max-x_min)/2),-((y_max-y_min)/2));
      ctx.lineTo(-((x_max-x_min)/2),-((y_max-y_min)/2));
      ctx.lineTo(-((x_max-x_min)/2),((y_max-y_min)/2));
      ctx.closePath();
      // fine bbox interno
    }
    ctx.fillStyle = 'rgba(0, 5, 25, 0.40)';
    ctx.fill();
    ctx.restore();
  }
  this._greyListenerKey = map.on('postcompose', postcompose);
};

proto.stopDrawGreyCover = function() {
  var map = this.viewer.map;
  ol.Observable.unByKey(this._greyListenerKey);
  this._greyListenerKey = null;
  if (this._drawShadow.inner.length) {
    this._resetDrawShadowInner();
  }
  map.render();
};

// funzione che rimuove layer aggiunti esterni
proto.removeExternalLayer = function(name) {
  var layer = this.getLayerByName(name);
  var catalogService = GUI.getComponent('catalog').getService();
  var QueryResultService = GUI.getComponent('queryresults').getService();
  QueryResultService.unregisterVectorLayer(layer);
  this.viewer.map.removeLayer(layer);
  catalogService.removeExternalLayer(name);
};

// funzione che aggiunge layer esterni
proto.addExternalLayer = function(externalLayer) {

  //funzione che mippermette di fare il loadind del layer sulla mappa
  function loadExternalLayer(format, data) {
    features = format.readFeatures(data, {
      dataProjection: 'EPSG:'+ crs,
      featureProjection: self.getEpsg()
    });
    vectorSource = new ol.source.Vector({
      features: features
    });
    vectorLayer = new ol.layer.Vector({
      source: vectorSource,
      //style: styleFunction,
      name: name
    });
    //vado a settare il colore al vector layer
    vectorLayer.setStyle(self.setExternalLayerColor(color));
    extent = vectorLayer.getSource().getExtent();
    //setto il bbox perchè mi servirà nel catalog
    externalLayer.bbox = {
      minx: extent[0],
      miny: extent[1],
      maxx: extent[2],
      maxy: extent[3]
    };
    map.addLayer(vectorLayer);
    //vado a registrae il layer vettoriale per la query
    QueryResultService.registerVectorLayer(vectorLayer);
    //vado ad aggiungere il layer esterno
    catalogService.addExternalLayer(externalLayer);
    map.getView().fit(vectorSource.getExtent());
  }

  var self = this;
  var format,
    features,
    vectorSource,
    vectorLayer,
    extent;
  var map = this.viewer.map;
  var name = externalLayer.name;
  var color = externalLayer.color;
  var type = externalLayer.type;
  var crs = externalLayer.crs;
  var data = externalLayer.data;
  var catalogService = GUI.getComponent('catalog').getService();
  var QueryResultService = GUI.getComponent('queryresults').getService();
  // cerco di verificare se esiste già un layer nella mappa
  var layer = this.getLayerByName(name);
  // aggiungo solo nel caso di layer non presente
  if (!layer) {
    // nel caso in cui i sistemi di riferimento del layer e della mappa sono diversi
    // vado a definirne il sistema (caso a sistemi di proiezione non standard in OL3 diversi da 3857 e 4326)
    if (crs != self.getCrs()) {
      self.defineProjection(crs);
    }
    //verifico il tipo di file uplodato
    switch (type) {
      case 'geojson':
        format = new ol.format.GeoJSON();
        loadExternalLayer(format, data);
        break;
      case 'kml':
        format = new ol.format.KML({
          extractStyles: false
        });
        loadExternalLayer(format, data);
        break;
      case 'zip':
        // qui non specifico l'epsg in quanto lo legge da solo
        // dal file prj
        var geoJSONFile;
        loadshp({
          url: data,
          encoding: 'big5',
          EPSG: crs
        }, function(geojson) {
          if (!geoJSONFile) {
            geoJSONFile = geojson;
            crs = '4326';
            data = JSON.stringify(geojson);
            format = new ol.format.GeoJSON();
            loadExternalLayer(format, data);
          }
        });
        break;
    }
  } else {
    GUI.notify.info('Layer già aggiunto');
  }
};

// setta il colore al layer caricati esternamente
proto.setExternalLayerColor = function(color) {
  // stile
  var color = color.rgba;
  color = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ','  + color.a + ')';
  var defaultStyle = {
    'Point': new ol.style.Style({
      image: new ol.style.Circle({
        fill: new ol.style.Fill({
          color: color
        }),
        radius: 5,
        stroke: new ol.style.Stroke({
          color: color,
          width: 1
        })
      })
    }),
    'LineString': new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'Polygon': new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(255,255,255,0.5)'
      }),
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'MultiPoint': new ol.style.Style({
      image: new ol.style.Circle({
        fill: new ol.style.Fill({
          color: color
        }),
        radius: 5,
        stroke: new ol.style.Stroke({
          color: color,
          width: 1
        })
      })
    }),
    'MultiLineString': new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'MultiPolygon': new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(255,255,255,0.5)'
      }),
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    })
  };
  var styleFunction = function(feature, resolution) {
    var featureStyleFunction = feature.getStyleFunction();
    if (featureStyleFunction) {
      return featureStyleFunction.call(feature, resolution);
    } else {
      return defaultStyle[feature.getGeometry().getType()];
    }
  };

  return styleFunction
};

module.exports = MapService;

},{"core/applicationservice":22,"core/g3wobject":34,"core/layers/layer":43,"core/layers/layersstoresregistry":45,"core/map/layer/binglayer":54,"core/map/layer/osmlayer":58,"core/map/layer/vectorlayer":59,"core/map/layer/wmslayer":60,"core/map/layer/xyzlayer":61,"core/project/projectsregistry":69,"core/query/queryservice":74,"core/utils/utils":77,"g3w-ol3/src/g3w.ol3":93,"gui/gui":118,"gui/map/control/factory":121,"gui/map/control/registry":122,"gui/streetview/streetviewservice":150}],124:[function(require,module,exports){
module.exports = "<!-- Modal -->\n<div class=\"modal fade\" id=\"modal-addlayer\" role=\"dialog\">\n  <div class=\"modal-dialog\">\n    <!-- Modal content-->\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\">&times;</button>\n        <h4 class=\"modal-title\">Aggiungi Layer</h4>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"form-group\">\n          <label for=\"proiezione-layer\">Seleziona il sistema di proiezione del layer</label>\n          <select class=\"form-control\" id=\"proiezione-layer\" v-model=\"layer.crs\">\n            <option value=\"3003\">EPSG:3003</option>\n            <option value=\"3857\">EPSG:3857</option>\n            <option value=\"4326\">EPSG:4326</option>\n          </select>\n        </div>\n        <p style=\"font-weight: 700;\">Seleziona il colore del layer</p>\n        <chrome-picker v-model=\"layer.color\" @change-color=\"onChangeColor\" style=\"width:90%;margin:auto\"></chrome-picker>\n        <form id=\"addcustomlayer\">\n          <input type=\"file\" title=\" \" @change=\"onAddLayer($event)\" accept=\".kml,.geojson, .KML, .GEOJSON, .zip\">\n          <h4>Trascina qui il file o clicca sull'area</h4>\n          <h4 v-if=\"layer.name\">{{ layer.name }}</h4>\n          <div>\n            <i class=\"fa fa-cloud-upload fa-5x\" aria-hidden=\"true\"></i>\n          </div>\n          <p>.geojson, .kml, .zip(shapefile)</p>\n        </form>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default pull-left\" @click=\"addLayer\" data-dismiss=\"modal\">Aggiungi</button>\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\" @click=\"clearLayer\">Chiudi</button>\n      </div>\n    </div>\n  </div>\n</div>";

},{}],125:[function(require,module,exports){
module.exports = "<div :id=\"target\" style=\"width:100%;height:100%\">\n  <div style=\"display: none;\">\n    <div id=\"marker\"></div>\n  </div>\n  <addlayer :service=\"service\"></addlayer>\n</div>\n\n\n";

},{}],126:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var MapService = require('../mapservice');
//componente vue.color
var ChromeComponent = VueColor.Chrome;
// setto la funzione mounted così tutti i componenti erediteranno da questo
ChromeComponent.mounted =  function() {
  this.$nextTick(function() {
    //vado a rimuovere elementi che non mi servono
    $('.vue-color__chrome__toggle-btn').remove();
    $('.vue-color__editable-input__label').remove();
    $('.vue-color__chrome__saturation-wrap').css('padding-bottom','100px');
    $('.vue-color__chrome').css({
      'box-shadow': '0 0 0 0',
      'border': '1px solid #97A1A8'
    });
  });
};

var AddLayerComponent = {
  template: require('./addlayer.html'),
  props: ['service'],
  data: function() {
    return {
      layer: {
        name: null,
        type: null,
        crs: null,
        color: {
          hex: '#194d33',
          rgba: {
            r: 25,
            g: 77,
            b: 51,
            a: 1
          },
          a: 1
        },
        data: null,
        visible: true,
        title: null,
        id: null,
        external: true
      }
    }
  },
  components: {
    'chrome-picker': ChromeComponent
  },
  mounted: function(){
    this.layer.crs = this.service.getCrs();
    this.service.on('addexternallayer', function() {
      $('#modal-addlayer').modal('show');
    });
  },
  methods: {
    onChangeColor: function(val) {
      this.layer.color = val;
    },
    onAddLayer: function(evt) {
      var self = this;
      var reader = new FileReader();
      var name = evt.target.files[0].name;
      this.layer.name = name;
      this.layer.title = name;
      this.layer.id = name;
      var type = evt.target.files[0].name.split('.');
      this.layer.type = type[type.length-1].toLowerCase();
      if (this.layer.type == 'zip') {
        self.layer.data = evt.target.files[0];
        $('input:file').val(null);
      } else {
        reader.onload = function(evt) {
          self.layer.data = evt.target.result;
          // vado a rimuovere il valore del layer ultimo aggiunto per
          // fare in mdo che l'evento change possa scattare
          $('input:file').val(null);
        };
        reader.readAsText(evt.target.files[0]);
      }
    },
    addLayer: function() {
      if (this.layer.name) {
        //devo fare il cloen al fine di evitare che quando
        // riapro la modale ci si sempre il
        var layer = _.cloneDeep(this.layer);
        this.service.addExternalLayer(layer);
        $('#modal-addlayer').modal('hide');
        this.clearLayer();
      }
    },
    clearLayer: function() {
      this.layer.name = null;
      this.layer.title = null;
      this.layer.id = null;
      this.layer.type = null;
      this.layer.crs = this.service.getCrs();
      this.layer.color = {
        hex: '#194d33',
          rgba: {
          r: 25,
            g: 77,
            b: 51,
            a: 1
        },
        a: 1
      };
      this.layer.data = null;
    }
  }
};

// componente vue della mappa
var vueComponentOptions = {
  template: require('./map.html'),
  data: function() {
    return {
      target: 'map', // specidica l'id
      service: this.$options.mapService
    }
  },
  components: {
    'addlayer': AddLayerComponent
  },
  mounted: function() {
    var self = this;
    var mapService = this.$options.mapService;
    this.crs = mapService.getCrs();
    this.$nextTick(function() {
      mapService.setTarget(self.$el.id);
    });
    // questo serve per quando viene cambiato progetto/vista cartografica,
    // in cui viene ricreato il viewer (e quindi la mappa)
    mapService.onafter('setupViewer',function() {
      mapService.setTarget(self.$el.id);
    });
  }
};
// registro internamente
var InternalComponent = Vue.extend(vueComponentOptions);
// viene definito il componte map
Vue.component('g3w-map', vueComponentOptions);
//componente mappa
function MapComponent(options) {
  base(this, options);
  this.id = "map-component";
  this.title = "Catalogo dati";
  this.target = options.target || 'map';
  this.setService(new MapService(options));
  merge(this, options);
  this.internalComponent = new InternalComponent({
    mapService: this._service // definisco il mapservice
  });
  this.internalComponent.target = this.target;
}

inherit(MapComponent, Component);

var proto = MapComponent.prototype;
// funzione che ne definisce il layout della mappa
// ed è chamata dall viewport per risettare le size delle due view
proto.layout = function(width, height) {
  // setto alterzza e larghezza nuove
  $('#'+this.target).height(height);
  $('#'+this.target).width(width);
  this._service.layout(width,height);
};

module.exports =  MapComponent;


},{"../mapservice":123,"./addlayer.html":124,"./map.html":125,"core/utils/utils":77,"gui/vue/component":156}],127:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var resolvedValue = require('core/utils/utils').resolve;
var G3WObject = require('core/g3wobject');

var Panel = function(options) {
  this.internalPanel = null;
  var options = options || {};
  this.id = options.id || null;
  this.title = options.title || '';
};

inherit(Panel, G3WObject);

var proto = Panel.prototype;

proto.getId = function(){
  return this.id;
};

proto.getTitle = function(){
  return this.title;
};

proto.getInternalPanel = function() {
  return this.internalPanel;
};

proto.setInternalPanel = function(internalPanel) {
  this.internalPanel = internalPanel;
};

/* HOOKS */

/*
 * Il metodo permette al pannello di montarsi nel DOM
 * parent: elemento DOM padre, su cui inserirsi;
 * ritorna una promise, risolta nel momento in cui sarà terminato il montaggio
*/

// SONO DUE TIPOLOGIE DI MONTAGGIO CON IL QUALE IL PANNELLO
// CHE VERRA' MONTATO AL VOLO CON IL METODO MOUNT A SECONDA DEL TIPO DI PANNELLO RICHIESTO

// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso

proto.mount = function(parent) {
  var panel = this.internalPanel;
  var iCinstance = panel.$mount();
  $(parent).append(iCinstance.$el);
  iCinstance.$nextTick(function(){
    $(parent).localize();
    if (panel.onShow) {
      panel.onShow();
    }
  });
  return resolvedValue(true);
};

/*
 * Metodo richiamato quando si vuole rimuovere il panello.
 * Ritorna una promessa che sarà risolta nel momento in cui il pannello avrà completato la propria rimozione (ed eventuale rilascio di risorse dipendenti)
*/
proto.unmount = function() {
  var panel = this.internalPanel;
  var deferred = $.Deferred();
  panel.$destroy(true);
  $(panel.$el).remove();
  // lo setta di nuovo a null
  if (panel.onClose) {
    panel.onClose();
  }
  this.internalComponent = null;
  deferred.resolve();
  return deferred.promise();
};

/*
 * Metodo (opzionale) che offre l'opportunità di ricalcolare proprietà dipendenti dalle dimensioni del padre
 * parentHeight: nuova altezza del parent
 * parentWidth: nuova larghezza del parent
 * richiamato ogni volta che il parent subisce un ridimensionamento
*/
proto.onResize = function(parentWidth,parentHeight){};


module.exports = Panel;

},{"core/g3wobject":34,"core/utils/utils":77}],128:[function(require,module,exports){
var scale = [
  {
    value:500,
    label:'1:500'
  },
  {
    value:1000,
    label:'1:1.000'
  },
  {
    value:2000,
    label:'1:2.000'
  },
  {
    value:2500,
    label:'1:2.500'
  },
  {
    value:5000,
    label:'1:5.000'
  },
  {
    value:10000,
    label:'1:10.000'
  },
  {
    value:25000,
    label:'1:25.000'
  },
  {
    value:50000,
    label:'1:50.000'
  },
  {
    value:100000,
    label:'1:100.000'
  },
  {
    value:250000,
    label:'1:250.000'
  },
  {
    value:500000,
    label:'1:500.000'
  },
  {
    value:1000000,
    label:'1:1.000.000'
  }
];
var dpis = [150, 300];

module.exports = {
  scale: scale,
  dpis: dpis
};

},{}],129:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var PrintService = require('core/print/printservice');
var resToScale = require('core/utils/geo').resToScale;
var scaleToRes = require('core/utils/geo').scaleToRes;
var printConfig = require('./printconfig');
var PrintPage = require('./vue/printpage');
var scale = printConfig.scale;
var dpis = printConfig.dpis;


function PrintComponentService() {
  base(this);
  // mi dice se è stato inizilizzato o meno
  this._initialized = false;
  // inizializzo lo state
  this.state = {};
  this._moveMapKeyEvent = null;
  // istanzio il componete page per la visualizzazione del pdf
  this._page = null;
  this._mapService = null;
  this._map = null;
  this._isOpen = false;
  // oggetto che va a mappare scale e risoluzione
  // si aggiornerà via via che verranno fatti zoom in e zoom out
  // tramite l'evento moveend
  this._scalesResolutions = {};
  // inizializzazione
  this.init = function() {
    // recupero il project
    this._project = ProjectsRegistry.getCurrentProject();
    // prendo le informazioni del print
    this.state.print = this._project.state.print;
    // setto lo state visible
    this.state.visible = (this.state.print && this.state.print.length) ? true : false;
    this.state.isShow = false;
    this.state.loading = false;
    this.state.url = null;
    if (this.state.visible) {
      // Imposto le configurazioni inziali da rivedere
      this.state.template = this.state.print[0].name;
      this.state.rotation = 0;
      this.state.inner = null;
      this.state.center = null;
      this.state.size = null;
      this.state.scale = scale;
      this.state.scala = null;
      this.state.dpis = dpis;
      this.state.dpi = dpis[0];
      this.state.map = null;//;this.state.print[0].maps[0].name;
      this.state.width = null;//this.state.print[0].maps[0].w;
      this.state.height = null;//this.state.print[0].maps[0].h;
    }
  };
  // metodo per il cambio di template
  this.changeTemplate = function() {
    var self = this;
    if (!this.state.template) return;
    var template = this.state.template;
    _.forEach(this.state.print, function(print) {
      if (print.name == template) {
        // al momento hardcoded mpa0
        self.state.width = print.maps[0].w;
        self.state.height = print.maps[0].h;
        self.state.map = print.maps[0].name;
      }
    });
    this._setPrintArea();
  };

  // metodo per il cambio di scala attraverso la select
  this.changeScale = function() {
    if (!this.state.scala) return;
    // vado a cambiare la print area
    this._setPrintArea();
  };

  // metodo per il cambio di rotazione
  this.changeRotation = function() {
    this._mapService.setInnerGreyCoverBBox({
      rotation: this.state.rotation
    });
    this._changePrintOutput();
  };

  // funzione che restituisce le options del print
  this._getOptionsPrint = function() {
    var options = {
      scale: this.state.scala, // scala scelta
      extent: this.state.inner.join(), // estensione
      rotation: this.state.rotation, // rotazione
      dpi: this.state.dpi,// dpi
      template: this.state.template, // nome template
      map: this.state.map // tipo mappa (sempre map0)
    };
    return options;
  };

  // funzione print
  this.print = function() {
    var self = this;
    this._page = new PrintPage({
      service: self
    });
    var options = this._getOptionsPrint();
    // apro il content
    GUI.setContent({
      content: self._page,
      title: 'Stampa',
      perc:100
    });
    PrintService.print(options)
    .then(function(data, status, xhr) {
      // setto l'url
      self.state.url = this.url;
    })
    .fail(function() {
      GUI.notify.error('Si è verificato un errore nella richiesta al server');
      GUI.closeContent();
    })
  };

  this._calculateInternalPrintExtent = function(resolution) {
    // rapporto tra largheza e altezza della mappa nel template
    var rapportoMappaTemplate = this.state.width/this.state.height;
    // rapporto larghezza e altezza della mappa nel client (viewport)
    var rapportoMappaClient = this.state.size[0]/this.state.size[1];
    var width, height;
    if (rapportoMappaClient > 1) { // mappa orizzontale
      if (rapportoMappaTemplate > 1) {
        if (rapportoMappaTemplate > rapportoMappaClient) {
          width = this.state.size[0] / 2; // numero di pixel raggio larghezza
        } else {
          width = (this.state.size[0] * (rapportoMappaTemplate/rapportoMappaClient))/2;
        }
        // setto un padding
        width = width - parseInt(width/10);

        height = width / rapportoMappaTemplate; // numero di pixel raggio altezza
      } else {
        height = this.state.size[1] / 2; // numero di pixel raggio larghezza
        // setto un padding
        height = height - parseInt(height/10);
        width = height * rapportoMappaTemplate ; // numero di pixel raggio altezza
      }
    } else { // mappa verticale
      if (rapportoMappaTemplate > 1) {
        width = this.state.size[0] / 2; // numero di pixel raggio larghezza
        // setto un padding
        width = width - parseInt(width/10);

        height = width / rapportoMappaTemplate; // numero di pixel raggio altezza
      } else {
        if (rapportoMappaTemplate < rapportoMappaClient) {
          height = this.state.size[1] / 2; // numero di pixel raggio larghezza
        } else {
          height = (this.state.size[1] * (rapportoMappaClient/rapportoMappaTemplate))/2;
        }
        // setto un padding
        height = height - parseInt(height/10);
        width = height * rapportoMappaTemplate ; // numero di pixel raggio altezza
      }
    }
    // vado a calcolare la x_min e x_max
    x_min = this.state.center[0] - (width*resolution);
    x_max = this.state.center[0] + (width*resolution);
    // vado a caloclare la y_min e y_max
    y_min = this.state.center[1] - (height*resolution);
    y_max = this.state.center[1] + (height*resolution);
    this.state.inner =  [x_min, y_min, x_max, y_max];
  };

  // funzione che setta il BBOX della printArea
  this._setPrintArea = function() {
    // size della mappa
    this.state.size = this._map.getSize();
    this.state.currentScala = resToScale(this._map.getView().getResolution());
    // centro della mappa
    this.state.center = this._map.getView().getCenter();
    // vado a prendere la risoluzione dell'area
    var resolution = scaleToRes(this.state.scala);
    this._calculateInternalPrintExtent(resolution);
    this._mapService.setInnerGreyCoverBBox({
      inner: this.state.inner,
      rotation: this.state.rotation
    });
  };

  // metodo chiusura print panel
  this._clearPrint = function() {
    // rimovo l'evento movend della mappa
    ol.Observable.unByKey(this._moveMapKeyEvent);
    // lo setto a null
    this._moveMapKeyEvent = null;
    // dico al mapservice di fermare il disegno del print area
    this._mapService.stopDrawGreyCover();
  };

  // funzione che fa il change dell'ouput pdf quando
  // ci spostiamo nella mappa o cambiano i parametri del print
  // al momento non usata
  this._changePrintOutput = function() {
    var self = this;
    // verifico se l'otuput pdf è visibile
    if (this.state.isShow) {
      this.state.loading = true;
      var options = this._getOptionsPrint();
      PrintService.print(options)
        .then(function (url) {
          if (self.state.url == url) {
            self.state.loading = false;
          }
          self.state.url = url;
        })
    }
  };

  // la funzione mi serve per adattare le scale da visulzizzare in base alle
  // varie risoluzione della mappa basate su maResolution della view
  this._setAllScalesBasedOnMaxResolution = function(maxResolution) {
    var self = this;
    var resolution = maxResolution;
    var mapScala = resToScale(resolution);
    // ordino le scale dal più grande al più piccolo
    var orderScales = _.orderBy(this.state.scale, ['value'], ['desc']);
    var scale = [];
    _.forEach(orderScales, function(scala) {
      if (mapScala > scala.value) {
        scale.push(scala);
        resolution = scaleToRes(scala.value);
        self._scalesResolutions[scala.value] = resolution;
        resolution = resolution / 2;
      }
    });
    // riordino in modo crescente
    this.state.scale = _.orderBy(scale, ['value'], ['asc']);
  };

  // funzione che mi restituisce la scala da settare inizialmente
  this._setInitialScalaSelect = function() {
    var self = this;
    // prendo la risoluzione della mappa
    var initialResolution = this._map.getView().getResolution();
    // ci calcolo la scala associata alla resoluzione iniziale della mappa
    var initialScala = resToScale(initialResolution);
    var found = false;
    _.forEach(this.state.scale, function(scala, index) {
      // qui vado a settare la scala in base alla risoluzione inziale della mappa
      if (initialScala < scala.value && !self.state.scala) {
        var idx = index ? index -1 : index;
        self.state.scala = self.state.scale[idx].value;
        $('#scala').val(self.state.scala);
        found = true;
        return false
      }
    });
    if (!found) {
      this.state.scala = this.state.scale[this.state.scale.length-1].value;
    }
  };

  //setta la scala in base alla risoluzione
  this._setCurrentScala = function(resolution) {
    var self = this;
    _.forEach(this._scalesResolutions, function(res, scala) {
      if (res == resolution) {
        self.state.scala = scala;
        return false
      }
    });
  };

  // funzione che ha lo scopo di settare il moveend della mappa
  this._setMoveendMapEvent = function() {
    var self = this;
    // prendo la chiave dell'evento moveend
    this._moveMapKeyEvent = this._map.on('moveend', function() {
      /// setto nella select la scala corrispondente
      // vado a settare la print area
      self._setPrintArea();
    })
  };

  //funzione che setta l'area iniziale
  this._showPrintArea = function() {
    // vado ad impostare l'area di stampa
    this._setPrintArea();
    // dico al mapservice di disegnare l'area di stampa
    this._mapService.startDrawGreyCover();
  };


  // funzione che setta la massima e iniziale scala del progetto
  this._initPrintConfig = function() {
    var resolution;
    if (!this._initialized) {
      // prendo la massima risoluzione della mappa
      var maxResolution = this._map.getView().getMaxResolution();
      // ricavo le scale adatte alle mie risoluzioni
      this._setAllScalesBasedOnMaxResolution(maxResolution);
      //se non è stata ancora inizializzata allora vado a settare
      // setto la scala iniziale nella select in base alla risoluzione di partenza del progetto
      this._setInitialScalaSelect();
      //dico che è stata inzializzata
      this._initialized = true;
    } else {
      // prendo la risoluzione corrente
      resolution = this._map.getView().getResolution();
      // vado a cambiare la scala
      this._setCurrentScala(resolution);
    }
  };

  // funzione che ricava sempre map0
  this._setMapInfo = function() {
    var self = this;
    _.forEach(this.state.print[0].maps, function(map) {
      if (map.name == 'map0') {
        self.state.map = map.name;
        self.state.width = map.w;
        self.state.height = map.h;
        return false;
      }
    })
  };

  // metodo per la visualizzazione dell'area grigia o meno
  // chamata dal metodo _setOpen del componente
  this.showPrintArea = function(bool) {
    this._mapService = GUI.getComponent('map').getService();
    this._map = this._mapService.viewer.map;
    if (bool) {
      this._setMapInfo();
      // registo il moveend map event
      this._setMoveendMapEvent();
      // setto la scala iniziale derivato dalle proprietà della mappa
      // e limito la selezione delle scale
      this._initPrintConfig();
      // setto la area di print
      this._showPrintArea();
    } else {
      // vado a ripulire tutti le cose legate al print
      this._clearPrint();
    }
  };

  this.reload = function() {
    var self = this;
    this._project = ProjectsRegistry.getCurrentProject();
    this._mapService = GUI.getComponent('map').getService();
    this._map = this._mapService.viewer.map;
    // prendo le informazioni del print
    this.state.print = this._project.state.print;
    // setto lo state visible
    this.state.visible = (this.state.print && this.state.print.length) ? true : false;
    //verifico se è visibile nel senso se ci sono informazioni
    //sul print per quel progetto
    if (this.state.visible) {
      this.state.template = this.state.print[0].name;
      // setto la area di print
      if (!this._initialized) {
        this.init();
      }
      this._initPrintConfig();
      this._mapService.on('changeviewaftercurrentproject', function() {
        var maxResolution = self._map.getView().getMaxResolution();
        // ricavo le scale adatte alle mie risoluzioni
        self.state.scale = scale;
        self._setAllScalesBasedOnMaxResolution(maxResolution);
      });
    } else {
      // vado a ripulire tutti le cose legate al print
      this._clearPrint();
    }
  }
}

inherit(PrintComponentService, G3WObject);

module.exports = PrintComponentService;
},{"./printconfig":128,"./vue/printpage":133,"core/g3wobject":34,"core/print/printservice":65,"core/project/projectsregistry":69,"core/utils/geo":76,"core/utils/utils":77,"gui/gui":118}],130:[function(require,module,exports){
module.exports = "<ul id=\"print\" class=\"treeview-menu\">\n  <li>\n    <form id=\"g3w-search-form\" class=\"form-horizonal\">\n      <div class=\"box-body\">\n        <label for=\"templates\">Template</label>\n        <select class=\"form-control\" @change=\"onChangeTemplate\" v-model=\"state.template\" id=\"templates\" placeholder=\"Seleziona il template\">\n          <option v-for=\"print in state.print\">{{ print.name }}</option>\n        </select>\n        <label for=\"scala\">Scala</label>\n        <select class=\"form-control\" @change=\"onChangeScale\" v-model=\"state.scala\" id=\"scala\" placeholder=\"Seleziona la scala\">\n          <option v-for=\"scala in state.scale\" :value=\"scala.value\">{{ scala.label }}</option>\n        </select>\n        <label for=\"dpi\">dpi</label>\n        <select class=\"form-control\" @change=\"onChangeDpi\"  v-model=\"state.dpi\" id=\"dpi\" placeholder=\"Seleziona i dpi\">\n          <option v-for=\"dpi in state.dpis\" >{{ dpi }}</option>\n        </select>\n        <label for=\"rotation\">Rotazione</label>\n        <input min=\"-360\" max=\"360\"  @input=\"onChangeRotation\" v-model=\"state.rotation\" id=\"rotation\" class=\"form-control\" type=\"number\">\n      </div>\n      <div class=\"box-footer\" style=\"background-color: transparent\">\n        <span>\n          <button style=\"width:100%; background-color: #3c8dbc\" class=\"btn \" @click.stop.prevent=\"exec(button.cbk)\" v-disabled=\"btnEnabled(button)\">{{ button.title }}</button>\n        </span>\n      </div>\n    </form>\n    <div id=\"message\" style=\"text-align:center; padding:3px; color: yellow\" class=\"message\" v-show=\"btnEnabled(button)\">\n      <div>\n        <span>Muovendoti all'interno della mappa</span>\n      </div>\n      <div>\n        <span>o cambiando i parametri della stampa</span>\n      </div>\n      <div>\n        <span>il PDF si aggiornerà automaticamente</span>\n      </div>\n    </div>\n  </li>\n</ul>\n";

},{}],131:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var Component = require('gui/vue/component');
var PrintService = require('gui/print/printservice');
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;

var vueComponentOptions = {
  template: require('./print.html'),
  data: function() {
    var self = this;
    return {
      state: null,
      button: {
        title: "Crea PDF",
        class: "btn-success",
        type:"stampa",
        disabled: false,
        cbk: function() {
          self.print()
        }
      }
    }
  },
  methods: {
    exec: function(cbk) {
      cbk();
    },
    btnEnabled: function(button) {
      return button.disabled;
    },
    isAnnullaButton: function(type) {
      return type == 'annulla'
    },
    // metodo per il cambio di template
    onChangeTemplate: function() {
      this.$options.service.changeTemplate();
    },
    // metodo per il cambio di scala
    onChangeScale: function() {
      this.$options.service.changeScale()
    },
    // metodo per il cambio di DPI
    onChangeDpi: function() {

    },
    // metodo per il cambio di rotazione
    onChangeRotation: function(evt) {
      if (this.state.rotation >= 0 && !_.isNil(this.state.rotation) && this.state.rotation != '') {
        this.state.rotation = (this.state.rotation > 360) ? 360 : this.state.rotation;
        evt.target.value = this.state.rotation;
      } else if (this.state.rotation < 0) {
        this.state.rotation = (this.state.rotation < -360) ? -360 : this.state.rotation;
        evt.target.value = this.state.rotation;
      } else {
        this.state.rotation = 0;
      }

      this.$options.service.changeRotation();
    },
    // funzione dedicata alla visualizzazione dell'ouput del print
    print: function() {
      this.$options.service.print();
    }
  }
};


function PrintComponent(options) {
  // proprietà necessarie. In futuro le mettermo in una classe Panel
  // da cui deriveranno tutti i pannelli che vogliono essere mostrati nella sidebar
  base(this, options);
  this.title = "print";
  // qui vado a tenere traccia delle due cose che mi permettono di customizzare
  // vue component e service
  this.vueComponent = vueComponentOptions;
  //merge(this, options);
  // dichiaro l'internal Component
  this.internalComponent = null;
  // setto il service del component (istanzio il nuovo servizio)
  var service = options.service || new PrintService;
  this.setService(service);
  this._service.init();
  // setto il componente interno
  this.setInternalComponent = function () {
    var InternalComponent = Vue.extend(this.vueComponent);
    this.internalComponent = new InternalComponent({
      service: service
    });
    // setto la visibilità del print in base a quella del servizio calcolata sull'array
    // print restituita dal server
    this.state.visible = service.state.visible;
    // assegno all'internal componente lo state mergiato
    this.internalComponent.state = service.state;
    // ritorno l'internal component
    return this.internalComponent;
  };

  //sovrascrivo il metodo reload
  this._reload = function() {
    var service = this.getService();
    service.reload();
    this.state.visible = service.state.visible;
  };

  // funzione che viene chaimata quando viene visualizzato il contentuto del componente Stampa
  // nella sidebar
  this._setOpen = function() {
    this._service.showPrintArea(this.state.open);
  };
  merge(this, options);

}

inherit(PrintComponent, Component);

module.exports = PrintComponent;



},{"./print.html":130,"core/utils/utils":77,"gui/print/printservice":129,"gui/vue/component":156}],132:[function(require,module,exports){
module.exports = "<div id=\"pdf-output\" style=\"height:100%\">\n  <div v-show=\"state.loading\" class=\"bar-loader\"></div>\n  <iframe id=\"pdf\" style=\"border:0px;width:100%;height:100%\" :src=\"state.url\"></iframe>\n</div>";

},{}],133:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');

var InternalComponent = Vue.extend({
  template: require('./printpage.html'),
  data: function() {
    return {
      state: null
    }
  },
  mounted: function() {
    var self = this;
    this.state.loading = true;
    this.$nextTick(function(){
      $('#pdf').load(function(){
        self.state.loading = false;
      })
    });
  }
});

var PrintPage = function(options) {
  base(this);
  var options = options || {};
  var service = options.service;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent();
  this.setInternalComponent(internalComponent);
  this.internalComponent.state = service.state;
};

inherit(PrintPage, Component);


module.exports = PrintPage;



},{"./printpage.html":132,"core/utils/utils":77,"gui/vue/component":156}],134:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function PhotoService(options) {
  var options = options || {};
  this.state = {};
  base(this);
}

inherit(PhotoService, G3WObject);

module.exports = PhotoService;

},{"core/g3wobject":34,"core/utils/utils":77}],135:[function(require,module,exports){
module.exports = "<div id=\"photo\" style=\"margin: 10px;\">\n  <img :src=\"url\" style=\"width: 100%;\">\n</div>";

},{}],136:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var Service = require('../photoservice');

var InternalComponent = Vue.extend({
  template: require('./photo.html'),
  data: function() {
    return {
      state: null,
      url: this.$options.url
    }
  }
});

var PhotoComponent = function(options) {
  base(this);
  var options = options || {};
  var service = options.service || new Service({});
  var url = options.url || null;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service,
    url: url
  });
  this.setInternalComponent(internalComponent);
  this.internalComponent.state = service.state;
};

inherit(PhotoComponent, Component);


module.exports = PhotoComponent;



},{"../photoservice":134,"./photo.html":135,"core/utils/utils":77,"gui/vue/component":156}],137:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectsRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');


function RelationsService(options) {
  this.state = {};
  this._project = ProjectsRegistry.getCurrentProject();
  base(this);

  this.getRelations = function(options) {
    var projectId = this._project.state.id;
    options = options || {};
    var value = options.value || null;
    var id = options.id || null;
    return $.get('/qdjango/api/relations/'+projectId+'/'+id+'/'+value)
  };
  this.buildRelationTable = function(relations) {
    var columns = _.keys(relations[0]);
    var rows = [];
    _.forEach(relations, function(relation){
      rows.push(_.values(relation));
    });
    return {
      columns: columns,
      rows: rows
    }
  };
}

inherit(RelationsService, G3WObject);

module.exports = RelationsService;

},{"core/g3wobject":34,"core/project/projectsregistry":69,"core/utils/utils":77,"gui/gui":118}],138:[function(require,module,exports){
module.exports = "<div class=\"query-relation\">\n  <div class=\"back-btn\" @click=\"back\">\n    <span class=\"back-link\">\n      <span class=\"glyphicon glyphicon-chevron-left\"></span>\n      Ritorna alle Relazioni\n    </span>\n  </div>\n  <div class=\"header\">\n    <div>\n      Dati relativi alla relazione <b>{{ relation.name }}</b>\n    </div>\n  </div>\n  <div class=\"nano\" v-if=\"table.rows.length\">\n    <div class=\"nano-content\">\n      <table class=\"table table-striped\">\n        <thead>\n          <tr>\n            <th v-for=\"column in table.columns\">{{ column }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-for=\"row in table.rows\">\n            <td v-for=\"value in row\">{{ value }}</td>\n          </tr>\n        </tbody>\n        </table>\n    </div>\n  </div>\n  <div v-else> Non ci sono relazioni </div>\n\n</div>\n";

},{}],139:[function(require,module,exports){
module.exports = "<div class=\"query-relations\">\n  <div class=\"header\">\n    <div>Elenco Relazioni della feature <span v-for=\"info in featureInfo()\"><b>{{ info.key }}</b>: {{ info.value }} </span></div>\n  </div>\n  <div class=\"nano\">\n    <div class=\"nano-content\">\n      <table class=\"table table-bordered table-hover\">\n        <thead>\n        </thead>\n        <tbody>\n          <tr @click=\"showRelation(relation)\" v-for=\"relation in relations\" style=\"cursor:pointer\">\n            <td>\n              <span >{{ relation.name }}</span>\n              <span class=\"glyphicon glyphicon-chevron-right pull-right\" aria-hidden=\"true\"></span>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n";

},{}],140:[function(require,module,exports){
module.exports = "<div class=\"query-relations-page\">\n    <component\n        :is=\"currentview\"\n        :relations=\"relations\"\n        :relation=\"relation\"\n        :feature=\"feature\"\n        :table=\"table\">\n    </component>\n</div>";

},{}],141:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var Service = require('../relationsservice');



/* Lista delle relationi associate  */
var relationsComponent = {
  template: require('./relations.html'),
  props: ['relations', 'feature'],
  methods: {
    showRelation: function(relation) {
      this.$parent.showRelation(relation);
    },
    featureInfo: function() {
      var infoFeatures = [];
      var index = 0;
      _.forEach(this.feature.attributes, function(value, key) {
        if (index > 2) return false;
        if (value && _.isString(value) && value.indexOf('/') == -1 ) {
          infoFeatures.push({
            key: key,
            value: value
          });
          index+=1;
        }

      });
      return infoFeatures
    }
  }
};
/*-----------------------------------*/

/* Tabella relation */
var relationComponent = {
  template: require('./relation.html'),
  props: ['table', 'relation'],
  methods: {
    back: function() {
      this.$parent.setRelationsList();
    }
  }
};
/*-----------------------------------*/

var InternalComponent = Vue.extend({
  template: require('./relationspage.html'),
  data: function() {
    return {
      state: null,
      table: null,
      relation: null,
      relations: this.$options.relations,
      feature: this.$options.feature,
      currentview: 'relations' // proprietà che serve per switchare tra componenti
    }
  },
  components: {
    'relations': relationsComponent,
    'relation': relationComponent
  },
  methods: {
    showRelation: function(relation) {
      var self = this;
      this.relation = relation;
      var field = relation.fieldRef.referencedField;
      var value = this.feature.attributes[field];
      this.$options.service.getRelations({
        id: relation.id,
        value: value
      }).then(function(relations) {
        self.table = self.$options.service.buildRelationTable(relations);
        self.currentview = 'relation';
        Vue.nextTick(function() {
          $(".nano").nanoScroller();
        })
      })
    },
    setRelationsList: function() {
      this.currentview = 'relations';
    }
  }
});

var RelationsPage = function(options) {
  base(this);
  var options = options || {};
  var service = options.service || new Service({});
  var relations = options.relations || [];
  var feature = options.feature || null;
  // istanzio il componente interno
  this.setService(service);
  // istanzio il componente interno
  var internalComponent = new InternalComponent({
    service: service,
    relations: relations,
    feature: feature
  });
  this.setInternalComponent(internalComponent);
  internalComponent.state = service.state;
};
inherit(RelationsPage, Component);


module.exports = RelationsPage;



},{"../relationsservice":137,"./relation.html":138,"./relations.html":139,"./relationspage.html":140,"core/utils/utils":77,"gui/vue/component":156}],142:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectsRegistry = require('core/project/projectsregistry');
var GeoLayer = require('core/layers/geolayer');
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var VectorLayer = require('core/map/layer/vectorlayer');
var ComponentsRegistry = require('gui/componentsregistry');
var QueryService = require('core/query/queryservice');
var PhotoComponent = require('./components/photo/vue/photo');
var RelationsPage = require('./components/relations/vue/relationspage');


function QueryResultsService() {
  var self = this;
  // prendo le relazioni dal progetto e se ci sono e le raggruppo per referencedLayer
  this._relations = ProjectsRegistry.getCurrentProject().state.relations ? _.groupBy(ProjectsRegistry.getCurrentProject().state.relations,'referencedLayer'): null;
  this._actions = {
    'zoomto': QueryResultsService.zoomToElement,
    'highlightgeometry': QueryResultsService.highlightGeometry,
    'clearHighlightGeometry': QueryResultsService.clearHighlightGeometry
  };
  this.state = {};
  this.init = function(options) {
    this.clearState();
  };

  // array dei layers vettoriali
  this._vectorLayers = [];

  this.setters = {
    setQueryResponse: function(queryResponse, coordinates, resolution ) {
      this.clearState();
      this.state.query = queryResponse.query;
      //recupero tutti i mlayers dalll'attributo data della risposta
      // costuendo il formato digeribile dal componente query
      var layers = this._digestFeaturesForLayers(queryResponse.data);
      //setto i layers data
      this.setLayersData(layers);
    },
    setLayersData: function(layers) {
      // un opportunità per aggiungere / modificare i risultati dell'interrogazione
      this.state.loading = false;
      this.state.layers =  layers;
      this.setActionsForLayers(layers);
    },
    addActionsForLayers: function(actions) {
      // un opportunità per i listener per aggiungere azioni a layer e feature
    },
    postRender: function(element) {
      // un opportunità per i listener di intervenire sul DOM
    }
  };
  // fa il clear dello state
  this.clearState = function() {
    this.state.layers = [];
    this.state.query = {};
    this.state.querytitle = "";
    this.state.loading = true;
    this.state.layersactions = {};
  };

  this.getState = function() {
    return this.state;
  };

  this.setState = function(state) {
    this.state = state;
  };

  this.setTitle = function(querytitle) {
    this.state.querytitle = querytitle || "";
  };
  
  this.reset = function() {
    this.clearState();
  };
  // funzione che serve a far digerire i risultati delle features
  this._digestFeaturesForLayers = function(featuresForLayers) {
    
    var self = this;
    var id = 0;
    // variabile che tiene traccia dei layer sotto query
    var layers = [];
    var layerAttributes,
      layerRelationsAttributes,
      layerTitle,
      layerId;
    _.forEach(featuresForLayers, function(featuresForLayer) {
      featuresForLayer = featuresForLayer[0];
      // prendo il layer
      var layer = featuresForLayer.layer;
      // verifico che tipo ti vector layer ci sono
      switch (layer.constructor) {
        case GeoLayer:
          layerAttributes = layer.getAttributes();
          layerRelationsAttributes =  layer.getRelationsAttributes();
          layerTitle = layer.getTitle();
          layerId = layer.getId();
          break;
        case ol.layer.Vector:
          layerAttributes = layer.getProperties();
          layerRelationsAttributes =  [];
          layerTitle = layer.get('name');
          layerId = layer.get('id');
          break;
      }
      // verifico che ci siano feature legate a quel layer che sono il risultato della query
      if (featuresForLayer.features.length) {
        // se si vado a csotrure un layer object
        var layerObj = {
          title: layerTitle,
          id: layerId,
          // prendo solo gli attributi effettivamente ritornati dal WMS (usando la prima feature disponibile)
          attributes: self._parseAttributes(layerAttributes, featuresForLayer.features[0].getProperties()),
          features: [],
          hasgeometry: false,
          show: true,
          expandable: true,
          hasImageField: false, // regola che mi permette di vedere se esiste un campo image
          relationsattributes: layerRelationsAttributes
        };
        // faccio una ricerca sugli attributi del layer se esiste un campo image
        // se si lo setto a true
        _.forEach(layerObj.attributes, function(attribute) {
          if (attribute.type == 'image') {
            layerObj.hasImageField = true;
          }
        });
        // a questo punto scorro sulle features selezionate dal risultato della query
        _.forEach(featuresForLayer.features, function(feature){
          var fid = feature.getId() ? feature.getId() : id;
          var geometry = feature.getGeometry();
          // verifico se il layer ha la geometria
          if (geometry) {
            // setto che ha geometria mi servirà per le action
            layerObj.hasgeometry = true
          }
          // creo un feature object
          var featureObj = {
            id: fid,
            attributes: feature.getProperties(),
            geometry: feature.getGeometry(),
            show: true
            // aggiungo le relazioni
          };
          layerObj.features.push(featureObj);
          id += 1;
        });
        layers.push(layerObj);
      }
    });
    return layers;
  };
  
  this._parseAttributes = function(layerAttributes, featureAttributes) {
    var featureAttributesNames = _.keys(featureAttributes);
    featureAttributesNames = _.filter(featureAttributesNames,function(featureAttributesName){
      return ['boundedBy','geom','the_geom','geometry','bbox', 'GEOMETRY'].indexOf(featureAttributesName) == -1;
    });
    if (layerAttributes && layerAttributes.length) {
      var featureAttributesNames = _.keys(featureAttributes);
      return _.filter(layerAttributes,function(attribute){
        return featureAttributesNames.indexOf(attribute.name) > -1;
      })
    }
    // se layer.attributes è vuoto
    // (es. quando l'interrogazione è verso un layer esterno di cui non so i campi)
    // costruisco la struttura "fittizia" usando l'attributo sia come name che come label
    else {
      return _.map(featureAttributesNames, function(featureAttributesName){
        return {
          name: featureAttributesName,
          label: featureAttributesName
        }
      })
    }
  };

  // metodo per settare le azioni che si possono fare sulle feature del layer
  this.setActionsForLayers = function(layers) {
    var self = this;
    // scorro su ogni layer che ho nella risposta
    _.forEach(layers, function(layer) {
      // se non esistono azioni su uno specifico layer creo
      // array di azioni con chiave id del layer (in quanto valore univoco)
      if (!self.state.layersactions[layer.id]) {
        self.state.layersactions[layer.id] = [];
      }
      // verifico se il layer ha gemetria
      if (layer.hasgeometry) {
        // se prsente aggiungo oggetto azione che mi server per fare
        // il goTo geometry
        self.state.layersactions[layer.id].push({
          id: 'gotogeometry',
          class: 'glyphicon glyphicon-map-marker',
          hint: 'Visualizza sulla mappa',
          cbk: QueryResultsService.goToGeometry
        })
      }
      // vado a costruire l'action delle query-relazioni
      if (self._relations) {
        // scorro sulle relazioni e vado a verificare se ci sono relazioni che riguardano quel determintato layer
        _.forEach(self._relations, function(relations, id) {
          // verifico se l'id del layer è uguale all'id della relazione
          if (layer.id == id) {
            self.state.layersactions[layer.id].push({
              id: 'show-query-relations',
              class: 'fa fa-sitemap',
              hint: 'Visualizza Relazioni',
              cbk: QueryResultsService.showQueryRelations,
              relations: relations
            })
          }
          return false;
        })
      }
    });
    this.addActionsForLayers(self.state.layersactions);
  };
  
  this.trigger = function(actionId, layer, feature) {
    var actionMethod = this._actions[actionId];
    if (actionMethod) {
      actionMethod(layer, feature);
    }
    if (layer) {
      var layerActions = self.state.layersactions[layer.id];
      if (layerActions) {
        var action;
        _.forEach(layerActions, function(layerAction){
          if (layerAction.id == actionId) {
            action = layerAction;
          }
        });
        if (action) {
          this.triggerLayerAction(action,layer,feature);
        }
      }
    }
  };

  this.triggerLayerAction = function(action,layer,feature) {
    if (action.cbk) {
      action.cbk(layer,feature, action)
    }
    if (action.route) {
      var url;
      var urlTemplate = action.route;
      url = urlTemplate.replace(/{(\w*)}/g,function(m,key){
        return feature.attributes.hasOwnProperty(key) ? feature.attributes[key] : "";
      });
      if (url && url != '') {
        GUI.goto(url);
      }
    }
  };

  //funzione che permette di vedere la foto a schermo intero
  this.showFullPhoto = function(url) {
    GUI.pushContent({
      content: new PhotoComponent({
        url: url
      }),
      backonclose: true,
      closable: false
    });
  };

  // funzione che mi serve per registrare il vector layer al fine di fare le query
  this.registerVectorLayer = function(vectorLayer) {
    if (this._vectorLayers.indexOf(vectorLayer) == -1) {
      //vado ad aggiungere informazioni utili alla visualizzazioni nel query
      vectorLayer.state = {};
      vectorLayer.state.title = vectorLayer.name;
      vectorLayer.state.id = vectorLayer.id;
      this._vectorLayers.push(vectorLayer);
    }
  };

  // funzione che mi serve per unregistrare il vector layer dalla query
  this.unregisterVectorLayer = function(vectorLayer) {
    var index = this._vectorLayers.indexOf(vectorLayer);
    if ( index != -1) {
      this._vectorLayers.splice(index, 1);
    }
  };

  // funzione che permette ai layer vettoriali di aggancirsi alla query info
  this._addVectorLayersDataToQueryResponse = function() {
    var self = this;
    this.onbefore('setQueryResponse', function (queryResponse, coordinates, resolution) {
      var mapService = ComponentsRegistry.getComponent('map').getService();
      var isVisible = false;
      _.forEach(self._vectorLayers, function(vectorLayer) {
        var features = [];
        var feature,
          intersectGeom;
        // la prima condizione mi server se viene fatto un setQueryResponse sul singolo layer vettoriale
        // ad esempio con un pickfeature per evitare che venga scatenato un'altra query
        // nel caso di attivazione di uno dei query control (la momento bbox, info e polygon)
        // la setQueryresponse ha priorità sugli altri di fatto cancellando la setResqponseqeusry dello specifico vectorLayer
        switch (vectorLayer.constructor) {
          case VectorLayer:
            isVisible = !vectorLayer.isVisible();
            break;
          case ol.layer.Vector:
            isVisible = !vectorLayer.getVisible();
            break;
        }
        if ((queryResponse.data && queryResponse.data.length && queryResponse.data[0].layer == vectorLayer) || !coordinates || isVisible ) { return true}
        // caso in cui è stato fatto una precedente richiesta identify e quindi devo attaccare il risultato
        // non mi piace perchè devo usare altro metodo
        // caso query info
        if (_.isArray(coordinates)) {
          if (coordinates.length == 2) {
            var pixel = mapService.viewer.map.getPixelFromCoordinate(coordinates);
            feature = mapService.viewer.map.forEachFeatureAtPixel(pixel, function (feature, layer) {
              return feature;
            },  {
              layerFilter: function(layer) {
                return layer === vectorLayer;
              }
            });
            if (feature) {
              QueryService.convertG3wRelations(feature);
              features.push(feature);
            }
          } else if (coordinates.length == 4) {
            intersectGeom = ol.geom.Polygon.fromExtent(coordinates);
            switch (vectorLayer.constructor) {
              case VectorLayer:
                features = vectorLayer.getIntersectedFeatures(intersectGeom);
                break;
              case ol.layer.Vector:
                _.forEach(vectorLayer.getSource().getFeatures(), function(feature) {
                  if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
                    features.push(feature);
                  }
                });
                break;
            }
          }
        } else if (coordinates instanceof ol.geom.Polygon || coordinates instanceof ol.geom.MultiPolygon) {
          intersectGeom = coordinates;
          switch (vectorLayer.constructor) {
            case VectorLayer:
              features = vectorLayer.getIntersectedFeatures(intersectGeom);
              break;
            case ol.layer.Vector:
              _.forEach(vectorLayer.getSource().getFeatures(), function(feature) {
                if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
                  features.push(feature);
                }
              });
              break;
          }
        }
        _.forEach(features, function(feature) {
          QueryService.convertG3wRelations(feature);
        });
        // vado a pushare le features verificando prima se c'è stato un risultato
        queryResponse.data = queryResponse.data ? queryResponse.data : [];
        queryResponse.data.push({
          features: features,
          layer: vectorLayer
        });
      })
    });
  };

  base(this);
  // lancio subito la registrazione
  this._addVectorLayersDataToQueryResponse();
}

QueryResultsService.zoomToElement = function(layer,feature) {
  //TODO
};

QueryResultsService.goToGeometry = function(layer,feature) {
  if (feature.geometry) {
    var mapService = ComponentsRegistry.getComponent('map').getService();
    mapService.highlightGeometry(feature.geometry, {duration: 4000});
  }
};

QueryResultsService.highlightGeometry = function(layer,feature) {
  if (feature.geometry) {
    var mapService = ComponentsRegistry.getComponent('map').getService();
    mapService.highlightGeometry(feature.geometry,{zoom: false});
  }
};

QueryResultsService.clearHighlightGeometry = function(layer, feature) {
  var mapService = ComponentsRegistry.getComponent('map').getService();
  mapService.clearHighlightGeometry();
};

QueryResultsService.showQueryRelations = function(layer, feature, action) {
  GUI.pushContent({
    content: new RelationsPage({
      relations: action.relations,
      feature: feature
    }),
    backonclose: true,
    closable: false
  });
};

// Make the public service en Event Emitter
inherit(QueryResultsService, G3WObject);

module.exports = QueryResultsService;

},{"./components/photo/vue/photo":136,"./components/relations/vue/relationspage":141,"core/g3wobject":34,"core/layers/geolayer":42,"core/map/layer/vectorlayer":59,"core/project/projectsregistry":69,"core/query/queryservice":74,"core/utils/utils":77,"gui/componentsregistry":111,"gui/gui":118}],143:[function(require,module,exports){
module.exports = "<div id=\"search-results\" class=\"queryresults-wrapper\">\n  <h3 v-if=\"state.querytitle\">Risultati {{state.querytitle.toLowerCase()}}</h3>\n  <div v-show=\"state.loading\" class=\"bar-loader\"></div>\n  <div class=\"queryresults-container\">\n    <ul v-if=\"hasResults()\" class=\"queryresults\" id=\"queryresults\">\n      <li v-if=\"layerHasFeatures(layer) && layer.show\" v-for=\"layer in state.layers\">\n        <div class=\"box box-primary\">\n          <div class=\"box-header with-border\" data-widget=\"collapse\">\n            <h3 class=\"box-title\">{{ layer.title }} ({{layer.features.length}})</h3>\n            <div class=\"box-tools pull-right\">\n              <button class=\"btn btn-box-tool\" data-widget=\"collapse\"><i class=\"btn-collapser fa fa-minus\"></i></button>\n            </div>\n          </div>\n          <div class=\"box-body\">\n            <table class=\"table table-striped\">\n              <thead>\n              <tr>\n                <th v-if=\"layer.hasgeometry\"></th>\n                <th v-for=\"(attribute, index) in attributesSubset(layer.attributes)\" :style=\"{ width:cellWidth(index,layer) + '%' }\">{{attribute.label}}</th>\n                <th :style=\"{ width:headerExpandActionCellWidth + '%' }\"></th>\n              </tr>\n              </thead>\n              <tbody>\n              <template v-if=\"feature.show\" v-for=\"feature in layer.features\">\n                <tr @click=\"toggleFeatureBoxAndZoom(layer,feature);\" @mouseover=\"trigger('highlightgeometry',layer,feature)\" @mouseout=\"trigger('clearHighlightGeometry')\" class=\"featurebox-header\">\n                  <td v-if=\"geometryAvailable(feature)\" class=\"action-cell\">\n                    <span @click.stop.prevent=\"trigger('gotogeometry',layer,feature)\" class=\"glyphicon glyphicon-map-marker action-button-icon\"></span>\n                  </td>\n                  <td v-for=\"attribute in attributesSubset(layer.attributes)\">\n                    <span>{{feature.attributes[attribute.name]}}</span>\n                  </td>\n                  <td class=\"action-cell\">\n                    <span class=\"fa link morelink\" :class=\"[collapsedFeatureBox(layer,feature) ? 'fa-plus' : 'fa-minus']\"></span>\n                  </td>\n                </tr>\n                <tr v-show=\"!collapsedFeatureBox(layer,feature)\" class=\"featurebox-body\">\n                  <td :colspan=\"attributesSubsetLength(layer.attributes)+2\">\n                    <div class=\"action-buttons-container\">\n                      <template v-for=\"action in state.layersactions[layer.id]\">\n                        <div @click=\"trigger(action.id,layer,feature)\"  class=\"action-button hint--top-right\" data-placement=\"auto bottom\" data-toggle=\"tooltip\" :title=\"action.hint\">\n                          <span :class=\"'action-button-icon ' + action.class\"></span>\n                        </div>\n                      </template>\n                    </div>\n                    <table>\n                      <tr v-for=\"attribute in layer.attributes\">\n                        <td class=\"attr-label\">{{attribute.label}}</td>\n                        <!--<td class=\"attr-value\">{{feature.attributes[attribute.name]}}</td>-->\n                        <td class=\"attr-value\">\n                          <span v-if=\"is('simple',layer,attribute.name,feature.attributes[attribute.name])\">{{feature.attributes[attribute.name]}}</span>\n                          <img v-if=\"is('photo',layer,attribute.name,feature.attributes[attribute.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(feature.attributes[attribute.name]))\" :src=\"isRelativePath(feature.attributes[attribute.name])\">\n                          <!--<span v-if=\"isRoute(layer,feature,attribute)\" class=\"link dashboardlink\" @click=\"goto(layer,feature.attributes[attribute.name])\">{{ feature.attributes[attribute.name] }}</span>-->\n                          <!--<img v-if=\"isPhoto(layer,feature,attribute)\" :data-url=\"getPhotoUrl(feature.attributes[attribute.name])\" style=\"max-width:50px\" :src=\"getPhotoUrl(feature.attributes[attribute.name],thumb)\" />-->\n                          <img v-else-if=\"checkField('image', attribute.label, layer.attributes)\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(attribute.value))\" :src=\"isRelativePath(attribute.value)\">\n                          <a v-if=\"is('link',layer,attribute.name,feature.attributes[attribute.name])\" :href=\"feature.attributes[attribute.name]\" target=\"_blank\" class=\"glyphicon glyphicon-link\"></a>\n                        </td>\n                      </tr>\n                    </table>\n                  </td>\n                </tr>\n                <tr v-show=\"collapsedFeatureBox(layer,feature) && feature.attributes.relations\">\n                  <td :colspan=\"attributesSubsetLength(layer.attributes)+2\">\n                    <!--Relazioni-->\n                    <div class=\"queryresults-container\">\n                      <ul class=\"queryresults\" id=\"relations\">\n                        <template v-for=\"relation in feature.attributes.relations\">\n                          <li>\n                            <div class=\"box box-solid box-default relationsbox collapsed-box\">\n                              <div class=\"box-header with-border\" data-widget=\"collapse\">\n                                <h3 class=\"box-title\">{{ relation.name }} ({{ relation.elements.length }})</h3>\n                                <div class=\"box-tools pull-right\">\n                                  <button class=\"btn btn-box-tool\" data-widget=\"collapse\"><i class=\"btn-collapser fa fa-plus\"></i></button>\n                                </div>\n                              </div>\n                              <div class=\"box-body\">\n                                <template v-for=\"(element, index) in relation.elements\">\n                                  <table class=\"table table-striped\">\n                                    <thead>\n                                    <tr>\n                                      <th v-for=\"attribute in relationsAttributesSubset(element)\">\n                                        {{attribute.label}}\n                                      </th>\n                                      <th></th>\n                                    </tr>\n                                    </thead>\n                                    <tbody>\n                                    <tr @click=\"toggleFeatureBox(layer, feature, relation.name+index)\"  class=\"featurebox-header\">\n                                      <td v-for=\"attribute in relationsAttributesSubset(element)\">\n                                        <span>{{attribute.value}}</span>\n                                      </td>\n                                      <td class=\"action-cell text-center\">\n                                        <span class=\"fa link morelink\" :class=\"[collapsedFeatureBox(layer, feature, relation.name+index) ? 'fa-minus' : 'fa-plus']\" style=\"text-align: right\"></span>\n                                      </td>\n                                    </tr>\n                                    <tr v-show=\"collapsedFeatureBox(layer, feature, relation.name+index)\" class=\"featurebox-body\">\n                                      <td :colspan=\"relationsAttributesSubsetLength(element)+1\">\n                                        <table>\n                                          <tr v-for=\"relattribute in relationsAttributes(element)\">\n                                            <td class=\"attr-label\">{{relattribute.label}}</td>\n                                            <!--<td class=\"attr-value\">{{attribute.value}}</td>-->\n                                            <td class=\"attr-value\">\n                                              <div v-if=\"isArray(relattribute.value)\" v-for=\"value in relattribute.value\">\n                                                <div v-for=\"value, label in value\">\n                                                  <span>{{ label }}</span><span class=\"pull-right\">{{ value }}</span>\n                                                </div>\n                                                <span class=\"divider\"></span>\n                                              </div>\n                                              <span v-if=\"isSimple(layer,relattribute.name, relattribute.value)\">{{relattribute.value}}</span>\n                                              <!--<img v-if=\"is('photo',layer,relattribute.name,feature.attributes[attribute.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(feature.attributes[attribute.name]))\" :src=\"isRelativePath(feature.attributes[attribute.name])\">-->\n                                              <!--<img v-if=\"relattribute.label == 'image'\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">-->\n                                              <img v-else-if=\"checkField('image', relattribute.label, layer.relationsattributes[relation.name])\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">\n                                              <img v-else-if=\"is('photo',layer, relattribute.name, relattribute.value)\"  class=\"photo-preview img-responsive img-thumbnail\" title=\"Clicca per allargare\"  @click=\"showFullPhoto(isRelativePath(relattribute.value))\" :src=\"isRelativePath(relattribute.value)\">\n                                              <!--&lt;!&ndash;<span v-if=\"isRoute(layer,feature,attribute)\" class=\"link dashboardlink\" @click=\"goto(layer,feature.attributes[attribute.name])\">{{ feature.attributes[attribute.name] }}</span>&ndash;&gt;-->\n                                              <!--<img v-if=\"isPhoto(layer,feature,attribute)\" v-bind:data-url=\"getPhotoUrl(feature.attributes[attribute.name])\" style=\"max-width:50px\" :src=\"getPhotoUrl(feature.attributes[attribute.name],thumb)\" />-->\n                                              <a v-if=\"isLink(layer,relattribute.name, relattribute.value)\" :href=\"relattribute.value\" target=\"_blank\" class=\"glyphicon glyphicon-link\"></a>\n                                            </td>\n                                          </tr>\n                                        </table>\n                                      </td>\n                                    </tr>\n                                    </tbody>\n                                  </table>\n                                </template>\n                              </div>\n                            </div>\n                          </li>\n                        </template>\n                      </ul>\n                    </div>\n                    <!--Fine Relazioni-->\n                  </td>\n                </tr>\n              </template>\n              </tbody>\n            </table>\n          </div>\n        </div>\n      </li>\n    </ul>\n  </div>\n  <span v-if=\"!hasResults() && !state.loading\">Nessun risultato</span>\n</div>\n\n";

},{}],144:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var QueryResultsService = require('gui/queryresults/queryresultsservice');
var ProjectsRegistry = require('core/project/projectsregistry');

Fields = {};
Fields.SIMPLE = 'simple';
Fields.LINK = 'link';
Fields.PHOTO = 'photo';
Fields.IMAGE = 'image';
Fields.POINTLINK = 'pointlink';
Fields.ROUTE = 'route';

function getFieldType(layer, name, value) {

  var URLPattern = /^(https?:\/\/[^\s]+)/g;
  var PhotoPattern = /[^\s]+.(png|jpg|jpeg)$/g;
  if (_.isNil(value)) {
    return Fields.SIMPLE;
  }
  value = value.toString();

  var extension = value.split('.').pop();
  if (value.match(PhotoPattern)) {
    return Fields.PHOTO;
  }

  if (value.match(URLPattern)) {
    return Fields.LINK;
  }

  return Fields.SIMPLE;
}

function fieldIs(TYPE,layer,attributeName,attributeValue) {
  var fieldType = getFieldType(layer,attributeName,attributeValue);
  return fieldType === TYPE;
}

var maxSubsetLength = 3;
var headerExpandActionCellWidth = 10;
var headerActionsCellWidth = 10;

var vueComponentOptions = {
  template: require('./queryresults.html'),
  data: function() {
    return {
      state: this.$options.queryResultsService.state,
      layersFeaturesBoxes: {},
      headerExpandActionCellWidth: headerExpandActionCellWidth,
      headerActionsCellWidth: headerActionsCellWidth
    }
  },
  methods: {
    isArray: function (value) {
      return _.isArray(value);
    },
    isSimple: function(layer,attributeName,attributeValue) {
      return !this.isArray(attributeValue) && fieldIs(Fields.SIMPLE,layer,attributeName,attributeValue);
    },
    isLink: function(layer,attributeName,attributeValue) {
      return fieldIs(Fields.LINK,layer,attributeName,attributeValue);
    },
    is: function(type,layer,attributeName,attributeValue) {
      return fieldIs(type,layer,attributeName,attributeValue);
    },
    checkField: function(type, fieldname, attributes) {
      var isType = false;
      _.forEach(attributes, function(attribute) {
        if (attribute.name == fieldname) {
          isType = attribute.type == type;
        }
      });

      return isType;
    },
    isRelativePath: function(url) {
      if (!_.startsWith(url,'/')) {
        return ProjectsRegistry.getConfig().mediaurl + url
      }
      return url
    },
    layerHasFeatures: function(layer) {
      if (layer.features) {
        return layer.features.length > 0;
      }
      return false;
    },
    hasResults: function() {
      return this.state.layers.length;
    },
    layerHasActions: function(layer) {
      return this.state.layersactions[layer.id].length > 0;
    },
    featureHasActions: function(layer,feature) {
      return this.geometryAvailable(feature);
    },
    /*getLayerActions: function(layer) {
     return this.$options.queryResultsService.getLayerActions(layer);
     },*/
    geometryAvailable: function(feature) {
      return feature.geometry ? true : false;
    },
    attributesSubset: function(attributes) {
      // faccio un filtro sul campo immagine perchè non ha senso far vedere
      // la stringa con il path dell'immagine
      var attributes = _.filter(attributes, function(attribute) {
        return attribute.type != 'image';
      });
      var end = Math.min(maxSubsetLength, attributes.length);
      return attributes.slice(0, end);
    },
    relationsAttributesSubset: function(relationAttributes) {
      var attributes = [];

      _.forEach(relationAttributes, function (value, attribute) {
        if (_.isArray(value)) return;
        attributes.push({label: attribute, value: value})
      });
      var end = Math.min(maxSubsetLength, attributes.length);
      return attributes.slice(0, end);
    },
    relationsAttributes: function(relationAttributes) {
      var attributes = [];
      _.forEach(relationAttributes, function (value, attribute) {
        attributes.push({label: attribute, value: value})
      });
      return attributes;
    },
    attributesSubsetLength: function(attributes) {
      return this.attributesSubset(attributes).length;
    },
    cellWidth: function(index,layer) {
      var subsetLength = this.attributesSubsetLength(layer.attributes);
      var diff = maxSubsetLength - subsetLength;
      actionsCellWidth = layer.hasgeometry ? headerActionsCellWidth : 0;
      var headerAttributeCellTotalWidth = 100 - headerExpandActionCellWidth - actionsCellWidth;
      var baseCellWidth = headerAttributeCellTotalWidth / maxSubsetLength;
      if ((index == subsetLength-1) && diff>0) {
        return baseCellWidth * (diff+1);
      }
      else {
        return baseCellWidth;
      }
    },
    featureBoxColspan: function(layer) {
      var colspan = this.attributesSubsetLength(layer.attributes);
      if (layer.expandable) {
        colspan += 1;
      }
      if (layer.hasgeometry) {
        colspan += 1;
      }
      return colspan;
    },
    relationsAttributesSubsetLength: function(elements) {
      return this.relationsAttributesSubset(elements).length;
    },
    collapsedFeatureBox: function(layer, feature, relation_index) {
      var collapsed = true;
      var boxid;
      if (!_.isNil(relation_index)) {
        boxid = layer.id + '_' + feature.id+ '_' + relation_index;
      } else {
        boxid = layer.id + '_' + feature.id;
      }
      if (this.layersFeaturesBoxes[boxid]) {
        collapsed = this.layersFeaturesBoxes[boxid].collapsed;
      }
      return collapsed;
    },
    toggleFeatureBox: function(layer, feature, relation_index) {
      var boxid;
      if (!_.isNil(relation_index)) {
        boxid = layer.id + '_' + feature.id+ '_' + relation_index;
      } else {
        boxid = layer.id + '_' + feature.id;
      }
      this.layersFeaturesBoxes[boxid].collapsed = !this.layersFeaturesBoxes[boxid].collapsed;
    },
    toggleFeatureBoxAndZoom: function(layer, feature, relation_index) {;
      // Disattivo zoom to sul toggle della featurebox. Casomai lo ripristineremo quando sarà gestito tramite qualche setting
      /*if (this.collapsedFeatureBox(layer, feature, relation_index)) {
       this.trigger('gotogeometry',layer,feature)
       }*/
      this.toggleFeatureBox(layer, feature, relation_index);
    },
    trigger: function(action,layer,feature) {
      this.$options.queryResultsService.trigger(action,layer,feature);
    },
    showFullPhoto: function(url) {
      this.$options.queryResultsService.showFullPhoto(url);
    }
  },
  watch: {
    // i listeners del queryResultsService.postRender
    // potrebbero avere bisogno di modificare il DOM dopo che sono cambiati
    // (per qualsiasi motivo) i dati e quindi Vue rirenderizza il DOM
    'state.layers': function(layers) {
      var self = this;
      if (layers.length) {
        this.$nextTick(function() {
          self.$options.queryResultsService.postRender(self.$el);
        })
      }
    }
  },
  mounted: function() {
    Vue.nextTick(function() {
      // vado a settare i tooltip
      $('[data-toggle="tooltip"]').tooltip();
    })
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);

function QueryResultsComponent(options) {
  base(this, options);
  var self = this;
  this.id = "queryresults";
  this.title = "Query Results";
  this._service = new QueryResultsService();
  //usato quando è stato distrutto
  this.setInternalComponent = function() {
    this.internalComponent = new InternalComponent({
      queryResultsService: this._service
    });
    this.createLayersFeaturesBoxes();
    this.internalComponent.querytitle = this._service.state.querytitle;
  };

  this.getElement = function() {
    if (this.internalComponent) {
      return this.internalComponent.$el;
    }
  };

  this._service.onafter('setLayersData',function() {
    if (!self.internalComponent) {
      self.setInternalComponent();
    }
    self.createLayersFeaturesBoxes();
  });

  merge(this, options);

  this.createLayersFeaturesBoxes = function() {
    var layersFeaturesBoxes = {};
    var layers = this._service.state.layers;
    _.forEach(layers, function(layer) {
      //da rivedere meglio
      if (layer.attributes.length <= maxSubsetLength && !layer.hasImageField) {
        layer.expandable = false;
      }
      _.forEach(layer.features, function(feature, index) {
        // se è la prima feature e il layer ha più di maxSubsetLength attributi, allora la espando già in apertura
        //var collapsed = (index == 0 && layer.attributes.length > maxSubsetLength) ? false : true;
        var collapsed = true;
        var boxid = layer.id+'_'+feature.id;
        layersFeaturesBoxes[boxid] = {
          collapsed: collapsed
        };
        if (feature.attributes.relations) {
          boxid = '';
          _.forEach(feature.attributes.relations, function(relation) {
            boxid = layer.id + '_' + feature.id + '_' + relation.name;
            _.forEach(relation.elements, function(element, index){
              layersFeaturesBoxes[boxid+index] = {
                collapsed: true
              };
            });
          })
        }
      })
    });
    this.internalComponent.layersFeaturesBoxes = layersFeaturesBoxes;
  };
  // sovracrive il metodo pader mount del component
  /*this.mount = function(parent, append) {
    var self = this;
    // richiama il mont padre
    return base(this, 'mount', parent, append)
  };*/

  this.layout = function(width,height) {
    //TODO
  }
}
inherit(QueryResultsComponent, Component);

module.exports = QueryResultsComponent;
},{"./queryresults.html":143,"core/project/projectsregistry":69,"core/utils/utils":77,"gui/queryresults/queryresultsservice":142,"gui/vue/component":156}],145:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var ProjectsRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');
var SearchPanel = require('gui/search/vue/panel/searchpanel');

function SearchesService(){

  this.init = function(searchesObject) {
    var searches = searchesObject || ProjectsRegistry.getCurrentProject().state.search;
    this.state.searches = searches;
  };
  this.state = {
    searches: []
  };
  this.showSearchPanel = function(panelConfig) {
    var panel =  new SearchPanel();// creo panello search
    panel.init(panelConfig);//inizializzo pannello se
    GUI.showPanel(panel);
    return panel;
  };

  this.cleanSearchPanels = function() {
    this.state.panels = {};
  };

  this.stop = function(){
    var deferred = $.Deferred();
    deferred.resolve();
    return deferred.promise();
  };

  this.reload = function() {
    var searches = ProjectsRegistry.getCurrentProject().state.search;
    Vue.set(this.state, 'searches', searches);
  }
}

// Make the public service en Event Emitter
inherit(SearchesService, G3WObject);

module.exports = SearchesService;

},{"core/g3wobject":34,"core/project/projectsregistry":69,"core/utils/utils":77,"gui/gui":118,"gui/search/vue/panel/searchpanel":147}],146:[function(require,module,exports){
module.exports = "<div class=\"g3w-search-panel form-group\">\n  <h4><b>{{ title }}</b></h4>\n  <form id=\"g3w-search-form\">\n    <template v-for=\"(forminput, index) in forminputs\">\n      <div v-if=\"forminput.input.type == 'numberfield'\" class=\"form-group numeric\">\n        <label :for=\"forminput.id + ' '\">{{ forminput.label }}</label>\n        <input type=\"number\" v-model=\"formInputValues[index].value\" class=\"form-control\" :id=\"forminput.id\">\n      </div>\n      <div v-if=\"forminput.input.type == 'textfield' || forminput.input.type == 'textField'\" class=\"form-group text\">\n        <label :for=\"forminput.id\">{{ forminput.label }}</label>\n        <input type=\"text\" v-model=\"formInputValues[index].value\" class=\"form-control\" :id=\"forminput.id\">\n      </div>\n    </template>\n    <div class=\"form-group\">\n      <button style=\"background-color:#3c8dbc\" class=\"btn btn-block pull-right\" @click=\"doSearch($event)\" data-i18n=\"dosearch\">Search</button>\n    </div>\n  </form>\n</div>\n";

},{}],147:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var localize = require('core/i18n/i18n.service').t;
var resolve = require('core/utils/utils').resolve;
var GUI = require('gui/gui');
var QueryService = require('core/query/queryservice');
var ListPanel = require('gui/listpanel').ListPanel;
var Panel = require('gui/panel');
var ProjectsRegistry = require('core/project/projectsregistry');

//componente vue pannello search
var SearchPanelComponet = Vue.extend({
  template: require('./searchpanel.html'),
  data: function() {
    return {
      title: "",
      forminputs: [],
      filterObject: {},
      formInputValues : [],
      queryurl: null
    }
  },
  methods: {
    doSearch: function(event) {
      var self = this;
      event.preventDefault();
      //al momento molto farragginoso ma da rivedere
      //per associazione valore input
      this.filterObject = this.fillFilterInputsWithValues(this.filterObject, this.formInputValues);
      // forzo il cambiamento dell'url se esiste il query url
      if (this.queryurl) {
        this.filterObject.url = this.queryurl;
      }
      var showQueryResults = GUI.showContentFactory('query');
      var queryResultsPanel = showQueryResults(self.title);
      QueryService.queryByFilter([this.filterObject])
      .then(function(results) {
         queryResultsPanel.setQueryResponse(results);
      })
      .fail(function() {
        GUI.notify.error('Si è verificato un errore nella richiesta al server');
        GUI.closeContent();
      })
    }
  }
});

//costruttore del pannello e del suo componente vue
function SearchPanel(options) {
  self = this;
  var options = options || {};
  this.config = {};
  this.filter = {};
  this.id = null;
  this.querylayerid = null;
  this.internalPanel = options.internalPanel || new SearchPanelComponet();
  //funzione inizializzazione
  this.init = function(config) {
    this.config = config || {};
    this.name = this.config.name || this.name;
    this.id = this.config.id || this.id;
    // rpendo il filtro restituito dal server
    this.filter = this.config.options.filter || this.filter;
    this.internalPanel.queryurl = this.config.options.queryurl || null;
    var queryLayerId = this.config.options.querylayerid || this.querylayerid;
    // recupero il query layer dall'id della configurazione
    this.queryLayer = ProjectsRegistry.getCurrentProject().getLayersStore().getLayerById(queryLayerId);
    //vado a riempire gli input del form del pannello con campo e valore
    this.fillInputsFormFromFilter();
    //creo e assegno l'oggetto filtro
    var filterObjFromConfig = QueryService.createQueryFilterFromConfig(this.filter);
    //alla fine creo l'ggetto finale del filtro da passare poi al provider QGISWMS o WFS etc.. che contiene sia
    //il filtro che url, il nome del layer il tipo di server etc ..
    this.internalPanel.filterObject = QueryService.createQueryFilterObject({
      queryLayers: [this.queryLayer],
      filter: filterObjFromConfig
    });
    // da migliorare
    this.internalPanel.filterObject = this.internalPanel.filterObject[0];
    //soluzione momentanea assegno  la funzione del SearchPanle ma come pattern è sbagliato
    //vorrei delegarlo a SearchesService ma lo stesso stanzia questo (loop) come uscirne???
    //creare un searchpanelservice?
    this.internalPanel.fillFilterInputsWithValues = this.fillFilterInputsWithValues;
    this.internalPanel.title = this.name;
  };
  //funzione che popola gli inputs che ci saranno nel form del pannello ricerca
  //oltre costruire un oggetto che legherà i valori degli inputs del form con gli oggetti
  //'operazionali' del filtro
  this.fillInputsFormFromFilter = function() {
    var id = 0;
    var formValue;
    _.forEach(this.filter,function(v,k,obj) {
      _.forEach(v, function(input){
        //sempre nuovo oggetto
        formValue = {};
        //inserisco l'id all'input
        input.id = id;
        //aggiungo il tipo al valore per fare conversione da stringa a tipo input
        formValue.type = input.input.type;
        ////TEMPORANEO !!! DEVO PRENDERE IL VERO VALORE DI DEFAULT
        formValue.value = null;
        //popolo gli inputs:
        // valori
        self.internalPanel.formInputValues.push(formValue);
        //input
        self.internalPanel.forminputs.push(input);
        id+=1;
      });
    });
  };
  //funzione che associa i valori dell'inputs form al relativo oggetto "operazionde del filtro"
  this.fillFilterInputsWithValues = function(filterObject, formInputValues, globalIndex) {
    //funzione conversione da valore restituito dall'input (sempre stringa) al vero tipo di valore
    function convertInputValueToInputType(type, value) {
      switch(type) {
        case 'numberfield':
             value = parseInt(value);
             break;
        default:
             break;
      }
      return value;
    }
    //ciclo sull'oggetto filtro che ha come chiave root 'AND' o 'OR'
    _.forEach(filterObject.filter, function(v,k) {
      //scorro attraverso l'array di elementi operazionali da confrontare
      _.forEach(v, function(input, idx) {
        //elemento operazionale {'=':{}}
        _.forEach(input, function(v, k, obj) {
          //vado a leggere l'oggetto attributo
          if (_.isArray(v)) {
            //richiama la funzione ricorsivamente .. andrà bene ?
            fillFilterInputsWithValues(input, formInputValues, idx);
          } else {
            _.forEach(v, function(v, k, obj) {
              //considero l'index globale in modo che inputs di operazioni booleane interne
              //vengono considerate
              index = (globalIndex) ? globalIndex + idx : idx;
              obj[k] = convertInputValueToInputType(formInputValues[index].type, formInputValues[index].value);
            });
          }
        });
      });
    });
    return filterObject;
  };
}

inherit(SearchPanel, Panel);

module.exports = SearchPanel;

},{"./searchpanel.html":146,"core/i18n/i18n.service":39,"core/project/projectsregistry":69,"core/query/queryservice":74,"core/utils/utils":77,"gui/gui":118,"gui/listpanel":120,"gui/panel":127}],148:[function(require,module,exports){
module.exports = "<ul id=\"g3w-search\" class=\"treeview-menu g3w-search g3w-tools menu-items\">\n  <li v-for=\"search in state.searches\" class=\"menu-item\" @click=\"showSearchPanel(search)\">\n    <i class=\"fa fa-circle-o\"></i>\n    <span>{{ search.name }}</span>\n  </li>\n</ul>\n";

},{}],149:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ProjectsRegistry = require('core/project/projectsregistry');
var SearchesService = require('gui/search/searchesservice');

var vueComponentOptions = {
   template: require('./search.html'),
   data: function() {
    	return {
    	  state: null
    	};
   },
   methods: {
    showSearchPanel: function(search) {
        this.$options.searchesService.showSearchPanel(search);
    }
  }
};

// se lo voglio istanziare manualmente
var InternalComponent = Vue.extend(vueComponentOptions);
// se lo voglio usare come componente come elemento html

/* COMPONENTI FIGLI */
/* FINE COMPONENTI FIGLI */

/* INTERFACCIA PUBBLICA */
function SearchComponent(options){
  base(this,options);
  this.id = "search-component";
  this.title = "search";
  this._service = new SearchesService();
  this.internalComponent = new InternalComponent({
    searchesService: this._service
  });
  this.internalComponent.state = this._service.state;
  this.state.visible = ProjectsRegistry.getCurrentProject().state.search.length > 0;
  merge(this, options);
  this.initService = function() {
    //inizializzo il servizio
    this._service.init();
  };

  this._reload = function() {
    this.state.visible = ProjectsRegistry.getCurrentProject().state.search.length > 0;
    this._service.reload();
  }
}

inherit(SearchComponent, Component);
module.exports = SearchComponent;

},{"./search.html":148,"core/project/projectsregistry":69,"core/utils/utils":77,"gui/search/searchesservice":145,"gui/vue/component":156}],150:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var StreetViewComponent = require('gui/streetview/vue/streetview');

function StreetViewService() {
  this._position = null;
  this.setters = {
    postRender: function(position) {
      //hook postrender
    }
  };

  this.getPosition = function() {
    return this._position;
  };

  this.showStreetView = function(position) {
    this._position = position;
    GUI.setContent({
      content: new StreetViewComponent({
        service: this
      }),
      title: 'StreetView'
    });
  };
  base(this);
}

inherit(StreetViewService, G3WObject);

module.exports = StreetViewService;

},{"core/g3wobject":34,"core/utils/utils":77,"gui/gui":118,"gui/streetview/vue/streetview":152}],151:[function(require,module,exports){
module.exports = "<div id=\"streetview\"></div>";

},{}],152:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');

var InternalComponent = Vue.extend({
  template: require('./streetview.html'),
  data: function() {
    return {
      state: null
    }
  },
  mounted: function() {
    var self = this;
    this.$nextTick(function() {
      var position = self.$options.service.getPosition();
      self.$options.service.postRender(position);
    });
  }
});

var StreetViewComponent = function(options) {
  base(this);
  var options = options || {};
  var service = options.service;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service
  });
  this.setInternalComponent(internalComponent);
  this.unmount = function() {
    return base(this, 'unmount');
  }
};

inherit(StreetViewComponent, Component);


module.exports = StreetViewComponent;



},{"./streetview.html":151,"core/utils/utils":77,"gui/vue/component":156}],153:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function ToolsService(){
  var self = this;
  this.config = null;
  this._actions = {};
  this.state = {
    toolsGroups: []
  };
  this.setters = {
    addTools: function(order, groupName, tools) {
      self._addTools(order, groupName, tools);
    },
    addToolGroup: function(order, group) {
      self.state.toolsGroups.splice(order, 0, group);
    },
    removeTools:function() {
      self._removeTools();
    }
  };
  
  this._addTools = function(order, groupName, tools) {
    var self = this;
    var group = this._getToolsGroup(groupName);
    if (!group) {
      group = {
        name: groupName,
        tools: []
      };
      this.addToolGroup(order, group);
    }
    _.forEach(tools, function(tool){
      group.tools.push(tool);
      self._addAction(tool);
    });
  };

  this._removeTool = function(toolIdx) {
    this.state.toolsGroups = this.state.toolsGroups.splice(toolIdx, 1);
  };

  this._removeTools = function() {
    var self = this;
    _.forEach(this.state.toolsGroups, function(toolGroup, toolIdx) {
      self.state.toolsGroups.splice(0,1);
    })
  };

  this.updateToolsGroup = function(order, groupConfig) {
    Vue.set(this.state.toolsGroups, order, groupConfig);
  };

  this.getState = function() {
    return this.state;
  };

  this.fireAction = function(actionId){
    var action = this._actions[actionId];
    action();
  };

  this._getToolsGroup = function(groupName) {
    var group = null;
    _.forEach(this.state.toolsGroups,function(_group){
      if (_group.name == groupName) {
        group = _group;
      }
    });
    return group;
  };

  this._addAction = function(tool) {
    var actionId = Math.floor(Math.random() * 1000000)+1;
    tool.actionId = actionId;
    this._actions[actionId] = tool.action;
  };

  base(this);
}

inherit(ToolsService, G3WObject);

module.exports = ToolsService;

},{"core/g3wobject":34,"core/utils/utils":77}],154:[function(require,module,exports){
module.exports = "<ul class=\"g3w-tools treeview-menu\">\n  <li v-for=\"group in state.toolsGroups\">\n    <div class=\"tool-header\">\n      <i class=\"fa fa-gear\"></i>\n      <span style=\"\">{{ group.name }}</span>\n    </div>\n    <div :id=\"group.name + '-tools'\" class=\"tool-box\">\n      <template v-for=\"tool in group.tools\">\n        <div v-if=\"tool.type == 'checkbox' \" class=\"checkbox\">\n          <label>\n            <input style=\"cursor:pointer\" :id=\"tool.layerName\" v-model=\"tool.isCheck\" type=\"checkbox\" :value=\"tool.layerName\" @click=\"fireAction(tool.actionId)\">{{ tool.name }}\n          </label>\n        </div>\n        <div v-else class=\"tool\" @click=\"fireAction(tool.actionId)\">\n          <i class=\"fa fa-caret-right\"></i>\n          <span >{{ tool.name }}</span>\n        </div>\n      </template>\n    </div>\n  </li>\n</ul>\n\n";

},{}],155:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var ToolsService = require('gui/tools/toolsservice');

var InternalComponent = Vue.extend({
  template: require('./tools.html'),
  data: function() {
    return {
      state: null
    }
  },
  methods: {
    fireAction: function(actionId) {
      this.$options.toolsService.fireAction(actionId);
    }
  }
});

function ToolsComponent(options) {

  base(this,options);
  var self = this;
  this._service = new ToolsService();
  this.id = "tools-component";
  this.title = "tools";
  this.state.visible = false;

  // vado a settare l'onafter nel caso di un add tools che di un remove tool
  this._service.onafter('addTools', function() {
    self.state.visible = self._service.state.toolsGroups.length > 0;
  });
  this._service.onafter('removeTools', function() {
    self.state.visible = self._service.state.toolsGroups.length > 0;
  });
  /* ----------------------*/
  merge(this, options);
  this.internalComponent = new InternalComponent({
    toolsService: this._service
  });
  //sostituisco lo state del servizio allo state del componente vue interno
  this.internalComponent.state = this._service.state;
}

inherit(ToolsComponent, Component);

var proto = ToolsComponent.prototype;

module.exports = ToolsComponent;

},{"./tools.html":154,"core/i18n/i18n.service":39,"core/utils/utils":77,"gui/tools/toolsservice":153,"gui/vue/component":156}],156:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var resolve = require('core/utils/utils').resolve;
var BaseComponent = require('gui/component');
// classe componente
var Component = function(options) {
  base(this, options);
};
// eredita le caratteristiche del componente base
inherit(Component, BaseComponent);

//prototype
var proto = Component.prototype;
// viene richiamato dalla toolbar o da qualsiasi parte per montare il componente vue su un particolare elemento dom padre
// quando il plugin chiede di mostrare un proprio pannello nella GUI (GUI.showPanel)
proto.mount = function(parent, append) {
  var self = this;
  var d = $.Deferred();
  // verifica che sia stato settato il componente interno
  if (!this.internalComponent) {
    this.setInternalComponent();
  }
  // verifica se è in append o no
  if (append) {
    var iCinstance = this.internalComponent.$mount();
    $(parent).append(iCinstance.$el);
  }
  else {
    this.internalComponent.$mount(parent);
  }
  //return resolve(true);
  Vue.nextTick(function(){
    $(parent).localize();
    // risolve la promessa
    d.resolve(true);
  });
  return d.promise();
};
// richiamato quando la GUI chiede di chiudere il pannello. Se ritorna false il pannello non viene chiuso
proto.unmount = function() {
  // il problema che distruggere
  if (_.isNil(this.internalComponent)) {
    var a = 1;
    return resolve();
  }
  this.internalComponent.$destroy(true);
  $(this.internalComponent.$el).remove();
  // lo setta di nuovo a null
  this.internalComponent = null;
  return resolve();
};
// funzione che verifica se il componente interno è montato
proto.ismount = function() {
  return this.internalComponent && this.internalComponent.$el;
};

proto.layout = function(width,height) {
  if (this.internalComponent) {
    //this.internalComponent.$broadcast('layout');
  }
};
module.exports = Component;

},{"core/utils/utils":77,"gui/component":110}],157:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;

Vue.directive("disabled",function(el, binding){
    if (binding.value){
      el.setAttribute('disabled','disabled');
    }
    else {
      el.removeAttribute('disabled');
    }
  }
);

Vue.directive("checked",function(el, binding){
    if (binding.value){
      el.setAttribute('checked','checked');
    }
    else {
      el.removeAttribute('checked');
    }
  }
);

Vue.directive("selected-first",function(el, binding){
    if (binding.value==0){
      el.setAttribute('selected','');
    }
    else {
      el.removeAttribute('selected');
    }
  }
);

Vue.directive("t",function(el, binding){
  return t(binding.value);
});

},{"core/i18n/i18n.service":39}],158:[function(require,module,exports){
var g3w = g3w || {};

g3w.core = {
   G3WObject: require('core/g3wobject'),
   utils: require('core/utils/utils'),
   ApplicationService: require('core/applicationservice'),
   ApiService: require('core/apiservice'),
   Router: require('core/router'),
   ProjectsRegistry: require('core/project/projectsregistry'),
   Project: require('core/project/project'),
   Layer: require('core/layers/layer'),
   QueryService: require('core/query/queryservice'),
   MapLayer: require('core/map/layer/maplayer'),
   VectorLayer: require('core/map/layer/vectorlayer'),
   WmsLayer: require('core/map/layer/wmslayer'),
   VectorLayerLoader: require('core/map/layer/loader/vectorloaderlayer'),
   Geometry: require('core/geometry/geometry'),
   geom: require('core/geometry/geom'),
   PickCoordinatesInteraction: require('g3w-ol3/src/interactions/pickcoordinatesinteraction'),
   PickFeatureInteraction: require('g3w-ol3/src/interactions/pickfeatureinteraction'),
   i18n: require('core/i18n/i18n.service'),
   Plugin: require('core/plugin/plugin'),
   PluginsRegistry: require('core/plugin/pluginsregistry'),
   PluginService: require('core/plugin/pluginservice'),
   Editor: require('core/editing/editor'),
   EditBuffer: require('core/editing/editbuffer'),
   RelationEditBuffer: require('core/editing/relationeditbuffer'),
   LayersStoreRegistry: require('core/layers/layersstoresregistry'),
   LayersStore: require('core/layers/layersstore')

};

g3w.gui = {
  GUI: require('gui/gui'),
  Panel: require('gui/panel'),
  ControlFactory: require('gui/map/control/factory'),
  vue: {
    Component: require('gui/vue/component'),
    SearchComponent: require('gui/search/vue/search'),
    SearchPanel: require('gui/search/vue/panel/searchpanel'),
    PrintComponent: require('gui/print/vue/print'),
    CatalogComponent: require('gui/catalog/vue/catalog'),
    MapComponent: require('gui/map/vue/map'),
    ToolsComponent: require('gui/tools/vue/tools'),
    QueryResultsComponent : require('gui/queryresults/vue/queryresults'),
    FormComponent: require('gui/form/vue/form'),
    EditingComponent: require('gui/editing/vue/editing')
  }
};

g3w.ol3 = {
  interactions : {
    PickFeatureInteraction : require('g3w-ol3/src/interactions/pickfeatureinteraction')
  },
  controls: {
  }
};

module.exports = {
  core: g3w.core,
  gui: g3w.gui,
  ol3: g3w.ol3
};

},{"core/apiservice":21,"core/applicationservice":22,"core/editing/editbuffer":24,"core/editing/editor":25,"core/editing/relationeditbuffer":26,"core/g3wobject":34,"core/geometry/geom":37,"core/geometry/geometry":38,"core/i18n/i18n.service":39,"core/layers/layer":43,"core/layers/layersstore":44,"core/layers/layersstoresregistry":45,"core/map/layer/loader/vectorloaderlayer":56,"core/map/layer/maplayer":57,"core/map/layer/vectorlayer":59,"core/map/layer/wmslayer":60,"core/plugin/plugin":62,"core/plugin/pluginservice":63,"core/plugin/pluginsregistry":64,"core/project/project":68,"core/project/projectsregistry":69,"core/query/queryservice":74,"core/router":75,"core/utils/utils":77,"g3w-ol3/src/interactions/pickcoordinatesinteraction":98,"g3w-ol3/src/interactions/pickfeatureinteraction":99,"gui/catalog/vue/catalog":106,"gui/editing/vue/editing":114,"gui/form/vue/form":116,"gui/gui":118,"gui/map/control/factory":121,"gui/map/vue/map":126,"gui/panel":127,"gui/print/vue/print":131,"gui/queryresults/vue/queryresults":144,"gui/search/vue/panel/searchpanel":147,"gui/search/vue/search":149,"gui/tools/vue/tools":155,"gui/vue/component":156}]},{},[3]);
